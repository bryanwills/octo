import { ae as __vitePreload, i as defineComponent, o as openBlock, c as createElementBlock, af as getAugmentedNamespace, z as getAuth, N as nanoid, ag as ref, ah as getStorage, ai as uploadBytes, aj as matchStarts, ak as HASHTAG_CODES, al as matchHashtagPrefix, am as matchHashtag, an as commonjsGlobal$1, ao as commonjsRequire$1, ap as customAlphabet, a0 as SET_RIGHT_SIDEBAR_VISIBILITY, _ as _export_sfc, r as resolveComponent, a as createBaseVNode, aq as normalizeStyle, b as createVNode, t as toDisplayString, f as createCommentVNode, p as pushScopeId, h as popScopeId } from "./index.99a5f7ec.js";
import { s as subscription } from "./account.81044ebe.js";
import { S as Selection$2, r as root$5, a as array$5, d as define$1, e as extend$2, R as Rgb$1, C as Color$3, b as rgbConvert$1, c as constant$f, i as interpolateNumber$1, f as color$1, g as interpolateRgb$1, h as interpolateString$1, n as nogamma$1, j as hue$2, k as initRange$1, s as select$1, o as ordinal$1 } from "./transform.606510e9.js";
const sharedConfig = {};
function setHydrateContext(context) {
  sharedConfig.context = context;
}
function nextHydrateContext() {
  return {
    ...sharedConfig.context,
    id: `${sharedConfig.context.id}${sharedConfig.context.count++}-`,
    count: 0
  };
}
const equalFn = (a2, b) => a2 === b;
const $TRACK = Symbol("solid-track");
const signalOptions = {
  equals: equalFn
};
let runEffects = runQueue;
const STALE = 1;
const PENDING = 2;
const UNOWNED = {
  owned: null,
  cleanups: null,
  context: null,
  owner: null
};
var Owner = null;
let Transition$1 = null;
let Listener = null;
let Updates = null;
let Effects = null;
let ExecCount = 0;
function createRoot(fn2, detachedOwner) {
  const listener = Listener, owner = Owner, unowned = fn2.length === 0, root2 = unowned && true ? UNOWNED : {
    owned: null,
    cleanups: null,
    context: null,
    owner: detachedOwner || owner
  }, updateFn = unowned ? fn2 : () => fn2(() => untrack(() => cleanNode(root2)));
  Owner = root2;
  Listener = null;
  try {
    return runUpdates(updateFn, true);
  } finally {
    Listener = listener;
    Owner = owner;
  }
}
function createSignal(value, options2) {
  options2 = options2 ? Object.assign({}, signalOptions, options2) : signalOptions;
  const s2 = {
    value,
    observers: null,
    observerSlots: null,
    comparator: options2.equals || void 0
  };
  const setter = (value2) => {
    if (typeof value2 === "function") {
      value2 = value2(s2.value);
    }
    return writeSignal(s2, value2);
  };
  return [readSignal.bind(s2), setter];
}
function createRenderEffect(fn2, value, options2) {
  const c2 = createComputation(fn2, value, false, STALE);
  updateComputation(c2);
}
function createEffect(fn2, value, options2) {
  runEffects = runUserEffects;
  const c2 = createComputation(fn2, value, false, STALE);
  c2.user = true;
  Effects ? Effects.push(c2) : updateComputation(c2);
}
function createMemo(fn2, value, options2) {
  options2 = options2 ? Object.assign({}, signalOptions, options2) : signalOptions;
  const c2 = createComputation(fn2, value, true, 0);
  c2.observers = null;
  c2.observerSlots = null;
  c2.comparator = options2.equals || void 0;
  updateComputation(c2);
  return readSignal.bind(c2);
}
function untrack(fn2) {
  let result, listener = Listener;
  Listener = null;
  result = fn2();
  Listener = listener;
  return result;
}
function onMount(fn2) {
  createEffect(() => untrack(fn2));
}
function onCleanup(fn2) {
  if (Owner === null)
    ;
  else if (Owner.cleanups === null)
    Owner.cleanups = [fn2];
  else
    Owner.cleanups.push(fn2);
  return fn2;
}
function createContext(defaultValue, options2) {
  const id2 = Symbol("context");
  return {
    id: id2,
    Provider: createProvider(id2),
    defaultValue
  };
}
function useContext(context) {
  let ctx;
  return (ctx = lookup(Owner, context.id)) !== void 0 ? ctx : context.defaultValue;
}
function children(fn2) {
  const children2 = createMemo(fn2);
  const memo = createMemo(() => resolveChildren(children2()));
  memo.toArray = () => {
    const c2 = memo();
    return Array.isArray(c2) ? c2 : c2 != null ? [c2] : [];
  };
  return memo;
}
function readSignal() {
  const runningTransition = Transition$1;
  if (this.sources && (this.state || runningTransition)) {
    if (this.state === STALE || runningTransition)
      updateComputation(this);
    else {
      const updates = Updates;
      Updates = null;
      runUpdates(() => lookUpstream(this), false);
      Updates = updates;
    }
  }
  if (Listener) {
    const sSlot = this.observers ? this.observers.length : 0;
    if (!Listener.sources) {
      Listener.sources = [this];
      Listener.sourceSlots = [sSlot];
    } else {
      Listener.sources.push(this);
      Listener.sourceSlots.push(sSlot);
    }
    if (!this.observers) {
      this.observers = [Listener];
      this.observerSlots = [Listener.sources.length - 1];
    } else {
      this.observers.push(Listener);
      this.observerSlots.push(Listener.sources.length - 1);
    }
  }
  return this.value;
}
function writeSignal(node2, value, isComp) {
  let current = node2.value;
  if (!node2.comparator || !node2.comparator(current, value)) {
    node2.value = value;
    if (node2.observers && node2.observers.length) {
      runUpdates(() => {
        for (let i = 0; i < node2.observers.length; i += 1) {
          const o = node2.observers[i];
          const TransitionRunning = Transition$1 && Transition$1.running;
          if (TransitionRunning && Transition$1.disposed.has(o))
            ;
          if (TransitionRunning && !o.tState || !TransitionRunning && !o.state) {
            if (o.pure)
              Updates.push(o);
            else
              Effects.push(o);
            if (o.observers)
              markDownstream(o);
          }
          if (TransitionRunning)
            ;
          else
            o.state = STALE;
        }
        if (Updates.length > 1e6) {
          Updates = [];
          if (false)
            ;
          throw new Error();
        }
      }, false);
    }
  }
  return value;
}
function updateComputation(node2) {
  if (!node2.fn)
    return;
  cleanNode(node2);
  const owner = Owner, listener = Listener, time2 = ExecCount;
  Listener = Owner = node2;
  runComputation(node2, node2.value, time2);
  Listener = listener;
  Owner = owner;
}
function runComputation(node2, value, time2) {
  let nextValue;
  try {
    nextValue = node2.fn(value);
  } catch (err) {
    if (node2.pure)
      node2.state = STALE;
    handleError$1(err);
  }
  if (!node2.updatedAt || node2.updatedAt <= time2) {
    if (node2.updatedAt != null && "observers" in node2) {
      writeSignal(node2, nextValue);
    } else
      node2.value = nextValue;
    node2.updatedAt = time2;
  }
}
function createComputation(fn2, init2, pure, state = STALE, options2) {
  const c2 = {
    fn: fn2,
    state,
    updatedAt: null,
    owned: null,
    sources: null,
    sourceSlots: null,
    cleanups: null,
    value: init2,
    owner: Owner,
    context: null,
    pure
  };
  if (Owner === null)
    ;
  else if (Owner !== UNOWNED) {
    {
      if (!Owner.owned)
        Owner.owned = [c2];
      else
        Owner.owned.push(c2);
    }
  }
  return c2;
}
function runTop(node2) {
  const runningTransition = Transition$1;
  if (node2.state === 0 || runningTransition)
    return;
  if (node2.state === PENDING || runningTransition)
    return lookUpstream(node2);
  if (node2.suspense && untrack(node2.suspense.inFallback))
    return node2.suspense.effects.push(node2);
  const ancestors = [node2];
  while ((node2 = node2.owner) && (!node2.updatedAt || node2.updatedAt < ExecCount)) {
    if (node2.state || runningTransition)
      ancestors.push(node2);
  }
  for (let i = ancestors.length - 1; i >= 0; i--) {
    node2 = ancestors[i];
    if (node2.state === STALE || runningTransition) {
      updateComputation(node2);
    } else if (node2.state === PENDING || runningTransition) {
      const updates = Updates;
      Updates = null;
      runUpdates(() => lookUpstream(node2, ancestors[0]), false);
      Updates = updates;
    }
  }
}
function runUpdates(fn2, init2) {
  if (Updates)
    return fn2();
  let wait = false;
  if (!init2)
    Updates = [];
  if (Effects)
    wait = true;
  else
    Effects = [];
  ExecCount++;
  try {
    const res = fn2();
    completeUpdates(wait);
    return res;
  } catch (err) {
    if (!Updates)
      Effects = null;
    handleError$1(err);
  }
}
function completeUpdates(wait) {
  if (Updates) {
    runQueue(Updates);
    Updates = null;
  }
  if (wait)
    return;
  const e = Effects;
  Effects = null;
  if (e.length)
    runUpdates(() => runEffects(e), false);
}
function runQueue(queue) {
  for (let i = 0; i < queue.length; i++)
    runTop(queue[i]);
}
function runUserEffects(queue) {
  let i, userLength = 0;
  for (i = 0; i < queue.length; i++) {
    const e = queue[i];
    if (!e.user)
      runTop(e);
    else
      queue[userLength++] = e;
  }
  if (sharedConfig.context)
    setHydrateContext();
  for (i = 0; i < userLength; i++)
    runTop(queue[i]);
}
function lookUpstream(node2, ignore) {
  const runningTransition = Transition$1;
  node2.state = 0;
  for (let i = 0; i < node2.sources.length; i += 1) {
    const source = node2.sources[i];
    if (source.sources) {
      if (source.state === STALE || runningTransition) {
        if (source !== ignore)
          runTop(source);
      } else if (source.state === PENDING || runningTransition)
        lookUpstream(source, ignore);
    }
  }
}
function markDownstream(node2) {
  const runningTransition = Transition$1;
  for (let i = 0; i < node2.observers.length; i += 1) {
    const o = node2.observers[i];
    if (!o.state || runningTransition) {
      o.state = PENDING;
      if (o.pure)
        Updates.push(o);
      else
        Effects.push(o);
      o.observers && markDownstream(o);
    }
  }
}
function cleanNode(node2) {
  let i;
  if (node2.sources) {
    while (node2.sources.length) {
      const source = node2.sources.pop(), index2 = node2.sourceSlots.pop(), obs = source.observers;
      if (obs && obs.length) {
        const n = obs.pop(), s2 = source.observerSlots.pop();
        if (index2 < obs.length) {
          n.sourceSlots[s2] = index2;
          obs[index2] = n;
          source.observerSlots[index2] = s2;
        }
      }
    }
  }
  if (node2.owned) {
    for (i = 0; i < node2.owned.length; i++)
      cleanNode(node2.owned[i]);
    node2.owned = null;
  }
  if (node2.cleanups) {
    for (i = 0; i < node2.cleanups.length; i++)
      node2.cleanups[i]();
    node2.cleanups = null;
  }
  node2.state = 0;
  node2.context = null;
}
function castError(err) {
  if (err instanceof Error || typeof err === "string")
    return err;
  return new Error("Unknown error");
}
function handleError$1(err) {
  err = castError(err);
  throw err;
}
function lookup(owner, key) {
  return owner ? owner.context && owner.context[key] !== void 0 ? owner.context[key] : lookup(owner.owner, key) : void 0;
}
function resolveChildren(children2) {
  if (typeof children2 === "function" && !children2.length)
    return resolveChildren(children2());
  if (Array.isArray(children2)) {
    const results = [];
    for (let i = 0; i < children2.length; i++) {
      const result = resolveChildren(children2[i]);
      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);
    }
    return results;
  }
  return children2;
}
function createProvider(id2, options2) {
  return function provider(props) {
    let res;
    createRenderEffect(() => res = untrack(() => {
      Owner.context = {
        [id2]: props.value
      };
      return children(() => props.children);
    }), void 0);
    return res;
  };
}
const FALLBACK = Symbol("fallback");
function dispose(d) {
  for (let i = 0; i < d.length; i++)
    d[i]();
}
function mapArray(list2, mapFn, options2 = {}) {
  let items = [], mapped = [], disposers = [], len = 0, indexes = mapFn.length > 1 ? [] : null;
  onCleanup(() => dispose(disposers));
  return () => {
    let newItems = list2() || [], i, j2;
    newItems[$TRACK];
    return untrack(() => {
      let newLen = newItems.length, newIndices, newIndicesNext, temp2, tempdisposers, tempIndexes, start2, end2, newEnd, item;
      if (newLen === 0) {
        if (len !== 0) {
          dispose(disposers);
          disposers = [];
          items = [];
          mapped = [];
          len = 0;
          indexes && (indexes = []);
        }
        if (options2.fallback) {
          items = [FALLBACK];
          mapped[0] = createRoot((disposer) => {
            disposers[0] = disposer;
            return options2.fallback();
          });
          len = 1;
        }
      } else if (len === 0) {
        mapped = new Array(newLen);
        for (j2 = 0; j2 < newLen; j2++) {
          items[j2] = newItems[j2];
          mapped[j2] = createRoot(mapper);
        }
        len = newLen;
      } else {
        temp2 = new Array(newLen);
        tempdisposers = new Array(newLen);
        indexes && (tempIndexes = new Array(newLen));
        for (start2 = 0, end2 = Math.min(len, newLen); start2 < end2 && items[start2] === newItems[start2]; start2++)
          ;
        for (end2 = len - 1, newEnd = newLen - 1; end2 >= start2 && newEnd >= start2 && items[end2] === newItems[newEnd]; end2--, newEnd--) {
          temp2[newEnd] = mapped[end2];
          tempdisposers[newEnd] = disposers[end2];
          indexes && (tempIndexes[newEnd] = indexes[end2]);
        }
        newIndices = /* @__PURE__ */ new Map();
        newIndicesNext = new Array(newEnd + 1);
        for (j2 = newEnd; j2 >= start2; j2--) {
          item = newItems[j2];
          i = newIndices.get(item);
          newIndicesNext[j2] = i === void 0 ? -1 : i;
          newIndices.set(item, j2);
        }
        for (i = start2; i <= end2; i++) {
          item = items[i];
          j2 = newIndices.get(item);
          if (j2 !== void 0 && j2 !== -1) {
            temp2[j2] = mapped[i];
            tempdisposers[j2] = disposers[i];
            indexes && (tempIndexes[j2] = indexes[i]);
            j2 = newIndicesNext[j2];
            newIndices.set(item, j2);
          } else
            disposers[i]();
        }
        for (j2 = start2; j2 < newLen; j2++) {
          if (j2 in temp2) {
            mapped[j2] = temp2[j2];
            disposers[j2] = tempdisposers[j2];
            if (indexes) {
              indexes[j2] = tempIndexes[j2];
              indexes[j2](j2);
            }
          } else
            mapped[j2] = createRoot(mapper);
        }
        mapped = mapped.slice(0, len = newLen);
        items = newItems.slice(0);
      }
      return mapped;
    });
    function mapper(disposer) {
      disposers[j2] = disposer;
      if (indexes) {
        const [s2, set2] = createSignal(j2);
        indexes[j2] = set2;
        return mapFn(newItems[j2], s2);
      }
      return mapFn(newItems[j2]);
    }
  };
}
let hydrationEnabled = false;
function enableHydration() {
  hydrationEnabled = true;
}
function createComponent(Comp, props) {
  if (hydrationEnabled) {
    if (sharedConfig.context) {
      const c2 = sharedConfig.context;
      setHydrateContext(nextHydrateContext());
      const r = untrack(() => Comp(props || {}));
      setHydrateContext(c2);
      return r;
    }
  }
  return untrack(() => Comp(props || {}));
}
function For(props) {
  const fallback = "fallback" in props && {
    fallback: () => props.fallback
  };
  return createMemo(mapArray(() => props.each, props.children, fallback ? fallback : void 0));
}
function Show(props) {
  let strictEqual = false;
  const keyed = props.keyed;
  const condition = createMemo(() => props.when, void 0, {
    equals: (a2, b) => strictEqual ? a2 === b : !a2 === !b
  });
  return createMemo(() => {
    const c2 = condition();
    if (c2) {
      const child = props.children;
      const fn2 = typeof child === "function" && child.length > 0;
      strictEqual = keyed || fn2;
      return fn2 ? untrack(() => child(c2)) : child;
    }
    return props.fallback;
  });
}
const booleans = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "controls", "default", "disabled", "formnovalidate", "hidden", "indeterminate", "ismap", "loop", "multiple", "muted", "nomodule", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "seamless", "selected"];
const Properties = /* @__PURE__ */ new Set(["className", "value", "readOnly", "formNoValidate", "isMap", "noModule", "playsInline", ...booleans]);
const ChildProperties = /* @__PURE__ */ new Set(["innerHTML", "textContent", "innerText", "children"]);
const Aliases = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {
  className: "class",
  htmlFor: "for"
});
const PropAliases = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {
  class: "className",
  formnovalidate: "formNoValidate",
  ismap: "isMap",
  nomodule: "noModule",
  playsinline: "playsInline",
  readonly: "readOnly"
});
const DelegatedEvents = /* @__PURE__ */ new Set(["beforeinput", "click", "dblclick", "contextmenu", "focusin", "focusout", "input", "keydown", "keyup", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "pointerdown", "pointermove", "pointerout", "pointerover", "pointerup", "touchend", "touchmove", "touchstart"]);
const SVGNamespace = {
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace"
};
function reconcileArrays(parentNode, a2, b) {
  let bLength = b.length, aEnd = a2.length, bEnd = bLength, aStart = 0, bStart = 0, after = a2[aEnd - 1].nextSibling, map2 = null;
  while (aStart < aEnd || bStart < bEnd) {
    if (a2[aStart] === b[bStart]) {
      aStart++;
      bStart++;
      continue;
    }
    while (a2[aEnd - 1] === b[bEnd - 1]) {
      aEnd--;
      bEnd--;
    }
    if (aEnd === aStart) {
      const node2 = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;
      while (bStart < bEnd)
        parentNode.insertBefore(b[bStart++], node2);
    } else if (bEnd === bStart) {
      while (aStart < aEnd) {
        if (!map2 || !map2.has(a2[aStart]))
          a2[aStart].remove();
        aStart++;
      }
    } else if (a2[aStart] === b[bEnd - 1] && b[bStart] === a2[aEnd - 1]) {
      const node2 = a2[--aEnd].nextSibling;
      parentNode.insertBefore(b[bStart++], a2[aStart++].nextSibling);
      parentNode.insertBefore(b[--bEnd], node2);
      a2[aEnd] = b[bEnd];
    } else {
      if (!map2) {
        map2 = /* @__PURE__ */ new Map();
        let i = bStart;
        while (i < bEnd)
          map2.set(b[i], i++);
      }
      const index2 = map2.get(a2[aStart]);
      if (index2 != null) {
        if (bStart < index2 && index2 < bEnd) {
          let i = aStart, sequence2 = 1, t4;
          while (++i < aEnd && i < bEnd) {
            if ((t4 = map2.get(a2[i])) == null || t4 !== index2 + sequence2)
              break;
            sequence2++;
          }
          if (sequence2 > index2 - bStart) {
            const node2 = a2[aStart];
            while (bStart < index2)
              parentNode.insertBefore(b[bStart++], node2);
          } else
            parentNode.replaceChild(b[bStart++], a2[aStart++]);
        } else
          aStart++;
      } else
        a2[aStart++].remove();
    }
  }
}
const $$EVENTS = "_$DX_DELEGATE";
function render$3(code, element, init2, options2 = {}) {
  let disposer;
  createRoot((dispose2) => {
    disposer = dispose2;
    element === document ? code() : insert$1(element, code(), element.firstChild ? null : void 0, init2);
  }, options2.owner);
  return () => {
    disposer();
    element.textContent = "";
  };
}
function template$1(html2, check, isSVG) {
  const t4 = document.createElement("template");
  t4.innerHTML = html2;
  let node2 = t4.content.firstChild;
  if (isSVG)
    node2 = node2.firstChild;
  return node2;
}
function delegateEvents(eventNames, document2 = window.document) {
  const e = document2[$$EVENTS] || (document2[$$EVENTS] = /* @__PURE__ */ new Set());
  for (let i = 0, l2 = eventNames.length; i < l2; i++) {
    const name2 = eventNames[i];
    if (!e.has(name2)) {
      e.add(name2);
      document2.addEventListener(name2, eventHandler);
    }
  }
}
function setAttribute(node2, name2, value) {
  if (value == null)
    node2.removeAttribute(name2);
  else
    node2.setAttribute(name2, value);
}
function setAttributeNS(node2, namespace2, name2, value) {
  if (value == null)
    node2.removeAttributeNS(namespace2, name2);
  else
    node2.setAttributeNS(namespace2, name2, value);
}
function className(node2, value) {
  if (value == null)
    node2.removeAttribute("class");
  else
    node2.className = value;
}
function addEventListener(node2, name2, handler, delegate) {
  if (delegate) {
    if (Array.isArray(handler)) {
      node2[`$$${name2}`] = handler[0];
      node2[`$$${name2}Data`] = handler[1];
    } else
      node2[`$$${name2}`] = handler;
  } else if (Array.isArray(handler)) {
    const handlerFn = handler[0];
    node2.addEventListener(name2, handler[0] = (e) => handlerFn.call(node2, handler[1], e));
  } else
    node2.addEventListener(name2, handler);
}
function classList$1(node2, value, prev2 = {}) {
  const classKeys = Object.keys(value || {}), prevKeys = Object.keys(prev2);
  let i, len;
  for (i = 0, len = prevKeys.length; i < len; i++) {
    const key = prevKeys[i];
    if (!key || key === "undefined" || value[key])
      continue;
    toggleClassKey(node2, key, false);
    delete prev2[key];
  }
  for (i = 0, len = classKeys.length; i < len; i++) {
    const key = classKeys[i], classValue = !!value[key];
    if (!key || key === "undefined" || prev2[key] === classValue || !classValue)
      continue;
    toggleClassKey(node2, key, true);
    prev2[key] = classValue;
  }
  return prev2;
}
function style(node2, value, prev2) {
  if (!value)
    return prev2 ? setAttribute(node2, "style") : value;
  const nodeStyle = node2.style;
  if (typeof value === "string")
    return nodeStyle.cssText = value;
  typeof prev2 === "string" && (nodeStyle.cssText = prev2 = void 0);
  prev2 || (prev2 = {});
  value || (value = {});
  let v, s2;
  for (s2 in prev2) {
    value[s2] == null && nodeStyle.removeProperty(s2);
    delete prev2[s2];
  }
  for (s2 in value) {
    v = value[s2];
    if (v !== prev2[s2]) {
      nodeStyle.setProperty(s2, v);
      prev2[s2] = v;
    }
  }
  return prev2;
}
function spread(node2, props = {}, isSVG, skipChildren) {
  const prevProps = {};
  if (!skipChildren) {
    createRenderEffect(() => prevProps.children = insertExpression(node2, props.children, prevProps.children));
  }
  createRenderEffect(() => props.ref && props.ref(node2));
  createRenderEffect(() => assign(node2, props, isSVG, true, prevProps, true));
  return prevProps;
}
function insert$1(parent, accessor, marker, initial) {
  if (marker !== void 0 && !initial)
    initial = [];
  if (typeof accessor !== "function")
    return insertExpression(parent, accessor, initial, marker);
  createRenderEffect((current) => insertExpression(parent, accessor(), current, marker), initial);
}
function assign(node2, props, isSVG, skipChildren, prevProps = {}, skipRef = false) {
  props || (props = {});
  for (const prop in prevProps) {
    if (!(prop in props)) {
      if (prop === "children")
        continue;
      prevProps[prop] = assignProp(node2, prop, null, prevProps[prop], isSVG, skipRef);
    }
  }
  for (const prop in props) {
    if (prop === "children") {
      if (!skipChildren)
        insertExpression(node2, props.children);
      continue;
    }
    const value = props[prop];
    prevProps[prop] = assignProp(node2, prop, value, prevProps[prop], isSVG, skipRef);
  }
}
function hydrate$1(code, element, options2 = {}) {
  sharedConfig.completed = globalThis._$HY.completed;
  sharedConfig.events = globalThis._$HY.events;
  sharedConfig.load = globalThis._$HY.load;
  sharedConfig.gather = (root2) => gatherHydratable(element, root2);
  sharedConfig.registry = /* @__PURE__ */ new Map();
  sharedConfig.context = {
    id: options2.renderId || "",
    count: 0
  };
  gatherHydratable(element, options2.renderId);
  const dispose2 = render$3(code, element, [...element.childNodes], options2);
  sharedConfig.context = null;
  return dispose2;
}
function getNextElement(template2) {
  let node2, key;
  if (!sharedConfig.context || !(node2 = sharedConfig.registry.get(key = getHydrationKey()))) {
    return template2.cloneNode(true);
  }
  if (sharedConfig.completed)
    sharedConfig.completed.add(node2);
  sharedConfig.registry.delete(key);
  return node2;
}
function getNextMarker(start2) {
  let end2 = start2, count2 = 0, current = [];
  if (sharedConfig.context) {
    while (end2) {
      if (end2.nodeType === 8) {
        const v = end2.nodeValue;
        if (v === "#")
          count2++;
        else if (v === "/") {
          if (count2 === 0)
            return [end2, current];
          count2--;
        }
      }
      current.push(end2);
      end2 = end2.nextSibling;
    }
  }
  return [end2, current];
}
function runHydrationEvents() {
  if (sharedConfig.events && !sharedConfig.events.queued) {
    queueMicrotask(() => {
      const {
        completed,
        events
      } = sharedConfig;
      events.queued = false;
      while (events.length) {
        const [el, e] = events[0];
        if (!completed.has(el))
          return;
        eventHandler(e);
        events.shift();
      }
    });
    sharedConfig.events.queued = true;
  }
}
function toPropertyName(name2) {
  return name2.toLowerCase().replace(/-([a-z])/g, (_2, w2) => w2.toUpperCase());
}
function toggleClassKey(node2, key, value) {
  const classNames = key.trim().split(/\s+/);
  for (let i = 0, nameLen = classNames.length; i < nameLen; i++)
    node2.classList.toggle(classNames[i], value);
}
function assignProp(node2, prop, value, prev2, isSVG, skipRef) {
  let isCE, isProp, isChildProp;
  if (prop === "style")
    return style(node2, value, prev2);
  if (prop === "classList")
    return classList$1(node2, value, prev2);
  if (value === prev2)
    return prev2;
  if (prop === "ref") {
    if (!skipRef)
      value(node2);
  } else if (prop.slice(0, 3) === "on:") {
    const e = prop.slice(3);
    prev2 && node2.removeEventListener(e, prev2);
    value && node2.addEventListener(e, value);
  } else if (prop.slice(0, 10) === "oncapture:") {
    const e = prop.slice(10);
    prev2 && node2.removeEventListener(e, prev2, true);
    value && node2.addEventListener(e, value, true);
  } else if (prop.slice(0, 2) === "on") {
    const name2 = prop.slice(2).toLowerCase();
    const delegate = DelegatedEvents.has(name2);
    if (!delegate && prev2) {
      const h2 = Array.isArray(prev2) ? prev2[0] : prev2;
      node2.removeEventListener(name2, h2);
    }
    if (delegate || value) {
      addEventListener(node2, name2, value, delegate);
      delegate && delegateEvents([name2]);
    }
  } else if ((isChildProp = ChildProperties.has(prop)) || !isSVG && (PropAliases[prop] || (isProp = Properties.has(prop))) || (isCE = node2.nodeName.includes("-"))) {
    if (prop === "class" || prop === "className")
      className(node2, value);
    else if (isCE && !isProp && !isChildProp)
      node2[toPropertyName(prop)] = value;
    else
      node2[PropAliases[prop] || prop] = value;
  } else {
    const ns = isSVG && prop.indexOf(":") > -1 && SVGNamespace[prop.split(":")[0]];
    if (ns)
      setAttributeNS(node2, ns, prop, value);
    else
      setAttribute(node2, Aliases[prop] || prop, value);
  }
  return value;
}
function eventHandler(e) {
  const key = `$$${e.type}`;
  let node2 = e.composedPath && e.composedPath()[0] || e.target;
  if (e.target !== node2) {
    Object.defineProperty(e, "target", {
      configurable: true,
      value: node2
    });
  }
  Object.defineProperty(e, "currentTarget", {
    configurable: true,
    get() {
      return node2 || document;
    }
  });
  if (sharedConfig.registry && !sharedConfig.done) {
    sharedConfig.done = true;
    document.querySelectorAll("[id^=pl-]").forEach((elem) => elem.remove());
  }
  while (node2 !== null) {
    const handler = node2[key];
    if (handler && !node2.disabled) {
      const data2 = node2[`${key}Data`];
      data2 !== void 0 ? handler.call(node2, data2, e) : handler.call(node2, e);
      if (e.cancelBubble)
        return;
    }
    node2 = node2.host && node2.host !== node2 && node2.host instanceof Node ? node2.host : node2.parentNode;
  }
}
function insertExpression(parent, value, current, marker, unwrapArray) {
  if (sharedConfig.context && !current)
    current = [...parent.childNodes];
  while (typeof current === "function")
    current = current();
  if (value === current)
    return current;
  const t4 = typeof value, multi = marker !== void 0;
  parent = multi && current[0] && current[0].parentNode || parent;
  if (t4 === "string" || t4 === "number") {
    if (sharedConfig.context)
      return current;
    if (t4 === "number")
      value = value.toString();
    if (multi) {
      let node2 = current[0];
      if (node2 && node2.nodeType === 3) {
        node2.data = value;
      } else
        node2 = document.createTextNode(value);
      current = cleanChildren(parent, current, marker, node2);
    } else {
      if (current !== "" && typeof current === "string") {
        current = parent.firstChild.data = value;
      } else
        current = parent.textContent = value;
    }
  } else if (value == null || t4 === "boolean") {
    if (sharedConfig.context)
      return current;
    current = cleanChildren(parent, current, marker);
  } else if (t4 === "function") {
    createRenderEffect(() => {
      let v = value();
      while (typeof v === "function")
        v = v();
      current = insertExpression(parent, v, current, marker);
    });
    return () => current;
  } else if (Array.isArray(value)) {
    const array2 = [];
    const currentArray = current && Array.isArray(current);
    if (normalizeIncomingArray(array2, value, current, unwrapArray)) {
      createRenderEffect(() => current = insertExpression(parent, array2, current, marker, true));
      return () => current;
    }
    if (sharedConfig.context) {
      if (!array2.length)
        return current;
      for (let i = 0; i < array2.length; i++) {
        if (array2[i].parentNode)
          return current = array2;
      }
    }
    if (array2.length === 0) {
      current = cleanChildren(parent, current, marker);
      if (multi)
        return current;
    } else if (currentArray) {
      if (current.length === 0) {
        appendNodes(parent, array2, marker);
      } else
        reconcileArrays(parent, current, array2);
    } else {
      current && cleanChildren(parent);
      appendNodes(parent, array2);
    }
    current = array2;
  } else if (value instanceof Node) {
    if (sharedConfig.context && value.parentNode)
      return current = multi ? [value] : value;
    if (Array.isArray(current)) {
      if (multi)
        return current = cleanChildren(parent, current, marker, value);
      cleanChildren(parent, current, null, value);
    } else if (current == null || current === "" || !parent.firstChild) {
      parent.appendChild(value);
    } else
      parent.replaceChild(value, parent.firstChild);
    current = value;
  } else
    ;
  return current;
}
function normalizeIncomingArray(normalized, array2, current, unwrap) {
  let dynamic = false;
  for (let i = 0, len = array2.length; i < len; i++) {
    let item = array2[i], prev2 = current && current[i];
    if (item instanceof Node) {
      normalized.push(item);
    } else if (item == null || item === true || item === false)
      ;
    else if (Array.isArray(item)) {
      dynamic = normalizeIncomingArray(normalized, item, prev2) || dynamic;
    } else if (typeof item === "function") {
      if (unwrap) {
        while (typeof item === "function")
          item = item();
        dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item], Array.isArray(prev2) ? prev2 : [prev2]) || dynamic;
      } else {
        normalized.push(item);
        dynamic = true;
      }
    } else {
      const value = String(item);
      if (prev2 && prev2.nodeType === 3 && prev2.data === value) {
        normalized.push(prev2);
      } else
        normalized.push(document.createTextNode(value));
    }
  }
  return dynamic;
}
function appendNodes(parent, array2, marker = null) {
  for (let i = 0, len = array2.length; i < len; i++)
    parent.insertBefore(array2[i], marker);
}
function cleanChildren(parent, current, marker, replacement) {
  if (marker === void 0)
    return parent.textContent = "";
  const node2 = replacement || document.createTextNode("");
  if (current.length) {
    let inserted = false;
    for (let i = current.length - 1; i >= 0; i--) {
      const el = current[i];
      if (node2 !== el) {
        const isParent2 = el.parentNode === parent;
        if (!inserted && !i)
          isParent2 ? parent.replaceChild(node2, el) : parent.insertBefore(node2, marker);
        else
          isParent2 && el.remove();
      } else
        inserted = true;
    }
  } else
    parent.insertBefore(node2, marker);
  return [node2];
}
function gatherHydratable(element, root2) {
  const templates = element.querySelectorAll(`*[data-hk]`);
  for (let i = 0; i < templates.length; i++) {
    const node2 = templates[i];
    const key = node2.getAttribute("data-hk");
    if ((!root2 || key.startsWith(root2)) && !sharedConfig.registry.has(key))
      sharedConfig.registry.set(key, node2);
  }
}
function getHydrationKey() {
  const hydrate2 = sharedConfig.context;
  return `${hydrate2.id}${hydrate2.count++}`;
}
const hydrate = (...args) => {
  enableHydration();
  return hydrate$1(...args);
};
class Text {
  constructor() {
  }
  lineAt(pos) {
    if (pos < 0 || pos > this.length)
      throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
    return this.lineInner(pos, false, 1, 0);
  }
  line(n) {
    if (n < 1 || n > this.lines)
      throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
    return this.lineInner(n, true, 1, 0);
  }
  replace(from2, to2, text2) {
    let parts = [];
    this.decompose(0, from2, parts, 2);
    if (text2.length)
      text2.decompose(0, text2.length, parts, 1 | 2);
    this.decompose(to2, this.length, parts, 1);
    return TextNode.from(parts, this.length - (to2 - from2) + text2.length);
  }
  append(other) {
    return this.replace(this.length, this.length, other);
  }
  slice(from2, to2 = this.length) {
    let parts = [];
    this.decompose(from2, to2, parts, 0);
    return TextNode.from(parts, to2 - from2);
  }
  eq(other) {
    if (other == this)
      return true;
    if (other.length != this.length || other.lines != this.lines)
      return false;
    let start2 = this.scanIdentical(other, 1), end2 = this.length - this.scanIdentical(other, -1);
    let a2 = new RawTextCursor(this), b = new RawTextCursor(other);
    for (let skip = start2, pos = start2; ; ) {
      a2.next(skip);
      b.next(skip);
      skip = 0;
      if (a2.lineBreak != b.lineBreak || a2.done != b.done || a2.value != b.value)
        return false;
      pos += a2.value.length;
      if (a2.done || pos >= end2)
        return true;
    }
  }
  iter(dir = 1) {
    return new RawTextCursor(this, dir);
  }
  iterRange(from2, to2 = this.length) {
    return new PartialTextCursor(this, from2, to2);
  }
  iterLines(from2, to2) {
    let inner;
    if (from2 == null) {
      inner = this.iter();
    } else {
      if (to2 == null)
        to2 = this.lines + 1;
      let start2 = this.line(from2).from;
      inner = this.iterRange(start2, Math.max(start2, to2 == this.lines + 1 ? this.length : to2 <= 1 ? 0 : this.line(to2 - 1).to));
    }
    return new LineCursor(inner);
  }
  toString() {
    return this.sliceString(0);
  }
  toJSON() {
    let lines = [];
    this.flatten(lines);
    return lines;
  }
  static of(text2) {
    if (text2.length == 0)
      throw new RangeError("A document must have at least one line");
    if (text2.length == 1 && !text2[0])
      return Text.empty;
    return text2.length <= 32 ? new TextLeaf(text2) : TextNode.from(TextLeaf.split(text2, []));
  }
}
class TextLeaf extends Text {
  constructor(text2, length2 = textLength(text2)) {
    super();
    this.text = text2;
    this.length = length2;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(target, isLine, line2, offset) {
    for (let i = 0; ; i++) {
      let string2 = this.text[i], end2 = offset + string2.length;
      if ((isLine ? line2 : end2) >= target)
        return new Line$1(offset, end2, line2, string2);
      offset = end2 + 1;
      line2++;
    }
  }
  decompose(from2, to2, target, open) {
    let text2 = from2 <= 0 && to2 >= this.length ? this : new TextLeaf(sliceText(this.text, from2, to2), Math.min(to2, this.length) - Math.max(0, from2));
    if (open & 1) {
      let prev2 = target.pop();
      let joined = appendText(text2.text, prev2.text.slice(), 0, text2.length);
      if (joined.length <= 32) {
        target.push(new TextLeaf(joined, prev2.length + text2.length));
      } else {
        let mid = joined.length >> 1;
        target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
      }
    } else {
      target.push(text2);
    }
  }
  replace(from2, to2, text2) {
    if (!(text2 instanceof TextLeaf))
      return super.replace(from2, to2, text2);
    let lines = appendText(this.text, appendText(text2.text, sliceText(this.text, 0, from2)), to2);
    let newLen = this.length + text2.length - (to2 - from2);
    if (lines.length <= 32)
      return new TextLeaf(lines, newLen);
    return TextNode.from(TextLeaf.split(lines, []), newLen);
  }
  sliceString(from2, to2 = this.length, lineSep = "\n") {
    let result = "";
    for (let pos = 0, i = 0; pos <= to2 && i < this.text.length; i++) {
      let line2 = this.text[i], end2 = pos + line2.length;
      if (pos > from2 && i)
        result += lineSep;
      if (from2 < end2 && to2 > pos)
        result += line2.slice(Math.max(0, from2 - pos), to2 - pos);
      pos = end2 + 1;
    }
    return result;
  }
  flatten(target) {
    for (let line2 of this.text)
      target.push(line2);
  }
  scanIdentical() {
    return 0;
  }
  static split(text2, target) {
    let part = [], len = -1;
    for (let line2 of text2) {
      part.push(line2);
      len += line2.length + 1;
      if (part.length == 32) {
        target.push(new TextLeaf(part, len));
        part = [];
        len = -1;
      }
    }
    if (len > -1)
      target.push(new TextLeaf(part, len));
    return target;
  }
}
class TextNode extends Text {
  constructor(children2, length2) {
    super();
    this.children = children2;
    this.length = length2;
    this.lines = 0;
    for (let child of children2)
      this.lines += child.lines;
  }
  lineInner(target, isLine, line2, offset) {
    for (let i = 0; ; i++) {
      let child = this.children[i], end2 = offset + child.length, endLine = line2 + child.lines - 1;
      if ((isLine ? endLine : end2) >= target)
        return child.lineInner(target, isLine, line2, offset);
      offset = end2 + 1;
      line2 = endLine + 1;
    }
  }
  decompose(from2, to2, target, open) {
    for (let i = 0, pos = 0; pos <= to2 && i < this.children.length; i++) {
      let child = this.children[i], end2 = pos + child.length;
      if (from2 <= end2 && to2 >= pos) {
        let childOpen = open & ((pos <= from2 ? 1 : 0) | (end2 >= to2 ? 2 : 0));
        if (pos >= from2 && end2 <= to2 && !childOpen)
          target.push(child);
        else
          child.decompose(from2 - pos, to2 - pos, target, childOpen);
      }
      pos = end2 + 1;
    }
  }
  replace(from2, to2, text2) {
    if (text2.lines < this.lines)
      for (let i = 0, pos = 0; i < this.children.length; i++) {
        let child = this.children[i], end2 = pos + child.length;
        if (from2 >= pos && to2 <= end2) {
          let updated = child.replace(from2 - pos, to2 - pos, text2);
          let totalLines = this.lines - child.lines + updated.lines;
          if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
            let copy2 = this.children.slice();
            copy2[i] = updated;
            return new TextNode(copy2, this.length - (to2 - from2) + text2.length);
          }
          return super.replace(pos, end2, updated);
        }
        pos = end2 + 1;
      }
    return super.replace(from2, to2, text2);
  }
  sliceString(from2, to2 = this.length, lineSep = "\n") {
    let result = "";
    for (let i = 0, pos = 0; i < this.children.length && pos <= to2; i++) {
      let child = this.children[i], end2 = pos + child.length;
      if (pos > from2 && i)
        result += lineSep;
      if (from2 < end2 && to2 > pos)
        result += child.sliceString(from2 - pos, to2 - pos, lineSep);
      pos = end2 + 1;
    }
    return result;
  }
  flatten(target) {
    for (let child of this.children)
      child.flatten(target);
  }
  scanIdentical(other, dir) {
    if (!(other instanceof TextNode))
      return 0;
    let length2 = 0;
    let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
    for (; ; iA += dir, iB += dir) {
      if (iA == eA || iB == eB)
        return length2;
      let chA = this.children[iA], chB = other.children[iB];
      if (chA != chB)
        return length2 + chA.scanIdentical(chB, dir);
      length2 += chA.length + 1;
    }
  }
  static from(children2, length2 = children2.reduce((l2, ch) => l2 + ch.length + 1, -1)) {
    let lines = 0;
    for (let ch of children2)
      lines += ch.lines;
    if (lines < 32) {
      let flat = [];
      for (let ch of children2)
        ch.flatten(flat);
      return new TextLeaf(flat, length2);
    }
    let chunk = Math.max(32, lines >> 5), maxChunk = chunk << 1, minChunk = chunk >> 1;
    let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
    function add2(child) {
      let last;
      if (child.lines > maxChunk && child instanceof TextNode) {
        for (let node2 of child.children)
          add2(node2);
      } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
        flush();
        chunked.push(child);
      } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32) {
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
      } else {
        if (currentLines + child.lines > chunk)
          flush();
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk.push(child);
      }
    }
    function flush() {
      if (currentLines == 0)
        return;
      chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
      currentLen = -1;
      currentLines = currentChunk.length = 0;
    }
    for (let child of children2)
      add2(child);
    flush();
    return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length2);
  }
}
Text.empty = /* @__PURE__ */ new TextLeaf([""], 0);
function textLength(text2) {
  let length2 = -1;
  for (let line2 of text2)
    length2 += line2.length + 1;
  return length2;
}
function appendText(text2, target, from2 = 0, to2 = 1e9) {
  for (let pos = 0, i = 0, first = true; i < text2.length && pos <= to2; i++) {
    let line2 = text2[i], end2 = pos + line2.length;
    if (end2 >= from2) {
      if (end2 > to2)
        line2 = line2.slice(0, to2 - pos);
      if (pos < from2)
        line2 = line2.slice(from2 - pos);
      if (first) {
        target[target.length - 1] += line2;
        first = false;
      } else
        target.push(line2);
    }
    pos = end2 + 1;
  }
  return target;
}
function sliceText(text2, from2, to2) {
  return appendText(text2, [""], from2, to2);
}
class RawTextCursor {
  constructor(text2, dir = 1) {
    this.dir = dir;
    this.done = false;
    this.lineBreak = false;
    this.value = "";
    this.nodes = [text2];
    this.offsets = [dir > 0 ? 1 : (text2 instanceof TextLeaf ? text2.text.length : text2.children.length) << 1];
  }
  nextInner(skip, dir) {
    this.done = this.lineBreak = false;
    for (; ; ) {
      let last = this.nodes.length - 1;
      let top2 = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;
      let size = top2 instanceof TextLeaf ? top2.text.length : top2.children.length;
      if (offset == (dir > 0 ? size : 0)) {
        if (last == 0) {
          this.done = true;
          this.value = "";
          return this;
        }
        if (dir > 0)
          this.offsets[last - 1]++;
        this.nodes.pop();
        this.offsets.pop();
      } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
        this.offsets[last] += dir;
        if (skip == 0) {
          this.lineBreak = true;
          this.value = "\n";
          return this;
        }
        skip--;
      } else if (top2 instanceof TextLeaf) {
        let next2 = top2.text[offset + (dir < 0 ? -1 : 0)];
        this.offsets[last] += dir;
        if (next2.length > Math.max(0, skip)) {
          this.value = skip == 0 ? next2 : dir > 0 ? next2.slice(skip) : next2.slice(0, next2.length - skip);
          return this;
        }
        skip -= next2.length;
      } else {
        let next2 = top2.children[offset + (dir < 0 ? -1 : 0)];
        if (skip > next2.length) {
          skip -= next2.length;
          this.offsets[last] += dir;
        } else {
          if (dir < 0)
            this.offsets[last]--;
          this.nodes.push(next2);
          this.offsets.push(dir > 0 ? 1 : (next2 instanceof TextLeaf ? next2.text.length : next2.children.length) << 1);
        }
      }
    }
  }
  next(skip = 0) {
    if (skip < 0) {
      this.nextInner(-skip, -this.dir);
      skip = this.value.length;
    }
    return this.nextInner(skip, this.dir);
  }
}
class PartialTextCursor {
  constructor(text2, start2, end2) {
    this.value = "";
    this.done = false;
    this.cursor = new RawTextCursor(text2, start2 > end2 ? -1 : 1);
    this.pos = start2 > end2 ? text2.length : 0;
    this.from = Math.min(start2, end2);
    this.to = Math.max(start2, end2);
  }
  nextInner(skip, dir) {
    if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
      this.value = "";
      this.done = true;
      return this;
    }
    skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
    let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
    if (skip > limit)
      skip = limit;
    limit -= skip;
    let { value } = this.cursor.next(skip);
    this.pos += (value.length + skip) * dir;
    this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
    this.done = !this.value;
    return this;
  }
  next(skip = 0) {
    if (skip < 0)
      skip = Math.max(skip, this.from - this.pos);
    else if (skip > 0)
      skip = Math.min(skip, this.to - this.pos);
    return this.nextInner(skip, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class LineCursor {
  constructor(inner) {
    this.inner = inner;
    this.afterBreak = true;
    this.value = "";
    this.done = false;
  }
  next(skip = 0) {
    let { done, lineBreak, value } = this.inner.next(skip);
    if (done) {
      this.done = true;
      this.value = "";
    } else if (lineBreak) {
      if (this.afterBreak) {
        this.value = "";
      } else {
        this.afterBreak = true;
        this.next();
      }
    } else {
      this.value = value;
      this.afterBreak = false;
    }
    return this;
  }
  get lineBreak() {
    return false;
  }
}
if (typeof Symbol != "undefined") {
  Text.prototype[Symbol.iterator] = function() {
    return this.iter();
  };
  RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function() {
    return this;
  };
}
class Line$1 {
  constructor(from2, to2, number3, text2) {
    this.from = from2;
    this.to = to2;
    this.number = number3;
    this.text = text2;
  }
  get length() {
    return this.to - this.from;
  }
}
let extend$1 = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s2) => s2 ? parseInt(s2, 36) : 1);
for (let i = 1; i < extend$1.length; i++)
  extend$1[i] += extend$1[i - 1];
function isExtendingChar(code) {
  for (let i = 1; i < extend$1.length; i += 2)
    if (extend$1[i] > code)
      return extend$1[i - 1] <= code;
  return false;
}
function isRegionalIndicator(code) {
  return code >= 127462 && code <= 127487;
}
const ZWJ = 8205;
function findClusterBreak(str, pos, forward = true, includeExtending = true) {
  return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
}
function nextClusterBreak(str, pos, includeExtending) {
  if (pos == str.length)
    return pos;
  if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))
    pos--;
  let prev2 = codePointAt(str, pos);
  pos += codePointSize(prev2);
  while (pos < str.length) {
    let next2 = codePointAt(str, pos);
    if (prev2 == ZWJ || next2 == ZWJ || includeExtending && isExtendingChar(next2)) {
      pos += codePointSize(next2);
      prev2 = next2;
    } else if (isRegionalIndicator(next2)) {
      let countBefore = 0, i = pos - 2;
      while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {
        countBefore++;
        i -= 2;
      }
      if (countBefore % 2 == 0)
        break;
      else
        pos += 2;
    } else {
      break;
    }
  }
  return pos;
}
function prevClusterBreak(str, pos, includeExtending) {
  while (pos > 0) {
    let found = nextClusterBreak(str, pos - 2, includeExtending);
    if (found < pos)
      return found;
    pos--;
  }
  return 0;
}
function surrogateLow(ch) {
  return ch >= 56320 && ch < 57344;
}
function surrogateHigh(ch) {
  return ch >= 55296 && ch < 56320;
}
function codePointAt(str, pos) {
  let code0 = str.charCodeAt(pos);
  if (!surrogateHigh(code0) || pos + 1 == str.length)
    return code0;
  let code1 = str.charCodeAt(pos + 1);
  if (!surrogateLow(code1))
    return code0;
  return (code0 - 55296 << 10) + (code1 - 56320) + 65536;
}
function fromCodePoint(code) {
  if (code <= 65535)
    return String.fromCharCode(code);
  code -= 65536;
  return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
function codePointSize(code) {
  return code < 65536 ? 1 : 2;
}
const DefaultSplit = /\r\n?|\n/;
var MapMode = /* @__PURE__ */ function(MapMode2) {
  MapMode2[MapMode2["Simple"] = 0] = "Simple";
  MapMode2[MapMode2["TrackDel"] = 1] = "TrackDel";
  MapMode2[MapMode2["TrackBefore"] = 2] = "TrackBefore";
  MapMode2[MapMode2["TrackAfter"] = 3] = "TrackAfter";
  return MapMode2;
}(MapMode || (MapMode = {}));
class ChangeDesc {
  constructor(sections2) {
    this.sections = sections2;
  }
  get length() {
    let result = 0;
    for (let i = 0; i < this.sections.length; i += 2)
      result += this.sections[i];
    return result;
  }
  get newLength() {
    let result = 0;
    for (let i = 0; i < this.sections.length; i += 2) {
      let ins = this.sections[i + 1];
      result += ins < 0 ? this.sections[i] : ins;
    }
    return result;
  }
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  iterGaps(f2) {
    for (let i = 0, posA = 0, posB = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++];
      if (ins < 0) {
        f2(posA, posB, len);
        posB += len;
      } else {
        posB += ins;
      }
      posA += len;
    }
  }
  iterChangedRanges(f2, individual = false) {
    iterChanges(this, f2, individual);
  }
  get invertedDesc() {
    let sections2 = [];
    for (let i = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++];
      if (ins < 0)
        sections2.push(len, ins);
      else
        sections2.push(ins, len);
    }
    return new ChangeDesc(sections2);
  }
  composeDesc(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other);
  }
  mapDesc(other, before = false) {
    return other.empty ? this : mapSet(this, other, before);
  }
  mapPos(pos, assoc = -1, mode = MapMode.Simple) {
    let posA = 0, posB = 0;
    for (let i = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;
      if (ins < 0) {
        if (endA > pos)
          return posB + (pos - posA);
        posB += len;
      } else {
        if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos))
          return null;
        if (endA > pos || endA == pos && assoc < 0 && !len)
          return pos == posA || assoc < 0 ? posB : posB + ins;
        posB += ins;
      }
      posA = endA;
    }
    if (pos > posA)
      throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
    return posB;
  }
  touchesRange(from2, to2 = from2) {
    for (let i = 0, pos = 0; i < this.sections.length && pos <= to2; ) {
      let len = this.sections[i++], ins = this.sections[i++], end2 = pos + len;
      if (ins >= 0 && pos <= to2 && end2 >= from2)
        return pos < from2 && end2 > to2 ? "cover" : true;
      pos = end2;
    }
    return false;
  }
  toString() {
    let result = "";
    for (let i = 0; i < this.sections.length; ) {
      let len = this.sections[i++], ins = this.sections[i++];
      result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
    }
    return result;
  }
  toJSON() {
    return this.sections;
  }
  static fromJSON(json2) {
    if (!Array.isArray(json2) || json2.length % 2 || json2.some((a2) => typeof a2 != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new ChangeDesc(json2);
  }
  static create(sections2) {
    return new ChangeDesc(sections2);
  }
}
class ChangeSet extends ChangeDesc {
  constructor(sections2, inserted) {
    super(sections2);
    this.inserted = inserted;
  }
  apply(doc2) {
    if (this.length != doc2.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    iterChanges(this, (fromA, toA, fromB, _toB, text2) => doc2 = doc2.replace(fromB, fromB + (toA - fromA), text2), false);
    return doc2;
  }
  mapDesc(other, before = false) {
    return mapSet(this, other, before, true);
  }
  invert(doc2) {
    let sections2 = this.sections.slice(), inserted = [];
    for (let i = 0, pos = 0; i < sections2.length; i += 2) {
      let len = sections2[i], ins = sections2[i + 1];
      if (ins >= 0) {
        sections2[i] = ins;
        sections2[i + 1] = len;
        let index2 = i >> 1;
        while (inserted.length < index2)
          inserted.push(Text.empty);
        inserted.push(len ? doc2.slice(pos, pos + len) : Text.empty);
      }
      pos += len;
    }
    return new ChangeSet(sections2, inserted);
  }
  compose(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other, true);
  }
  map(other, before = false) {
    return other.empty ? this : mapSet(this, other, before, true);
  }
  iterChanges(f2, individual = false) {
    iterChanges(this, f2, individual);
  }
  get desc() {
    return ChangeDesc.create(this.sections);
  }
  filter(ranges2) {
    let resultSections = [], resultInserted = [], filteredSections = [];
    let iter = new SectionIter(this);
    done:
      for (let i = 0, pos = 0; ; ) {
        let next2 = i == ranges2.length ? 1e9 : ranges2[i++];
        while (pos < next2 || pos == next2 && iter.len == 0) {
          if (iter.done)
            break done;
          let len = Math.min(iter.len, next2 - pos);
          addSection$3(filteredSections, len, -1);
          let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
          addSection$3(resultSections, len, ins);
          if (ins > 0)
            addInsert(resultInserted, resultSections, iter.text);
          iter.forward(len);
          pos += len;
        }
        let end2 = ranges2[i++];
        while (pos < end2) {
          if (iter.done)
            break done;
          let len = Math.min(iter.len, end2 - pos);
          addSection$3(resultSections, len, -1);
          addSection$3(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
          iter.forward(len);
          pos += len;
        }
      }
    return {
      changes: new ChangeSet(resultSections, resultInserted),
      filtered: ChangeDesc.create(filteredSections)
    };
  }
  toJSON() {
    let parts = [];
    for (let i = 0; i < this.sections.length; i += 2) {
      let len = this.sections[i], ins = this.sections[i + 1];
      if (ins < 0)
        parts.push(len);
      else if (ins == 0)
        parts.push([len]);
      else
        parts.push([len].concat(this.inserted[i >> 1].toJSON()));
    }
    return parts;
  }
  static of(changes, length2, lineSep) {
    let sections2 = [], inserted = [], pos = 0;
    let total = null;
    function flush(force = false) {
      if (!force && !sections2.length)
        return;
      if (pos < length2)
        addSection$3(sections2, length2 - pos, -1);
      let set2 = new ChangeSet(sections2, inserted);
      total = total ? total.compose(set2.map(total)) : set2;
      sections2 = [];
      inserted = [];
      pos = 0;
    }
    function process2(spec) {
      if (Array.isArray(spec)) {
        for (let sub of spec)
          process2(sub);
      } else if (spec instanceof ChangeSet) {
        if (spec.length != length2)
          throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length2})`);
        flush();
        total = total ? total.compose(spec.map(total)) : spec;
      } else {
        let { from: from2, to: to2 = from2, insert: insert2 } = spec;
        if (from2 > to2 || from2 < 0 || to2 > length2)
          throw new RangeError(`Invalid change range ${from2} to ${to2} (in doc of length ${length2})`);
        let insText = !insert2 ? Text.empty : typeof insert2 == "string" ? Text.of(insert2.split(lineSep || DefaultSplit)) : insert2;
        let insLen = insText.length;
        if (from2 == to2 && insLen == 0)
          return;
        if (from2 < pos)
          flush();
        if (from2 > pos)
          addSection$3(sections2, from2 - pos, -1);
        addSection$3(sections2, to2 - from2, insLen);
        addInsert(inserted, sections2, insText);
        pos = to2;
      }
    }
    process2(changes);
    flush(!total);
    return total;
  }
  static empty(length2) {
    return new ChangeSet(length2 ? [length2, -1] : [], []);
  }
  static fromJSON(json2) {
    if (!Array.isArray(json2))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let sections2 = [], inserted = [];
    for (let i = 0; i < json2.length; i++) {
      let part = json2[i];
      if (typeof part == "number") {
        sections2.push(part, -1);
      } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i2) => i2 && typeof e != "string")) {
        throw new RangeError("Invalid JSON representation of ChangeSet");
      } else if (part.length == 1) {
        sections2.push(part[0], 0);
      } else {
        while (inserted.length < i)
          inserted.push(Text.empty);
        inserted[i] = Text.of(part.slice(1));
        sections2.push(part[0], inserted[i].length);
      }
    }
    return new ChangeSet(sections2, inserted);
  }
  static createSet(sections2, inserted) {
    return new ChangeSet(sections2, inserted);
  }
}
function addSection$3(sections2, len, ins, forceJoin = false) {
  if (len == 0 && ins <= 0)
    return;
  let last = sections2.length - 2;
  if (last >= 0 && ins <= 0 && ins == sections2[last + 1])
    sections2[last] += len;
  else if (len == 0 && sections2[last] == 0)
    sections2[last + 1] += ins;
  else if (forceJoin) {
    sections2[last] += len;
    sections2[last + 1] += ins;
  } else
    sections2.push(len, ins);
}
function addInsert(values2, sections2, value) {
  if (value.length == 0)
    return;
  let index2 = sections2.length - 2 >> 1;
  if (index2 < values2.length) {
    values2[values2.length - 1] = values2[values2.length - 1].append(value);
  } else {
    while (values2.length < index2)
      values2.push(Text.empty);
    values2.push(value);
  }
}
function iterChanges(desc, f2, individual) {
  let inserted = desc.inserted;
  for (let posA = 0, posB = 0, i = 0; i < desc.sections.length; ) {
    let len = desc.sections[i++], ins = desc.sections[i++];
    if (ins < 0) {
      posA += len;
      posB += len;
    } else {
      let endA = posA, endB = posB, text2 = Text.empty;
      for (; ; ) {
        endA += len;
        endB += ins;
        if (ins && inserted)
          text2 = text2.append(inserted[i - 2 >> 1]);
        if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)
          break;
        len = desc.sections[i++];
        ins = desc.sections[i++];
      }
      f2(posA, endA, posB, endB, text2);
      posA = endA;
      posB = endB;
    }
  }
}
function mapSet(setA, setB, before, mkSet = false) {
  let sections2 = [], insert2 = mkSet ? [] : null;
  let a2 = new SectionIter(setA), b = new SectionIter(setB);
  for (let inserted = -1; ; ) {
    if (a2.ins == -1 && b.ins == -1) {
      let len = Math.min(a2.len, b.len);
      addSection$3(sections2, len, -1);
      a2.forward(len);
      b.forward(len);
    } else if (b.ins >= 0 && (a2.ins < 0 || inserted == a2.i || a2.off == 0 && (b.len < a2.len || b.len == a2.len && !before))) {
      let len = b.len;
      addSection$3(sections2, b.ins, -1);
      while (len) {
        let piece = Math.min(a2.len, len);
        if (a2.ins >= 0 && inserted < a2.i && a2.len <= piece) {
          addSection$3(sections2, 0, a2.ins);
          if (insert2)
            addInsert(insert2, sections2, a2.text);
          inserted = a2.i;
        }
        a2.forward(piece);
        len -= piece;
      }
      b.next();
    } else if (a2.ins >= 0) {
      let len = 0, left2 = a2.len;
      while (left2) {
        if (b.ins == -1) {
          let piece = Math.min(left2, b.len);
          len += piece;
          left2 -= piece;
          b.forward(piece);
        } else if (b.ins == 0 && b.len < left2) {
          left2 -= b.len;
          b.next();
        } else {
          break;
        }
      }
      addSection$3(sections2, len, inserted < a2.i ? a2.ins : 0);
      if (insert2 && inserted < a2.i)
        addInsert(insert2, sections2, a2.text);
      inserted = a2.i;
      a2.forward(a2.len - left2);
    } else if (a2.done && b.done) {
      return insert2 ? ChangeSet.createSet(sections2, insert2) : ChangeDesc.create(sections2);
    } else {
      throw new Error("Mismatched change set lengths");
    }
  }
}
function composeSets(setA, setB, mkSet = false) {
  let sections2 = [];
  let insert2 = mkSet ? [] : null;
  let a2 = new SectionIter(setA), b = new SectionIter(setB);
  for (let open = false; ; ) {
    if (a2.done && b.done) {
      return insert2 ? ChangeSet.createSet(sections2, insert2) : ChangeDesc.create(sections2);
    } else if (a2.ins == 0) {
      addSection$3(sections2, a2.len, 0, open);
      a2.next();
    } else if (b.len == 0 && !b.done) {
      addSection$3(sections2, 0, b.ins, open);
      if (insert2)
        addInsert(insert2, sections2, b.text);
      b.next();
    } else if (a2.done || b.done) {
      throw new Error("Mismatched change set lengths");
    } else {
      let len = Math.min(a2.len2, b.len), sectionLen = sections2.length;
      if (a2.ins == -1) {
        let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
        addSection$3(sections2, len, insB, open);
        if (insert2 && insB)
          addInsert(insert2, sections2, b.text);
      } else if (b.ins == -1) {
        addSection$3(sections2, a2.off ? 0 : a2.len, len, open);
        if (insert2)
          addInsert(insert2, sections2, a2.textBit(len));
      } else {
        addSection$3(sections2, a2.off ? 0 : a2.len, b.off ? 0 : b.ins, open);
        if (insert2 && !b.off)
          addInsert(insert2, sections2, b.text);
      }
      open = (a2.ins > len || b.ins >= 0 && b.len > len) && (open || sections2.length > sectionLen);
      a2.forward2(len);
      b.forward(len);
    }
  }
}
class SectionIter {
  constructor(set2) {
    this.set = set2;
    this.i = 0;
    this.next();
  }
  next() {
    let { sections: sections2 } = this.set;
    if (this.i < sections2.length) {
      this.len = sections2[this.i++];
      this.ins = sections2[this.i++];
    } else {
      this.len = 0;
      this.ins = -2;
    }
    this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted } = this.set, index2 = this.i - 2 >> 1;
    return index2 >= inserted.length ? Text.empty : inserted[index2];
  }
  textBit(len) {
    let { inserted } = this.set, index2 = this.i - 2 >> 1;
    return index2 >= inserted.length && !len ? Text.empty : inserted[index2].slice(this.off, len == null ? void 0 : this.off + len);
  }
  forward(len) {
    if (len == this.len)
      this.next();
    else {
      this.len -= len;
      this.off += len;
    }
  }
  forward2(len) {
    if (this.ins == -1)
      this.forward(len);
    else if (len == this.ins)
      this.next();
    else {
      this.ins -= len;
      this.off += len;
    }
  }
}
class SelectionRange {
  constructor(from2, to2, flags) {
    this.from = from2;
    this.to = to2;
    this.flags = flags;
  }
  get anchor() {
    return this.flags & 16 ? this.to : this.from;
  }
  get head() {
    return this.flags & 16 ? this.from : this.to;
  }
  get empty() {
    return this.from == this.to;
  }
  get assoc() {
    return this.flags & 4 ? -1 : this.flags & 8 ? 1 : 0;
  }
  get bidiLevel() {
    let level = this.flags & 3;
    return level == 3 ? null : level;
  }
  get goalColumn() {
    let value = this.flags >> 5;
    return value == 33554431 ? void 0 : value;
  }
  map(change2, assoc = -1) {
    let from2, to2;
    if (this.empty) {
      from2 = to2 = change2.mapPos(this.from, assoc);
    } else {
      from2 = change2.mapPos(this.from, 1);
      to2 = change2.mapPos(this.to, -1);
    }
    return from2 == this.from && to2 == this.to ? this : new SelectionRange(from2, to2, this.flags);
  }
  extend(from2, to2 = from2) {
    if (from2 <= this.anchor && to2 >= this.anchor)
      return EditorSelection.range(from2, to2);
    let head2 = Math.abs(from2 - this.anchor) > Math.abs(to2 - this.anchor) ? from2 : to2;
    return EditorSelection.range(this.anchor, head2);
  }
  eq(other) {
    return this.anchor == other.anchor && this.head == other.head;
  }
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  static fromJSON(json2) {
    if (!json2 || typeof json2.anchor != "number" || typeof json2.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return EditorSelection.range(json2.anchor, json2.head);
  }
  static create(from2, to2, flags) {
    return new SelectionRange(from2, to2, flags);
  }
}
class EditorSelection {
  constructor(ranges2, mainIndex) {
    this.ranges = ranges2;
    this.mainIndex = mainIndex;
  }
  map(change2, assoc = -1) {
    if (change2.empty)
      return this;
    return EditorSelection.create(this.ranges.map((r) => r.map(change2, assoc)), this.mainIndex);
  }
  eq(other) {
    if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex)
      return false;
    for (let i = 0; i < this.ranges.length; i++)
      if (!this.ranges[i].eq(other.ranges[i]))
        return false;
    return true;
  }
  get main() {
    return this.ranges[this.mainIndex];
  }
  asSingle() {
    return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);
  }
  addRange(range2, main2 = true) {
    return EditorSelection.create([range2].concat(this.ranges), main2 ? 0 : this.mainIndex + 1);
  }
  replaceRange(range2, which = this.mainIndex) {
    let ranges2 = this.ranges.slice();
    ranges2[which] = range2;
    return EditorSelection.create(ranges2, this.mainIndex);
  }
  toJSON() {
    return { ranges: this.ranges.map((r) => r.toJSON()), main: this.mainIndex };
  }
  static fromJSON(json2) {
    if (!json2 || !Array.isArray(json2.ranges) || typeof json2.main != "number" || json2.main >= json2.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new EditorSelection(json2.ranges.map((r) => SelectionRange.fromJSON(r)), json2.main);
  }
  static single(anchor, head2 = anchor) {
    return new EditorSelection([EditorSelection.range(anchor, head2)], 0);
  }
  static create(ranges2, mainIndex = 0) {
    if (ranges2.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let pos = 0, i = 0; i < ranges2.length; i++) {
      let range2 = ranges2[i];
      if (range2.empty ? range2.from <= pos : range2.from < pos)
        return EditorSelection.normalized(ranges2.slice(), mainIndex);
      pos = range2.to;
    }
    return new EditorSelection(ranges2, mainIndex);
  }
  static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
    return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 4 : 8) | (bidiLevel == null ? 3 : Math.min(2, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5);
  }
  static range(anchor, head2, goalColumn) {
    let goal = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 33554431) << 5;
    return head2 < anchor ? SelectionRange.create(head2, anchor, 16 | goal | 8) : SelectionRange.create(anchor, head2, goal | (head2 > anchor ? 4 : 0));
  }
  static normalized(ranges2, mainIndex = 0) {
    let main2 = ranges2[mainIndex];
    ranges2.sort((a2, b) => a2.from - b.from);
    mainIndex = ranges2.indexOf(main2);
    for (let i = 1; i < ranges2.length; i++) {
      let range2 = ranges2[i], prev2 = ranges2[i - 1];
      if (range2.empty ? range2.from <= prev2.to : range2.from < prev2.to) {
        let from2 = prev2.from, to2 = Math.max(range2.to, prev2.to);
        if (i <= mainIndex)
          mainIndex--;
        ranges2.splice(--i, 2, range2.anchor > range2.head ? EditorSelection.range(to2, from2) : EditorSelection.range(from2, to2));
      }
    }
    return new EditorSelection(ranges2, mainIndex);
  }
}
function checkSelection(selection2, docLength) {
  for (let range2 of selection2.ranges)
    if (range2.to > docLength)
      throw new RangeError("Selection points outside of document");
}
let nextID = 0;
class Facet {
  constructor(combine, compareInput, compare2, isStatic, enables) {
    this.combine = combine;
    this.compareInput = compareInput;
    this.compare = compare2;
    this.isStatic = isStatic;
    this.id = nextID++;
    this.default = combine([]);
    this.extensions = typeof enables == "function" ? enables(this) : enables;
  }
  static define(config2 = {}) {
    return new Facet(config2.combine || ((a2) => a2), config2.compareInput || ((a2, b) => a2 === b), config2.compare || (!config2.combine ? sameArray$1 : (a2, b) => a2 === b), !!config2.static, config2.enables);
  }
  of(value) {
    return new FacetProvider([], this, 0, value);
  }
  compute(deps, get2) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 1, get2);
  }
  computeN(deps, get2) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 2, get2);
  }
  from(field, get2) {
    if (!get2)
      get2 = (x2) => x2;
    return this.compute([field], (state) => get2(state.field(field)));
  }
}
function sameArray$1(a2, b) {
  return a2 == b || a2.length == b.length && a2.every((e, i) => e === b[i]);
}
class FacetProvider {
  constructor(dependencies2, facet, type2, value) {
    this.dependencies = dependencies2;
    this.facet = facet;
    this.type = type2;
    this.value = value;
    this.id = nextID++;
  }
  dynamicSlot(addresses) {
    var _a2;
    let getter = this.value;
    let compare2 = this.facet.compareInput;
    let id2 = this.id, idx = addresses[id2] >> 1, multi = this.type == 2;
    let depDoc = false, depSel = false, depAddrs = [];
    for (let dep of this.dependencies) {
      if (dep == "doc")
        depDoc = true;
      else if (dep == "selection")
        depSel = true;
      else if ((((_a2 = addresses[dep.id]) !== null && _a2 !== void 0 ? _a2 : 1) & 1) == 0)
        depAddrs.push(addresses[dep.id]);
    }
    return {
      create(state) {
        state.values[idx] = getter(state);
        return 1;
      },
      update(state, tr) {
        if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state, depAddrs)) {
          let newVal = getter(state);
          if (multi ? !compareArray(newVal, state.values[idx], compare2) : !compare2(newVal, state.values[idx])) {
            state.values[idx] = newVal;
            return 1;
          }
        }
        return 0;
      },
      reconfigure: (state, oldState) => {
        let newVal = getter(state);
        let oldAddr = oldState.config.address[id2];
        if (oldAddr != null) {
          let oldVal = getAddr(oldState, oldAddr);
          if (this.dependencies.every((dep) => {
            return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
          }) || (multi ? compareArray(newVal, oldVal, compare2) : compare2(newVal, oldVal))) {
            state.values[idx] = oldVal;
            return 0;
          }
        }
        state.values[idx] = newVal;
        return 1;
      }
    };
  }
}
function compareArray(a2, b, compare2) {
  if (a2.length != b.length)
    return false;
  for (let i = 0; i < a2.length; i++)
    if (!compare2(a2[i], b[i]))
      return false;
  return true;
}
function ensureAll(state, addrs) {
  let changed = false;
  for (let addr of addrs)
    if (ensureAddr(state, addr) & 1)
      changed = true;
  return changed;
}
function dynamicFacetSlot(addresses, facet, providers) {
  let providerAddrs = providers.map((p) => addresses[p.id]);
  let providerTypes = providers.map((p) => p.type);
  let dynamic = providerAddrs.filter((p) => !(p & 1));
  let idx = addresses[facet.id] >> 1;
  function get2(state) {
    let values2 = [];
    for (let i = 0; i < providerAddrs.length; i++) {
      let value = getAddr(state, providerAddrs[i]);
      if (providerTypes[i] == 2)
        for (let val of value)
          values2.push(val);
      else
        values2.push(value);
    }
    return facet.combine(values2);
  }
  return {
    create(state) {
      for (let addr of providerAddrs)
        ensureAddr(state, addr);
      state.values[idx] = get2(state);
      return 1;
    },
    update(state, tr) {
      if (!ensureAll(state, dynamic))
        return 0;
      let value = get2(state);
      if (facet.compare(value, state.values[idx]))
        return 0;
      state.values[idx] = value;
      return 1;
    },
    reconfigure(state, oldState) {
      let depChanged = ensureAll(state, providerAddrs);
      let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
      if (oldProviders && !depChanged && sameArray$1(providers, oldProviders)) {
        state.values[idx] = oldValue;
        return 0;
      }
      let value = get2(state);
      if (facet.compare(value, oldValue)) {
        state.values[idx] = oldValue;
        return 0;
      }
      state.values[idx] = value;
      return 1;
    }
  };
}
const initField = /* @__PURE__ */ Facet.define({ static: true });
class StateField {
  constructor(id2, createF, updateF, compareF, spec) {
    this.id = id2;
    this.createF = createF;
    this.updateF = updateF;
    this.compareF = compareF;
    this.spec = spec;
    this.provides = void 0;
  }
  static define(config2) {
    let field = new StateField(nextID++, config2.create, config2.update, config2.compare || ((a2, b) => a2 === b), config2);
    if (config2.provide)
      field.provides = config2.provide(field);
    return field;
  }
  create(state) {
    let init2 = state.facet(initField).find((i) => i.field == this);
    return ((init2 === null || init2 === void 0 ? void 0 : init2.create) || this.createF)(state);
  }
  slot(addresses) {
    let idx = addresses[this.id] >> 1;
    return {
      create: (state) => {
        state.values[idx] = this.create(state);
        return 1;
      },
      update: (state, tr) => {
        let oldVal = state.values[idx];
        let value = this.updateF(oldVal, tr);
        if (this.compareF(oldVal, value))
          return 0;
        state.values[idx] = value;
        return 1;
      },
      reconfigure: (state, oldState) => {
        if (oldState.config.address[this.id] != null) {
          state.values[idx] = oldState.field(this);
          return 0;
        }
        state.values[idx] = this.create(state);
        return 1;
      }
    };
  }
  init(create2) {
    return [this, initField.of({ field: this, create: create2 })];
  }
  get extension() {
    return this;
  }
}
const Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function prec(value) {
  return (ext) => new PrecExtension(ext, value);
}
const Prec = {
  highest: /* @__PURE__ */ prec(Prec_.highest),
  high: /* @__PURE__ */ prec(Prec_.high),
  default: /* @__PURE__ */ prec(Prec_.default),
  low: /* @__PURE__ */ prec(Prec_.low),
  lowest: /* @__PURE__ */ prec(Prec_.lowest)
};
class PrecExtension {
  constructor(inner, prec2) {
    this.inner = inner;
    this.prec = prec2;
  }
}
class Compartment {
  of(ext) {
    return new CompartmentInstance(this, ext);
  }
  reconfigure(content2) {
    return Compartment.reconfigure.of({ compartment: this, extension: content2 });
  }
  get(state) {
    return state.config.compartments.get(this);
  }
}
class CompartmentInstance {
  constructor(compartment, inner) {
    this.compartment = compartment;
    this.inner = inner;
  }
}
class Configuration {
  constructor(base2, compartments, dynamicSlots, address, staticValues, facets) {
    this.base = base2;
    this.compartments = compartments;
    this.dynamicSlots = dynamicSlots;
    this.address = address;
    this.staticValues = staticValues;
    this.facets = facets;
    this.statusTemplate = [];
    while (this.statusTemplate.length < dynamicSlots.length)
      this.statusTemplate.push(0);
  }
  staticFacet(facet) {
    let addr = this.address[facet.id];
    return addr == null ? facet.default : this.staticValues[addr >> 1];
  }
  static resolve(base2, compartments, oldState) {
    let fields = [];
    let facets = /* @__PURE__ */ Object.create(null);
    let newCompartments = /* @__PURE__ */ new Map();
    for (let ext of flatten(base2, compartments, newCompartments)) {
      if (ext instanceof StateField)
        fields.push(ext);
      else
        (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
    }
    let address = /* @__PURE__ */ Object.create(null);
    let staticValues = [];
    let dynamicSlots = [];
    for (let field of fields) {
      address[field.id] = dynamicSlots.length << 1;
      dynamicSlots.push((a2) => field.slot(a2));
    }
    let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
    for (let id2 in facets) {
      let providers = facets[id2], facet = providers[0].facet;
      let oldProviders = oldFacets && oldFacets[id2] || [];
      if (providers.every((p) => p.type == 0)) {
        address[facet.id] = staticValues.length << 1 | 1;
        if (sameArray$1(oldProviders, providers)) {
          staticValues.push(oldState.facet(facet));
        } else {
          let value = facet.combine(providers.map((p) => p.value));
          staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
        }
      } else {
        for (let p of providers) {
          if (p.type == 0) {
            address[p.id] = staticValues.length << 1 | 1;
            staticValues.push(p.value);
          } else {
            address[p.id] = dynamicSlots.length << 1;
            dynamicSlots.push((a2) => p.dynamicSlot(a2));
          }
        }
        address[facet.id] = dynamicSlots.length << 1;
        dynamicSlots.push((a2) => dynamicFacetSlot(a2, facet, providers));
      }
    }
    let dynamic = dynamicSlots.map((f2) => f2(address));
    return new Configuration(base2, newCompartments, dynamic, address, staticValues, facets);
  }
}
function flatten(extension2, compartments, newCompartments) {
  let result = [[], [], [], [], []];
  let seen = /* @__PURE__ */ new Map();
  function inner(ext, prec2) {
    let known = seen.get(ext);
    if (known != null) {
      if (known <= prec2)
        return;
      let found = result[known].indexOf(ext);
      if (found > -1)
        result[known].splice(found, 1);
      if (ext instanceof CompartmentInstance)
        newCompartments.delete(ext.compartment);
    }
    seen.set(ext, prec2);
    if (Array.isArray(ext)) {
      for (let e of ext)
        inner(e, prec2);
    } else if (ext instanceof CompartmentInstance) {
      if (newCompartments.has(ext.compartment))
        throw new RangeError(`Duplicate use of compartment in extensions`);
      let content2 = compartments.get(ext.compartment) || ext.inner;
      newCompartments.set(ext.compartment, content2);
      inner(content2, prec2);
    } else if (ext instanceof PrecExtension) {
      inner(ext.inner, ext.prec);
    } else if (ext instanceof StateField) {
      result[prec2].push(ext);
      if (ext.provides)
        inner(ext.provides, prec2);
    } else if (ext instanceof FacetProvider) {
      result[prec2].push(ext);
      if (ext.facet.extensions)
        inner(ext.facet.extensions, Prec_.default);
    } else {
      let content2 = ext.extension;
      if (!content2)
        throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      inner(content2, prec2);
    }
  }
  inner(extension2, Prec_.default);
  return result.reduce((a2, b) => a2.concat(b));
}
function ensureAddr(state, addr) {
  if (addr & 1)
    return 2;
  let idx = addr >> 1;
  let status = state.status[idx];
  if (status == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (status & 2)
    return status;
  state.status[idx] = 4;
  let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
  return state.status[idx] = 2 | changed;
}
function getAddr(state, addr) {
  return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
}
const languageData = /* @__PURE__ */ Facet.define();
const allowMultipleSelections = /* @__PURE__ */ Facet.define({
  combine: (values2) => values2.some((v) => v),
  static: true
});
const lineSeparator = /* @__PURE__ */ Facet.define({
  combine: (values2) => values2.length ? values2[0] : void 0,
  static: true
});
const changeFilter = /* @__PURE__ */ Facet.define();
const transactionFilter = /* @__PURE__ */ Facet.define();
const transactionExtender = /* @__PURE__ */ Facet.define();
const readOnly = /* @__PURE__ */ Facet.define({
  combine: (values2) => values2.length ? values2[0] : false
});
class Annotation {
  constructor(type2, value) {
    this.type = type2;
    this.value = value;
  }
  static define() {
    return new AnnotationType();
  }
}
class AnnotationType {
  of(value) {
    return new Annotation(this, value);
  }
}
class StateEffectType {
  constructor(map2) {
    this.map = map2;
  }
  of(value) {
    return new StateEffect(this, value);
  }
}
class StateEffect {
  constructor(type2, value) {
    this.type = type2;
    this.value = value;
  }
  map(mapping) {
    let mapped = this.type.map(this.value, mapping);
    return mapped === void 0 ? void 0 : mapped == this.value ? this : new StateEffect(this.type, mapped);
  }
  is(type2) {
    return this.type == type2;
  }
  static define(spec = {}) {
    return new StateEffectType(spec.map || ((v) => v));
  }
  static mapEffects(effects, mapping) {
    if (!effects.length)
      return effects;
    let result = [];
    for (let effect of effects) {
      let mapped = effect.map(mapping);
      if (mapped)
        result.push(mapped);
    }
    return result;
  }
}
StateEffect.reconfigure = /* @__PURE__ */ StateEffect.define();
StateEffect.appendConfig = /* @__PURE__ */ StateEffect.define();
class Transaction {
  constructor(startState, changes, selection2, effects, annotations, scrollIntoView2) {
    this.startState = startState;
    this.changes = changes;
    this.selection = selection2;
    this.effects = effects;
    this.annotations = annotations;
    this.scrollIntoView = scrollIntoView2;
    this._doc = null;
    this._state = null;
    if (selection2)
      checkSelection(selection2, changes.newLength);
    if (!annotations.some((a2) => a2.type == Transaction.time))
      this.annotations = annotations.concat(Transaction.time.of(Date.now()));
  }
  static create(startState, changes, selection2, effects, annotations, scrollIntoView2) {
    return new Transaction(startState, changes, selection2, effects, annotations, scrollIntoView2);
  }
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  get state() {
    if (!this._state)
      this.startState.applyTransaction(this);
    return this._state;
  }
  annotation(type2) {
    for (let ann of this.annotations)
      if (ann.type == type2)
        return ann.value;
    return void 0;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  isUserEvent(event2) {
    let e = this.annotation(Transaction.userEvent);
    return !!(e && (e == event2 || e.length > event2.length && e.slice(0, event2.length) == event2 && e[event2.length] == "."));
  }
}
Transaction.time = /* @__PURE__ */ Annotation.define();
Transaction.userEvent = /* @__PURE__ */ Annotation.define();
Transaction.addToHistory = /* @__PURE__ */ Annotation.define();
Transaction.remote = /* @__PURE__ */ Annotation.define();
function joinRanges(a2, b) {
  let result = [];
  for (let iA = 0, iB = 0; ; ) {
    let from2, to2;
    if (iA < a2.length && (iB == b.length || b[iB] >= a2[iA])) {
      from2 = a2[iA++];
      to2 = a2[iA++];
    } else if (iB < b.length) {
      from2 = b[iB++];
      to2 = b[iB++];
    } else
      return result;
    if (!result.length || result[result.length - 1] < from2)
      result.push(from2, to2);
    else if (result[result.length - 1] < to2)
      result[result.length - 1] = to2;
  }
}
function mergeTransaction(a2, b, sequential2) {
  var _a2;
  let mapForA, mapForB, changes;
  if (sequential2) {
    mapForA = b.changes;
    mapForB = ChangeSet.empty(b.changes.length);
    changes = a2.changes.compose(b.changes);
  } else {
    mapForA = b.changes.map(a2.changes);
    mapForB = a2.changes.mapDesc(b.changes, true);
    changes = a2.changes.compose(mapForA);
  }
  return {
    changes,
    selection: b.selection ? b.selection.map(mapForB) : (_a2 = a2.selection) === null || _a2 === void 0 ? void 0 : _a2.map(mapForA),
    effects: StateEffect.mapEffects(a2.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
    annotations: a2.annotations.length ? a2.annotations.concat(b.annotations) : b.annotations,
    scrollIntoView: a2.scrollIntoView || b.scrollIntoView
  };
}
function resolveTransactionInner(state, spec, docSize) {
  let sel = spec.selection, annotations = asArray(spec.annotations);
  if (spec.userEvent)
    annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
  return {
    changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
    selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
    effects: asArray(spec.effects),
    annotations,
    scrollIntoView: !!spec.scrollIntoView
  };
}
function resolveTransaction(state, specs, filter) {
  let s2 = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
  if (specs.length && specs[0].filter === false)
    filter = false;
  for (let i = 1; i < specs.length; i++) {
    if (specs[i].filter === false)
      filter = false;
    let seq2 = !!specs[i].sequential;
    s2 = mergeTransaction(s2, resolveTransactionInner(state, specs[i], seq2 ? s2.changes.newLength : state.doc.length), seq2);
  }
  let tr = Transaction.create(state, s2.changes, s2.selection, s2.effects, s2.annotations, s2.scrollIntoView);
  return extendTransaction(filter ? filterTransaction(tr) : tr);
}
function filterTransaction(tr) {
  let state = tr.startState;
  let result = true;
  for (let filter of state.facet(changeFilter)) {
    let value = filter(tr);
    if (value === false) {
      result = false;
      break;
    }
    if (Array.isArray(value))
      result = result === true ? value : joinRanges(result, value);
  }
  if (result !== true) {
    let changes, back;
    if (result === false) {
      back = tr.changes.invertedDesc;
      changes = ChangeSet.empty(state.doc.length);
    } else {
      let filtered = tr.changes.filter(result);
      changes = filtered.changes;
      back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
    }
    tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
  }
  let filters = state.facet(transactionFilter);
  for (let i = filters.length - 1; i >= 0; i--) {
    let filtered = filters[i](tr);
    if (filtered instanceof Transaction)
      tr = filtered;
    else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
      tr = filtered[0];
    else
      tr = resolveTransaction(state, asArray(filtered), false);
  }
  return tr;
}
function extendTransaction(tr) {
  let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
  for (let i = extenders.length - 1; i >= 0; i--) {
    let extension2 = extenders[i](tr);
    if (extension2 && Object.keys(extension2).length)
      spec = mergeTransaction(spec, resolveTransactionInner(state, extension2, tr.changes.newLength), true);
  }
  return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
}
const none$6 = [];
function asArray(value) {
  return value == null ? none$6 : Array.isArray(value) ? value : [value];
}
var CharCategory = /* @__PURE__ */ function(CharCategory2) {
  CharCategory2[CharCategory2["Word"] = 0] = "Word";
  CharCategory2[CharCategory2["Space"] = 1] = "Space";
  CharCategory2[CharCategory2["Other"] = 2] = "Other";
  return CharCategory2;
}(CharCategory || (CharCategory = {}));
const nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let wordChar;
try {
  wordChar = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch (_2) {
}
function hasWordChar(str) {
  if (wordChar)
    return wordChar.test(str);
  for (let i = 0; i < str.length; i++) {
    let ch = str[i];
    if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
      return true;
  }
  return false;
}
function makeCategorizer(wordChars) {
  return (char2) => {
    if (!/\S/.test(char2))
      return CharCategory.Space;
    if (hasWordChar(char2))
      return CharCategory.Word;
    for (let i = 0; i < wordChars.length; i++)
      if (char2.indexOf(wordChars[i]) > -1)
        return CharCategory.Word;
    return CharCategory.Other;
  };
}
class EditorState {
  constructor(config2, doc2, selection2, values2, computeSlot, tr) {
    this.config = config2;
    this.doc = doc2;
    this.selection = selection2;
    this.values = values2;
    this.status = config2.statusTemplate.slice();
    this.computeSlot = computeSlot;
    if (tr)
      tr._state = this;
    for (let i = 0; i < this.config.dynamicSlots.length; i++)
      ensureAddr(this, i << 1);
    this.computeSlot = null;
  }
  field(field, require2 = true) {
    let addr = this.config.address[field.id];
    if (addr == null) {
      if (require2)
        throw new RangeError("Field is not present in this state");
      return void 0;
    }
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  update(...specs) {
    return resolveTransaction(this, specs, true);
  }
  applyTransaction(tr) {
    let conf2 = this.config, { base: base2, compartments } = conf2;
    for (let effect of tr.effects) {
      if (effect.is(Compartment.reconfigure)) {
        if (conf2) {
          compartments = /* @__PURE__ */ new Map();
          conf2.compartments.forEach((val, key) => compartments.set(key, val));
          conf2 = null;
        }
        compartments.set(effect.value.compartment, effect.value.extension);
      } else if (effect.is(StateEffect.reconfigure)) {
        conf2 = null;
        base2 = effect.value;
      } else if (effect.is(StateEffect.appendConfig)) {
        conf2 = null;
        base2 = asArray(base2).concat(effect.value);
      }
    }
    let startValues;
    if (!conf2) {
      conf2 = Configuration.resolve(base2, compartments, this);
      let intermediateState = new EditorState(conf2, this.doc, this.selection, conf2.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
      startValues = intermediateState.values;
    } else {
      startValues = tr.startState.values.slice();
    }
    new EditorState(conf2, tr.newDoc, tr.newSelection, startValues, (state, slot) => slot.update(state, tr), tr);
  }
  replaceSelection(text2) {
    if (typeof text2 == "string")
      text2 = this.toText(text2);
    return this.changeByRange((range2) => ({
      changes: { from: range2.from, to: range2.to, insert: text2 },
      range: EditorSelection.cursor(range2.from + text2.length)
    }));
  }
  changeByRange(f2) {
    let sel = this.selection;
    let result1 = f2(sel.ranges[0]);
    let changes = this.changes(result1.changes), ranges2 = [result1.range];
    let effects = asArray(result1.effects);
    for (let i = 1; i < sel.ranges.length; i++) {
      let result = f2(sel.ranges[i]);
      let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
      for (let j2 = 0; j2 < i; j2++)
        ranges2[j2] = ranges2[j2].map(newMapped);
      let mapBy = changes.mapDesc(newChanges, true);
      ranges2.push(result.range.map(mapBy));
      changes = changes.compose(newMapped);
      effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
    }
    return {
      changes,
      selection: EditorSelection.create(ranges2, sel.mainIndex),
      effects
    };
  }
  changes(spec = []) {
    if (spec instanceof ChangeSet)
      return spec;
    return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
  }
  toText(string2) {
    return Text.of(string2.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
  }
  sliceDoc(from2 = 0, to2 = this.doc.length) {
    return this.doc.sliceString(from2, to2, this.lineBreak);
  }
  facet(facet) {
    let addr = this.config.address[facet.id];
    if (addr == null)
      return facet.default;
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  toJSON(fields) {
    let result = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (fields)
      for (let prop in fields) {
        let value = fields[prop];
        if (value instanceof StateField && this.config.address[value.id] != null)
          result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
      }
    return result;
  }
  static fromJSON(json2, config2 = {}, fields) {
    if (!json2 || typeof json2.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let fieldInit = [];
    if (fields)
      for (let prop in fields) {
        if (Object.prototype.hasOwnProperty.call(json2, prop)) {
          let field = fields[prop], value = json2[prop];
          fieldInit.push(field.init((state) => field.spec.fromJSON(value, state)));
        }
      }
    return EditorState.create({
      doc: json2.doc,
      selection: EditorSelection.fromJSON(json2.selection),
      extensions: config2.extensions ? fieldInit.concat([config2.extensions]) : fieldInit
    });
  }
  static create(config2 = {}) {
    let configuration = Configuration.resolve(config2.extensions || [], /* @__PURE__ */ new Map());
    let doc2 = config2.doc instanceof Text ? config2.doc : Text.of((config2.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
    let selection2 = !config2.selection ? EditorSelection.single(0) : config2.selection instanceof EditorSelection ? config2.selection : EditorSelection.single(config2.selection.anchor, config2.selection.head);
    checkSelection(selection2, doc2.length);
    if (!configuration.staticFacet(allowMultipleSelections))
      selection2 = selection2.asSingle();
    return new EditorState(configuration, doc2, selection2, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
  }
  get tabSize() {
    return this.facet(EditorState.tabSize);
  }
  get lineBreak() {
    return this.facet(EditorState.lineSeparator) || "\n";
  }
  get readOnly() {
    return this.facet(readOnly);
  }
  phrase(phrase, ...insert2) {
    for (let map2 of this.facet(EditorState.phrases))
      if (Object.prototype.hasOwnProperty.call(map2, phrase)) {
        phrase = map2[phrase];
        break;
      }
    if (insert2.length)
      phrase = phrase.replace(/\$(\$|\d*)/g, (m, i) => {
        if (i == "$")
          return "$";
        let n = +(i || 1);
        return !n || n > insert2.length ? m : insert2[n - 1];
      });
    return phrase;
  }
  languageDataAt(name2, pos, side = -1) {
    let values2 = [];
    for (let provider of this.facet(languageData)) {
      for (let result of provider(this, pos, side)) {
        if (Object.prototype.hasOwnProperty.call(result, name2))
          values2.push(result[name2]);
      }
    }
    return values2;
  }
  charCategorizer(at) {
    return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
  }
  wordAt(pos) {
    let { text: text2, from: from2, length: length2 } = this.doc.lineAt(pos);
    let cat = this.charCategorizer(pos);
    let start2 = pos - from2, end2 = pos - from2;
    while (start2 > 0) {
      let prev2 = findClusterBreak(text2, start2, false);
      if (cat(text2.slice(prev2, start2)) != CharCategory.Word)
        break;
      start2 = prev2;
    }
    while (end2 < length2) {
      let next2 = findClusterBreak(text2, end2);
      if (cat(text2.slice(end2, next2)) != CharCategory.Word)
        break;
      end2 = next2;
    }
    return start2 == end2 ? null : EditorSelection.range(start2 + from2, end2 + from2);
  }
}
EditorState.allowMultipleSelections = allowMultipleSelections;
EditorState.tabSize = /* @__PURE__ */ Facet.define({
  combine: (values2) => values2.length ? values2[0] : 4
});
EditorState.lineSeparator = lineSeparator;
EditorState.readOnly = readOnly;
EditorState.phrases = /* @__PURE__ */ Facet.define({
  compare(a2, b) {
    let kA = Object.keys(a2), kB = Object.keys(b);
    return kA.length == kB.length && kA.every((k2) => a2[k2] == b[k2]);
  }
});
EditorState.languageData = languageData;
EditorState.changeFilter = changeFilter;
EditorState.transactionFilter = transactionFilter;
EditorState.transactionExtender = transactionExtender;
Compartment.reconfigure = /* @__PURE__ */ StateEffect.define();
function combineConfig(configs, defaults2, combine = {}) {
  let result = {};
  for (let config2 of configs)
    for (let key of Object.keys(config2)) {
      let value = config2[key], current = result[key];
      if (current === void 0)
        result[key] = value;
      else if (current === value || value === void 0)
        ;
      else if (Object.hasOwnProperty.call(combine, key))
        result[key] = combine[key](current, value);
      else
        throw new Error("Config merge conflict for field " + key);
    }
  for (let key in defaults2)
    if (result[key] === void 0)
      result[key] = defaults2[key];
  return result;
}
class RangeValue {
  eq(other) {
    return this == other;
  }
  range(from2, to2 = from2) {
    return Range$1.create(from2, to2, this);
  }
}
RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
RangeValue.prototype.point = false;
RangeValue.prototype.mapMode = MapMode.TrackDel;
class Range$1 {
  constructor(from2, to2, value) {
    this.from = from2;
    this.to = to2;
    this.value = value;
  }
  static create(from2, to2, value) {
    return new Range$1(from2, to2, value);
  }
}
function cmpRange(a2, b) {
  return a2.from - b.from || a2.value.startSide - b.value.startSide;
}
class Chunk {
  constructor(from2, to2, value, maxPoint) {
    this.from = from2;
    this.to = to2;
    this.value = value;
    this.maxPoint = maxPoint;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  findIndex(pos, side, end2, startAt = 0) {
    let arr = end2 ? this.to : this.from;
    for (let lo = startAt, hi = arr.length; ; ) {
      if (lo == hi)
        return lo;
      let mid = lo + hi >> 1;
      let diff = arr[mid] - pos || (end2 ? this.value[mid].endSide : this.value[mid].startSide) - side;
      if (mid == lo)
        return diff >= 0 ? lo : hi;
      if (diff >= 0)
        hi = mid;
      else
        lo = mid + 1;
    }
  }
  between(offset, from2, to2, f2) {
    for (let i = this.findIndex(from2, -1e9, true), e = this.findIndex(to2, 1e9, false, i); i < e; i++)
      if (f2(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)
        return false;
  }
  map(offset, changes) {
    let value = [], from2 = [], to2 = [], newPos = -1, maxPoint = -1;
    for (let i = 0; i < this.value.length; i++) {
      let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;
      if (curFrom == curTo) {
        let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
        if (mapped == null)
          continue;
        newFrom = newTo = mapped;
        if (val.startSide != val.endSide) {
          newTo = changes.mapPos(curFrom, val.endSide);
          if (newTo < newFrom)
            continue;
        }
      } else {
        newFrom = changes.mapPos(curFrom, val.startSide);
        newTo = changes.mapPos(curTo, val.endSide);
        if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
          continue;
      }
      if ((newTo - newFrom || val.endSide - val.startSide) < 0)
        continue;
      if (newPos < 0)
        newPos = newFrom;
      if (val.point)
        maxPoint = Math.max(maxPoint, newTo - newFrom);
      value.push(val);
      from2.push(newFrom - newPos);
      to2.push(newTo - newPos);
    }
    return { mapped: value.length ? new Chunk(from2, to2, value, maxPoint) : null, pos: newPos };
  }
}
class RangeSet {
  constructor(chunkPos, chunk, nextLayer, maxPoint) {
    this.chunkPos = chunkPos;
    this.chunk = chunk;
    this.nextLayer = nextLayer;
    this.maxPoint = maxPoint;
  }
  static create(chunkPos, chunk, nextLayer, maxPoint) {
    return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);
  }
  get length() {
    let last = this.chunk.length - 1;
    return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
  }
  get size() {
    if (this.isEmpty)
      return 0;
    let size = this.nextLayer.size;
    for (let chunk of this.chunk)
      size += chunk.value.length;
    return size;
  }
  chunkEnd(index2) {
    return this.chunkPos[index2] + this.chunk[index2].length;
  }
  update(updateSpec) {
    let { add: add2 = [], sort: sort2 = false, filterFrom = 0, filterTo = this.length } = updateSpec;
    let filter = updateSpec.filter;
    if (add2.length == 0 && !filter)
      return this;
    if (sort2)
      add2 = add2.slice().sort(cmpRange);
    if (this.isEmpty)
      return add2.length ? RangeSet.of(add2) : this;
    let cur2 = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];
    let builder = new RangeSetBuilder();
    while (cur2.value || i < add2.length) {
      if (i < add2.length && (cur2.from - add2[i].from || cur2.startSide - add2[i].value.startSide) >= 0) {
        let range2 = add2[i++];
        if (!builder.addInner(range2.from, range2.to, range2.value))
          spill.push(range2);
      } else if (cur2.rangeIndex == 1 && cur2.chunkIndex < this.chunk.length && (i == add2.length || this.chunkEnd(cur2.chunkIndex) < add2[i].from) && (!filter || filterFrom > this.chunkEnd(cur2.chunkIndex) || filterTo < this.chunkPos[cur2.chunkIndex]) && builder.addChunk(this.chunkPos[cur2.chunkIndex], this.chunk[cur2.chunkIndex])) {
        cur2.nextChunk();
      } else {
        if (!filter || filterFrom > cur2.to || filterTo < cur2.from || filter(cur2.from, cur2.to, cur2.value)) {
          if (!builder.addInner(cur2.from, cur2.to, cur2.value))
            spill.push(Range$1.create(cur2.from, cur2.to, cur2.value));
        }
        cur2.next();
      }
    }
    return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));
  }
  map(changes) {
    if (changes.empty || this.isEmpty)
      return this;
    let chunks = [], chunkPos = [], maxPoint = -1;
    for (let i = 0; i < this.chunk.length; i++) {
      let start2 = this.chunkPos[i], chunk = this.chunk[i];
      let touch2 = changes.touchesRange(start2, start2 + chunk.length);
      if (touch2 === false) {
        maxPoint = Math.max(maxPoint, chunk.maxPoint);
        chunks.push(chunk);
        chunkPos.push(changes.mapPos(start2));
      } else if (touch2 === true) {
        let { mapped, pos } = chunk.map(start2, changes);
        if (mapped) {
          maxPoint = Math.max(maxPoint, mapped.maxPoint);
          chunks.push(mapped);
          chunkPos.push(pos);
        }
      }
    }
    let next2 = this.nextLayer.map(changes);
    return chunks.length == 0 ? next2 : new RangeSet(chunkPos, chunks, next2 || RangeSet.empty, maxPoint);
  }
  between(from2, to2, f2) {
    if (this.isEmpty)
      return;
    for (let i = 0; i < this.chunk.length; i++) {
      let start2 = this.chunkPos[i], chunk = this.chunk[i];
      if (to2 >= start2 && from2 <= start2 + chunk.length && chunk.between(start2, from2 - start2, to2 - start2, f2) === false)
        return;
    }
    this.nextLayer.between(from2, to2, f2);
  }
  iter(from2 = 0) {
    return HeapCursor.from([this]).goto(from2);
  }
  get isEmpty() {
    return this.nextLayer == this;
  }
  static iter(sets, from2 = 0) {
    return HeapCursor.from(sets).goto(from2);
  }
  static compare(oldSets, newSets, textDiff, comparator, minPointSize = -1) {
    let a2 = oldSets.filter((set2) => set2.maxPoint > 0 || !set2.isEmpty && set2.maxPoint >= minPointSize);
    let b = newSets.filter((set2) => set2.maxPoint > 0 || !set2.isEmpty && set2.maxPoint >= minPointSize);
    let sharedChunks = findSharedChunks(a2, b, textDiff);
    let sideA = new SpanCursor(a2, sharedChunks, minPointSize);
    let sideB = new SpanCursor(b, sharedChunks, minPointSize);
    textDiff.iterGaps((fromA, fromB, length2) => compare(sideA, fromA, sideB, fromB, length2, comparator));
    if (textDiff.empty && textDiff.length == 0)
      compare(sideA, 0, sideB, 0, 0, comparator);
  }
  static eq(oldSets, newSets, from2 = 0, to2) {
    if (to2 == null)
      to2 = 1e9;
    let a2 = oldSets.filter((set2) => !set2.isEmpty && newSets.indexOf(set2) < 0);
    let b = newSets.filter((set2) => !set2.isEmpty && oldSets.indexOf(set2) < 0);
    if (a2.length != b.length)
      return false;
    if (!a2.length)
      return true;
    let sharedChunks = findSharedChunks(a2, b);
    let sideA = new SpanCursor(a2, sharedChunks, 0).goto(from2), sideB = new SpanCursor(b, sharedChunks, 0).goto(from2);
    for (; ; ) {
      if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
        return false;
      if (sideA.to > to2)
        return true;
      sideA.next();
      sideB.next();
    }
  }
  static spans(sets, from2, to2, iterator2, minPointSize = -1) {
    let cursor = new SpanCursor(sets, null, minPointSize).goto(from2), pos = from2;
    let open = cursor.openStart;
    for (; ; ) {
      let curTo = Math.min(cursor.to, to2);
      if (cursor.point) {
        iterator2.point(pos, curTo, cursor.point, cursor.activeForPoint(cursor.to), open, cursor.pointRank);
        open = cursor.openEnd(curTo) + (cursor.to > curTo ? 1 : 0);
      } else if (curTo > pos) {
        iterator2.span(pos, curTo, cursor.active, open);
        open = cursor.openEnd(curTo);
      }
      if (cursor.to > to2)
        break;
      pos = cursor.to;
      cursor.next();
    }
    return open;
  }
  static of(ranges2, sort2 = false) {
    let build = new RangeSetBuilder();
    for (let range2 of ranges2 instanceof Range$1 ? [ranges2] : sort2 ? lazySort(ranges2) : ranges2)
      build.add(range2.from, range2.to, range2.value);
    return build.finish();
  }
}
RangeSet.empty = /* @__PURE__ */ new RangeSet([], [], null, -1);
function lazySort(ranges2) {
  if (ranges2.length > 1)
    for (let prev2 = ranges2[0], i = 1; i < ranges2.length; i++) {
      let cur2 = ranges2[i];
      if (cmpRange(prev2, cur2) > 0)
        return ranges2.slice().sort(cmpRange);
      prev2 = cur2;
    }
  return ranges2;
}
RangeSet.empty.nextLayer = RangeSet.empty;
class RangeSetBuilder {
  constructor() {
    this.chunks = [];
    this.chunkPos = [];
    this.chunkStart = -1;
    this.last = null;
    this.lastFrom = -1e9;
    this.lastTo = -1e9;
    this.from = [];
    this.to = [];
    this.value = [];
    this.maxPoint = -1;
    this.setMaxPoint = -1;
    this.nextLayer = null;
  }
  finishChunk(newArrays) {
    this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
    this.chunkPos.push(this.chunkStart);
    this.chunkStart = -1;
    this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
    this.maxPoint = -1;
    if (newArrays) {
      this.from = [];
      this.to = [];
      this.value = [];
    }
  }
  add(from2, to2, value) {
    if (!this.addInner(from2, to2, value))
      (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from2, to2, value);
  }
  addInner(from2, to2, value) {
    let diff = from2 - this.lastTo || value.startSide - this.last.endSide;
    if (diff <= 0 && (from2 - this.lastFrom || value.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    if (diff < 0)
      return false;
    if (this.from.length == 250)
      this.finishChunk(true);
    if (this.chunkStart < 0)
      this.chunkStart = from2;
    this.from.push(from2 - this.chunkStart);
    this.to.push(to2 - this.chunkStart);
    this.last = value;
    this.lastFrom = from2;
    this.lastTo = to2;
    this.value.push(value);
    if (value.point)
      this.maxPoint = Math.max(this.maxPoint, to2 - from2);
    return true;
  }
  addChunk(from2, chunk) {
    if ((from2 - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
      return false;
    if (this.from.length)
      this.finishChunk(true);
    this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
    this.chunks.push(chunk);
    this.chunkPos.push(from2);
    let last = chunk.value.length - 1;
    this.last = chunk.value[last];
    this.lastFrom = chunk.from[last] + from2;
    this.lastTo = chunk.to[last] + from2;
    return true;
  }
  finish() {
    return this.finishInner(RangeSet.empty);
  }
  finishInner(next2) {
    if (this.from.length)
      this.finishChunk(false);
    if (this.chunks.length == 0)
      return next2;
    let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next2) : next2, this.setMaxPoint);
    this.from = null;
    return result;
  }
}
function findSharedChunks(a2, b, textDiff) {
  let inA = /* @__PURE__ */ new Map();
  for (let set2 of a2)
    for (let i = 0; i < set2.chunk.length; i++)
      if (set2.chunk[i].maxPoint <= 0)
        inA.set(set2.chunk[i], set2.chunkPos[i]);
  let shared = /* @__PURE__ */ new Set();
  for (let set2 of b)
    for (let i = 0; i < set2.chunk.length; i++) {
      let known = inA.get(set2.chunk[i]);
      if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set2.chunkPos[i] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set2.chunk[i].length)))
        shared.add(set2.chunk[i]);
    }
  return shared;
}
class LayerCursor {
  constructor(layer, skip, minPoint, rank2 = 0) {
    this.layer = layer;
    this.skip = skip;
    this.minPoint = minPoint;
    this.rank = rank2;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(pos, side = -1e9) {
    this.chunkIndex = this.rangeIndex = 0;
    this.gotoInner(pos, side, false);
    return this;
  }
  gotoInner(pos, side, forward) {
    while (this.chunkIndex < this.layer.chunk.length) {
      let next2 = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(next2) || this.layer.chunkEnd(this.chunkIndex) < pos || next2.maxPoint < this.minPoint))
        break;
      this.chunkIndex++;
      forward = false;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
      if (!forward || this.rangeIndex < rangeIndex)
        this.setRangeIndex(rangeIndex);
    }
    this.next();
  }
  forward(pos, side) {
    if ((this.to - pos || this.endSide - side) < 0)
      this.gotoInner(pos, side, true);
  }
  next() {
    for (; ; ) {
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9;
        this.value = null;
        break;
      } else {
        let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
        let from2 = chunkPos + chunk.from[this.rangeIndex];
        this.from = from2;
        this.to = chunkPos + chunk.to[this.rangeIndex];
        this.value = chunk.value[this.rangeIndex];
        this.setRangeIndex(this.rangeIndex + 1);
        if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
    }
  }
  setRangeIndex(index2) {
    if (index2 == this.layer.chunk[this.chunkIndex].value.length) {
      this.chunkIndex++;
      if (this.skip) {
        while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
          this.chunkIndex++;
      }
      this.rangeIndex = 0;
    } else {
      this.rangeIndex = index2;
    }
  }
  nextChunk() {
    this.chunkIndex++;
    this.rangeIndex = 0;
    this.next();
  }
  compare(other) {
    return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
  }
}
class HeapCursor {
  constructor(heap) {
    this.heap = heap;
  }
  static from(sets, skip = null, minPoint = -1) {
    let heap = [];
    for (let i = 0; i < sets.length; i++) {
      for (let cur2 = sets[i]; !cur2.isEmpty; cur2 = cur2.nextLayer) {
        if (cur2.maxPoint >= minPoint)
          heap.push(new LayerCursor(cur2, skip, minPoint, i));
      }
    }
    return heap.length == 1 ? heap[0] : new HeapCursor(heap);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(pos, side = -1e9) {
    for (let cur2 of this.heap)
      cur2.goto(pos, side);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      heapBubble(this.heap, i);
    this.next();
    return this;
  }
  forward(pos, side) {
    for (let cur2 of this.heap)
      cur2.forward(pos, side);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      heapBubble(this.heap, i);
    if ((this.to - pos || this.value.endSide - side) < 0)
      this.next();
  }
  next() {
    if (this.heap.length == 0) {
      this.from = this.to = 1e9;
      this.value = null;
      this.rank = -1;
    } else {
      let top2 = this.heap[0];
      this.from = top2.from;
      this.to = top2.to;
      this.value = top2.value;
      this.rank = top2.rank;
      if (top2.value)
        top2.next();
      heapBubble(this.heap, 0);
    }
  }
}
function heapBubble(heap, index2) {
  for (let cur2 = heap[index2]; ; ) {
    let childIndex = (index2 << 1) + 1;
    if (childIndex >= heap.length)
      break;
    let child = heap[childIndex];
    if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
      child = heap[childIndex + 1];
      childIndex++;
    }
    if (cur2.compare(child) < 0)
      break;
    heap[childIndex] = cur2;
    heap[index2] = child;
    index2 = childIndex;
  }
}
class SpanCursor {
  constructor(sets, skip, minPoint) {
    this.minPoint = minPoint;
    this.active = [];
    this.activeTo = [];
    this.activeRank = [];
    this.minActive = -1;
    this.point = null;
    this.pointFrom = 0;
    this.pointRank = 0;
    this.to = -1e9;
    this.endSide = 0;
    this.openStart = -1;
    this.cursor = HeapCursor.from(sets, skip, minPoint);
  }
  goto(pos, side = -1e9) {
    this.cursor.goto(pos, side);
    this.active.length = this.activeTo.length = this.activeRank.length = 0;
    this.minActive = -1;
    this.to = pos;
    this.endSide = side;
    this.openStart = -1;
    this.next();
    return this;
  }
  forward(pos, side) {
    while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
      this.removeActive(this.minActive);
    this.cursor.forward(pos, side);
  }
  removeActive(index2) {
    remove$1(this.active, index2);
    remove$1(this.activeTo, index2);
    remove$1(this.activeRank, index2);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  addActive(trackOpen) {
    let i = 0, { value, to: to2, rank: rank2 } = this.cursor;
    while (i < this.activeRank.length && this.activeRank[i] <= rank2)
      i++;
    insert(this.active, i, value);
    insert(this.activeTo, i, to2);
    insert(this.activeRank, i, rank2);
    if (trackOpen)
      insert(trackOpen, i, this.cursor.from);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  next() {
    let from2 = this.to, wasPoint = this.point;
    this.point = null;
    let trackOpen = this.openStart < 0 ? [] : null, trackExtra = 0;
    for (; ; ) {
      let a2 = this.minActive;
      if (a2 > -1 && (this.activeTo[a2] - this.cursor.from || this.active[a2].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[a2] > from2) {
          this.to = this.activeTo[a2];
          this.endSide = this.active[a2].endSide;
          break;
        }
        this.removeActive(a2);
        if (trackOpen)
          remove$1(trackOpen, a2);
      } else if (!this.cursor.value) {
        this.to = this.endSide = 1e9;
        break;
      } else if (this.cursor.from > from2) {
        this.to = this.cursor.from;
        this.endSide = this.cursor.startSide;
        break;
      } else {
        let nextVal = this.cursor.value;
        if (!nextVal.point) {
          this.addActive(trackOpen);
          if (this.cursor.from < from2 && this.cursor.to > from2)
            trackExtra++;
          this.cursor.next();
        } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
          this.cursor.next();
        } else {
          this.point = nextVal;
          this.pointFrom = this.cursor.from;
          this.pointRank = this.cursor.rank;
          this.to = this.cursor.to;
          this.endSide = nextVal.endSide;
          if (this.cursor.from < from2)
            trackExtra = 1;
          this.cursor.next();
          this.forward(this.to, this.endSide);
          break;
        }
      }
    }
    if (trackOpen) {
      let openStart = 0;
      while (openStart < trackOpen.length && trackOpen[openStart] < from2)
        openStart++;
      this.openStart = openStart + trackExtra;
    }
  }
  activeForPoint(to2) {
    if (!this.active.length)
      return this.active;
    let active2 = [];
    for (let i = this.active.length - 1; i >= 0; i--) {
      if (this.activeRank[i] < this.pointRank)
        break;
      if (this.activeTo[i] > to2 || this.activeTo[i] == to2 && this.active[i].endSide >= this.point.endSide)
        active2.push(this.active[i]);
    }
    return active2.reverse();
  }
  openEnd(to2) {
    let open = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to2; i--)
      open++;
    return open;
  }
}
function compare(a2, startA, b, startB, length2, comparator) {
  a2.goto(startA);
  b.goto(startB);
  let endB = startB + length2;
  let pos = startB, dPos = startB - startA;
  for (; ; ) {
    let diff = a2.to + dPos - b.to || a2.endSide - b.endSide;
    let end2 = diff < 0 ? a2.to + dPos : b.to, clipEnd = Math.min(end2, endB);
    if (a2.point || b.point) {
      if (!(a2.point && b.point && (a2.point == b.point || a2.point.eq(b.point)) && sameValues(a2.activeForPoint(a2.to + dPos), b.activeForPoint(b.to))))
        comparator.comparePoint(pos, clipEnd, a2.point, b.point);
    } else {
      if (clipEnd > pos && !sameValues(a2.active, b.active))
        comparator.compareRange(pos, clipEnd, a2.active, b.active);
    }
    if (end2 > endB)
      break;
    pos = end2;
    if (diff <= 0)
      a2.next();
    if (diff >= 0)
      b.next();
  }
}
function sameValues(a2, b) {
  if (a2.length != b.length)
    return false;
  for (let i = 0; i < a2.length; i++)
    if (a2[i] != b[i] && !a2[i].eq(b[i]))
      return false;
  return true;
}
function remove$1(array2, index2) {
  for (let i = index2, e = array2.length - 1; i < e; i++)
    array2[i] = array2[i + 1];
  array2.pop();
}
function insert(array2, index2, value) {
  for (let i = array2.length - 1; i >= index2; i--)
    array2[i + 1] = array2[i];
  array2[index2] = value;
}
function findMinIndex(value, array2) {
  let found = -1, foundPos = 1e9;
  for (let i = 0; i < array2.length; i++)
    if ((array2[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
      found = i;
      foundPos = array2[i];
    }
  return found;
}
function countColumn(string2, tabSize, to2 = string2.length) {
  let n = 0;
  for (let i = 0; i < to2; ) {
    if (string2.charCodeAt(i) == 9) {
      n += tabSize - n % tabSize;
      i++;
    } else {
      n++;
      i = findClusterBreak(string2, i);
    }
  }
  return n;
}
function findColumn(string2, col, tabSize, strict) {
  for (let i = 0, n = 0; ; ) {
    if (n >= col)
      return i;
    if (i == string2.length)
      break;
    n += string2.charCodeAt(i) == 9 ? tabSize - n % tabSize : 1;
    i = findClusterBreak(string2, i);
  }
  return strict === true ? -1 : string2.length;
}
const C$1 = "\u037C";
const COUNT = typeof Symbol == "undefined" ? "__" + C$1 : Symbol.for(C$1);
const SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
const top$2 = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
class StyleModule {
  constructor(spec, options2) {
    this.rules = [];
    let { finish } = options2 || {};
    function splitSelector(selector2) {
      return /^@/.test(selector2) ? [selector2] : selector2.split(/,\s*/);
    }
    function render2(selectors, spec2, target, isKeyframes) {
      let local2 = [], isAt = /^@(\w+)\b/.exec(selectors[0]), keyframes = isAt && isAt[1] == "keyframes";
      if (isAt && spec2 == null)
        return target.push(selectors[0] + ";");
      for (let prop in spec2) {
        let value = spec2[prop];
        if (/&/.test(prop)) {
          render2(
            prop.split(/,\s*/).map((part) => selectors.map((sel) => part.replace(/&/, sel))).reduce((a2, b) => a2.concat(b)),
            value,
            target
          );
        } else if (value && typeof value == "object") {
          if (!isAt)
            throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
          render2(splitSelector(prop), value, local2, keyframes);
        } else if (value != null) {
          local2.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, (l2) => "-" + l2.toLowerCase()) + ": " + value + ";");
        }
      }
      if (local2.length || keyframes) {
        target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local2.join(" ") + "}");
      }
    }
    for (let prop in spec)
      render2(splitSelector(prop), spec[prop], this.rules);
  }
  getRules() {
    return this.rules.join("\n");
  }
  static newName() {
    let id2 = top$2[COUNT] || 1;
    top$2[COUNT] = id2 + 1;
    return C$1 + id2.toString(36);
  }
  static mount(root2, modules) {
    (root2[SET] || new StyleSet(root2)).mount(Array.isArray(modules) ? modules : [modules]);
  }
}
let adoptedSet = null;
class StyleSet {
  constructor(root2) {
    if (!root2.head && root2.adoptedStyleSheets && typeof CSSStyleSheet != "undefined") {
      if (adoptedSet) {
        root2.adoptedStyleSheets = [adoptedSet.sheet].concat(root2.adoptedStyleSheets);
        return root2[SET] = adoptedSet;
      }
      this.sheet = new CSSStyleSheet();
      root2.adoptedStyleSheets = [this.sheet].concat(root2.adoptedStyleSheets);
      adoptedSet = this;
    } else {
      this.styleTag = (root2.ownerDocument || root2).createElement("style");
      let target = root2.head || root2;
      target.insertBefore(this.styleTag, target.firstChild);
    }
    this.modules = [];
    root2[SET] = this;
  }
  mount(modules) {
    let sheet = this.sheet;
    let pos = 0, j2 = 0;
    for (let i = 0; i < modules.length; i++) {
      let mod = modules[i], index2 = this.modules.indexOf(mod);
      if (index2 < j2 && index2 > -1) {
        this.modules.splice(index2, 1);
        j2--;
        index2 = -1;
      }
      if (index2 == -1) {
        this.modules.splice(j2++, 0, mod);
        if (sheet)
          for (let k2 = 0; k2 < mod.rules.length; k2++)
            sheet.insertRule(mod.rules[k2], pos++);
      } else {
        while (j2 < index2)
          pos += this.modules[j2++].rules.length;
        pos += mod.rules.length;
        j2++;
      }
    }
    if (!sheet) {
      let text2 = "";
      for (let i = 0; i < this.modules.length; i++)
        text2 += this.modules[i].getRules() + "\n";
      this.styleTag.textContent = text2;
    }
  }
}
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'",
  229: "q"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"',
  229: "Q"
};
var chrome$1 = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
var safari$1 = typeof navigator != "undefined" && /Apple Computer/.test(navigator.vendor);
var gecko$1 = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie$2 = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
var brokenModifierNames = chrome$1 && (mac || +chrome$1[1] < 57) || gecko$1 && mac;
for (var i = 0; i < 10; i++)
  base[48 + i] = base[96 + i] = String(i);
for (var i = 1; i <= 24; i++)
  base[i + 111] = "F" + i;
for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}
for (var code in base)
  if (!shift.hasOwnProperty(code))
    shift[code] = base[code];
function keyName(event2) {
  var ignoreKey = brokenModifierNames && (event2.ctrlKey || event2.altKey || event2.metaKey) || (safari$1 || ie$2) && event2.shiftKey && event2.key && event2.key.length == 1;
  var name2 = !ignoreKey && event2.key || (event2.shiftKey ? shift : base)[event2.keyCode] || event2.key || "Unidentified";
  if (name2 == "Esc")
    name2 = "Escape";
  if (name2 == "Del")
    name2 = "Delete";
  if (name2 == "Left")
    name2 = "ArrowLeft";
  if (name2 == "Up")
    name2 = "ArrowUp";
  if (name2 == "Right")
    name2 = "ArrowRight";
  if (name2 == "Down")
    name2 = "ArrowDown";
  return name2;
}
function getSelection(root2) {
  let target;
  if (root2.nodeType == 11) {
    target = root2.getSelection ? root2 : root2.ownerDocument;
  } else {
    target = root2;
  }
  return target.getSelection();
}
function contains$3(dom, node2) {
  return node2 ? dom == node2 || dom.contains(node2.nodeType != 1 ? node2.parentNode : node2) : false;
}
function deepActiveElement(doc2) {
  let elt2 = doc2.activeElement;
  while (elt2 && elt2.shadowRoot)
    elt2 = elt2.shadowRoot.activeElement;
  return elt2;
}
function hasSelection(dom, selection2) {
  if (!selection2.anchorNode)
    return false;
  try {
    return contains$3(dom, selection2.anchorNode);
  } catch (_2) {
    return false;
  }
}
function clientRectsFor(dom) {
  if (dom.nodeType == 3)
    return textRange(dom, 0, dom.nodeValue.length).getClientRects();
  else if (dom.nodeType == 1)
    return dom.getClientRects();
  else
    return [];
}
function isEquivalentPosition(node2, off, targetNode, targetOff) {
  return targetNode ? scanFor(node2, off, targetNode, targetOff, -1) || scanFor(node2, off, targetNode, targetOff, 1) : false;
}
function domIndex(node2) {
  for (var index2 = 0; ; index2++) {
    node2 = node2.previousSibling;
    if (!node2)
      return index2;
  }
}
function scanFor(node2, off, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node2 == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : maxOffset(node2))) {
      if (node2.nodeName == "DIV")
        return false;
      let parent = node2.parentNode;
      if (!parent || parent.nodeType != 1)
        return false;
      off = domIndex(node2) + (dir < 0 ? 0 : 1);
      node2 = parent;
    } else if (node2.nodeType == 1) {
      node2 = node2.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node2.nodeType == 1 && node2.contentEditable == "false")
        return false;
      off = dir < 0 ? maxOffset(node2) : 0;
    } else {
      return false;
    }
  }
}
function maxOffset(node2) {
  return node2.nodeType == 3 ? node2.nodeValue.length : node2.childNodes.length;
}
const Rect0 = { left: 0, right: 0, top: 0, bottom: 0 };
function flattenRect(rect2, left2) {
  let x2 = left2 ? rect2.left : rect2.right;
  return { left: x2, right: x2, top: rect2.top, bottom: rect2.bottom };
}
function windowRect(win) {
  return {
    left: 0,
    right: win.innerWidth,
    top: 0,
    bottom: win.innerHeight
  };
}
function scrollRectIntoView(dom, rect2, side, x2, y2, xMargin, yMargin, ltr) {
  let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
  for (let cur2 = dom; cur2; ) {
    if (cur2.nodeType == 1) {
      let bounding, top2 = cur2 == doc2.body;
      if (top2) {
        bounding = windowRect(win);
      } else {
        if (cur2.scrollHeight <= cur2.clientHeight && cur2.scrollWidth <= cur2.clientWidth) {
          cur2 = cur2.assignedSlot || cur2.parentNode;
          continue;
        }
        let rect3 = cur2.getBoundingClientRect();
        bounding = {
          left: rect3.left,
          right: rect3.left + cur2.clientWidth,
          top: rect3.top,
          bottom: rect3.top + cur2.clientHeight
        };
      }
      let moveX = 0, moveY = 0;
      if (y2 == "nearest") {
        if (rect2.top < bounding.top) {
          moveY = -(bounding.top - rect2.top + yMargin);
          if (side > 0 && rect2.bottom > bounding.bottom + moveY)
            moveY = rect2.bottom - bounding.bottom + moveY + yMargin;
        } else if (rect2.bottom > bounding.bottom) {
          moveY = rect2.bottom - bounding.bottom + yMargin;
          if (side < 0 && rect2.top - moveY < bounding.top)
            moveY = -(bounding.top + moveY - rect2.top + yMargin);
        }
      } else {
        let rectHeight = rect2.bottom - rect2.top, boundingHeight = bounding.bottom - bounding.top;
        let targetTop = y2 == "center" && rectHeight <= boundingHeight ? rect2.top + rectHeight / 2 - boundingHeight / 2 : y2 == "start" || y2 == "center" && side < 0 ? rect2.top - yMargin : rect2.bottom - boundingHeight + yMargin;
        moveY = targetTop - bounding.top;
      }
      if (x2 == "nearest") {
        if (rect2.left < bounding.left) {
          moveX = -(bounding.left - rect2.left + xMargin);
          if (side > 0 && rect2.right > bounding.right + moveX)
            moveX = rect2.right - bounding.right + moveX + xMargin;
        } else if (rect2.right > bounding.right) {
          moveX = rect2.right - bounding.right + xMargin;
          if (side < 0 && rect2.left < bounding.left + moveX)
            moveX = -(bounding.left + moveX - rect2.left + xMargin);
        }
      } else {
        let targetLeft = x2 == "center" ? rect2.left + (rect2.right - rect2.left) / 2 - (bounding.right - bounding.left) / 2 : x2 == "start" == ltr ? rect2.left - xMargin : rect2.right - (bounding.right - bounding.left) + xMargin;
        moveX = targetLeft - bounding.left;
      }
      if (moveX || moveY) {
        if (top2) {
          win.scrollBy(moveX, moveY);
        } else {
          let movedX = 0, movedY = 0;
          if (moveY) {
            let start2 = cur2.scrollTop;
            cur2.scrollTop += moveY;
            movedY = cur2.scrollTop - start2;
          }
          if (moveX) {
            let start2 = cur2.scrollLeft;
            cur2.scrollLeft += moveX;
            movedX = cur2.scrollLeft - start2;
          }
          rect2 = {
            left: rect2.left - movedX,
            top: rect2.top - movedY,
            right: rect2.right - movedX,
            bottom: rect2.bottom - movedY
          };
          if (movedX && Math.abs(movedX - moveX) < 1)
            x2 = "nearest";
          if (movedY && Math.abs(movedY - moveY) < 1)
            y2 = "nearest";
        }
      }
      if (top2)
        break;
      cur2 = cur2.assignedSlot || cur2.parentNode;
    } else if (cur2.nodeType == 11) {
      cur2 = cur2.host;
    } else {
      break;
    }
  }
}
class DOMSelectionState {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  eq(domSel) {
    return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
  }
  setRange(range2) {
    this.set(range2.anchorNode, range2.anchorOffset, range2.focusNode, range2.focusOffset);
  }
  set(anchorNode, anchorOffset, focusNode, focusOffset) {
    this.anchorNode = anchorNode;
    this.anchorOffset = anchorOffset;
    this.focusNode = focusNode;
    this.focusOffset = focusOffset;
  }
}
let preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stack2 = [];
  for (let cur2 = dom; cur2; cur2 = cur2.parentNode) {
    stack2.push(cur2, cur2.scrollTop, cur2.scrollLeft);
    if (cur2 == cur2.ownerDocument)
      break;
  }
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    for (let i = 0; i < stack2.length; ) {
      let elt2 = stack2[i++], top2 = stack2[i++], left2 = stack2[i++];
      if (elt2.scrollTop != top2)
        elt2.scrollTop = top2;
      if (elt2.scrollLeft != left2)
        elt2.scrollLeft = left2;
    }
  }
}
let scratchRange;
function textRange(node2, from2, to2 = from2) {
  let range2 = scratchRange || (scratchRange = document.createRange());
  range2.setEnd(node2, to2);
  range2.setStart(node2, from2);
  return range2;
}
function dispatchKey(elt2, name2, code) {
  let options2 = { key: name2, code: name2, keyCode: code, which: code, cancelable: true };
  let down = new KeyboardEvent("keydown", options2);
  down.synthetic = true;
  elt2.dispatchEvent(down);
  let up = new KeyboardEvent("keyup", options2);
  up.synthetic = true;
  elt2.dispatchEvent(up);
  return down.defaultPrevented || up.defaultPrevented;
}
function getRoot(node2) {
  while (node2) {
    if (node2 && (node2.nodeType == 9 || node2.nodeType == 11 && node2.host))
      return node2;
    node2 = node2.assignedSlot || node2.parentNode;
  }
  return null;
}
function clearAttributes(node2) {
  while (node2.attributes.length)
    node2.removeAttributeNode(node2.attributes[0]);
}
function atElementStart(doc2, selection2) {
  let node2 = selection2.focusNode, offset = selection2.focusOffset;
  if (!node2 || selection2.anchorNode != node2 || selection2.anchorOffset != offset)
    return false;
  for (; ; ) {
    if (offset) {
      if (node2.nodeType != 1)
        return false;
      let prev2 = node2.childNodes[offset - 1];
      if (prev2.contentEditable == "false")
        offset--;
      else {
        node2 = prev2;
        offset = maxOffset(node2);
      }
    } else if (node2 == doc2) {
      return true;
    } else {
      offset = domIndex(node2);
      node2 = node2.parentNode;
    }
  }
}
class DOMPos {
  constructor(node2, offset, precise = true) {
    this.node = node2;
    this.offset = offset;
    this.precise = precise;
  }
  static before(dom, precise) {
    return new DOMPos(dom.parentNode, domIndex(dom), precise);
  }
  static after(dom, precise) {
    return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
  }
}
const noChildren = [];
class ContentView {
  constructor() {
    this.parent = null;
    this.dom = null;
    this.dirty = 2;
  }
  get editorView() {
    if (!this.parent)
      throw new Error("Accessing view in orphan content view");
    return this.parent.editorView;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(view) {
    let pos = this.posAtStart;
    for (let child of this.children) {
      if (child == view)
        return pos;
      pos += child.length + child.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(view) {
    return this.posBefore(view) + view.length;
  }
  coordsAt(_pos, _side) {
    return null;
  }
  sync(track) {
    if (this.dirty & 2) {
      let parent = this.dom;
      let prev2 = null, next2;
      for (let child of this.children) {
        if (child.dirty) {
          if (!child.dom && (next2 = prev2 ? prev2.nextSibling : parent.firstChild)) {
            let contentView = ContentView.get(next2);
            if (!contentView || !contentView.parent && contentView.canReuseDOM(child))
              child.reuseDOM(next2);
          }
          child.sync(track);
          child.dirty = 0;
        }
        next2 = prev2 ? prev2.nextSibling : parent.firstChild;
        if (track && !track.written && track.node == parent && next2 != child.dom)
          track.written = true;
        if (child.dom.parentNode == parent) {
          while (next2 && next2 != child.dom)
            next2 = rm$1(next2);
        } else {
          parent.insertBefore(child.dom, next2);
        }
        prev2 = child.dom;
      }
      next2 = prev2 ? prev2.nextSibling : parent.firstChild;
      if (next2 && track && track.node == parent)
        track.written = true;
      while (next2)
        next2 = rm$1(next2);
    } else if (this.dirty & 1) {
      for (let child of this.children)
        if (child.dirty) {
          child.sync(track);
          child.dirty = 0;
        }
    }
  }
  reuseDOM(_dom) {
  }
  localPosFromDOM(node2, offset) {
    let after;
    if (node2 == this.dom) {
      after = this.dom.childNodes[offset];
    } else {
      let bias = maxOffset(node2) == 0 ? 0 : offset == 0 ? -1 : 1;
      for (; ; ) {
        let parent = node2.parentNode;
        if (parent == this.dom)
          break;
        if (bias == 0 && parent.firstChild != parent.lastChild) {
          if (node2 == parent.firstChild)
            bias = -1;
          else
            bias = 1;
        }
        node2 = parent;
      }
      if (bias < 0)
        after = node2;
      else
        after = node2.nextSibling;
    }
    if (after == this.dom.firstChild)
      return 0;
    while (after && !ContentView.get(after))
      after = after.nextSibling;
    if (!after)
      return this.length;
    for (let i = 0, pos = 0; ; i++) {
      let child = this.children[i];
      if (child.dom == after)
        return pos;
      pos += child.length + child.breakAfter;
    }
  }
  domBoundsAround(from2, to2, offset = 0) {
    let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
    for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {
      let child = this.children[i], end2 = pos + child.length;
      if (pos < from2 && end2 > to2)
        return child.domBoundsAround(from2, to2, pos);
      if (end2 >= from2 && fromI == -1) {
        fromI = i;
        fromStart = pos;
      }
      if (pos > to2 && child.dom.parentNode == this.dom) {
        toI = i;
        toEnd = prevEnd;
        break;
      }
      prevEnd = end2;
      pos = end2 + child.breakAfter;
    }
    return {
      from: fromStart,
      to: toEnd < 0 ? offset + this.length : toEnd,
      startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
    };
  }
  markDirty(andParent = false) {
    this.dirty |= 2;
    this.markParentsDirty(andParent);
  }
  markParentsDirty(childList) {
    for (let parent = this.parent; parent; parent = parent.parent) {
      if (childList)
        parent.dirty |= 2;
      if (parent.dirty & 1)
        return;
      parent.dirty |= 1;
      childList = false;
    }
  }
  setParent(parent) {
    if (this.parent != parent) {
      this.parent = parent;
      if (this.dirty)
        this.markParentsDirty(true);
    }
  }
  setDOM(dom) {
    if (this.dom)
      this.dom.cmView = null;
    this.dom = dom;
    dom.cmView = this;
  }
  get rootView() {
    for (let v = this; ; ) {
      let parent = v.parent;
      if (!parent)
        return v;
      v = parent;
    }
  }
  replaceChildren(from2, to2, children2 = noChildren) {
    this.markDirty();
    for (let i = from2; i < to2; i++) {
      let child = this.children[i];
      if (child.parent == this)
        child.destroy();
    }
    this.children.splice(from2, to2 - from2, ...children2);
    for (let i = 0; i < children2.length; i++)
      children2[i].setParent(this);
  }
  ignoreMutation(_rec) {
    return false;
  }
  ignoreEvent(_event) {
    return false;
  }
  childCursor(pos = this.length) {
    return new ChildCursor(this.children, pos, this.children.length);
  }
  childPos(pos, bias = 1) {
    return this.childCursor().findPos(pos, bias);
  }
  toString() {
    let name2 = this.constructor.name.replace("View", "");
    return name2 + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name2 == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(node2) {
    return node2.cmView;
  }
  get isEditable() {
    return true;
  }
  merge(from2, to2, source, hasStart, openStart, openEnd) {
    return false;
  }
  become(other) {
    return false;
  }
  canReuseDOM(other) {
    return other.constructor == this.constructor;
  }
  getSide() {
    return 0;
  }
  destroy() {
    this.parent = null;
  }
}
ContentView.prototype.breakAfter = 0;
function rm$1(dom) {
  let next2 = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next2;
}
class ChildCursor {
  constructor(children2, pos, i) {
    this.children = children2;
    this.pos = pos;
    this.i = i;
    this.off = 0;
  }
  findPos(pos, bias = 1) {
    for (; ; ) {
      if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
        this.off = pos - this.pos;
        return this;
      }
      let next2 = this.children[--this.i];
      this.pos -= next2.length + next2.breakAfter;
    }
  }
}
function replaceRange(parent, fromI, fromOff, toI, toOff, insert2, breakAtStart, openStart, openEnd) {
  let { children: children2 } = parent;
  let before = children2.length ? children2[fromI] : null;
  let last = insert2.length ? insert2[insert2.length - 1] : null;
  let breakAtEnd = last ? last.breakAfter : breakAtStart;
  if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert2.length < 2 && before.merge(fromOff, toOff, insert2.length ? last : null, fromOff == 0, openStart, openEnd))
    return;
  if (toI < children2.length) {
    let after = children2[toI];
    if (after && toOff < after.length) {
      if (fromI == toI) {
        after = after.split(toOff);
        toOff = 0;
      }
      if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
        insert2[insert2.length - 1] = after;
      } else {
        if (toOff)
          after.merge(0, toOff, null, false, 0, openEnd);
        insert2.push(after);
      }
    } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
      if (last)
        last.breakAfter = 1;
      else
        breakAtStart = 1;
    }
    toI++;
  }
  if (before) {
    before.breakAfter = breakAtStart;
    if (fromOff > 0) {
      if (!breakAtStart && insert2.length && before.merge(fromOff, before.length, insert2[0], false, openStart, 0)) {
        before.breakAfter = insert2.shift().breakAfter;
      } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
        before.merge(fromOff, before.length, null, false, openStart, 0);
      }
      fromI++;
    }
  }
  while (fromI < toI && insert2.length) {
    if (children2[toI - 1].become(insert2[insert2.length - 1])) {
      toI--;
      insert2.pop();
      openEnd = insert2.length ? 0 : openStart;
    } else if (children2[fromI].become(insert2[0])) {
      fromI++;
      insert2.shift();
      openStart = insert2.length ? 0 : openEnd;
    } else {
      break;
    }
  }
  if (!insert2.length && fromI && toI < children2.length && !children2[fromI - 1].breakAfter && children2[toI].merge(0, 0, children2[fromI - 1], false, openStart, openEnd))
    fromI--;
  if (fromI < toI || insert2.length)
    parent.replaceChildren(fromI, toI, insert2);
}
function mergeChildrenInto(parent, from2, to2, insert2, openStart, openEnd) {
  let cur2 = parent.childCursor();
  let { i: toI, off: toOff } = cur2.findPos(to2, 1);
  let { i: fromI, off: fromOff } = cur2.findPos(from2, -1);
  let dLen = from2 - to2;
  for (let view of insert2)
    dLen += view.length;
  parent.length += dLen;
  replaceRange(parent, fromI, fromOff, toI, toOff, insert2, 0, openStart, openEnd);
}
let nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
let doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
const ie_edge = /* @__PURE__ */ /Edge\/(\d+)/.exec(nav.userAgent);
const ie_upto10 = /* @__PURE__ */ /MSIE \d/.test(nav.userAgent);
const ie_11up = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
const ie$1 = !!(ie_upto10 || ie_11up || ie_edge);
const gecko = !ie$1 && /* @__PURE__ */ /gecko\/(\d+)/i.test(nav.userAgent);
const chrome = !ie$1 && /* @__PURE__ */ /Chrome\/(\d+)/.exec(nav.userAgent);
const webkit = "webkitFontSmoothing" in doc.documentElement.style;
const safari = !ie$1 && /* @__PURE__ */ /Apple Computer/.test(nav.vendor);
const ios = safari && (/* @__PURE__ */ /Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
var browser = {
  mac: ios || /* @__PURE__ */ /Mac/.test(nav.platform),
  windows: /* @__PURE__ */ /Win/.test(nav.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(nav.platform),
  ie: ie$1,
  ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
  gecko,
  gecko_version: gecko ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
  chrome: !!chrome,
  chrome_version: chrome ? +chrome[1] : 0,
  ios,
  android: /* @__PURE__ */ /Android\b/.test(nav.userAgent),
  webkit,
  safari,
  webkit_version: webkit ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const MaxJoinLen = 256;
class TextView extends ContentView {
  constructor(text2) {
    super();
    this.text = text2;
  }
  get length() {
    return this.text.length;
  }
  createDOM(textDOM) {
    this.setDOM(textDOM || document.createTextNode(this.text));
  }
  sync(track) {
    if (!this.dom)
      this.createDOM();
    if (this.dom.nodeValue != this.text) {
      if (track && track.node == this.dom)
        track.written = true;
      this.dom.nodeValue = this.text;
    }
  }
  reuseDOM(dom) {
    if (dom.nodeType == 3)
      this.createDOM(dom);
  }
  merge(from2, to2, source) {
    if (source && (!(source instanceof TextView) || this.length - (to2 - from2) + source.length > MaxJoinLen))
      return false;
    this.text = this.text.slice(0, from2) + (source ? source.text : "") + this.text.slice(to2);
    this.markDirty();
    return true;
  }
  split(from2) {
    let result = new TextView(this.text.slice(from2));
    this.text = this.text.slice(0, from2);
    this.markDirty();
    return result;
  }
  localPosFromDOM(node2, offset) {
    return node2 == this.dom ? offset : offset ? this.text.length : 0;
  }
  domAtPos(pos) {
    return new DOMPos(this.dom, pos);
  }
  domBoundsAround(_from, _to, offset) {
    return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(pos, side) {
    return textCoords(this.dom, pos, side);
  }
}
class MarkView extends ContentView {
  constructor(mark, children2 = [], length2 = 0) {
    super();
    this.mark = mark;
    this.children = children2;
    this.length = length2;
    for (let ch of children2)
      ch.setParent(this);
  }
  setAttrs(dom) {
    clearAttributes(dom);
    if (this.mark.class)
      dom.className = this.mark.class;
    if (this.mark.attrs)
      for (let name2 in this.mark.attrs)
        dom.setAttribute(name2, this.mark.attrs[name2]);
    return dom;
  }
  reuseDOM(node2) {
    if (node2.nodeName == this.mark.tagName.toUpperCase()) {
      this.setDOM(node2);
      this.dirty |= 4 | 2;
    }
  }
  sync(track) {
    if (!this.dom)
      this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
    else if (this.dirty & 4)
      this.setAttrs(this.dom);
    super.sync(track);
  }
  merge(from2, to2, source, _hasStart, openStart, openEnd) {
    if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) || from2 && openStart <= 0 || to2 < this.length && openEnd <= 0))
      return false;
    mergeChildrenInto(this, from2, to2, source ? source.children : [], openStart - 1, openEnd - 1);
    this.markDirty();
    return true;
  }
  split(from2) {
    let result = [], off = 0, detachFrom = -1, i = 0;
    for (let elt2 of this.children) {
      let end2 = off + elt2.length;
      if (end2 > from2)
        result.push(off < from2 ? elt2.split(from2 - off) : elt2);
      if (detachFrom < 0 && off >= from2)
        detachFrom = i;
      off = end2;
      i++;
    }
    let length2 = this.length - from2;
    this.length = from2;
    if (detachFrom > -1) {
      this.children.length = detachFrom;
      this.markDirty();
    }
    return new MarkView(this.mark, result, length2);
  }
  domAtPos(pos) {
    return inlineDOMAtPos(this, pos);
  }
  coordsAt(pos, side) {
    return coordsInChildren(this, pos, side);
  }
}
function textCoords(text2, pos, side) {
  let length2 = text2.nodeValue.length;
  if (pos > length2)
    pos = length2;
  let from2 = pos, to2 = pos, flatten2 = 0;
  if (pos == 0 && side < 0 || pos == length2 && side >= 0) {
    if (!(browser.chrome || browser.gecko)) {
      if (pos) {
        from2--;
        flatten2 = 1;
      } else if (to2 < length2) {
        to2++;
        flatten2 = -1;
      }
    }
  } else {
    if (side < 0)
      from2--;
    else if (to2 < length2)
      to2++;
  }
  let rects = textRange(text2, from2, to2).getClientRects();
  if (!rects.length)
    return Rect0;
  let rect2 = rects[(flatten2 ? flatten2 < 0 : side >= 0) ? 0 : rects.length - 1];
  if (browser.safari && !flatten2 && rect2.width == 0)
    rect2 = Array.prototype.find.call(rects, (r) => r.width) || rect2;
  return flatten2 ? flattenRect(rect2, flatten2 < 0) : rect2 || null;
}
class WidgetView extends ContentView {
  constructor(widget2, length2, side) {
    super();
    this.widget = widget2;
    this.length = length2;
    this.side = side;
    this.prevWidget = null;
  }
  static create(widget2, length2, side) {
    return new (widget2.customView || WidgetView)(widget2, length2, side);
  }
  split(from2) {
    let result = WidgetView.create(this.widget, this.length - from2, this.side);
    this.length -= from2;
    return result;
  }
  sync() {
    if (!this.dom || !this.widget.updateDOM(this.dom)) {
      if (this.dom && this.prevWidget)
        this.prevWidget.destroy(this.dom);
      this.prevWidget = null;
      this.setDOM(this.widget.toDOM(this.editorView));
      this.dom.contentEditable = "false";
    }
  }
  getSide() {
    return this.side;
  }
  merge(from2, to2, source, hasStart, openStart, openEnd) {
    if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) || from2 > 0 && openStart <= 0 || to2 < this.length && openEnd <= 0))
      return false;
    this.length = from2 + (source ? source.length : 0) + (this.length - to2);
    return true;
  }
  become(other) {
    if (other.length == this.length && other instanceof WidgetView && other.side == this.side) {
      if (this.widget.constructor == other.widget.constructor) {
        if (!this.widget.eq(other.widget))
          this.markDirty(true);
        if (this.dom && !this.prevWidget)
          this.prevWidget = this.widget;
        this.widget = other.widget;
        return true;
      }
    }
    return false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(event2) {
    return this.widget.ignoreEvent(event2);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Text.empty;
    let top2 = this;
    while (top2.parent)
      top2 = top2.parent;
    let view = top2.editorView, text2 = view && view.state.doc, start2 = this.posAtStart;
    return text2 ? text2.slice(start2, start2 + this.length) : Text.empty;
  }
  domAtPos(pos) {
    return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(pos, side) {
    let rects = this.dom.getClientRects(), rect2 = null;
    if (!rects.length)
      return Rect0;
    for (let i = pos > 0 ? rects.length - 1 : 0; ; i += pos > 0 ? -1 : 1) {
      rect2 = rects[i];
      if (pos > 0 ? i == 0 : i == rects.length - 1 || rect2.top < rect2.bottom)
        break;
    }
    return flattenRect(rect2, this.side > 0);
  }
  get isEditable() {
    return false;
  }
  destroy() {
    super.destroy();
    if (this.dom)
      this.widget.destroy(this.dom);
  }
}
class CompositionView extends WidgetView {
  domAtPos(pos) {
    let { topView, text: text2 } = this.widget;
    if (!topView)
      return new DOMPos(text2, Math.min(pos, text2.nodeValue.length));
    return scanCompositionTree(pos, 0, topView, text2, (v, p) => v.domAtPos(p), (p) => new DOMPos(text2, Math.min(p, text2.nodeValue.length)));
  }
  sync() {
    this.setDOM(this.widget.toDOM());
  }
  localPosFromDOM(node2, offset) {
    let { topView, text: text2 } = this.widget;
    if (!topView)
      return Math.min(offset, this.length);
    return posFromDOMInCompositionTree(node2, offset, topView, text2);
  }
  ignoreMutation() {
    return false;
  }
  get overrideDOMText() {
    return null;
  }
  coordsAt(pos, side) {
    let { topView, text: text2 } = this.widget;
    if (!topView)
      return textCoords(text2, pos, side);
    return scanCompositionTree(pos, side, topView, text2, (v, pos2, side2) => v.coordsAt(pos2, side2), (pos2, side2) => textCoords(text2, pos2, side2));
  }
  destroy() {
    var _a2;
    super.destroy();
    (_a2 = this.widget.topView) === null || _a2 === void 0 ? void 0 : _a2.destroy();
  }
  get isEditable() {
    return true;
  }
  canReuseDOM() {
    return true;
  }
}
function scanCompositionTree(pos, side, view, text2, enterView, fromText) {
  if (view instanceof MarkView) {
    for (let child = view.dom.firstChild; child; child = child.nextSibling) {
      let desc = ContentView.get(child);
      if (!desc)
        return fromText(pos, side);
      let hasComp = contains$3(child, text2);
      let len = desc.length + (hasComp ? text2.nodeValue.length : 0);
      if (pos < len || pos == len && desc.getSide() <= 0)
        return hasComp ? scanCompositionTree(pos, side, desc, text2, enterView, fromText) : enterView(desc, pos, side);
      pos -= len;
    }
    return enterView(view, view.length, -1);
  } else if (view.dom == text2) {
    return fromText(pos, side);
  } else {
    return enterView(view, pos, side);
  }
}
function posFromDOMInCompositionTree(node2, offset, view, text2) {
  if (view instanceof MarkView) {
    for (let child of view.children) {
      let pos = 0, hasComp = contains$3(child.dom, text2);
      if (contains$3(child.dom, node2))
        return pos + (hasComp ? posFromDOMInCompositionTree(node2, offset, child, text2) : child.localPosFromDOM(node2, offset));
      pos += hasComp ? text2.nodeValue.length : child.length;
    }
  } else if (view.dom == text2) {
    return Math.min(offset, text2.nodeValue.length);
  }
  return view.localPosFromDOM(node2, offset);
}
class WidgetBufferView extends ContentView {
  constructor(side) {
    super();
    this.side = side;
  }
  get length() {
    return 0;
  }
  merge() {
    return false;
  }
  become(other) {
    return other instanceof WidgetBufferView && other.side == this.side;
  }
  split() {
    return new WidgetBufferView(this.side);
  }
  sync() {
    if (!this.dom) {
      let dom = document.createElement("img");
      dom.className = "cm-widgetBuffer";
      dom.setAttribute("aria-hidden", "true");
      this.setDOM(dom);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(pos) {
    return DOMPos.before(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(pos) {
    let imgRect = this.dom.getBoundingClientRect();
    let siblingRect = inlineSiblingRect(this, this.side > 0 ? -1 : 1);
    return siblingRect && siblingRect.top < imgRect.bottom && siblingRect.bottom > imgRect.top ? { left: imgRect.left, right: imgRect.right, top: siblingRect.top, bottom: siblingRect.bottom } : imgRect;
  }
  get overrideDOMText() {
    return Text.empty;
  }
}
TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
function inlineSiblingRect(view, side) {
  let parent = view.parent, index2 = parent ? parent.children.indexOf(view) : -1;
  while (parent && index2 >= 0) {
    if (side < 0 ? index2 > 0 : index2 < parent.children.length) {
      let next2 = parent.children[index2 + side];
      if (next2 instanceof TextView) {
        let nextRect = next2.coordsAt(side < 0 ? next2.length : 0, side);
        if (nextRect)
          return nextRect;
      }
      index2 += side;
    } else if (parent instanceof MarkView && parent.parent) {
      index2 = parent.parent.children.indexOf(parent) + (side < 0 ? 0 : 1);
      parent = parent.parent;
    } else {
      let last = parent.dom.lastChild;
      if (last && last.nodeName == "BR")
        return last.getClientRects()[0];
      break;
    }
  }
  return void 0;
}
function inlineDOMAtPos(parent, pos) {
  let dom = parent.dom, { children: children2 } = parent, i = 0;
  for (let off = 0; i < children2.length; i++) {
    let child = children2[i], end2 = off + child.length;
    if (end2 == off && child.getSide() <= 0)
      continue;
    if (pos > off && pos < end2 && child.dom.parentNode == dom)
      return child.domAtPos(pos - off);
    if (pos <= off)
      break;
    off = end2;
  }
  for (let j2 = i; j2 > 0; j2--) {
    let prev2 = children2[j2 - 1];
    if (prev2.dom.parentNode == dom)
      return prev2.domAtPos(prev2.length);
  }
  for (let j2 = i; j2 < children2.length; j2++) {
    let next2 = children2[j2];
    if (next2.dom.parentNode == dom)
      return next2.domAtPos(0);
  }
  return new DOMPos(dom, 0);
}
function joinInlineInto(parent, view, open) {
  let last, { children: children2 } = parent;
  if (open > 0 && view instanceof MarkView && children2.length && (last = children2[children2.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
    joinInlineInto(last, view.children[0], open - 1);
  } else {
    children2.push(view);
    view.setParent(parent);
  }
  parent.length += view.length;
}
function coordsInChildren(view, pos, side) {
  let before = null, beforePos = -1, after = null, afterPos = -1;
  function scan2(view2, pos2) {
    for (let i = 0, off = 0; i < view2.children.length && off <= pos2; i++) {
      let child = view2.children[i], end2 = off + child.length;
      if (end2 >= pos2) {
        if (child.children.length) {
          scan2(child, pos2 - off);
        } else if (!after && (end2 > pos2 || off == end2 && child.getSide() > 0)) {
          after = child;
          afterPos = pos2 - off;
        } else if (off < pos2 || off == end2 && child.getSide() < 0) {
          before = child;
          beforePos = pos2 - off;
        }
      }
      off = end2;
    }
  }
  scan2(view, pos);
  let target = (side < 0 ? before : after) || before || after;
  if (target)
    return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);
  return fallbackRect(view);
}
function fallbackRect(view) {
  let last = view.dom.lastChild;
  if (!last)
    return view.dom.getBoundingClientRect();
  let rects = clientRectsFor(last);
  return rects[rects.length - 1] || null;
}
function combineAttrs(source, target) {
  for (let name2 in source) {
    if (name2 == "class" && target.class)
      target.class += " " + source.class;
    else if (name2 == "style" && target.style)
      target.style += ";" + source.style;
    else
      target[name2] = source[name2];
  }
  return target;
}
function attrsEq(a2, b) {
  if (a2 == b)
    return true;
  if (!a2 || !b)
    return false;
  let keysA = Object.keys(a2), keysB = Object.keys(b);
  if (keysA.length != keysB.length)
    return false;
  for (let key of keysA) {
    if (keysB.indexOf(key) == -1 || a2[key] !== b[key])
      return false;
  }
  return true;
}
function updateAttrs(dom, prev2, attrs) {
  let changed = null;
  if (prev2) {
    for (let name2 in prev2)
      if (!(attrs && name2 in attrs))
        dom.removeAttribute(changed = name2);
  }
  if (attrs) {
    for (let name2 in attrs)
      if (!(prev2 && prev2[name2] == attrs[name2]))
        dom.setAttribute(changed = name2, attrs[name2]);
  }
  return !!changed;
}
class WidgetType {
  eq(widget2) {
    return false;
  }
  updateDOM(dom) {
    return false;
  }
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  get estimatedHeight() {
    return -1;
  }
  ignoreEvent(event2) {
    return true;
  }
  get customView() {
    return null;
  }
  destroy(dom) {
  }
}
var BlockType = /* @__PURE__ */ function(BlockType2) {
  BlockType2[BlockType2["Text"] = 0] = "Text";
  BlockType2[BlockType2["WidgetBefore"] = 1] = "WidgetBefore";
  BlockType2[BlockType2["WidgetAfter"] = 2] = "WidgetAfter";
  BlockType2[BlockType2["WidgetRange"] = 3] = "WidgetRange";
  return BlockType2;
}(BlockType || (BlockType = {}));
class Decoration extends RangeValue {
  constructor(startSide, endSide, widget2, spec) {
    super();
    this.startSide = startSide;
    this.endSide = endSide;
    this.widget = widget2;
    this.spec = spec;
  }
  get heightRelevant() {
    return false;
  }
  static mark(spec) {
    return new MarkDecoration(spec);
  }
  static widget(spec) {
    let side = spec.side || 0, block = !!spec.block;
    side += block ? side > 0 ? 3e8 : -4e8 : side > 0 ? 1e8 : -1e8;
    return new PointDecoration(spec, side, side, block, spec.widget || null, false);
  }
  static replace(spec) {
    let block = !!spec.block, startSide, endSide;
    if (spec.isBlockGap) {
      startSide = -5e8;
      endSide = 4e8;
    } else {
      let { start: start2, end: end2 } = getInclusive(spec, block);
      startSide = (start2 ? block ? -3e8 : -1 : 5e8) - 1;
      endSide = (end2 ? block ? 2e8 : 1 : -6e8) + 1;
    }
    return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
  }
  static line(spec) {
    return new LineDecoration(spec);
  }
  static set(of, sort2 = false) {
    return RangeSet.of(of, sort2);
  }
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : false;
  }
}
Decoration.none = RangeSet.empty;
class MarkDecoration extends Decoration {
  constructor(spec) {
    let { start: start2, end: end2 } = getInclusive(spec);
    super(start2 ? -1 : 5e8, end2 ? 1 : -6e8, null, spec);
    this.tagName = spec.tagName || "span";
    this.class = spec.class || "";
    this.attrs = spec.attributes || null;
  }
  eq(other) {
    return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && this.class == other.class && attrsEq(this.attrs, other.attrs);
  }
  range(from2, to2 = from2) {
    if (from2 >= to2)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(from2, to2);
  }
}
MarkDecoration.prototype.point = false;
class LineDecoration extends Decoration {
  constructor(spec) {
    super(-2e8, -2e8, null, spec);
  }
  eq(other) {
    return other instanceof LineDecoration && attrsEq(this.spec.attributes, other.spec.attributes);
  }
  range(from2, to2 = from2) {
    if (to2 != from2)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(from2, to2);
  }
}
LineDecoration.prototype.mapMode = MapMode.TrackBefore;
LineDecoration.prototype.point = true;
class PointDecoration extends Decoration {
  constructor(spec, startSide, endSide, block, widget2, isReplace) {
    super(startSide, endSide, widget2, spec);
    this.block = block;
    this.isReplace = isReplace;
    this.mapMode = !block ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
  }
  get type() {
    return this.startSide < this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && this.widget.estimatedHeight >= 5;
  }
  eq(other) {
    return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
  }
  range(from2, to2 = from2) {
    if (this.isReplace && (from2 > to2 || from2 == to2 && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && to2 != from2)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(from2, to2);
  }
}
PointDecoration.prototype.point = true;
function getInclusive(spec, block = false) {
  let { inclusiveStart: start2, inclusiveEnd: end2 } = spec;
  if (start2 == null)
    start2 = spec.inclusive;
  if (end2 == null)
    end2 = spec.inclusive;
  return { start: start2 !== null && start2 !== void 0 ? start2 : block, end: end2 !== null && end2 !== void 0 ? end2 : block };
}
function widgetsEq(a2, b) {
  return a2 == b || !!(a2 && b && a2.compare(b));
}
function addRange(from2, to2, ranges2, margin = 0) {
  let last = ranges2.length - 1;
  if (last >= 0 && ranges2[last] + margin >= from2)
    ranges2[last] = Math.max(ranges2[last], to2);
  else
    ranges2.push(from2, to2);
}
class LineView extends ContentView {
  constructor() {
    super(...arguments);
    this.children = [];
    this.length = 0;
    this.prevAttrs = void 0;
    this.attrs = null;
    this.breakAfter = 0;
  }
  merge(from2, to2, source, hasStart, openStart, openEnd) {
    if (source) {
      if (!(source instanceof LineView))
        return false;
      if (!this.dom)
        source.transferDOM(this);
    }
    if (hasStart)
      this.setDeco(source ? source.attrs : null);
    mergeChildrenInto(this, from2, to2, source ? source.children : [], openStart, openEnd);
    return true;
  }
  split(at) {
    let end2 = new LineView();
    end2.breakAfter = this.breakAfter;
    if (this.length == 0)
      return end2;
    let { i, off } = this.childPos(at);
    if (off) {
      end2.append(this.children[i].split(off), 0);
      this.children[i].merge(off, this.children[i].length, null, false, 0, 0);
      i++;
    }
    for (let j2 = i; j2 < this.children.length; j2++)
      end2.append(this.children[j2], 0);
    while (i > 0 && this.children[i - 1].length == 0)
      this.children[--i].destroy();
    this.children.length = i;
    this.markDirty();
    this.length = at;
    return end2;
  }
  transferDOM(other) {
    if (!this.dom)
      return;
    this.markDirty();
    other.setDOM(this.dom);
    other.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs;
    this.prevAttrs = void 0;
    this.dom = null;
  }
  setDeco(attrs) {
    if (!attrsEq(this.attrs, attrs)) {
      if (this.dom) {
        this.prevAttrs = this.attrs;
        this.markDirty();
      }
      this.attrs = attrs;
    }
  }
  append(child, openStart) {
    joinInlineInto(this, child, openStart);
  }
  addLineDeco(deco) {
    let attrs = deco.spec.attributes, cls = deco.spec.class;
    if (attrs)
      this.attrs = combineAttrs(attrs, this.attrs || {});
    if (cls)
      this.attrs = combineAttrs({ class: cls }, this.attrs || {});
  }
  domAtPos(pos) {
    return inlineDOMAtPos(this, pos);
  }
  reuseDOM(node2) {
    if (node2.nodeName == "DIV") {
      this.setDOM(node2);
      this.dirty |= 4 | 2;
    }
  }
  sync(track) {
    var _a2;
    if (!this.dom) {
      this.setDOM(document.createElement("div"));
      this.dom.className = "cm-line";
      this.prevAttrs = this.attrs ? null : void 0;
    } else if (this.dirty & 4) {
      clearAttributes(this.dom);
      this.dom.className = "cm-line";
      this.prevAttrs = this.attrs ? null : void 0;
    }
    if (this.prevAttrs !== void 0) {
      updateAttrs(this.dom, this.prevAttrs, this.attrs);
      this.dom.classList.add("cm-line");
      this.prevAttrs = void 0;
    }
    super.sync(track);
    let last = this.dom.lastChild;
    while (last && ContentView.get(last) instanceof MarkView)
      last = last.lastChild;
    if (!last || !this.length || last.nodeName != "BR" && ((_a2 = ContentView.get(last)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) == false && (!browser.ios || !this.children.some((ch) => ch instanceof TextView))) {
      let hack = document.createElement("BR");
      hack.cmIgnore = true;
      this.dom.appendChild(hack);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let totalWidth = 0;
    for (let child of this.children) {
      if (!(child instanceof TextView) || /[^ -~]/.test(child.text))
        return null;
      let rects = clientRectsFor(child.dom);
      if (rects.length != 1)
        return null;
      totalWidth += rects[0].width;
    }
    return !totalWidth ? null : {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: totalWidth / this.length
    };
  }
  coordsAt(pos, side) {
    return coordsInChildren(this, pos, side);
  }
  become(_other) {
    return false;
  }
  get type() {
    return BlockType.Text;
  }
  static find(docView, pos) {
    for (let i = 0, off = 0; i < docView.children.length; i++) {
      let block = docView.children[i], end2 = off + block.length;
      if (end2 >= pos) {
        if (block instanceof LineView)
          return block;
        if (end2 > pos)
          break;
      }
      off = end2 + block.breakAfter;
    }
    return null;
  }
}
class BlockWidgetView extends ContentView {
  constructor(widget2, length2, type2) {
    super();
    this.widget = widget2;
    this.length = length2;
    this.type = type2;
    this.breakAfter = 0;
    this.prevWidget = null;
  }
  merge(from2, to2, source, _takeDeco, openStart, openEnd) {
    if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) || from2 > 0 && openStart <= 0 || to2 < this.length && openEnd <= 0))
      return false;
    this.length = from2 + (source ? source.length : 0) + (this.length - to2);
    return true;
  }
  domAtPos(pos) {
    return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
  }
  split(at) {
    let len = this.length - at;
    this.length = at;
    let end2 = new BlockWidgetView(this.widget, len, this.type);
    end2.breakAfter = this.breakAfter;
    return end2;
  }
  get children() {
    return noChildren;
  }
  sync() {
    if (!this.dom || !this.widget.updateDOM(this.dom)) {
      if (this.dom && this.prevWidget)
        this.prevWidget.destroy(this.dom);
      this.prevWidget = null;
      this.setDOM(this.widget.toDOM(this.editorView));
      this.dom.contentEditable = "false";
    }
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(other) {
    if (other instanceof BlockWidgetView && other.type == this.type && other.widget.constructor == this.widget.constructor) {
      if (!other.widget.eq(this.widget))
        this.markDirty(true);
      if (this.dom && !this.prevWidget)
        this.prevWidget = this.widget;
      this.widget = other.widget;
      this.length = other.length;
      this.breakAfter = other.breakAfter;
      return true;
    }
    return false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(event2) {
    return this.widget.ignoreEvent(event2);
  }
  destroy() {
    super.destroy();
    if (this.dom)
      this.widget.destroy(this.dom);
  }
}
class ContentBuilder {
  constructor(doc2, pos, end2, disallowBlockEffectsFor) {
    this.doc = doc2;
    this.pos = pos;
    this.end = end2;
    this.disallowBlockEffectsFor = disallowBlockEffectsFor;
    this.content = [];
    this.curLine = null;
    this.breakAtStart = 0;
    this.pendingBuffer = 0;
    this.atCursorPos = true;
    this.openStart = -1;
    this.openEnd = -1;
    this.text = "";
    this.textOff = 0;
    this.cursor = doc2.iter();
    this.skip = pos;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let last = this.content[this.content.length - 1];
    return !last.breakAfter && !(last instanceof BlockWidgetView && last.type == BlockType.WidgetBefore);
  }
  getLine() {
    if (!this.curLine) {
      this.content.push(this.curLine = new LineView());
      this.atCursorPos = true;
    }
    return this.curLine;
  }
  flushBuffer(active2) {
    if (this.pendingBuffer) {
      this.curLine.append(wrapMarks(new WidgetBufferView(-1), active2), active2.length);
      this.pendingBuffer = 0;
    }
  }
  addBlockWidget(view) {
    this.flushBuffer([]);
    this.curLine = null;
    this.content.push(view);
  }
  finish(openEnd) {
    if (!openEnd)
      this.flushBuffer([]);
    else
      this.pendingBuffer = 0;
    if (!this.posCovered())
      this.getLine();
  }
  buildText(length2, active2, openStart) {
    while (length2 > 0) {
      if (this.textOff == this.text.length) {
        let { value, lineBreak, done } = this.cursor.next(this.skip);
        this.skip = 0;
        if (done)
          throw new Error("Ran out of text content when drawing inline views");
        if (lineBreak) {
          if (!this.posCovered())
            this.getLine();
          if (this.content.length)
            this.content[this.content.length - 1].breakAfter = 1;
          else
            this.breakAtStart = 1;
          this.flushBuffer([]);
          this.curLine = null;
          length2--;
          continue;
        } else {
          this.text = value;
          this.textOff = 0;
        }
      }
      let take = Math.min(this.text.length - this.textOff, length2, 512);
      this.flushBuffer(active2.slice(0, openStart));
      this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active2), openStart);
      this.atCursorPos = true;
      this.textOff += take;
      length2 -= take;
      openStart = 0;
    }
  }
  span(from2, to2, active2, openStart) {
    this.buildText(to2 - from2, active2, openStart);
    this.pos = to2;
    if (this.openStart < 0)
      this.openStart = openStart;
  }
  point(from2, to2, deco, active2, openStart, index2) {
    if (this.disallowBlockEffectsFor[index2] && deco instanceof PointDecoration) {
      if (deco.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (to2 > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let len = to2 - from2;
    if (deco instanceof PointDecoration) {
      if (deco.block) {
        let { type: type2 } = deco;
        if (type2 == BlockType.WidgetAfter && !this.posCovered())
          this.getLine();
        this.addBlockWidget(new BlockWidgetView(deco.widget || new NullWidget("div"), len, type2));
      } else {
        let view = WidgetView.create(deco.widget || new NullWidget("span"), len, len ? 0 : deco.startSide);
        let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active2.length && (from2 < to2 || deco.startSide > 0);
        let cursorAfter = !view.isEditable && (from2 < to2 || deco.startSide <= 0);
        let line2 = this.getLine();
        if (this.pendingBuffer == 2 && !cursorBefore)
          this.pendingBuffer = 0;
        this.flushBuffer(active2);
        if (cursorBefore) {
          line2.append(wrapMarks(new WidgetBufferView(1), active2), openStart);
          openStart = active2.length + Math.max(0, openStart - active2.length);
        }
        line2.append(wrapMarks(view, active2), openStart);
        this.atCursorPos = cursorAfter;
        this.pendingBuffer = !cursorAfter ? 0 : from2 < to2 ? 1 : 2;
      }
    } else if (this.doc.lineAt(this.pos).from == this.pos) {
      this.getLine().addLineDeco(deco);
    }
    if (len) {
      if (this.textOff + len <= this.text.length) {
        this.textOff += len;
      } else {
        this.skip += len - (this.text.length - this.textOff);
        this.text = "";
        this.textOff = 0;
      }
      this.pos = to2;
    }
    if (this.openStart < 0)
      this.openStart = openStart;
  }
  static build(text2, from2, to2, decorations2, dynamicDecorationMap) {
    let builder = new ContentBuilder(text2, from2, to2, dynamicDecorationMap);
    builder.openEnd = RangeSet.spans(decorations2, from2, to2, builder);
    if (builder.openStart < 0)
      builder.openStart = builder.openEnd;
    builder.finish(builder.openEnd);
    return builder;
  }
}
function wrapMarks(view, active2) {
  for (let mark of active2)
    view = new MarkView(mark, [view], view.length);
  return view;
}
class NullWidget extends WidgetType {
  constructor(tag) {
    super();
    this.tag = tag;
  }
  eq(other) {
    return other.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(elt2) {
    return elt2.nodeName.toLowerCase() == this.tag;
  }
}
const clickAddsSelectionRange = /* @__PURE__ */ Facet.define();
const dragMovesSelection$1 = /* @__PURE__ */ Facet.define();
const mouseSelectionStyle = /* @__PURE__ */ Facet.define();
const exceptionSink = /* @__PURE__ */ Facet.define();
const updateListener = /* @__PURE__ */ Facet.define();
const inputHandler$1 = /* @__PURE__ */ Facet.define();
const perLineTextDirection = /* @__PURE__ */ Facet.define({
  combine: (values2) => values2.some((x2) => x2)
});
class ScrollTarget {
  constructor(range2, y2 = "nearest", x2 = "nearest", yMargin = 5, xMargin = 5) {
    this.range = range2;
    this.y = y2;
    this.x = x2;
    this.yMargin = yMargin;
    this.xMargin = xMargin;
  }
  map(changes) {
    return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin);
  }
}
const scrollIntoView$1 = /* @__PURE__ */ StateEffect.define({ map: (t4, ch) => t4.map(ch) });
function logException(state, exception, context) {
  let handler = state.facet(exceptionSink);
  if (handler.length)
    handler[0](exception);
  else if (window.onerror)
    window.onerror(String(exception), context, void 0, void 0, exception);
  else if (context)
    console.error(context + ":", exception);
  else
    console.error(exception);
}
const editable = /* @__PURE__ */ Facet.define({ combine: (values2) => values2.length ? values2[0] : true });
let nextPluginID = 0;
const viewPlugin = /* @__PURE__ */ Facet.define();
class ViewPlugin {
  constructor(id2, create2, domEventHandlers, buildExtensions) {
    this.id = id2;
    this.create = create2;
    this.domEventHandlers = domEventHandlers;
    this.extension = buildExtensions(this);
  }
  static define(create2, spec) {
    const { eventHandlers, provide, decorations: deco } = spec || {};
    return new ViewPlugin(nextPluginID++, create2, eventHandlers, (plugin) => {
      let ext = [viewPlugin.of(plugin)];
      if (deco)
        ext.push(decorations.of((view) => {
          let pluginInst = view.plugin(plugin);
          return pluginInst ? deco(pluginInst) : Decoration.none;
        }));
      if (provide)
        ext.push(provide(plugin));
      return ext;
    });
  }
  static fromClass(cls, spec) {
    return ViewPlugin.define((view) => new cls(view), spec);
  }
}
class PluginInstance {
  constructor(spec) {
    this.spec = spec;
    this.mustUpdate = null;
    this.value = null;
  }
  update(view) {
    if (!this.value) {
      if (this.spec) {
        try {
          this.value = this.spec.create(view);
        } catch (e) {
          logException(view.state, e, "CodeMirror plugin crashed");
          this.deactivate();
        }
      }
    } else if (this.mustUpdate) {
      let update = this.mustUpdate;
      this.mustUpdate = null;
      if (this.value.update) {
        try {
          this.value.update(update);
        } catch (e) {
          logException(update.state, e, "CodeMirror plugin crashed");
          if (this.value.destroy)
            try {
              this.value.destroy();
            } catch (_2) {
            }
          this.deactivate();
        }
      }
    }
    return this;
  }
  destroy(view) {
    var _a2;
    if ((_a2 = this.value) === null || _a2 === void 0 ? void 0 : _a2.destroy) {
      try {
        this.value.destroy();
      } catch (e) {
        logException(view.state, e, "CodeMirror plugin crashed");
      }
    }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const editorAttributes = /* @__PURE__ */ Facet.define();
const contentAttributes = /* @__PURE__ */ Facet.define();
const decorations = /* @__PURE__ */ Facet.define();
const atomicRanges = /* @__PURE__ */ Facet.define();
const scrollMargins = /* @__PURE__ */ Facet.define();
const styleModule = /* @__PURE__ */ Facet.define();
class ChangedRange {
  constructor(fromA, toA, fromB, toB) {
    this.fromA = fromA;
    this.toA = toA;
    this.fromB = fromB;
    this.toB = toB;
  }
  join(other) {
    return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
  }
  addToSet(set2) {
    let i = set2.length, me = this;
    for (; i > 0; i--) {
      let range2 = set2[i - 1];
      if (range2.fromA > me.toA)
        continue;
      if (range2.toA < me.fromA)
        break;
      me = me.join(range2);
      set2.splice(i - 1, 1);
    }
    set2.splice(i, 0, me);
    return set2;
  }
  static extendWithRanges(diff, ranges2) {
    if (ranges2.length == 0)
      return diff;
    let result = [];
    for (let dI = 0, rI = 0, posA = 0, posB = 0; ; dI++) {
      let next2 = dI == diff.length ? null : diff[dI], off = posA - posB;
      let end2 = next2 ? next2.fromB : 1e9;
      while (rI < ranges2.length && ranges2[rI] < end2) {
        let from2 = ranges2[rI], to2 = ranges2[rI + 1];
        let fromB = Math.max(posB, from2), toB = Math.min(end2, to2);
        if (fromB <= toB)
          new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
        if (to2 > end2)
          break;
        else
          rI += 2;
      }
      if (!next2)
        return result;
      new ChangedRange(next2.fromA, next2.toA, next2.fromB, next2.toB).addToSet(result);
      posA = next2.toA;
      posB = next2.toB;
    }
  }
}
class ViewUpdate {
  constructor(view, state, transactions) {
    this.view = view;
    this.state = state;
    this.transactions = transactions;
    this.flags = 0;
    this.startState = view.state;
    this.changes = ChangeSet.empty(this.startState.doc.length);
    for (let tr of transactions)
      this.changes = this.changes.compose(tr.changes);
    let changedRanges = [];
    this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
    this.changedRanges = changedRanges;
    let focus = view.hasFocus;
    if (focus != view.inputState.notifiedFocused) {
      view.inputState.notifiedFocused = focus;
      this.flags |= 1;
    }
  }
  static create(view, state, transactions) {
    return new ViewUpdate(view, state, transactions);
  }
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  get geometryChanged() {
    return this.docChanged || (this.flags & (8 | 2)) > 0;
  }
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get selectionSet() {
    return this.transactions.some((tr) => tr.selection);
  }
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
var Direction = /* @__PURE__ */ function(Direction2) {
  Direction2[Direction2["LTR"] = 0] = "LTR";
  Direction2[Direction2["RTL"] = 1] = "RTL";
  return Direction2;
}(Direction || (Direction = {}));
const LTR = Direction.LTR, RTL = Direction.RTL;
function dec(str) {
  let result = [];
  for (let i = 0; i < str.length; i++)
    result.push(1 << +str[i]);
  return result;
}
const LowTypes = /* @__PURE__ */ dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
const ArabicTypes = /* @__PURE__ */ dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
const Brackets = /* @__PURE__ */ Object.create(null), BracketStack = [];
for (let p of ["()", "[]", "{}"]) {
  let l2 = /* @__PURE__ */ p.charCodeAt(0), r = /* @__PURE__ */ p.charCodeAt(1);
  Brackets[l2] = r;
  Brackets[r] = -l2;
}
function charType(ch) {
  return ch <= 247 ? LowTypes[ch] : 1424 <= ch && ch <= 1524 ? 2 : 1536 <= ch && ch <= 1785 ? ArabicTypes[ch - 1536] : 1774 <= ch && ch <= 2220 ? 4 : 8192 <= ch && ch <= 8203 ? 256 : 64336 <= ch && ch <= 65023 ? 4 : ch == 8204 ? 256 : 1;
}
const BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class BidiSpan {
  constructor(from2, to2, level) {
    this.from = from2;
    this.to = to2;
    this.level = level;
  }
  get dir() {
    return this.level % 2 ? RTL : LTR;
  }
  side(end2, dir) {
    return this.dir == dir == end2 ? this.to : this.from;
  }
  static find(order2, index2, level, assoc) {
    let maybe = -1;
    for (let i = 0; i < order2.length; i++) {
      let span = order2[i];
      if (span.from <= index2 && span.to >= index2) {
        if (span.level == level)
          return i;
        if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index2 : span.to > index2 : order2[maybe].level > span.level))
          maybe = i;
      }
    }
    if (maybe < 0)
      throw new RangeError("Index out of range");
    return maybe;
  }
}
const types$1 = [];
function computeOrder(line2, direction2) {
  let len = line2.length, outerType = direction2 == LTR ? 1 : 2, oppositeType = direction2 == LTR ? 2 : 1;
  if (!line2 || outerType == 1 && !BidiRE.test(line2))
    return trivialOrder(len);
  for (let i = 0, prev2 = outerType, prevStrong = outerType; i < len; i++) {
    let type2 = charType(line2.charCodeAt(i));
    if (type2 == 512)
      type2 = prev2;
    else if (type2 == 8 && prevStrong == 4)
      type2 = 16;
    types$1[i] = type2 == 4 ? 2 : type2;
    if (type2 & 7)
      prevStrong = type2;
    prev2 = type2;
  }
  for (let i = 0, prev2 = outerType, prevStrong = outerType; i < len; i++) {
    let type2 = types$1[i];
    if (type2 == 128) {
      if (i < len - 1 && prev2 == types$1[i + 1] && prev2 & 24)
        type2 = types$1[i] = prev2;
      else
        types$1[i] = 256;
    } else if (type2 == 64) {
      let end2 = i + 1;
      while (end2 < len && types$1[end2] == 64)
        end2++;
      let replace2 = i && prev2 == 8 || end2 < len && types$1[end2] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
      for (let j2 = i; j2 < end2; j2++)
        types$1[j2] = replace2;
      i = end2 - 1;
    } else if (type2 == 8 && prevStrong == 1) {
      types$1[i] = 1;
    }
    prev2 = type2;
    if (type2 & 7)
      prevStrong = type2;
  }
  for (let i = 0, sI = 0, context = 0, ch, br, type2; i < len; i++) {
    if (br = Brackets[ch = line2.charCodeAt(i)]) {
      if (br < 0) {
        for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
          if (BracketStack[sJ + 1] == -br) {
            let flags = BracketStack[sJ + 2];
            let type3 = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
            if (type3)
              types$1[i] = types$1[BracketStack[sJ]] = type3;
            sI = sJ;
            break;
          }
        }
      } else if (BracketStack.length == 189) {
        break;
      } else {
        BracketStack[sI++] = i;
        BracketStack[sI++] = ch;
        BracketStack[sI++] = context;
      }
    } else if ((type2 = types$1[i]) == 2 || type2 == 1) {
      let embed = type2 == outerType;
      context = embed ? 0 : 1;
      for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
        let cur2 = BracketStack[sJ + 2];
        if (cur2 & 2)
          break;
        if (embed) {
          BracketStack[sJ + 2] |= 2;
        } else {
          if (cur2 & 4)
            break;
          BracketStack[sJ + 2] |= 4;
        }
      }
    }
  }
  for (let i = 0; i < len; i++) {
    if (types$1[i] == 256) {
      let end2 = i + 1;
      while (end2 < len && types$1[end2] == 256)
        end2++;
      let beforeL = (i ? types$1[i - 1] : outerType) == 1;
      let afterL = (end2 < len ? types$1[end2] : outerType) == 1;
      let replace2 = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
      for (let j2 = i; j2 < end2; j2++)
        types$1[j2] = replace2;
      i = end2 - 1;
    }
  }
  let order2 = [];
  if (outerType == 1) {
    for (let i = 0; i < len; ) {
      let start2 = i, rtl = types$1[i++] != 1;
      while (i < len && rtl == (types$1[i] != 1))
        i++;
      if (rtl) {
        for (let j2 = i; j2 > start2; ) {
          let end2 = j2, l2 = types$1[--j2] != 2;
          while (j2 > start2 && l2 == (types$1[j2 - 1] != 2))
            j2--;
          order2.push(new BidiSpan(j2, end2, l2 ? 2 : 1));
        }
      } else {
        order2.push(new BidiSpan(start2, i, 0));
      }
    }
  } else {
    for (let i = 0; i < len; ) {
      let start2 = i, rtl = types$1[i++] == 2;
      while (i < len && rtl == (types$1[i] == 2))
        i++;
      order2.push(new BidiSpan(start2, i, rtl ? 1 : 2));
    }
  }
  return order2;
}
function trivialOrder(length2) {
  return [new BidiSpan(0, length2, 0)];
}
let movedOver = "";
function moveVisually(line2, order2, dir, start2, forward) {
  var _a2;
  let startIndex = start2.head - line2.from, spanI = -1;
  if (startIndex == 0) {
    if (!forward || !line2.length)
      return null;
    if (order2[0].level != dir) {
      startIndex = order2[0].side(false, dir);
      spanI = 0;
    }
  } else if (startIndex == line2.length) {
    if (forward)
      return null;
    let last = order2[order2.length - 1];
    if (last.level != dir) {
      startIndex = last.side(true, dir);
      spanI = order2.length - 1;
    }
  }
  if (spanI < 0)
    spanI = BidiSpan.find(order2, startIndex, (_a2 = start2.bidiLevel) !== null && _a2 !== void 0 ? _a2 : -1, start2.assoc);
  let span = order2[spanI];
  if (startIndex == span.side(forward, dir)) {
    span = order2[spanI += forward ? 1 : -1];
    startIndex = span.side(!forward, dir);
  }
  let indexForward = forward == (span.dir == dir);
  let nextIndex = findClusterBreak(line2.text, startIndex, indexForward);
  movedOver = line2.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
  if (nextIndex != span.side(forward, dir))
    return EditorSelection.cursor(nextIndex + line2.from, indexForward ? -1 : 1, span.level);
  let nextSpan = spanI == (forward ? order2.length - 1 : 0) ? null : order2[spanI + (forward ? 1 : -1)];
  if (!nextSpan && span.level != dir)
    return EditorSelection.cursor(forward ? line2.to : line2.from, forward ? -1 : 1, dir);
  if (nextSpan && nextSpan.level < span.level)
    return EditorSelection.cursor(nextSpan.side(!forward, dir) + line2.from, forward ? 1 : -1, nextSpan.level);
  return EditorSelection.cursor(nextIndex + line2.from, forward ? -1 : 1, span.level);
}
const LineBreakPlaceholder = "\uFFFF";
class DOMReader {
  constructor(points, state) {
    this.points = points;
    this.text = "";
    this.lineSeparator = state.facet(EditorState.lineSeparator);
  }
  append(text2) {
    this.text += text2;
  }
  lineBreak() {
    this.text += LineBreakPlaceholder;
  }
  readRange(start2, end2) {
    if (!start2)
      return this;
    let parent = start2.parentNode;
    for (let cur2 = start2; ; ) {
      this.findPointBefore(parent, cur2);
      this.readNode(cur2);
      let next2 = cur2.nextSibling;
      if (next2 == end2)
        break;
      let view = ContentView.get(cur2), nextView = ContentView.get(next2);
      if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur2)) || isBlockElement(next2) && (cur2.nodeName != "BR" || cur2.cmIgnore))
        this.lineBreak();
      cur2 = next2;
    }
    this.findPointBefore(parent, end2);
    return this;
  }
  readTextNode(node2) {
    let text2 = node2.nodeValue;
    for (let point2 of this.points)
      if (point2.node == node2)
        point2.pos = this.text.length + Math.min(point2.offset, text2.length);
    for (let off = 0, re2 = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let nextBreak = -1, breakSize = 1, m;
      if (this.lineSeparator) {
        nextBreak = text2.indexOf(this.lineSeparator, off);
        breakSize = this.lineSeparator.length;
      } else if (m = re2.exec(text2)) {
        nextBreak = m.index;
        breakSize = m[0].length;
      }
      this.append(text2.slice(off, nextBreak < 0 ? text2.length : nextBreak));
      if (nextBreak < 0)
        break;
      this.lineBreak();
      if (breakSize > 1) {
        for (let point2 of this.points)
          if (point2.node == node2 && point2.pos > this.text.length)
            point2.pos -= breakSize - 1;
      }
      off = nextBreak + breakSize;
    }
  }
  readNode(node2) {
    if (node2.cmIgnore)
      return;
    let view = ContentView.get(node2);
    let fromView = view && view.overrideDOMText;
    if (fromView != null) {
      this.findPointInside(node2, fromView.length);
      for (let i = fromView.iter(); !i.next().done; ) {
        if (i.lineBreak)
          this.lineBreak();
        else
          this.append(i.value);
      }
    } else if (node2.nodeType == 3) {
      this.readTextNode(node2);
    } else if (node2.nodeName == "BR") {
      if (node2.nextSibling)
        this.lineBreak();
    } else if (node2.nodeType == 1) {
      this.readRange(node2.firstChild, null);
    }
  }
  findPointBefore(node2, next2) {
    for (let point2 of this.points)
      if (point2.node == node2 && node2.childNodes[point2.offset] == next2)
        point2.pos = this.text.length;
  }
  findPointInside(node2, maxLen) {
    for (let point2 of this.points)
      if (node2.nodeType == 3 ? point2.node == node2 : node2.contains(point2.node))
        point2.pos = this.text.length + Math.min(maxLen, point2.offset);
  }
}
function isBlockElement(node2) {
  return node2.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node2.nodeName);
}
class DOMPoint {
  constructor(node2, offset) {
    this.node = node2;
    this.offset = offset;
    this.pos = -1;
  }
}
class DocView extends ContentView {
  constructor(view) {
    super();
    this.view = view;
    this.compositionDeco = Decoration.none;
    this.decorations = [];
    this.dynamicDecorationMap = [];
    this.minWidth = 0;
    this.minWidthFrom = 0;
    this.minWidthTo = 0;
    this.impreciseAnchor = null;
    this.impreciseHead = null;
    this.forceSelection = false;
    this.lastUpdate = Date.now();
    this.setDOM(view.contentDOM);
    this.children = [new LineView()];
    this.children[0].setParent(this);
    this.updateDeco();
    this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0);
  }
  get editorView() {
    return this.view;
  }
  get length() {
    return this.view.state.doc.length;
  }
  update(update) {
    let changedRanges = update.changedRanges;
    if (this.minWidth > 0 && changedRanges.length) {
      if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
        this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
      } else {
        this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
        this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
      }
    }
    if (this.view.inputState.composing < 0)
      this.compositionDeco = Decoration.none;
    else if (update.transactions.length || this.dirty)
      this.compositionDeco = computeCompositionDeco(this.view, update.changes);
    if ((browser.ie || browser.chrome) && !this.compositionDeco.size && update && update.state.doc.lines != update.startState.doc.lines)
      this.forceSelection = true;
    let prevDeco = this.decorations, deco = this.updateDeco();
    let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
    changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
    if (this.dirty == 0 && changedRanges.length == 0) {
      return false;
    } else {
      this.updateInner(changedRanges, update.startState.doc.length);
      if (update.transactions.length)
        this.lastUpdate = Date.now();
      return true;
    }
  }
  updateInner(changes, oldLength) {
    this.view.viewState.mustMeasureContent = true;
    this.updateChildren(changes, oldLength);
    let { observer } = this.view;
    observer.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight + "px";
      this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : void 0;
      this.sync(track);
      this.dirty = 0;
      if (track && (track.written || observer.selectionRange.focusNode != track.node))
        this.forceSelection = true;
      this.dom.style.height = "";
    });
    let gaps = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
      for (let child of this.children)
        if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
          gaps.push(child.dom);
    }
    observer.updateGaps(gaps);
  }
  updateChildren(changes, oldLength) {
    let cursor = this.childCursor(oldLength);
    for (let i = changes.length - 1; ; i--) {
      let next2 = i >= 0 ? changes[i] : null;
      if (!next2)
        break;
      let { fromA, toA, fromB, toB } = next2;
      let { content: content2, breakAtStart, openStart, openEnd } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap);
      let { i: toI, off: toOff } = cursor.findPos(toA, 1);
      let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);
      replaceRange(this, fromI, fromOff, toI, toOff, content2, breakAtStart, openStart, openEnd);
    }
  }
  updateSelection(mustRead = false, fromPointer = false) {
    if (mustRead || !this.view.observer.selectionRange.focusNode)
      this.view.observer.readSelectionRange();
    if (!(fromPointer || this.mayControlSelection()))
      return;
    let force = this.forceSelection;
    this.forceSelection = false;
    let main2 = this.view.state.selection.main;
    let anchor = this.domAtPos(main2.anchor);
    let head2 = main2.empty ? anchor : this.domAtPos(main2.head);
    if (browser.gecko && main2.empty && betweenUneditable(anchor)) {
      let dummy = document.createTextNode("");
      this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
      anchor = head2 = new DOMPos(dummy, 0);
      force = true;
    }
    let domSel = this.view.observer.selectionRange;
    if (force || !domSel.focusNode || !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head2.node, head2.offset, domSel.focusNode, domSel.focusOffset)) {
      this.view.observer.ignore(() => {
        if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {
          this.dom.blur();
          this.dom.focus({ preventScroll: true });
        }
        let rawSel = getSelection(this.view.root);
        if (!rawSel)
          ;
        else if (main2.empty) {
          if (browser.gecko) {
            let nextTo = nextToUneditable(anchor.node, anchor.offset);
            if (nextTo && nextTo != (1 | 2)) {
              let text2 = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 ? 1 : -1);
              if (text2)
                anchor = new DOMPos(text2, nextTo == 1 ? 0 : text2.nodeValue.length);
            }
          }
          rawSel.collapse(anchor.node, anchor.offset);
          if (main2.bidiLevel != null && domSel.cursorBidiLevel != null)
            domSel.cursorBidiLevel = main2.bidiLevel;
        } else if (rawSel.extend) {
          rawSel.collapse(anchor.node, anchor.offset);
          try {
            rawSel.extend(head2.node, head2.offset);
          } catch (_2) {
          }
        } else {
          let range2 = document.createRange();
          if (main2.anchor > main2.head)
            [anchor, head2] = [head2, anchor];
          range2.setEnd(head2.node, head2.offset);
          range2.setStart(anchor.node, anchor.offset);
          rawSel.removeAllRanges();
          rawSel.addRange(range2);
        }
      });
      this.view.observer.setSelectionRange(anchor, head2);
    }
    this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
    this.impreciseHead = head2.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
  }
  enforceCursorAssoc() {
    if (this.compositionDeco.size)
      return;
    let cursor = this.view.state.selection.main;
    let sel = getSelection(this.view.root);
    if (!sel || !cursor.empty || !cursor.assoc || !sel.modify)
      return;
    let line2 = LineView.find(this, cursor.head);
    if (!line2)
      return;
    let lineStart = line2.posAtStart;
    if (cursor.head == lineStart || cursor.head == lineStart + line2.length)
      return;
    let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);
    if (!before || !after || before.bottom > after.top)
      return;
    let dom = this.domAtPos(cursor.head + cursor.assoc);
    sel.collapse(dom.node, dom.offset);
    sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
  }
  mayControlSelection() {
    let active2 = this.view.root.activeElement;
    return active2 == this.dom || hasSelection(this.dom, this.view.observer.selectionRange) && !(active2 && this.dom.contains(active2));
  }
  nearest(dom) {
    for (let cur2 = dom; cur2; ) {
      let domView = ContentView.get(cur2);
      if (domView && domView.rootView == this)
        return domView;
      cur2 = cur2.parentNode;
    }
    return null;
  }
  posFromDOM(node2, offset) {
    let view = this.nearest(node2);
    if (!view)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return view.localPosFromDOM(node2, offset) + view.posAtStart;
  }
  domAtPos(pos) {
    let { i, off } = this.childCursor().findPos(pos, -1);
    for (; i < this.children.length - 1; ) {
      let child = this.children[i];
      if (off < child.length || child instanceof LineView)
        break;
      i++;
      off = 0;
    }
    return this.children[i].domAtPos(off);
  }
  coordsAt(pos, side) {
    for (let off = this.length, i = this.children.length - 1; ; i--) {
      let child = this.children[i], start2 = off - child.breakAfter - child.length;
      if (pos > start2 || pos == start2 && child.type != BlockType.WidgetBefore && child.type != BlockType.WidgetAfter && (!i || side == 2 || this.children[i - 1].breakAfter || this.children[i - 1].type == BlockType.WidgetBefore && side > -2))
        return child.coordsAt(pos - start2, side);
      off = start2;
    }
  }
  measureVisibleLineHeights(viewport) {
    let result = [], { from: from2, to: to2 } = viewport;
    let contentWidth = this.view.contentDOM.clientWidth;
    let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
    let widest = -1, ltr = this.view.textDirection == Direction.LTR;
    for (let pos = 0, i = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = pos + child.length;
      if (end2 > to2)
        break;
      if (pos >= from2) {
        let childRect = child.dom.getBoundingClientRect();
        result.push(childRect.height);
        if (isWider) {
          let last = child.dom.lastChild;
          let rects = last ? clientRectsFor(last) : [];
          if (rects.length) {
            let rect2 = rects[rects.length - 1];
            let width2 = ltr ? rect2.right - childRect.left : childRect.right - rect2.left;
            if (width2 > widest) {
              widest = width2;
              this.minWidth = contentWidth;
              this.minWidthFrom = pos;
              this.minWidthTo = end2;
            }
          }
        }
      }
      pos = end2 + child.breakAfter;
    }
    return result;
  }
  textDirectionAt(pos) {
    let { i } = this.childPos(pos, 1);
    return getComputedStyle(this.children[i].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
  }
  measureTextSize() {
    for (let child of this.children) {
      if (child instanceof LineView) {
        let measure = child.measureTextSize();
        if (measure)
          return measure;
      }
    }
    let dummy = document.createElement("div"), lineHeight, charWidth;
    dummy.className = "cm-line";
    dummy.style.width = "99999px";
    dummy.textContent = "abc def ghi jkl mno pqr stu";
    this.view.observer.ignore(() => {
      this.dom.appendChild(dummy);
      let rect2 = clientRectsFor(dummy.firstChild)[0];
      lineHeight = dummy.getBoundingClientRect().height;
      charWidth = rect2 ? rect2.width / 27 : 7;
      dummy.remove();
    });
    return { lineHeight, charWidth };
  }
  childCursor(pos = this.length) {
    let i = this.children.length;
    if (i)
      pos -= this.children[--i].length;
    return new ChildCursor(this.children, pos, i);
  }
  computeBlockGapDeco() {
    let deco = [], vs = this.view.viewState;
    for (let pos = 0, i = 0; ; i++) {
      let next2 = i == vs.viewports.length ? null : vs.viewports[i];
      let end2 = next2 ? next2.from - 1 : this.length;
      if (end2 > pos) {
        let height2 = vs.lineBlockAt(end2).bottom - vs.lineBlockAt(pos).top;
        deco.push(Decoration.replace({
          widget: new BlockGapWidget(height2),
          block: true,
          inclusive: true,
          isBlockGap: true
        }).range(pos, end2));
      }
      if (!next2)
        break;
      pos = next2.to + 1;
    }
    return Decoration.set(deco);
  }
  updateDeco() {
    let allDeco = this.view.state.facet(decorations).map((d, i) => {
      let dynamic = this.dynamicDecorationMap[i] = typeof d == "function";
      return dynamic ? d(this.view) : d;
    });
    for (let i = allDeco.length; i < allDeco.length + 3; i++)
      this.dynamicDecorationMap[i] = false;
    return this.decorations = [
      ...allDeco,
      this.compositionDeco,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
  }
  scrollIntoView(target) {
    let { range: range2 } = target;
    let rect2 = this.coordsAt(range2.head, range2.empty ? range2.assoc : range2.head > range2.anchor ? -1 : 1), other;
    if (!rect2)
      return;
    if (!range2.empty && (other = this.coordsAt(range2.anchor, range2.anchor > range2.head ? -1 : 1)))
      rect2 = {
        left: Math.min(rect2.left, other.left),
        top: Math.min(rect2.top, other.top),
        right: Math.max(rect2.right, other.right),
        bottom: Math.max(rect2.bottom, other.bottom)
      };
    let mLeft = 0, mRight = 0, mTop = 0, mBottom = 0;
    for (let margins of this.view.state.facet(scrollMargins).map((f2) => f2(this.view)))
      if (margins) {
        let { left: left2, right: right2, top: top2, bottom: bottom2 } = margins;
        if (left2 != null)
          mLeft = Math.max(mLeft, left2);
        if (right2 != null)
          mRight = Math.max(mRight, right2);
        if (top2 != null)
          mTop = Math.max(mTop, top2);
        if (bottom2 != null)
          mBottom = Math.max(mBottom, bottom2);
      }
    let targetRect = {
      left: rect2.left - mLeft,
      top: rect2.top - mTop,
      right: rect2.right + mRight,
      bottom: rect2.bottom + mBottom
    };
    scrollRectIntoView(this.view.scrollDOM, targetRect, range2.head < range2.anchor ? -1 : 1, target.x, target.y, target.xMargin, target.yMargin, this.view.textDirection == Direction.LTR);
  }
}
function betweenUneditable(pos) {
  return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
}
class BlockGapWidget extends WidgetType {
  constructor(height2) {
    super();
    this.height = height2;
  }
  toDOM() {
    let elt2 = document.createElement("div");
    this.updateDOM(elt2);
    return elt2;
  }
  eq(other) {
    return other.height == this.height;
  }
  updateDOM(elt2) {
    elt2.style.height = this.height + "px";
    return true;
  }
  get estimatedHeight() {
    return this.height;
  }
}
function compositionSurroundingNode(view) {
  let sel = view.observer.selectionRange;
  let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);
  if (!textNode)
    return null;
  let cView = view.docView.nearest(textNode);
  if (!cView)
    return null;
  if (cView instanceof LineView) {
    let topNode = textNode;
    while (topNode.parentNode != cView.dom)
      topNode = topNode.parentNode;
    let prev2 = topNode.previousSibling;
    while (prev2 && !ContentView.get(prev2))
      prev2 = prev2.previousSibling;
    let pos = prev2 ? ContentView.get(prev2).posAtEnd : cView.posAtStart;
    return { from: pos, to: pos, node: topNode, text: textNode };
  } else {
    for (; ; ) {
      let { parent } = cView;
      if (!parent)
        return null;
      if (parent instanceof LineView)
        break;
      cView = parent;
    }
    let from2 = cView.posAtStart;
    return { from: from2, to: from2 + cView.length, node: cView.dom, text: textNode };
  }
}
function computeCompositionDeco(view, changes) {
  let surrounding = compositionSurroundingNode(view);
  if (!surrounding)
    return Decoration.none;
  let { from: from2, to: to2, node: node2, text: textNode } = surrounding;
  let newFrom = changes.mapPos(from2, 1), newTo = Math.max(newFrom, changes.mapPos(to2, -1));
  let { state } = view, text2 = node2.nodeType == 3 ? node2.nodeValue : new DOMReader([], state).readRange(node2.firstChild, null).text;
  if (newTo - newFrom < text2.length) {
    if (state.doc.sliceString(newFrom, Math.min(state.doc.length, newFrom + text2.length), LineBreakPlaceholder) == text2)
      newTo = newFrom + text2.length;
    else if (state.doc.sliceString(Math.max(0, newTo - text2.length), newTo, LineBreakPlaceholder) == text2)
      newFrom = newTo - text2.length;
    else
      return Decoration.none;
  } else if (state.doc.sliceString(newFrom, newTo, LineBreakPlaceholder) != text2) {
    return Decoration.none;
  }
  let topView = ContentView.get(node2);
  if (topView instanceof CompositionView)
    topView = topView.widget.topView;
  else if (topView)
    topView.parent = null;
  return Decoration.set(Decoration.replace({ widget: new CompositionWidget(node2, textNode, topView), inclusive: true }).range(newFrom, newTo));
}
class CompositionWidget extends WidgetType {
  constructor(top2, text2, topView) {
    super();
    this.top = top2;
    this.text = text2;
    this.topView = topView;
  }
  eq(other) {
    return this.top == other.top && this.text == other.text;
  }
  toDOM() {
    return this.top;
  }
  ignoreEvent() {
    return false;
  }
  get customView() {
    return CompositionView;
  }
}
function nearbyTextNode(node2, offset, side) {
  for (; ; ) {
    if (node2.nodeType == 3)
      return node2;
    if (node2.nodeType == 1 && offset > 0 && side <= 0) {
      node2 = node2.childNodes[offset - 1];
      offset = maxOffset(node2);
    } else if (node2.nodeType == 1 && offset < node2.childNodes.length && side >= 0) {
      node2 = node2.childNodes[offset];
      offset = 0;
    } else {
      return null;
    }
  }
}
function nextToUneditable(node2, offset) {
  if (node2.nodeType != 1)
    return 0;
  return (offset && node2.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node2.childNodes.length && node2.childNodes[offset].contentEditable == "false" ? 2 : 0);
}
class DecorationComparator$1 {
  constructor() {
    this.changes = [];
  }
  compareRange(from2, to2) {
    addRange(from2, to2, this.changes);
  }
  comparePoint(from2, to2) {
    addRange(from2, to2, this.changes);
  }
}
function findChangedDeco(a2, b, diff) {
  let comp = new DecorationComparator$1();
  RangeSet.compare(a2, b, diff, comp);
  return comp.changes;
}
function inUneditable(node2, inside2) {
  for (let cur2 = node2; cur2 && cur2 != inside2; cur2 = cur2.assignedSlot || cur2.parentNode) {
    if (cur2.nodeType == 1 && cur2.contentEditable == "false") {
      return true;
    }
  }
  return false;
}
function groupAt(state, pos, bias = 1) {
  let categorize = state.charCategorizer(pos);
  let line2 = state.doc.lineAt(pos), linePos = pos - line2.from;
  if (line2.length == 0)
    return EditorSelection.cursor(pos);
  if (linePos == 0)
    bias = 1;
  else if (linePos == line2.length)
    bias = -1;
  let from2 = linePos, to2 = linePos;
  if (bias < 0)
    from2 = findClusterBreak(line2.text, linePos, false);
  else
    to2 = findClusterBreak(line2.text, linePos);
  let cat = categorize(line2.text.slice(from2, to2));
  while (from2 > 0) {
    let prev2 = findClusterBreak(line2.text, from2, false);
    if (categorize(line2.text.slice(prev2, from2)) != cat)
      break;
    from2 = prev2;
  }
  while (to2 < line2.length) {
    let next2 = findClusterBreak(line2.text, to2);
    if (categorize(line2.text.slice(to2, next2)) != cat)
      break;
    to2 = next2;
  }
  return EditorSelection.range(from2 + line2.from, to2 + line2.from);
}
function getdx(x2, rect2) {
  return rect2.left > x2 ? rect2.left - x2 : Math.max(0, x2 - rect2.right);
}
function getdy(y2, rect2) {
  return rect2.top > y2 ? rect2.top - y2 : Math.max(0, y2 - rect2.bottom);
}
function yOverlap(a2, b) {
  return a2.top < b.bottom - 1 && a2.bottom > b.top + 1;
}
function upTop(rect2, top2) {
  return top2 < rect2.top ? { top: top2, left: rect2.left, right: rect2.right, bottom: rect2.bottom } : rect2;
}
function upBot(rect2, bottom2) {
  return bottom2 > rect2.bottom ? { top: rect2.top, left: rect2.left, right: rect2.right, bottom: bottom2 } : rect2;
}
function domPosAtCoords(parent, x2, y2) {
  let closest, closestRect, closestX, closestY, closestOverlap = false;
  let above, below, aboveRect, belowRect;
  for (let child = parent.firstChild; child; child = child.nextSibling) {
    let rects = clientRectsFor(child);
    for (let i = 0; i < rects.length; i++) {
      let rect2 = rects[i];
      if (closestRect && yOverlap(closestRect, rect2))
        rect2 = upTop(upBot(rect2, closestRect.bottom), closestRect.top);
      let dx = getdx(x2, rect2), dy = getdy(y2, rect2);
      if (dx == 0 && dy == 0)
        return child.nodeType == 3 ? domPosInText(child, x2, y2) : domPosAtCoords(child, x2, y2);
      if (!closest || closestY > dy || closestY == dy && closestX > dx) {
        closest = child;
        closestRect = rect2;
        closestX = dx;
        closestY = dy;
        closestOverlap = !dx || (dx > 0 ? i < rects.length - 1 : i > 0);
      }
      if (dx == 0) {
        if (y2 > rect2.bottom && (!aboveRect || aboveRect.bottom < rect2.bottom)) {
          above = child;
          aboveRect = rect2;
        } else if (y2 < rect2.top && (!belowRect || belowRect.top > rect2.top)) {
          below = child;
          belowRect = rect2;
        }
      } else if (aboveRect && yOverlap(aboveRect, rect2)) {
        aboveRect = upBot(aboveRect, rect2.bottom);
      } else if (belowRect && yOverlap(belowRect, rect2)) {
        belowRect = upTop(belowRect, rect2.top);
      }
    }
  }
  if (aboveRect && aboveRect.bottom >= y2) {
    closest = above;
    closestRect = aboveRect;
  } else if (belowRect && belowRect.top <= y2) {
    closest = below;
    closestRect = belowRect;
  }
  if (!closest)
    return { node: parent, offset: 0 };
  let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x2));
  if (closest.nodeType == 3)
    return domPosInText(closest, clipX, y2);
  if (closestOverlap && closest.contentEditable != "false")
    return domPosAtCoords(closest, clipX, y2);
  let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x2 >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
  return { node: parent, offset };
}
function domPosInText(node2, x2, y2) {
  let len = node2.nodeValue.length;
  let closestOffset = -1, closestDY = 1e9, generalSide = 0;
  for (let i = 0; i < len; i++) {
    let rects = textRange(node2, i, i + 1).getClientRects();
    for (let j2 = 0; j2 < rects.length; j2++) {
      let rect2 = rects[j2];
      if (rect2.top == rect2.bottom)
        continue;
      if (!generalSide)
        generalSide = x2 - rect2.left;
      let dy = (rect2.top > y2 ? rect2.top - y2 : y2 - rect2.bottom) - 1;
      if (rect2.left - 1 <= x2 && rect2.right + 1 >= x2 && dy < closestDY) {
        let right2 = x2 >= (rect2.left + rect2.right) / 2, after = right2;
        if (browser.chrome || browser.gecko) {
          let rectBefore = textRange(node2, i).getBoundingClientRect();
          if (rectBefore.left == rect2.right)
            after = !right2;
        }
        if (dy <= 0)
          return { node: node2, offset: i + (after ? 1 : 0) };
        closestOffset = i + (after ? 1 : 0);
        closestDY = dy;
      }
    }
  }
  return { node: node2, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node2.nodeValue.length : 0 };
}
function posAtCoords(view, { x: x2, y: y2 }, precise, bias = -1) {
  var _a2;
  let content2 = view.contentDOM.getBoundingClientRect(), docTop = content2.top + view.viewState.paddingTop;
  let block, { docHeight } = view.viewState;
  let yOffset = y2 - docTop;
  if (yOffset < 0)
    return 0;
  if (yOffset > docHeight)
    return view.state.doc.length;
  for (let halfLine = view.defaultLineHeight / 2, bounced = false; ; ) {
    block = view.elementAtHeight(yOffset);
    if (block.type == BlockType.Text)
      break;
    for (; ; ) {
      yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
      if (yOffset >= 0 && yOffset <= docHeight)
        break;
      if (bounced)
        return precise ? null : 0;
      bounced = true;
      bias = -bias;
    }
  }
  y2 = docTop + yOffset;
  let lineStart = block.from;
  if (lineStart < view.viewport.from)
    return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content2, block, x2, y2);
  if (lineStart > view.viewport.to)
    return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content2, block, x2, y2);
  let doc2 = view.dom.ownerDocument;
  let root2 = view.root.elementFromPoint ? view.root : doc2;
  let element = root2.elementFromPoint(x2, y2);
  if (element && !view.contentDOM.contains(element))
    element = null;
  if (!element) {
    x2 = Math.max(content2.left + 1, Math.min(content2.right - 1, x2));
    element = root2.elementFromPoint(x2, y2);
    if (element && !view.contentDOM.contains(element))
      element = null;
  }
  let node2, offset = -1;
  if (element && ((_a2 = view.docView.nearest(element)) === null || _a2 === void 0 ? void 0 : _a2.isEditable) != false) {
    if (doc2.caretPositionFromPoint) {
      let pos = doc2.caretPositionFromPoint(x2, y2);
      if (pos)
        ({ offsetNode: node2, offset } = pos);
    } else if (doc2.caretRangeFromPoint) {
      let range2 = doc2.caretRangeFromPoint(x2, y2);
      if (range2) {
        ({ startContainer: node2, startOffset: offset } = range2);
        if (!view.contentDOM.contains(node2) || browser.safari && isSuspiciousSafariCaretResult(node2, offset, x2) || browser.chrome && isSuspiciousChromeCaretResult(node2, offset, x2))
          node2 = void 0;
      }
    }
  }
  if (!node2 || !view.docView.dom.contains(node2)) {
    let line2 = LineView.find(view.docView, lineStart);
    if (!line2)
      return yOffset > block.top + block.height / 2 ? block.to : block.from;
    ({ node: node2, offset } = domPosAtCoords(line2.dom, x2, y2));
  }
  return view.docView.posFromDOM(node2, offset);
}
function posAtCoordsImprecise(view, contentRect, block, x2, y2) {
  let into = Math.round((x2 - contentRect.left) * view.defaultCharacterWidth);
  if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
    let line2 = Math.floor((y2 - block.top) / view.defaultLineHeight);
    into += line2 * view.viewState.heightOracle.lineLength;
  }
  let content2 = view.state.sliceDoc(block.from, block.to);
  return block.from + findColumn(content2, into, view.state.tabSize);
}
function isSuspiciousSafariCaretResult(node2, offset, x2) {
  let len;
  if (node2.nodeType != 3 || offset != (len = node2.nodeValue.length))
    return false;
  for (let next2 = node2.nextSibling; next2; next2 = next2.nextSibling)
    if (next2.nodeType != 1 || next2.nodeName != "BR")
      return false;
  return textRange(node2, len - 1, len).getBoundingClientRect().left > x2;
}
function isSuspiciousChromeCaretResult(node2, offset, x2) {
  if (offset != 0)
    return false;
  for (let cur2 = node2; ; ) {
    let parent = cur2.parentNode;
    if (!parent || parent.nodeType != 1 || parent.firstChild != cur2)
      return false;
    if (parent.classList.contains("cm-line"))
      break;
    cur2 = parent;
  }
  let rect2 = node2.nodeType == 1 ? node2.getBoundingClientRect() : textRange(node2, 0, Math.max(node2.nodeValue.length, 1)).getBoundingClientRect();
  return x2 - rect2.left > 5;
}
function moveToLineBoundary(view, start2, forward, includeWrap) {
  let line2 = view.state.doc.lineAt(start2.head);
  let coords = !includeWrap || !view.lineWrapping ? null : view.coordsAtPos(start2.assoc < 0 && start2.head > line2.from ? start2.head - 1 : start2.head);
  if (coords) {
    let editorRect = view.dom.getBoundingClientRect();
    let direction2 = view.textDirectionAt(line2.from);
    let pos = view.posAtCoords({
      x: forward == (direction2 == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
      y: (coords.top + coords.bottom) / 2
    });
    if (pos != null)
      return EditorSelection.cursor(pos, forward ? -1 : 1);
  }
  let lineView = LineView.find(view.docView, start2.head);
  let end2 = lineView ? forward ? lineView.posAtEnd : lineView.posAtStart : forward ? line2.to : line2.from;
  return EditorSelection.cursor(end2, forward ? -1 : 1);
}
function moveByChar(view, start2, forward, by) {
  let line2 = view.state.doc.lineAt(start2.head), spans = view.bidiSpans(line2);
  let direction2 = view.textDirectionAt(line2.from);
  for (let cur2 = start2, check = null; ; ) {
    let next2 = moveVisually(line2, spans, direction2, cur2, forward), char2 = movedOver;
    if (!next2) {
      if (line2.number == (forward ? view.state.doc.lines : 1))
        return cur2;
      char2 = "\n";
      line2 = view.state.doc.line(line2.number + (forward ? 1 : -1));
      spans = view.bidiSpans(line2);
      next2 = EditorSelection.cursor(forward ? line2.from : line2.to);
    }
    if (!check) {
      if (!by)
        return next2;
      check = by(char2);
    } else if (!check(char2)) {
      return cur2;
    }
    cur2 = next2;
  }
}
function byGroup(view, pos, start2) {
  let categorize = view.state.charCategorizer(pos);
  let cat = categorize(start2);
  return (next2) => {
    let nextCat = categorize(next2);
    if (cat == CharCategory.Space)
      cat = nextCat;
    return cat == nextCat;
  };
}
function moveVertically(view, start2, forward, distance2) {
  let startPos = start2.head, dir = forward ? 1 : -1;
  if (startPos == (forward ? view.state.doc.length : 0))
    return EditorSelection.cursor(startPos, start2.assoc);
  let goal = start2.goalColumn, startY;
  let rect2 = view.contentDOM.getBoundingClientRect();
  let startCoords = view.coordsAtPos(startPos), docTop = view.documentTop;
  if (startCoords) {
    if (goal == null)
      goal = startCoords.left - rect2.left;
    startY = dir < 0 ? startCoords.top : startCoords.bottom;
  } else {
    let line2 = view.viewState.lineBlockAt(startPos);
    if (goal == null)
      goal = Math.min(rect2.right - rect2.left, view.defaultCharacterWidth * (startPos - line2.from));
    startY = (dir < 0 ? line2.top : line2.bottom) + docTop;
  }
  let resolvedGoal = rect2.left + goal;
  let dist2 = distance2 !== null && distance2 !== void 0 ? distance2 : view.defaultLineHeight >> 1;
  for (let extra = 0; ; extra += 10) {
    let curY = startY + (dist2 + extra) * dir;
    let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);
    if (curY < rect2.top || curY > rect2.bottom || (dir < 0 ? pos < startPos : pos > startPos))
      return EditorSelection.cursor(pos, start2.assoc, void 0, goal);
  }
}
function skipAtoms(view, oldPos, pos) {
  let atoms = view.state.facet(atomicRanges).map((f2) => f2(view));
  for (; ; ) {
    let moved = false;
    for (let set2 of atoms) {
      set2.between(pos.from - 1, pos.from + 1, (from2, to2, value) => {
        if (pos.from > from2 && pos.from < to2) {
          pos = oldPos.head > pos.from ? EditorSelection.cursor(from2, 1) : EditorSelection.cursor(to2, -1);
          moved = true;
        }
      });
    }
    if (!moved)
      return pos;
  }
}
class InputState {
  constructor(view) {
    this.lastKeyCode = 0;
    this.lastKeyTime = 0;
    this.lastTouchTime = 0;
    this.lastFocusTime = 0;
    this.lastScrollTop = 0;
    this.lastScrollLeft = 0;
    this.chromeScrollHack = -1;
    this.pendingIOSKey = void 0;
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastEscPress = 0;
    this.lastContextMenu = 0;
    this.scrollHandlers = [];
    this.registeredEvents = [];
    this.customHandlers = [];
    this.composing = -1;
    this.compositionFirstChange = null;
    this.compositionEndedAt = 0;
    this.mouseSelection = null;
    for (let type2 in handlers) {
      let handler = handlers[type2];
      view.contentDOM.addEventListener(type2, (event2) => {
        if (!eventBelongsToEditor(view, event2) || this.ignoreDuringComposition(event2))
          return;
        if (type2 == "keydown" && this.keydown(view, event2))
          return;
        if (this.mustFlushObserver(event2))
          view.observer.forceFlush();
        if (this.runCustomHandlers(type2, view, event2))
          event2.preventDefault();
        else
          handler(view, event2);
      }, handlerOptions[type2]);
      this.registeredEvents.push(type2);
    }
    if (browser.chrome && browser.chrome_version == 102) {
      view.scrollDOM.addEventListener("wheel", () => {
        if (this.chromeScrollHack < 0)
          view.contentDOM.style.pointerEvents = "none";
        else
          window.clearTimeout(this.chromeScrollHack);
        this.chromeScrollHack = setTimeout(() => {
          this.chromeScrollHack = -1;
          view.contentDOM.style.pointerEvents = "";
        }, 100);
      }, { passive: true });
    }
    this.notifiedFocused = view.hasFocus;
    if (browser.safari)
      view.contentDOM.addEventListener("input", () => null);
  }
  setSelectionOrigin(origin) {
    this.lastSelectionOrigin = origin;
    this.lastSelectionTime = Date.now();
  }
  ensureHandlers(view, plugins2) {
    var _a2;
    let handlers2;
    this.customHandlers = [];
    for (let plugin of plugins2)
      if (handlers2 = (_a2 = plugin.update(view).spec) === null || _a2 === void 0 ? void 0 : _a2.domEventHandlers) {
        this.customHandlers.push({ plugin: plugin.value, handlers: handlers2 });
        for (let type2 in handlers2)
          if (this.registeredEvents.indexOf(type2) < 0 && type2 != "scroll") {
            this.registeredEvents.push(type2);
            view.contentDOM.addEventListener(type2, (event2) => {
              if (!eventBelongsToEditor(view, event2))
                return;
              if (this.runCustomHandlers(type2, view, event2))
                event2.preventDefault();
            });
          }
      }
  }
  runCustomHandlers(type2, view, event2) {
    for (let set2 of this.customHandlers) {
      let handler = set2.handlers[type2];
      if (handler) {
        try {
          if (handler.call(set2.plugin, event2, view) || event2.defaultPrevented)
            return true;
        } catch (e) {
          logException(view.state, e);
        }
      }
    }
    return false;
  }
  runScrollHandlers(view, event2) {
    this.lastScrollTop = view.scrollDOM.scrollTop;
    this.lastScrollLeft = view.scrollDOM.scrollLeft;
    for (let set2 of this.customHandlers) {
      let handler = set2.handlers.scroll;
      if (handler) {
        try {
          handler.call(set2.plugin, event2, view);
        } catch (e) {
          logException(view.state, e);
        }
      }
    }
  }
  keydown(view, event2) {
    this.lastKeyCode = event2.keyCode;
    this.lastKeyTime = Date.now();
    if (event2.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
      return true;
    if (browser.android && browser.chrome && !event2.synthetic && (event2.keyCode == 13 || event2.keyCode == 8)) {
      view.observer.delayAndroidKey(event2.key, event2.keyCode);
      return true;
    }
    let pending;
    if (browser.ios && !event2.synthetic && !event2.altKey && !event2.metaKey && ((pending = PendingKeys.find((key) => key.keyCode == event2.keyCode)) && !event2.ctrlKey || EmacsyPendingKeys.indexOf(event2.key) > -1 && event2.ctrlKey && !event2.shiftKey)) {
      this.pendingIOSKey = pending || event2;
      setTimeout(() => this.flushIOSKey(view), 250);
      return true;
    }
    return false;
  }
  flushIOSKey(view) {
    let key = this.pendingIOSKey;
    if (!key)
      return false;
    this.pendingIOSKey = void 0;
    return dispatchKey(view.contentDOM, key.key, key.keyCode);
  }
  ignoreDuringComposition(event2) {
    if (!/^key/.test(event2.type))
      return false;
    if (this.composing > 0)
      return true;
    if (browser.safari && !browser.ios && Date.now() - this.compositionEndedAt < 100) {
      this.compositionEndedAt = 0;
      return true;
    }
    return false;
  }
  mustFlushObserver(event2) {
    return event2.type == "keydown" && event2.keyCode != 229;
  }
  startMouseSelection(mouseSelection) {
    if (this.mouseSelection)
      this.mouseSelection.destroy();
    this.mouseSelection = mouseSelection;
  }
  update(update) {
    if (this.mouseSelection)
      this.mouseSelection.update(update);
    if (update.transactions.length)
      this.lastKeyCode = this.lastSelectionTime = 0;
  }
  destroy() {
    if (this.mouseSelection)
      this.mouseSelection.destroy();
  }
}
const PendingKeys = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
];
const EmacsyPendingKeys = "dthko";
const modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
class MouseSelection {
  constructor(view, startEvent, style2, mustSelect) {
    this.view = view;
    this.style = style2;
    this.mustSelect = mustSelect;
    this.lastEvent = startEvent;
    let doc2 = view.contentDOM.ownerDocument;
    doc2.addEventListener("mousemove", this.move = this.move.bind(this));
    doc2.addEventListener("mouseup", this.up = this.up.bind(this));
    this.extend = startEvent.shiftKey;
    this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
    this.dragMove = dragMovesSelection(view, startEvent);
    this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
    if (this.dragging === false) {
      startEvent.preventDefault();
      this.select(startEvent);
    }
  }
  move(event2) {
    if (event2.buttons == 0)
      return this.destroy();
    if (this.dragging !== false)
      return;
    this.select(this.lastEvent = event2);
  }
  up(event2) {
    if (this.dragging == null)
      this.select(this.lastEvent);
    if (!this.dragging)
      event2.preventDefault();
    this.destroy();
  }
  destroy() {
    let doc2 = this.view.contentDOM.ownerDocument;
    doc2.removeEventListener("mousemove", this.move);
    doc2.removeEventListener("mouseup", this.up);
    this.view.inputState.mouseSelection = null;
  }
  select(event2) {
    let selection2 = this.style.get(event2, this.extend, this.multiple);
    if (this.mustSelect || !selection2.eq(this.view.state.selection) || selection2.main.assoc != this.view.state.selection.main.assoc)
      this.view.dispatch({
        selection: selection2,
        userEvent: "select.pointer",
        scrollIntoView: true
      });
    this.mustSelect = false;
  }
  update(update) {
    if (update.docChanged && this.dragging)
      this.dragging = this.dragging.map(update.changes);
    if (this.style.update(update))
      setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function addsSelectionRange(view, event2) {
  let facet = view.state.facet(clickAddsSelectionRange);
  return facet.length ? facet[0](event2) : browser.mac ? event2.metaKey : event2.ctrlKey;
}
function dragMovesSelection(view, event2) {
  let facet = view.state.facet(dragMovesSelection$1);
  return facet.length ? facet[0](event2) : browser.mac ? !event2.altKey : !event2.ctrlKey;
}
function isInPrimarySelection(view, event2) {
  let { main: main2 } = view.state.selection;
  if (main2.empty)
    return false;
  let sel = getSelection(view.root);
  if (!sel || sel.rangeCount == 0)
    return true;
  let rects = sel.getRangeAt(0).getClientRects();
  for (let i = 0; i < rects.length; i++) {
    let rect2 = rects[i];
    if (rect2.left <= event2.clientX && rect2.right >= event2.clientX && rect2.top <= event2.clientY && rect2.bottom >= event2.clientY)
      return true;
  }
  return false;
}
function eventBelongsToEditor(view, event2) {
  if (!event2.bubbles)
    return true;
  if (event2.defaultPrevented)
    return false;
  for (let node2 = event2.target, cView; node2 != view.contentDOM; node2 = node2.parentNode)
    if (!node2 || node2.nodeType == 11 || (cView = ContentView.get(node2)) && cView.ignoreEvent(event2))
      return false;
  return true;
}
const handlers = /* @__PURE__ */ Object.create(null);
const handlerOptions = /* @__PURE__ */ Object.create(null);
const brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
function capturePaste(view) {
  let parent = view.dom.parentNode;
  if (!parent)
    return;
  let target = parent.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(() => {
    view.focus();
    target.remove();
    doPaste(view, target.value);
  }, 50);
}
function doPaste(view, input) {
  let { state } = view, changes, i = 1, text2 = state.toText(input);
  let byLine = text2.lines == state.selection.ranges.length;
  let linewise = lastLinewiseCopy != null && state.selection.ranges.every((r) => r.empty) && lastLinewiseCopy == text2.toString();
  if (linewise) {
    let lastLine = -1;
    changes = state.changeByRange((range2) => {
      let line2 = state.doc.lineAt(range2.from);
      if (line2.from == lastLine)
        return { range: range2 };
      lastLine = line2.from;
      let insert2 = state.toText((byLine ? text2.line(i++).text : input) + state.lineBreak);
      return {
        changes: { from: line2.from, insert: insert2 },
        range: EditorSelection.cursor(range2.from + insert2.length)
      };
    });
  } else if (byLine) {
    changes = state.changeByRange((range2) => {
      let line2 = text2.line(i++);
      return {
        changes: { from: range2.from, to: range2.to, insert: line2.text },
        range: EditorSelection.cursor(range2.from + line2.length)
      };
    });
  } else {
    changes = state.replaceSelection(text2);
  }
  view.dispatch(changes, {
    userEvent: "input.paste",
    scrollIntoView: true
  });
}
handlers.keydown = (view, event2) => {
  view.inputState.setSelectionOrigin("select");
  if (event2.keyCode == 27)
    view.inputState.lastEscPress = Date.now();
  else if (modifierCodes.indexOf(event2.keyCode) < 0)
    view.inputState.lastEscPress = 0;
};
handlers.touchstart = (view, e) => {
  view.inputState.lastTouchTime = Date.now();
  view.inputState.setSelectionOrigin("select.pointer");
};
handlers.touchmove = (view) => {
  view.inputState.setSelectionOrigin("select.pointer");
};
handlerOptions.touchstart = handlerOptions.touchmove = { passive: true };
handlers.mousedown = (view, event2) => {
  view.observer.flush();
  if (view.inputState.lastTouchTime > Date.now() - 2e3)
    return;
  let style2 = null;
  for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
    style2 = makeStyle(view, event2);
    if (style2)
      break;
  }
  if (!style2 && event2.button == 0)
    style2 = basicMouseSelection(view, event2);
  if (style2) {
    let mustFocus = view.root.activeElement != view.contentDOM;
    if (mustFocus)
      view.observer.ignore(() => focusPreventScroll(view.contentDOM));
    view.inputState.startMouseSelection(new MouseSelection(view, event2, style2, mustFocus));
  }
};
function rangeForClick(view, pos, bias, type2) {
  if (type2 == 1) {
    return EditorSelection.cursor(pos, bias);
  } else if (type2 == 2) {
    return groupAt(view.state, pos, bias);
  } else {
    let visual = LineView.find(view.docView, pos), line2 = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
    let from2 = visual ? visual.posAtStart : line2.from, to2 = visual ? visual.posAtEnd : line2.to;
    if (to2 < view.state.doc.length && to2 == line2.to)
      to2++;
    return EditorSelection.range(from2, to2);
  }
}
let insideY = (y2, rect2) => y2 >= rect2.top && y2 <= rect2.bottom;
let inside = (x2, y2, rect2) => insideY(y2, rect2) && x2 >= rect2.left && x2 <= rect2.right;
function findPositionSide(view, pos, x2, y2) {
  let line2 = LineView.find(view.docView, pos);
  if (!line2)
    return 1;
  let off = pos - line2.posAtStart;
  if (off == 0)
    return 1;
  if (off == line2.length)
    return -1;
  let before = line2.coordsAt(off, -1);
  if (before && inside(x2, y2, before))
    return -1;
  let after = line2.coordsAt(off, 1);
  if (after && inside(x2, y2, after))
    return 1;
  return before && insideY(y2, before) ? -1 : 1;
}
function queryPos(view, event2) {
  let pos = view.posAtCoords({ x: event2.clientX, y: event2.clientY }, false);
  return { pos, bias: findPositionSide(view, pos, event2.clientX, event2.clientY) };
}
const BadMouseDetail = browser.ie && browser.ie_version <= 11;
let lastMouseDown = null, lastMouseDownCount = 0, lastMouseDownTime = 0;
function getClickType(event2) {
  if (!BadMouseDetail)
    return event2.detail;
  let last = lastMouseDown, lastTime = lastMouseDownTime;
  lastMouseDown = event2;
  lastMouseDownTime = Date.now();
  return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event2.clientX) < 2 && Math.abs(last.clientY - event2.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
}
function basicMouseSelection(view, event2) {
  let start2 = queryPos(view, event2), type2 = getClickType(event2);
  let startSel = view.state.selection;
  let last = start2, lastEvent = event2;
  return {
    update(update) {
      if (update.docChanged) {
        start2.pos = update.changes.mapPos(start2.pos);
        startSel = startSel.map(update.changes);
        lastEvent = null;
      }
    },
    get(event3, extend2, multiple) {
      let cur2;
      if (lastEvent && event3.clientX == lastEvent.clientX && event3.clientY == lastEvent.clientY)
        cur2 = last;
      else {
        cur2 = last = queryPos(view, event3);
        lastEvent = event3;
      }
      let range2 = rangeForClick(view, cur2.pos, cur2.bias, type2);
      if (start2.pos != cur2.pos && !extend2) {
        let startRange = rangeForClick(view, start2.pos, start2.bias, type2);
        let from2 = Math.min(startRange.from, range2.from), to2 = Math.max(startRange.to, range2.to);
        range2 = from2 < range2.from ? EditorSelection.range(from2, to2) : EditorSelection.range(to2, from2);
      }
      if (extend2)
        return startSel.replaceRange(startSel.main.extend(range2.from, range2.to));
      else if (multiple && startSel.ranges.length > 1 && startSel.ranges.some((r) => r.eq(range2)))
        return removeRange(startSel, range2);
      else if (multiple)
        return startSel.addRange(range2);
      else
        return EditorSelection.create([range2]);
    }
  };
}
function removeRange(sel, range2) {
  for (let i = 0; ; i++) {
    if (sel.ranges[i].eq(range2))
      return EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));
  }
}
handlers.dragstart = (view, event2) => {
  let { selection: { main: main2 } } = view.state;
  let { mouseSelection } = view.inputState;
  if (mouseSelection)
    mouseSelection.dragging = main2;
  if (event2.dataTransfer) {
    event2.dataTransfer.setData("Text", view.state.sliceDoc(main2.from, main2.to));
    event2.dataTransfer.effectAllowed = "copyMove";
  }
};
function dropText(view, event2, text2, direct) {
  if (!text2)
    return;
  let dropPos = view.posAtCoords({ x: event2.clientX, y: event2.clientY }, false);
  event2.preventDefault();
  let { mouseSelection } = view.inputState;
  let del = direct && mouseSelection && mouseSelection.dragging && mouseSelection.dragMove ? { from: mouseSelection.dragging.from, to: mouseSelection.dragging.to } : null;
  let ins = { from: dropPos, insert: text2 };
  let changes = view.state.changes(del ? [del, ins] : ins);
  view.focus();
  view.dispatch({
    changes,
    selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
    userEvent: del ? "move.drop" : "input.drop"
  });
}
handlers.drop = (view, event2) => {
  if (!event2.dataTransfer)
    return;
  if (view.state.readOnly)
    return event2.preventDefault();
  let files2 = event2.dataTransfer.files;
  if (files2 && files2.length) {
    event2.preventDefault();
    let text2 = Array(files2.length), read2 = 0;
    let finishFile = () => {
      if (++read2 == files2.length)
        dropText(view, event2, text2.filter((s2) => s2 != null).join(view.state.lineBreak), false);
    };
    for (let i = 0; i < files2.length; i++) {
      let reader = new FileReader();
      reader.onerror = finishFile;
      reader.onload = () => {
        if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
          text2[i] = reader.result;
        finishFile();
      };
      reader.readAsText(files2[i]);
    }
  } else {
    dropText(view, event2, event2.dataTransfer.getData("Text"), true);
  }
};
handlers.paste = (view, event2) => {
  if (view.state.readOnly)
    return event2.preventDefault();
  view.observer.flush();
  let data2 = brokenClipboardAPI ? null : event2.clipboardData;
  if (data2) {
    doPaste(view, data2.getData("text/plain"));
    event2.preventDefault();
  } else {
    capturePaste(view);
  }
};
function captureCopy(view, text2) {
  let parent = view.dom.parentNode;
  if (!parent)
    return;
  let target = parent.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.value = text2;
  target.focus();
  target.selectionEnd = text2.length;
  target.selectionStart = 0;
  setTimeout(() => {
    target.remove();
    view.focus();
  }, 50);
}
function copiedRange(state) {
  let content2 = [], ranges2 = [], linewise = false;
  for (let range2 of state.selection.ranges)
    if (!range2.empty) {
      content2.push(state.sliceDoc(range2.from, range2.to));
      ranges2.push(range2);
    }
  if (!content2.length) {
    let upto = -1;
    for (let { from: from2 } of state.selection.ranges) {
      let line2 = state.doc.lineAt(from2);
      if (line2.number > upto) {
        content2.push(line2.text);
        ranges2.push({ from: line2.from, to: Math.min(state.doc.length, line2.to + 1) });
      }
      upto = line2.number;
    }
    linewise = true;
  }
  return { text: content2.join(state.lineBreak), ranges: ranges2, linewise };
}
let lastLinewiseCopy = null;
handlers.copy = handlers.cut = (view, event2) => {
  let { text: text2, ranges: ranges2, linewise } = copiedRange(view.state);
  if (!text2 && !linewise)
    return;
  lastLinewiseCopy = linewise ? text2 : null;
  let data2 = brokenClipboardAPI ? null : event2.clipboardData;
  if (data2) {
    event2.preventDefault();
    data2.clearData();
    data2.setData("text/plain", text2);
  } else {
    captureCopy(view, text2);
  }
  if (event2.type == "cut" && !view.state.readOnly)
    view.dispatch({
      changes: ranges2,
      scrollIntoView: true,
      userEvent: "delete.cut"
    });
};
function updateForFocusChange(view) {
  setTimeout(() => {
    if (view.hasFocus != view.inputState.notifiedFocused)
      view.update([]);
  }, 10);
}
handlers.focus = (view) => {
  view.inputState.lastFocusTime = Date.now();
  if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
    view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
    view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
  }
  updateForFocusChange(view);
};
handlers.blur = (view) => {
  view.observer.clearSelectionRange();
  updateForFocusChange(view);
};
handlers.compositionstart = handlers.compositionupdate = (view) => {
  if (view.inputState.compositionFirstChange == null)
    view.inputState.compositionFirstChange = true;
  if (view.inputState.composing < 0) {
    view.inputState.composing = 0;
  }
};
handlers.compositionend = (view) => {
  view.inputState.composing = -1;
  view.inputState.compositionEndedAt = Date.now();
  view.inputState.compositionFirstChange = null;
  if (browser.chrome && browser.android)
    view.observer.flushSoon();
  setTimeout(() => {
    if (view.inputState.composing < 0 && view.docView.compositionDeco.size)
      view.update([]);
  }, 50);
};
handlers.contextmenu = (view) => {
  view.inputState.lastContextMenu = Date.now();
};
handlers.beforeinput = (view, event2) => {
  var _a2;
  let pending;
  if (browser.chrome && browser.android && (pending = PendingKeys.find((key) => key.inputType == event2.inputType))) {
    view.observer.delayAndroidKey(pending.key, pending.keyCode);
    if (pending.key == "Backspace" || pending.key == "Delete") {
      let startViewHeight = ((_a2 = window.visualViewport) === null || _a2 === void 0 ? void 0 : _a2.height) || 0;
      setTimeout(() => {
        var _a3;
        if ((((_a3 = window.visualViewport) === null || _a3 === void 0 ? void 0 : _a3.height) || 0) > startViewHeight + 10 && view.hasFocus) {
          view.contentDOM.blur();
          view.focus();
        }
      }, 100);
    }
  }
};
const wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class HeightOracle {
  constructor() {
    this.doc = Text.empty;
    this.lineWrapping = false;
    this.heightSamples = {};
    this.lineHeight = 14;
    this.charWidth = 7;
    this.lineLength = 30;
    this.heightChanged = false;
  }
  heightForGap(from2, to2) {
    let lines = this.doc.lineAt(to2).number - this.doc.lineAt(from2).number + 1;
    if (this.lineWrapping)
      lines += Math.ceil((to2 - from2 - lines * this.lineLength * 0.5) / this.lineLength);
    return this.lineHeight * lines;
  }
  heightForLine(length2) {
    if (!this.lineWrapping)
      return this.lineHeight;
    let lines = 1 + Math.max(0, Math.ceil((length2 - this.lineLength) / (this.lineLength - 5)));
    return lines * this.lineHeight;
  }
  setDoc(doc2) {
    this.doc = doc2;
    return this;
  }
  mustRefreshForWrapping(whiteSpace) {
    return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(lineHeights) {
    let newHeight = false;
    for (let i = 0; i < lineHeights.length; i++) {
      let h2 = lineHeights[i];
      if (h2 < 0) {
        i++;
      } else if (!this.heightSamples[Math.floor(h2 * 10)]) {
        newHeight = true;
        this.heightSamples[Math.floor(h2 * 10)] = true;
      }
    }
    return newHeight;
  }
  refresh(whiteSpace, lineHeight, charWidth, lineLength, knownHeights) {
    let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
    let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
    this.lineWrapping = lineWrapping;
    this.lineHeight = lineHeight;
    this.charWidth = charWidth;
    this.lineLength = lineLength;
    if (changed) {
      this.heightSamples = {};
      for (let i = 0; i < knownHeights.length; i++) {
        let h2 = knownHeights[i];
        if (h2 < 0)
          i++;
        else
          this.heightSamples[Math.floor(h2 * 10)] = true;
      }
    }
    return changed;
  }
}
class MeasuredHeights {
  constructor(from2, heights) {
    this.from = from2;
    this.heights = heights;
    this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class BlockInfo {
  constructor(from2, length2, top2, height2, type2) {
    this.from = from2;
    this.length = length2;
    this.top = top2;
    this.height = height2;
    this.type = type2;
  }
  get to() {
    return this.from + this.length;
  }
  get bottom() {
    return this.top + this.height;
  }
  join(other) {
    let detail = (Array.isArray(this.type) ? this.type : [this]).concat(Array.isArray(other.type) ? other.type : [other]);
    return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, detail);
  }
}
var QueryType = /* @__PURE__ */ function(QueryType2) {
  QueryType2[QueryType2["ByPos"] = 0] = "ByPos";
  QueryType2[QueryType2["ByHeight"] = 1] = "ByHeight";
  QueryType2[QueryType2["ByPosNoHeight"] = 2] = "ByPosNoHeight";
  return QueryType2;
}(QueryType || (QueryType = {}));
const Epsilon = 1e-3;
class HeightMap {
  constructor(length2, height2, flags = 2) {
    this.length = length2;
    this.height = height2;
    this.flags = flags;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(value) {
    this.flags = (value ? 2 : 0) | this.flags & ~2;
  }
  setHeight(oracle, height2) {
    if (this.height != height2) {
      if (Math.abs(this.height - height2) > Epsilon)
        oracle.heightChanged = true;
      this.height = height2;
    }
  }
  replace(_from, _to, nodes) {
    return HeightMap.of(nodes);
  }
  decomposeLeft(_to, result) {
    result.push(this);
  }
  decomposeRight(_from, result) {
    result.push(this);
  }
  applyChanges(decorations2, oldDoc, oracle, changes) {
    let me = this;
    for (let i = changes.length - 1; i >= 0; i--) {
      let { fromA, toA, fromB, toB } = changes[i];
      let start2 = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
      let end2 = start2.to >= toA ? start2 : me.lineAt(toA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
      toB += end2.to - toA;
      toA = end2.to;
      while (i > 0 && start2.from <= changes[i - 1].toA) {
        fromA = changes[i - 1].fromA;
        fromB = changes[i - 1].fromB;
        i--;
        if (fromA < start2.from)
          start2 = me.lineAt(fromA, QueryType.ByPosNoHeight, oldDoc, 0, 0);
      }
      fromB += start2.from - fromA;
      fromA = start2.from;
      let nodes = NodeBuilder.build(oracle, decorations2, fromB, toB);
      me = me.replace(fromA, toA, nodes);
    }
    return me.updateHeight(oracle, 0);
  }
  static empty() {
    return new HeightMapText(0, 0);
  }
  static of(nodes) {
    if (nodes.length == 1)
      return nodes[0];
    let i = 0, j2 = nodes.length, before = 0, after = 0;
    for (; ; ) {
      if (i == j2) {
        if (before > after * 2) {
          let split = nodes[i - 1];
          if (split.break)
            nodes.splice(--i, 1, split.left, null, split.right);
          else
            nodes.splice(--i, 1, split.left, split.right);
          j2 += 1 + split.break;
          before -= split.size;
        } else if (after > before * 2) {
          let split = nodes[j2];
          if (split.break)
            nodes.splice(j2, 1, split.left, null, split.right);
          else
            nodes.splice(j2, 1, split.left, split.right);
          j2 += 2 + split.break;
          after -= split.size;
        } else {
          break;
        }
      } else if (before < after) {
        let next2 = nodes[i++];
        if (next2)
          before += next2.size;
      } else {
        let next2 = nodes[--j2];
        if (next2)
          after += next2.size;
      }
    }
    let brk = 0;
    if (nodes[i - 1] == null) {
      brk = 1;
      i--;
    } else if (nodes[i] == null) {
      brk = 1;
      j2++;
    }
    return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j2)));
  }
}
HeightMap.prototype.size = 1;
class HeightMapBlock extends HeightMap {
  constructor(length2, height2, type2) {
    super(length2, height2);
    this.type = type2;
  }
  blockAt(_height, _doc, top2, offset) {
    return new BlockInfo(offset, this.length, top2, this.height, this.type);
  }
  lineAt(_value, _type, doc2, top2, offset) {
    return this.blockAt(0, doc2, top2, offset);
  }
  forEachLine(from2, to2, doc2, top2, offset, f2) {
    if (from2 <= offset + this.length && to2 >= offset)
      f2(this.blockAt(0, doc2, top2, offset));
  }
  updateHeight(oracle, offset = 0, _force = false, measured) {
    if (measured && measured.from <= offset && measured.more)
      this.setHeight(oracle, measured.heights[measured.index++]);
    this.outdated = false;
    return this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class HeightMapText extends HeightMapBlock {
  constructor(length2, height2) {
    super(length2, height2, BlockType.Text);
    this.collapsed = 0;
    this.widgetHeight = 0;
  }
  replace(_from, _to, nodes) {
    let node2 = nodes[0];
    if (nodes.length == 1 && (node2 instanceof HeightMapText || node2 instanceof HeightMapGap && node2.flags & 4) && Math.abs(this.length - node2.length) < 10) {
      if (node2 instanceof HeightMapGap)
        node2 = new HeightMapText(node2.length, this.height);
      else
        node2.height = this.height;
      if (!this.outdated)
        node2.outdated = false;
      return node2;
    } else {
      return HeightMap.of(nodes);
    }
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    if (measured && measured.from <= offset && measured.more)
      this.setHeight(oracle, measured.heights[measured.index++]);
    else if (force || this.outdated)
      this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)));
    this.outdated = false;
    return this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class HeightMapGap extends HeightMap {
  constructor(length2) {
    super(length2, 0);
  }
  lines(doc2, offset) {
    let firstLine = doc2.lineAt(offset).number, lastLine = doc2.lineAt(offset + this.length).number;
    return { firstLine, lastLine, lineHeight: this.height / (lastLine - firstLine + 1) };
  }
  blockAt(height2, doc2, top2, offset) {
    let { firstLine, lastLine, lineHeight } = this.lines(doc2, offset);
    let line2 = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height2 - top2) / lineHeight)));
    let { from: from2, length: length2 } = doc2.line(firstLine + line2);
    return new BlockInfo(from2, length2, top2 + lineHeight * line2, lineHeight, BlockType.Text);
  }
  lineAt(value, type2, doc2, top2, offset) {
    if (type2 == QueryType.ByHeight)
      return this.blockAt(value, doc2, top2, offset);
    if (type2 == QueryType.ByPosNoHeight) {
      let { from: from3, to: to2 } = doc2.lineAt(value);
      return new BlockInfo(from3, to2 - from3, 0, 0, BlockType.Text);
    }
    let { firstLine, lineHeight } = this.lines(doc2, offset);
    let { from: from2, length: length2, number: number3 } = doc2.lineAt(value);
    return new BlockInfo(from2, length2, top2 + lineHeight * (number3 - firstLine), lineHeight, BlockType.Text);
  }
  forEachLine(from2, to2, doc2, top2, offset, f2) {
    let { firstLine, lineHeight } = this.lines(doc2, offset);
    for (let pos = Math.max(from2, offset), end2 = Math.min(offset + this.length, to2); pos <= end2; ) {
      let line2 = doc2.lineAt(pos);
      if (pos == from2)
        top2 += lineHeight * (line2.number - firstLine);
      f2(new BlockInfo(line2.from, line2.length, top2, lineHeight, BlockType.Text));
      top2 += lineHeight;
      pos = line2.to + 1;
    }
  }
  replace(from2, to2, nodes) {
    let after = this.length - to2;
    if (after > 0) {
      let last = nodes[nodes.length - 1];
      if (last instanceof HeightMapGap)
        nodes[nodes.length - 1] = new HeightMapGap(last.length + after);
      else
        nodes.push(null, new HeightMapGap(after - 1));
    }
    if (from2 > 0) {
      let first = nodes[0];
      if (first instanceof HeightMapGap)
        nodes[0] = new HeightMapGap(from2 + first.length);
      else
        nodes.unshift(new HeightMapGap(from2 - 1), null);
    }
    return HeightMap.of(nodes);
  }
  decomposeLeft(to2, result) {
    result.push(new HeightMapGap(to2 - 1), null);
  }
  decomposeRight(from2, result) {
    result.push(null, new HeightMapGap(this.length - from2 - 1));
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    let end2 = offset + this.length;
    if (measured && measured.from <= offset + this.length && measured.more) {
      let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
      let wasChanged = oracle.heightChanged;
      if (measured.from > offset)
        nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
      while (pos <= end2 && measured.more) {
        let len = oracle.doc.lineAt(pos).length;
        if (nodes.length)
          nodes.push(null);
        let height2 = measured.heights[measured.index++];
        if (singleHeight == -1)
          singleHeight = height2;
        else if (Math.abs(height2 - singleHeight) >= Epsilon)
          singleHeight = -2;
        let line2 = new HeightMapText(len, height2);
        line2.outdated = false;
        nodes.push(line2);
        pos += len + 1;
      }
      if (pos <= end2)
        nodes.push(null, new HeightMapGap(end2 - pos).updateHeight(oracle, pos));
      let result = HeightMap.of(nodes);
      oracle.heightChanged = wasChanged || singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.lines(oracle.doc, offset).lineHeight) >= Epsilon;
      return result;
    } else if (force || this.outdated) {
      this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));
      this.outdated = false;
    }
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class HeightMapBranch extends HeightMap {
  constructor(left2, brk, right2) {
    super(left2.length + brk + right2.length, left2.height + right2.height, brk | (left2.outdated || right2.outdated ? 2 : 0));
    this.left = left2;
    this.right = right2;
    this.size = left2.size + right2.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(height2, doc2, top2, offset) {
    let mid = top2 + this.left.height;
    return height2 < mid ? this.left.blockAt(height2, doc2, top2, offset) : this.right.blockAt(height2, doc2, mid, offset + this.left.length + this.break);
  }
  lineAt(value, type2, doc2, top2, offset) {
    let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
    let left2 = type2 == QueryType.ByHeight ? value < rightTop : value < rightOffset;
    let base2 = left2 ? this.left.lineAt(value, type2, doc2, top2, offset) : this.right.lineAt(value, type2, doc2, rightTop, rightOffset);
    if (this.break || (left2 ? base2.to < rightOffset : base2.from > rightOffset))
      return base2;
    let subQuery = type2 == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
    if (left2)
      return base2.join(this.right.lineAt(rightOffset, subQuery, doc2, rightTop, rightOffset));
    else
      return this.left.lineAt(rightOffset, subQuery, doc2, top2, offset).join(base2);
  }
  forEachLine(from2, to2, doc2, top2, offset, f2) {
    let rightTop = top2 + this.left.height, rightOffset = offset + this.left.length + this.break;
    if (this.break) {
      if (from2 < rightOffset)
        this.left.forEachLine(from2, to2, doc2, top2, offset, f2);
      if (to2 >= rightOffset)
        this.right.forEachLine(from2, to2, doc2, rightTop, rightOffset, f2);
    } else {
      let mid = this.lineAt(rightOffset, QueryType.ByPos, doc2, top2, offset);
      if (from2 < mid.from)
        this.left.forEachLine(from2, mid.from - 1, doc2, top2, offset, f2);
      if (mid.to >= from2 && mid.from <= to2)
        f2(mid);
      if (to2 > mid.to)
        this.right.forEachLine(mid.to + 1, to2, doc2, rightTop, rightOffset, f2);
    }
  }
  replace(from2, to2, nodes) {
    let rightStart = this.left.length + this.break;
    if (to2 < rightStart)
      return this.balanced(this.left.replace(from2, to2, nodes), this.right);
    if (from2 > this.left.length)
      return this.balanced(this.left, this.right.replace(from2 - rightStart, to2 - rightStart, nodes));
    let result = [];
    if (from2 > 0)
      this.decomposeLeft(from2, result);
    let left2 = result.length;
    for (let node2 of nodes)
      result.push(node2);
    if (from2 > 0)
      mergeGaps(result, left2 - 1);
    if (to2 < this.length) {
      let right2 = result.length;
      this.decomposeRight(to2, result);
      mergeGaps(result, right2);
    }
    return HeightMap.of(result);
  }
  decomposeLeft(to2, result) {
    let left2 = this.left.length;
    if (to2 <= left2)
      return this.left.decomposeLeft(to2, result);
    result.push(this.left);
    if (this.break) {
      left2++;
      if (to2 >= left2)
        result.push(null);
    }
    if (to2 > left2)
      this.right.decomposeLeft(to2 - left2, result);
  }
  decomposeRight(from2, result) {
    let left2 = this.left.length, right2 = left2 + this.break;
    if (from2 >= right2)
      return this.right.decomposeRight(from2 - right2, result);
    if (from2 < left2)
      this.left.decomposeRight(from2, result);
    if (this.break && from2 < right2)
      result.push(null);
    result.push(this.right);
  }
  balanced(left2, right2) {
    if (left2.size > 2 * right2.size || right2.size > 2 * left2.size)
      return HeightMap.of(this.break ? [left2, null, right2] : [left2, right2]);
    this.left = left2;
    this.right = right2;
    this.height = left2.height + right2.height;
    this.outdated = left2.outdated || right2.outdated;
    this.size = left2.size + right2.size;
    this.length = left2.length + this.break + right2.length;
    return this;
  }
  updateHeight(oracle, offset = 0, force = false, measured) {
    let { left: left2, right: right2 } = this, rightStart = offset + left2.length + this.break, rebalance = null;
    if (measured && measured.from <= offset + left2.length && measured.more)
      rebalance = left2 = left2.updateHeight(oracle, offset, force, measured);
    else
      left2.updateHeight(oracle, offset, force);
    if (measured && measured.from <= rightStart + right2.length && measured.more)
      rebalance = right2 = right2.updateHeight(oracle, rightStart, force, measured);
    else
      right2.updateHeight(oracle, rightStart, force);
    if (rebalance)
      return this.balanced(left2, right2);
    this.height = this.left.height + this.right.height;
    this.outdated = false;
    return this;
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function mergeGaps(nodes, around) {
  let before, after;
  if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap)
    nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
}
const relevantWidgetHeight = 5;
class NodeBuilder {
  constructor(pos, oracle) {
    this.pos = pos;
    this.oracle = oracle;
    this.nodes = [];
    this.lineStart = -1;
    this.lineEnd = -1;
    this.covering = null;
    this.writtenTo = pos;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(_from, to2) {
    if (this.lineStart > -1) {
      let end2 = Math.min(to2, this.lineEnd), last = this.nodes[this.nodes.length - 1];
      if (last instanceof HeightMapText)
        last.length += end2 - this.pos;
      else if (end2 > this.pos || !this.isCovered)
        this.nodes.push(new HeightMapText(end2 - this.pos, -1));
      this.writtenTo = end2;
      if (to2 > end2) {
        this.nodes.push(null);
        this.writtenTo++;
        this.lineStart = -1;
      }
    }
    this.pos = to2;
  }
  point(from2, to2, deco) {
    if (from2 < to2 || deco.heightRelevant) {
      let height2 = deco.widget ? deco.widget.estimatedHeight : 0;
      if (height2 < 0)
        height2 = this.oracle.lineHeight;
      let len = to2 - from2;
      if (deco.block) {
        this.addBlock(new HeightMapBlock(len, height2, deco.type));
      } else if (len || height2 >= relevantWidgetHeight) {
        this.addLineDeco(height2, len);
      }
    } else if (to2 > from2) {
      this.span(from2, to2);
    }
    if (this.lineEnd > -1 && this.lineEnd < this.pos)
      this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: from2, to: to2 } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = from2;
    this.lineEnd = to2;
    if (this.writtenTo < from2) {
      if (this.writtenTo < from2 - 1 || this.nodes[this.nodes.length - 1] == null)
        this.nodes.push(this.blankContent(this.writtenTo, from2 - 1));
      this.nodes.push(null);
    }
    if (this.pos > from2)
      this.nodes.push(new HeightMapText(this.pos - from2, -1));
    this.writtenTo = this.pos;
  }
  blankContent(from2, to2) {
    let gap = new HeightMapGap(to2 - from2);
    if (this.oracle.doc.lineAt(from2).to == to2)
      gap.flags |= 4;
    return gap;
  }
  ensureLine() {
    this.enterLine();
    let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (last instanceof HeightMapText)
      return last;
    let line2 = new HeightMapText(0, -1);
    this.nodes.push(line2);
    return line2;
  }
  addBlock(block) {
    this.enterLine();
    if (block.type == BlockType.WidgetAfter && !this.isCovered)
      this.ensureLine();
    this.nodes.push(block);
    this.writtenTo = this.pos = this.pos + block.length;
    if (block.type != BlockType.WidgetBefore)
      this.covering = block;
  }
  addLineDeco(height2, length2) {
    let line2 = this.ensureLine();
    line2.length += length2;
    line2.collapsed += length2;
    line2.widgetHeight = Math.max(line2.widgetHeight, height2);
    this.writtenTo = this.pos = this.pos + length2;
  }
  finish(from2) {
    let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)
      this.nodes.push(new HeightMapText(0, -1));
    else if (this.writtenTo < this.pos || last == null)
      this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let pos = from2;
    for (let node2 of this.nodes) {
      if (node2 instanceof HeightMapText)
        node2.updateHeight(this.oracle, pos);
      pos += node2 ? node2.length : 1;
    }
    return this.nodes;
  }
  static build(oracle, decorations2, from2, to2) {
    let builder = new NodeBuilder(from2, oracle);
    RangeSet.spans(decorations2, from2, to2, builder, 0);
    return builder.finish(from2);
  }
}
function heightRelevantDecoChanges(a2, b, diff) {
  let comp = new DecorationComparator();
  RangeSet.compare(a2, b, diff, comp, 0);
  return comp.changes;
}
class DecorationComparator {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(from2, to2, a2, b) {
    if (from2 < to2 || a2 && a2.heightRelevant || b && b.heightRelevant)
      addRange(from2, to2, this.changes, 5);
  }
}
function visiblePixelRange(dom, paddingTop) {
  let rect2 = dom.getBoundingClientRect();
  let doc2 = dom.ownerDocument, win = doc2.defaultView || window;
  let left2 = Math.max(0, rect2.left), right2 = Math.min(win.innerWidth, rect2.right);
  let top2 = Math.max(0, rect2.top), bottom2 = Math.min(win.innerHeight, rect2.bottom);
  for (let parent = dom.parentNode; parent && parent != doc2.body; ) {
    if (parent.nodeType == 1) {
      let elt2 = parent;
      let style2 = window.getComputedStyle(elt2);
      if ((elt2.scrollHeight > elt2.clientHeight || elt2.scrollWidth > elt2.clientWidth) && style2.overflow != "visible") {
        let parentRect = elt2.getBoundingClientRect();
        left2 = Math.max(left2, parentRect.left);
        right2 = Math.min(right2, parentRect.right);
        top2 = Math.max(top2, parentRect.top);
        bottom2 = parent == dom.parentNode ? parentRect.bottom : Math.min(bottom2, parentRect.bottom);
      }
      parent = style2.position == "absolute" || style2.position == "fixed" ? elt2.offsetParent : elt2.parentNode;
    } else if (parent.nodeType == 11) {
      parent = parent.host;
    } else {
      break;
    }
  }
  return {
    left: left2 - rect2.left,
    right: Math.max(left2, right2) - rect2.left,
    top: top2 - (rect2.top + paddingTop),
    bottom: Math.max(top2, bottom2) - (rect2.top + paddingTop)
  };
}
function fullPixelRange(dom, paddingTop) {
  let rect2 = dom.getBoundingClientRect();
  return {
    left: 0,
    right: rect2.right - rect2.left,
    top: paddingTop,
    bottom: rect2.bottom - (rect2.top + paddingTop)
  };
}
class LineGap {
  constructor(from2, to2, size) {
    this.from = from2;
    this.to = to2;
    this.size = size;
  }
  static same(a2, b) {
    if (a2.length != b.length)
      return false;
    for (let i = 0; i < a2.length; i++) {
      let gA = a2[i], gB = b[i];
      if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
        return false;
    }
    return true;
  }
  draw(wrapping) {
    return Decoration.replace({ widget: new LineGapWidget(this.size, wrapping) }).range(this.from, this.to);
  }
}
class LineGapWidget extends WidgetType {
  constructor(size, vertical) {
    super();
    this.size = size;
    this.vertical = vertical;
  }
  eq(other) {
    return other.size == this.size && other.vertical == this.vertical;
  }
  toDOM() {
    let elt2 = document.createElement("div");
    if (this.vertical) {
      elt2.style.height = this.size + "px";
    } else {
      elt2.style.width = this.size + "px";
      elt2.style.height = "2px";
      elt2.style.display = "inline-block";
    }
    return elt2;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class ViewState {
  constructor(state) {
    this.state = state;
    this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
    this.inView = true;
    this.paddingTop = 0;
    this.paddingBottom = 0;
    this.contentDOMWidth = 0;
    this.contentDOMHeight = 0;
    this.editorHeight = 0;
    this.editorWidth = 0;
    this.heightOracle = new HeightOracle();
    this.scaler = IdScaler;
    this.scrollTarget = null;
    this.printing = false;
    this.mustMeasureContent = true;
    this.defaultTextDirection = Direction.RTL;
    this.visibleRanges = [];
    this.mustEnforceCursorAssoc = false;
    this.stateDeco = state.facet(decorations).filter((d) => typeof d != "function");
    this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
    this.viewport = this.getViewport(0, null);
    this.updateViewportLines();
    this.updateForViewport();
    this.lineGaps = this.ensureLineGaps([]);
    this.lineGapDeco = Decoration.set(this.lineGaps.map((gap) => gap.draw(false)));
    this.computeVisibleRanges();
  }
  updateForViewport() {
    let viewports = [this.viewport], { main: main2 } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let pos = i ? main2.head : main2.anchor;
      if (!viewports.some(({ from: from2, to: to2 }) => pos >= from2 && pos <= to2)) {
        let { from: from2, to: to2 } = this.lineBlockAt(pos);
        viewports.push(new Viewport(from2, to2));
      }
    }
    this.viewports = viewports.sort((a2, b) => a2.from - b.from);
    this.scaler = this.heightMap.height <= 7e6 ? IdScaler : new BigScaler(this.heightOracle.doc, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [];
    this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, (block) => {
      this.viewportLines.push(this.scaler.scale == 1 ? block : scaleBlock(block, this.scaler));
    });
  }
  update(update, scrollTarget = null) {
    this.state = update.state;
    let prevDeco = this.stateDeco;
    this.stateDeco = this.state.facet(decorations).filter((d) => typeof d != "function");
    let contentChanges = update.changedRanges;
    let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));
    let prevHeight = this.heightMap.height;
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
    if (this.heightMap.height != prevHeight)
      update.flags |= 2;
    let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
    if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport))
      viewport = this.getViewport(0, scrollTarget);
    let updateLines = !update.changes.empty || update.flags & 2 || viewport.from != this.viewport.from || viewport.to != this.viewport.to;
    this.viewport = viewport;
    this.updateForViewport();
    if (updateLines)
      this.updateViewportLines();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
      this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
    update.flags |= this.computeVisibleRanges();
    if (scrollTarget)
      this.scrollTarget = scrollTarget;
    if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc)
      this.mustEnforceCursorAssoc = true;
  }
  measure(view) {
    let dom = view.contentDOM, style2 = window.getComputedStyle(dom);
    let oracle = this.heightOracle;
    let whiteSpace = style2.whiteSpace;
    this.defaultTextDirection = style2.direction == "rtl" ? Direction.RTL : Direction.LTR;
    let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
    let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != dom.clientHeight;
    this.contentDOMHeight = dom.clientHeight;
    this.mustMeasureContent = false;
    let result = 0, bias = 0;
    let paddingTop = parseInt(style2.paddingTop) || 0, paddingBottom = parseInt(style2.paddingBottom) || 0;
    if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
      this.paddingTop = paddingTop;
      this.paddingBottom = paddingBottom;
      result |= 8 | 2;
    }
    if (this.editorWidth != view.scrollDOM.clientWidth) {
      if (oracle.lineWrapping)
        measureContent = true;
      this.editorWidth = view.scrollDOM.clientWidth;
      result |= 8;
    }
    let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
    let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
    this.pixelViewport = pixelViewport;
    let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (inView != this.inView) {
      this.inView = inView;
      if (inView)
        measureContent = true;
    }
    if (!this.inView && !this.scrollTarget)
      return 0;
    let contentWidth = dom.clientWidth;
    if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
      this.contentDOMWidth = contentWidth;
      this.editorHeight = view.scrollDOM.clientHeight;
      result |= 8;
    }
    if (measureContent) {
      let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
      if (oracle.mustRefreshForHeights(lineHeights))
        refresh = true;
      if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
        let { lineHeight, charWidth } = view.docView.measureTextSize();
        refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, contentWidth / charWidth, lineHeights);
        if (refresh) {
          view.docView.minWidth = 0;
          result |= 8;
        }
      }
      if (dTop > 0 && dBottom > 0)
        bias = Math.max(dTop, dBottom);
      else if (dTop < 0 && dBottom < 0)
        bias = Math.min(dTop, dBottom);
      oracle.heightChanged = false;
      for (let vp of this.viewports) {
        let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
        this.heightMap = this.heightMap.updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
      }
      if (oracle.heightChanged)
        result |= 2;
    }
    let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    if (viewportChange)
      this.viewport = this.getViewport(bias, this.scrollTarget);
    this.updateForViewport();
    if (result & 2 || viewportChange)
      this.updateViewportLines();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1)
      this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
    result |= this.computeVisibleRanges();
    if (this.mustEnforceCursorAssoc) {
      this.mustEnforceCursorAssoc = false;
      view.docView.enforceCursorAssoc();
    }
    return result;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(bias, scrollTarget) {
    let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1e3 / 2));
    let map2 = this.heightMap, doc2 = this.state.doc, { visibleTop, visibleBottom } = this;
    let viewport = new Viewport(map2.lineAt(visibleTop - marginTop * 1e3, QueryType.ByHeight, doc2, 0, 0).from, map2.lineAt(visibleBottom + (1 - marginTop) * 1e3, QueryType.ByHeight, doc2, 0, 0).to);
    if (scrollTarget) {
      let { head: head2 } = scrollTarget.range;
      if (head2 < viewport.from || head2 > viewport.to) {
        let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
        let block = map2.lineAt(head2, QueryType.ByPos, doc2, 0, 0), topPos;
        if (scrollTarget.y == "center")
          topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
        else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head2 < viewport.from)
          topPos = block.top;
        else
          topPos = block.bottom - viewHeight;
        viewport = new Viewport(map2.lineAt(topPos - 1e3 / 2, QueryType.ByHeight, doc2, 0, 0).from, map2.lineAt(topPos + viewHeight + 1e3 / 2, QueryType.ByHeight, doc2, 0, 0).to);
      }
    }
    return viewport;
  }
  mapViewport(viewport, changes) {
    let from2 = changes.mapPos(viewport.from, -1), to2 = changes.mapPos(viewport.to, 1);
    return new Viewport(this.heightMap.lineAt(from2, QueryType.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(to2, QueryType.ByPos, this.state.doc, 0, 0).to);
  }
  viewportIsAppropriate({ from: from2, to: to2 }, bias = 0) {
    if (!this.inView)
      return true;
    let { top: top2 } = this.heightMap.lineAt(from2, QueryType.ByPos, this.state.doc, 0, 0);
    let { bottom: bottom2 } = this.heightMap.lineAt(to2, QueryType.ByPos, this.state.doc, 0, 0);
    let { visibleTop, visibleBottom } = this;
    return (from2 == 0 || top2 <= visibleTop - Math.max(10, Math.min(-bias, 250))) && (to2 == this.state.doc.length || bottom2 >= visibleBottom + Math.max(10, Math.min(bias, 250))) && (top2 > visibleTop - 2 * 1e3 && bottom2 < visibleBottom + 2 * 1e3);
  }
  mapLineGaps(gaps, changes) {
    if (!gaps.length || changes.empty)
      return gaps;
    let mapped = [];
    for (let gap of gaps)
      if (!changes.touchesRange(gap.from, gap.to))
        mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));
    return mapped;
  }
  ensureLineGaps(current, mayMeasure) {
    let wrapping = this.heightOracle.lineWrapping;
    let margin = wrapping ? 1e4 : 2e3, halfMargin = margin >> 1, doubleMargin = margin << 1;
    if (this.defaultTextDirection != Direction.LTR && !wrapping)
      return [];
    let gaps = [];
    let addGap = (from2, to2, line2, structure) => {
      if (to2 - from2 < halfMargin)
        return;
      let sel = this.state.selection.main, avoid = [sel.from];
      if (!sel.empty)
        avoid.push(sel.to);
      for (let pos of avoid) {
        if (pos > from2 && pos < to2) {
          addGap(from2, pos - 10, line2, structure);
          addGap(pos + 10, to2, line2, structure);
          return;
        }
      }
      let gap = find$1(current, (gap2) => gap2.from >= line2.from && gap2.to <= line2.to && Math.abs(gap2.from - from2) < halfMargin && Math.abs(gap2.to - to2) < halfMargin && !avoid.some((pos) => gap2.from < pos && gap2.to > pos));
      if (!gap) {
        if (to2 < line2.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some((r) => r.from <= to2 && r.to >= to2)) {
          let lineStart = mayMeasure.moveToLineBoundary(EditorSelection.cursor(to2), false, true).head;
          if (lineStart > from2)
            to2 = lineStart;
        }
        gap = new LineGap(from2, to2, this.gapSize(line2, from2, to2, structure));
      }
      gaps.push(gap);
    };
    for (let line2 of this.viewportLines) {
      if (line2.length < doubleMargin)
        continue;
      let structure = lineStructure(line2.from, line2.to, this.stateDeco);
      if (structure.total < doubleMargin)
        continue;
      let target = this.scrollTarget ? this.scrollTarget.range.head : null;
      let viewFrom, viewTo;
      if (wrapping) {
        let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;
        let top2, bot;
        if (target != null) {
          let targetFrac = findFraction(structure, target);
          let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line2.height;
          top2 = targetFrac - spaceFrac;
          bot = targetFrac + spaceFrac;
        } else {
          top2 = (this.visibleTop - line2.top - marginHeight) / line2.height;
          bot = (this.visibleBottom - line2.top + marginHeight) / line2.height;
        }
        viewFrom = findPosition(structure, top2);
        viewTo = findPosition(structure, bot);
      } else {
        let totalWidth = structure.total * this.heightOracle.charWidth;
        let marginWidth = margin * this.heightOracle.charWidth;
        let left2, right2;
        if (target != null) {
          let targetFrac = findFraction(structure, target);
          let spaceFrac = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + marginWidth) / totalWidth;
          left2 = targetFrac - spaceFrac;
          right2 = targetFrac + spaceFrac;
        } else {
          left2 = (this.pixelViewport.left - marginWidth) / totalWidth;
          right2 = (this.pixelViewport.right + marginWidth) / totalWidth;
        }
        viewFrom = findPosition(structure, left2);
        viewTo = findPosition(structure, right2);
      }
      if (viewFrom > line2.from)
        addGap(line2.from, viewFrom, line2, structure);
      if (viewTo < line2.to)
        addGap(viewTo, line2.to, line2, structure);
    }
    return gaps;
  }
  gapSize(line2, from2, to2, structure) {
    let fraction = findFraction(structure, to2) - findFraction(structure, from2);
    if (this.heightOracle.lineWrapping) {
      return line2.height * fraction;
    } else {
      return structure.total * this.heightOracle.charWidth * fraction;
    }
  }
  updateLineGaps(gaps) {
    if (!LineGap.same(gaps, this.lineGaps)) {
      this.lineGaps = gaps;
      this.lineGapDeco = Decoration.set(gaps.map((gap) => gap.draw(this.heightOracle.lineWrapping)));
    }
  }
  computeVisibleRanges() {
    let deco = this.stateDeco;
    if (this.lineGaps.length)
      deco = deco.concat(this.lineGapDeco);
    let ranges2 = [];
    RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
      span(from2, to2) {
        ranges2.push({ from: from2, to: to2 });
      },
      point() {
      }
    }, 20);
    let changed = ranges2.length != this.visibleRanges.length || this.visibleRanges.some((r, i) => r.from != ranges2[i].from || r.to != ranges2[i].to);
    this.visibleRanges = ranges2;
    return changed ? 4 : 0;
  }
  lineBlockAt(pos) {
    return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find((b) => b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.state.doc, 0, 0), this.scaler);
  }
  lineBlockAtHeight(height2) {
    return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height2), QueryType.ByHeight, this.state.doc, 0, 0), this.scaler);
  }
  elementAtHeight(height2) {
    return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height2), this.state.doc, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Viewport {
  constructor(from2, to2) {
    this.from = from2;
    this.to = to2;
  }
}
function lineStructure(from2, to2, stateDeco) {
  let ranges2 = [], pos = from2, total = 0;
  RangeSet.spans(stateDeco, from2, to2, {
    span() {
    },
    point(from3, to3) {
      if (from3 > pos) {
        ranges2.push({ from: pos, to: from3 });
        total += from3 - pos;
      }
      pos = to3;
    }
  }, 20);
  if (pos < to2) {
    ranges2.push({ from: pos, to: to2 });
    total += to2 - pos;
  }
  return { total, ranges: ranges2 };
}
function findPosition({ total, ranges: ranges2 }, ratio) {
  if (ratio <= 0)
    return ranges2[0].from;
  if (ratio >= 1)
    return ranges2[ranges2.length - 1].to;
  let dist2 = Math.floor(total * ratio);
  for (let i = 0; ; i++) {
    let { from: from2, to: to2 } = ranges2[i], size = to2 - from2;
    if (dist2 <= size)
      return from2 + dist2;
    dist2 -= size;
  }
}
function findFraction(structure, pos) {
  let counted = 0;
  for (let { from: from2, to: to2 } of structure.ranges) {
    if (pos <= to2) {
      counted += pos - from2;
      break;
    }
    counted += to2 - from2;
  }
  return counted / structure.total;
}
function find$1(array2, f2) {
  for (let val of array2)
    if (f2(val))
      return val;
  return void 0;
}
const IdScaler = {
  toDOM(n) {
    return n;
  },
  fromDOM(n) {
    return n;
  },
  scale: 1
};
class BigScaler {
  constructor(doc2, heightMap, viewports) {
    let vpHeight = 0, base2 = 0, domBase = 0;
    this.viewports = viewports.map(({ from: from2, to: to2 }) => {
      let top2 = heightMap.lineAt(from2, QueryType.ByPos, doc2, 0, 0).top;
      let bottom2 = heightMap.lineAt(to2, QueryType.ByPos, doc2, 0, 0).bottom;
      vpHeight += bottom2 - top2;
      return { from: from2, to: to2, top: top2, bottom: bottom2, domTop: 0, domBottom: 0 };
    });
    this.scale = (7e6 - vpHeight) / (heightMap.height - vpHeight);
    for (let obj of this.viewports) {
      obj.domTop = domBase + (obj.top - base2) * this.scale;
      domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
      base2 = obj.bottom;
    }
  }
  toDOM(n) {
    for (let i = 0, base2 = 0, domBase = 0; ; i++) {
      let vp = i < this.viewports.length ? this.viewports[i] : null;
      if (!vp || n < vp.top)
        return domBase + (n - base2) * this.scale;
      if (n <= vp.bottom)
        return vp.domTop + (n - vp.top);
      base2 = vp.bottom;
      domBase = vp.domBottom;
    }
  }
  fromDOM(n) {
    for (let i = 0, base2 = 0, domBase = 0; ; i++) {
      let vp = i < this.viewports.length ? this.viewports[i] : null;
      if (!vp || n < vp.domTop)
        return base2 + (n - domBase) / this.scale;
      if (n <= vp.domBottom)
        return vp.top + (n - vp.domTop);
      base2 = vp.bottom;
      domBase = vp.domBottom;
    }
  }
}
function scaleBlock(block, scaler) {
  if (scaler.scale == 1)
    return block;
  let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
  return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block.type) ? block.type.map((b) => scaleBlock(b, scaler)) : block.type);
}
const theme$5 = /* @__PURE__ */ Facet.define({ combine: (strs) => strs.join(" ") });
const darkTheme = /* @__PURE__ */ Facet.define({ combine: (values2) => values2.indexOf(true) > -1 });
const baseThemeID = /* @__PURE__ */ StyleModule.newName(), baseLightID = /* @__PURE__ */ StyleModule.newName(), baseDarkID = /* @__PURE__ */ StyleModule.newName();
const lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
function buildTheme(main2, spec, scopes) {
  return new StyleModule(spec, {
    finish(sel) {
      return /&/.test(sel) ? sel.replace(/&\w*/, (m) => {
        if (m == "&")
          return main2;
        if (!scopes || !scopes[m])
          throw new RangeError(`Unsupported selector: ${m}`);
        return scopes[m];
      }) : main2 + " " + sel;
    }
  });
}
const baseTheme$1$1 = /* @__PURE__ */ buildTheme("." + baseThemeID, {
  "&.cm-editor": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    minHeight: "100%",
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    boxSizing: "border-box",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 4px"
  },
  ".cm-selectionLayer": {
    zIndex: -1,
    contain: "size style"
  },
  ".cm-selectionBackground": {
    position: "absolute"
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    zIndex: 100,
    contain: "size style",
    pointerEvents: "none"
  },
  "&.cm-focused .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    position: "absolute",
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  "&.cm-focused .cm-cursor": {
    display: "block"
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    left: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, lightDarkIDs);
class DOMChange {
  constructor(view, start2, end2, typeOver) {
    this.typeOver = typeOver;
    this.bounds = null;
    this.text = "";
    let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
    if (start2 > -1 && !view.state.readOnly && (this.bounds = view.docView.domBoundsAround(start2, end2, 0))) {
      let selPoints = iHead || iAnchor ? [] : selectionPoints(view);
      let reader = new DOMReader(selPoints, view.state);
      reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
      this.text = reader.text;
      this.newSel = selectionFromPoints(selPoints, this.bounds.from);
    } else {
      let domSel = view.observer.selectionRange;
      let head2 = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains$3(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
      let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains$3(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
      this.newSel = EditorSelection.single(anchor, head2);
    }
  }
}
function applyDOMChange(view, domChange) {
  let change2;
  let { newSel } = domChange, sel = view.state.selection.main;
  if (domChange.bounds) {
    let { from: from2, to: to2 } = domChange.bounds;
    let preferredPos = sel.from, preferredSide = null;
    if (view.inputState.lastKeyCode === 8 && view.inputState.lastKeyTime > Date.now() - 100 || browser.android && domChange.text.length < to2 - from2) {
      preferredPos = sel.to;
      preferredSide = "end";
    }
    let diff = findDiff(view.state.doc.sliceString(from2, to2, LineBreakPlaceholder), domChange.text, preferredPos - from2, preferredSide);
    if (diff) {
      if (browser.chrome && view.inputState.lastKeyCode == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
        diff.toB--;
      change2 = {
        from: from2 + diff.from,
        to: from2 + diff.toA,
        insert: Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
      };
    }
  } else if (newSel && (!view.hasFocus || !view.state.facet(editable) || newSel.main.eq(sel))) {
    newSel = null;
  }
  if (!change2 && !newSel)
    return false;
  if (!change2 && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
    change2 = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
  } else if (change2 && change2.from >= sel.from && change2.to <= sel.to && (change2.from != sel.from || change2.to != sel.to) && sel.to - sel.from - (change2.to - change2.from) <= 4) {
    change2 = {
      from: sel.from,
      to: sel.to,
      insert: view.state.doc.slice(sel.from, change2.from).append(change2.insert).append(view.state.doc.slice(change2.to, sel.to))
    };
  } else if ((browser.mac || browser.android) && change2 && change2.from == change2.to && change2.from == sel.head - 1 && /^\. ?$/.test(change2.insert.toString())) {
    if (newSel && change2.insert.length == 2)
      newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
    change2 = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
  } else if (browser.chrome && change2 && change2.from == change2.to && change2.from == sel.head && change2.insert.toString() == "\n " && view.lineWrapping) {
    if (newSel)
      newSel = EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
    change2 = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
  }
  if (change2) {
    let startState = view.state;
    if (browser.ios && view.inputState.flushIOSKey(view))
      return true;
    if (browser.android && (change2.from == sel.from && change2.to == sel.to && change2.insert.length == 1 && change2.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || change2.from == sel.from - 1 && change2.to == sel.to && change2.insert.length == 0 && dispatchKey(view.contentDOM, "Backspace", 8) || change2.from == sel.from && change2.to == sel.to + 1 && change2.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46)))
      return true;
    let text2 = change2.insert.toString();
    if (view.state.facet(inputHandler$1).some((h2) => h2(view, change2.from, change2.to, text2)))
      return true;
    if (view.inputState.composing >= 0)
      view.inputState.composing++;
    let tr;
    if (change2.from >= sel.from && change2.to <= sel.to && change2.to - change2.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change2.from + change2.insert.length) && view.inputState.composing < 0) {
      let before = sel.from < change2.from ? startState.sliceDoc(sel.from, change2.from) : "";
      let after = sel.to > change2.to ? startState.sliceDoc(change2.to, sel.to) : "";
      tr = startState.replaceSelection(view.state.toText(before + change2.insert.sliceString(0, void 0, view.state.lineBreak) + after));
    } else {
      let changes = startState.changes(change2);
      let mainSel = newSel && !startState.selection.main.eq(newSel.main) && newSel.main.to <= changes.newLength ? newSel.main : void 0;
      if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change2.to <= sel.to && change2.to >= sel.to - 10) {
        let replaced = view.state.sliceDoc(change2.from, change2.to);
        let compositionRange = compositionSurroundingNode(view) || view.state.doc.lineAt(sel.head);
        let offset = sel.to - change2.to, size = sel.to - sel.from;
        tr = startState.changeByRange((range2) => {
          if (range2.from == sel.from && range2.to == sel.to)
            return { changes, range: mainSel || range2.map(changes) };
          let to2 = range2.to - offset, from2 = to2 - replaced.length;
          if (range2.to - range2.from != size || view.state.sliceDoc(from2, to2) != replaced || compositionRange && range2.to >= compositionRange.from && range2.from <= compositionRange.to)
            return { range: range2 };
          let rangeChanges = startState.changes({ from: from2, to: to2, insert: change2.insert }), selOff = range2.to - sel.to;
          return {
            changes: rangeChanges,
            range: !mainSel ? range2.map(rangeChanges) : EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
          };
        });
      } else {
        tr = {
          changes,
          selection: mainSel && startState.selection.replaceRange(mainSel)
        };
      }
    }
    let userEvent = "input.type";
    if (view.composing) {
      userEvent += ".compose";
      if (view.inputState.compositionFirstChange) {
        userEvent += ".start";
        view.inputState.compositionFirstChange = false;
      }
    }
    view.dispatch(tr, { scrollIntoView: true, userEvent });
    return true;
  } else if (newSel && !newSel.main.eq(sel)) {
    let scrollIntoView2 = false, userEvent = "select";
    if (view.inputState.lastSelectionTime > Date.now() - 50) {
      if (view.inputState.lastSelectionOrigin == "select")
        scrollIntoView2 = true;
      userEvent = view.inputState.lastSelectionOrigin;
    }
    view.dispatch({ selection: newSel, scrollIntoView: scrollIntoView2, userEvent });
    return true;
  } else {
    return false;
  }
}
function findDiff(a2, b, preferredPos, preferredSide) {
  let minLen = Math.min(a2.length, b.length);
  let from2 = 0;
  while (from2 < minLen && a2.charCodeAt(from2) == b.charCodeAt(from2))
    from2++;
  if (from2 == minLen && a2.length == b.length)
    return null;
  let toA = a2.length, toB = b.length;
  while (toA > 0 && toB > 0 && a2.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
    toA--;
    toB--;
  }
  if (preferredSide == "end") {
    let adjust2 = Math.max(0, from2 - Math.min(toA, toB));
    preferredPos -= toA + adjust2 - from2;
  }
  if (toA < from2 && a2.length < b.length) {
    let move = preferredPos <= from2 && preferredPos >= toA ? from2 - preferredPos : 0;
    from2 -= move;
    toB = from2 + (toB - toA);
    toA = from2;
  } else if (toB < from2) {
    let move = preferredPos <= from2 && preferredPos >= toB ? from2 - preferredPos : 0;
    from2 -= move;
    toA = from2 + (toA - toB);
    toB = from2;
  }
  return { from: from2, toA, toB };
}
function selectionPoints(view) {
  let result = [];
  if (view.root.activeElement != view.contentDOM)
    return result;
  let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
  if (anchorNode) {
    result.push(new DOMPoint(anchorNode, anchorOffset));
    if (focusNode != anchorNode || focusOffset != anchorOffset)
      result.push(new DOMPoint(focusNode, focusOffset));
  }
  return result;
}
function selectionFromPoints(points, base2) {
  if (points.length == 0)
    return null;
  let anchor = points[0].pos, head2 = points.length == 2 ? points[1].pos : anchor;
  return anchor > -1 && head2 > -1 ? EditorSelection.single(anchor + base2, head2 + base2) : null;
}
const observeOptions = {
  childList: true,
  characterData: true,
  subtree: true,
  attributes: true,
  characterDataOldValue: true
};
const useCharData = browser.ie && browser.ie_version <= 11;
class DOMObserver {
  constructor(view) {
    this.view = view;
    this.active = false;
    this.selectionRange = new DOMSelectionState();
    this.selectionChanged = false;
    this.delayedFlush = -1;
    this.resizeTimeout = -1;
    this.queue = [];
    this.delayedAndroidKey = null;
    this.flushingAndroidKey = -1;
    this.lastChange = 0;
    this.scrollTargets = [];
    this.intersection = null;
    this.resize = null;
    this.intersecting = false;
    this.gapIntersection = null;
    this.gaps = [];
    this.parentCheck = -1;
    this.dom = view.contentDOM;
    this.observer = new MutationObserver((mutations) => {
      for (let mut of mutations)
        this.queue.push(mut);
      if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (useCharData)
      this.onCharData = (event2) => {
        this.queue.push({
          target: event2.target,
          type: "characterData",
          oldValue: event2.prevValue
        });
        this.flushSoon();
      };
    this.onSelectionChange = this.onSelectionChange.bind(this);
    this.onResize = this.onResize.bind(this);
    this.onPrint = this.onPrint.bind(this);
    this.onScroll = this.onScroll.bind(this);
    if (typeof ResizeObserver == "function") {
      this.resize = new ResizeObserver(() => {
        if (this.view.docView.lastUpdate < Date.now() - 75)
          this.onResize();
      });
      this.resize.observe(view.scrollDOM);
    }
    this.addWindowListeners(this.win = view.win);
    this.start();
    if (typeof IntersectionObserver == "function") {
      this.intersection = new IntersectionObserver((entries2) => {
        if (this.parentCheck < 0)
          this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3);
        if (entries2.length > 0 && entries2[entries2.length - 1].intersectionRatio > 0 != this.intersecting) {
          this.intersecting = !this.intersecting;
          if (this.intersecting != this.view.inView)
            this.onScrollChanged(document.createEvent("Event"));
        }
      }, {});
      this.intersection.observe(this.dom);
      this.gapIntersection = new IntersectionObserver((entries2) => {
        if (entries2.length > 0 && entries2[entries2.length - 1].intersectionRatio > 0)
          this.onScrollChanged(document.createEvent("Event"));
      }, {});
    }
    this.listenForScroll();
    this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runScrollHandlers(this.view, e);
    if (this.intersecting)
      this.view.measure();
  }
  onScroll(e) {
    if (this.intersecting)
      this.flush(false);
    this.onScrollChanged(e);
  }
  onResize() {
    if (this.resizeTimeout < 0)
      this.resizeTimeout = setTimeout(() => {
        this.resizeTimeout = -1;
        this.view.requestMeasure();
      }, 50);
  }
  onPrint() {
    this.view.viewState.printing = true;
    this.view.measure();
    setTimeout(() => {
      this.view.viewState.printing = false;
      this.view.requestMeasure();
    }, 500);
  }
  updateGaps(gaps) {
    if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g2, i) => g2 != gaps[i]))) {
      this.gapIntersection.disconnect();
      for (let gap of gaps)
        this.gapIntersection.observe(gap);
      this.gaps = gaps;
    }
  }
  onSelectionChange(event2) {
    let wasChanged = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view } = this, sel = this.selectionRange;
    if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel))
      return;
    let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
    if (context && context.ignoreEvent(event2)) {
      if (!wasChanged)
        this.selectionChanged = false;
      return;
    }
    if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
      this.flushSoon();
    else
      this.flush(false);
  }
  readSelectionRange() {
    let { view } = this;
    let range2 = browser.safari && view.root.nodeType == 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariSelectionRangeHack(this.view) || getSelection(view.root);
    if (!range2 || this.selectionRange.eq(range2))
      return false;
    let local2 = hasSelection(this.dom, range2);
    if (local2 && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range2)) {
      this.view.inputState.lastFocusTime = 0;
      view.docView.updateSelection();
      return false;
    }
    this.selectionRange.setRange(range2);
    if (local2)
      this.selectionChanged = true;
    return true;
  }
  setSelectionRange(anchor, head2) {
    this.selectionRange.set(anchor.node, anchor.offset, head2.node, head2.offset);
    this.selectionChanged = false;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let i = 0, changed = null;
    for (let dom = this.dom; dom; ) {
      if (dom.nodeType == 1) {
        if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)
          i++;
        else if (!changed)
          changed = this.scrollTargets.slice(0, i);
        if (changed)
          changed.push(dom);
        dom = dom.assignedSlot || dom.parentNode;
      } else if (dom.nodeType == 11) {
        dom = dom.host;
      } else {
        break;
      }
    }
    if (i < this.scrollTargets.length && !changed)
      changed = this.scrollTargets.slice(0, i);
    if (changed) {
      for (let dom of this.scrollTargets)
        dom.removeEventListener("scroll", this.onScroll);
      for (let dom of this.scrollTargets = changed)
        dom.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(f2) {
    if (!this.active)
      return f2();
    try {
      this.stop();
      return f2();
    } finally {
      this.start();
      this.clear();
    }
  }
  start() {
    if (this.active)
      return;
    this.observer.observe(this.dom, observeOptions);
    if (useCharData)
      this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.active = true;
  }
  stop() {
    if (!this.active)
      return;
    this.active = false;
    this.observer.disconnect();
    if (useCharData)
      this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
  }
  clear() {
    this.processRecords();
    this.queue.length = 0;
    this.selectionChanged = false;
  }
  delayAndroidKey(key, keyCode) {
    var _a2;
    if (!this.delayedAndroidKey) {
      let flush = () => {
        let key2 = this.delayedAndroidKey;
        if (key2) {
          this.clearDelayedAndroidKey();
          if (!this.flush() && key2.force)
            dispatchKey(this.dom, key2.key, key2.keyCode);
        }
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
    }
    if (!this.delayedAndroidKey || key == "Enter")
      this.delayedAndroidKey = {
        key,
        keyCode,
        force: this.lastChange < Date.now() - 50 || !!((_a2 = this.delayedAndroidKey) === null || _a2 === void 0 ? void 0 : _a2.force)
      };
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey);
    this.delayedAndroidKey = null;
    this.flushingAndroidKey = -1;
  }
  flushSoon() {
    if (this.delayedFlush < 0)
      this.delayedFlush = this.view.win.requestAnimationFrame(() => {
        this.delayedFlush = -1;
        this.flush();
      });
  }
  forceFlush() {
    if (this.delayedFlush >= 0) {
      this.view.win.cancelAnimationFrame(this.delayedFlush);
      this.delayedFlush = -1;
    }
    this.flush();
  }
  processRecords() {
    let records = this.queue;
    for (let mut of this.observer.takeRecords())
      records.push(mut);
    if (records.length)
      this.queue = [];
    let from2 = -1, to2 = -1, typeOver = false;
    for (let record of records) {
      let range2 = this.readMutation(record);
      if (!range2)
        continue;
      if (range2.typeOver)
        typeOver = true;
      if (from2 == -1) {
        ({ from: from2, to: to2 } = range2);
      } else {
        from2 = Math.min(range2.from, from2);
        to2 = Math.max(range2.to, to2);
      }
    }
    return { from: from2, to: to2, typeOver };
  }
  readChange() {
    let { from: from2, to: to2, typeOver } = this.processRecords();
    let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
    if (from2 < 0 && !newSel)
      return null;
    if (from2 > -1)
      this.lastChange = Date.now();
    this.view.inputState.lastFocusTime = 0;
    this.selectionChanged = false;
    return new DOMChange(this.view, from2, to2, typeOver);
  }
  flush(readSelection = true) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return false;
    if (readSelection)
      this.readSelectionRange();
    let domChange = this.readChange();
    if (!domChange)
      return false;
    let startState = this.view.state;
    let handled = applyDOMChange(this.view, domChange);
    if (this.view.state == startState)
      this.view.update([]);
    return handled;
  }
  readMutation(rec) {
    let cView = this.view.docView.nearest(rec.target);
    if (!cView || cView.ignoreMutation(rec))
      return null;
    cView.markDirty(rec.type == "attributes");
    if (rec.type == "attributes")
      cView.dirty |= 4;
    if (rec.type == "childList") {
      let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
      let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
      return {
        from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
        to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
        typeOver: false
      };
    } else if (rec.type == "characterData") {
      return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
    } else {
      return null;
    }
  }
  setWindow(win) {
    if (win != this.win) {
      this.removeWindowListeners(this.win);
      this.win = win;
      this.addWindowListeners(this.win);
    }
  }
  addWindowListeners(win) {
    win.addEventListener("resize", this.onResize);
    win.addEventListener("beforeprint", this.onPrint);
    win.addEventListener("scroll", this.onScroll);
    win.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(win) {
    win.removeEventListener("scroll", this.onScroll);
    win.removeEventListener("resize", this.onResize);
    win.removeEventListener("beforeprint", this.onPrint);
    win.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var _a2, _b, _c;
    this.stop();
    (_a2 = this.intersection) === null || _a2 === void 0 ? void 0 : _a2.disconnect();
    (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
    (_c = this.resize) === null || _c === void 0 ? void 0 : _c.disconnect();
    for (let dom of this.scrollTargets)
      dom.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win);
    clearTimeout(this.parentCheck);
    clearTimeout(this.resizeTimeout);
    this.win.cancelAnimationFrame(this.delayedFlush);
    this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
}
function findChild(cView, dom, dir) {
  while (dom) {
    let curView = ContentView.get(dom);
    if (curView && curView.parent == cView)
      return curView;
    let parent = dom.parentNode;
    dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
  }
  return null;
}
function safariSelectionRangeHack(view) {
  let found = null;
  function read2(event2) {
    event2.preventDefault();
    event2.stopImmediatePropagation();
    found = event2.getTargetRanges()[0];
  }
  view.contentDOM.addEventListener("beforeinput", read2, true);
  view.dom.ownerDocument.execCommand("indent");
  view.contentDOM.removeEventListener("beforeinput", read2, true);
  if (!found)
    return null;
  let anchorNode = found.startContainer, anchorOffset = found.startOffset;
  let focusNode = found.endContainer, focusOffset = found.endOffset;
  let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
  if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
class EditorView {
  constructor(config2 = {}) {
    this.plugins = [];
    this.pluginMap = /* @__PURE__ */ new Map();
    this.editorAttrs = {};
    this.contentAttrs = {};
    this.bidiCache = [];
    this.destroyed = false;
    this.updateState = 2;
    this.measureScheduled = -1;
    this.measureRequests = [];
    this.contentDOM = document.createElement("div");
    this.scrollDOM = document.createElement("div");
    this.scrollDOM.tabIndex = -1;
    this.scrollDOM.className = "cm-scroller";
    this.scrollDOM.appendChild(this.contentDOM);
    this.announceDOM = document.createElement("div");
    this.announceDOM.style.cssText = "position: absolute; top: -10000px";
    this.announceDOM.setAttribute("aria-live", "polite");
    this.dom = document.createElement("div");
    this.dom.appendChild(this.announceDOM);
    this.dom.appendChild(this.scrollDOM);
    this._dispatch = config2.dispatch || ((tr) => this.update([tr]));
    this.dispatch = this.dispatch.bind(this);
    this._root = config2.root || getRoot(config2.parent) || document;
    this.viewState = new ViewState(config2.state || EditorState.create(config2));
    this.plugins = this.state.facet(viewPlugin).map((spec) => new PluginInstance(spec));
    for (let plugin of this.plugins)
      plugin.update(this);
    this.observer = new DOMObserver(this);
    this.inputState = new InputState(this);
    this.inputState.ensureHandlers(this, this.plugins);
    this.docView = new DocView(this);
    this.mountStyles();
    this.updateAttrs();
    this.updateState = 0;
    this.requestMeasure();
    if (config2.parent)
      config2.parent.appendChild(this.dom);
  }
  get state() {
    return this.viewState.state;
  }
  get viewport() {
    return this.viewState.viewport;
  }
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  get inView() {
    return this.viewState.inView;
  }
  get composing() {
    return this.inputState.composing > 0;
  }
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  get root() {
    return this._root;
  }
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  dispatch(...input) {
    this._dispatch(input.length == 1 && input[0] instanceof Transaction ? input[0] : this.state.update(...input));
  }
  update(transactions) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let redrawn = false, attrsChanged = false, update;
    let state = this.state;
    for (let tr of transactions) {
      if (tr.startState != state)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      state = tr.state;
    }
    if (this.destroyed) {
      this.viewState.state = state;
      return;
    }
    let pendingKey = this.observer.delayedAndroidKey, domChange = null;
    if (pendingKey) {
      this.observer.clearDelayedAndroidKey();
      domChange = this.observer.readChange();
      if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection))
        domChange = null;
    } else {
      this.observer.clear();
    }
    if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
      return this.setState(state);
    update = ViewUpdate.create(this, state, transactions);
    let scrollTarget = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let tr of transactions) {
        if (scrollTarget)
          scrollTarget = scrollTarget.map(tr.changes);
        if (tr.scrollIntoView) {
          let { main: main2 } = tr.state.selection;
          scrollTarget = new ScrollTarget(main2.empty ? main2 : EditorSelection.cursor(main2.head, main2.head > main2.anchor ? -1 : 1));
        }
        for (let e of tr.effects)
          if (e.is(scrollIntoView$1))
            scrollTarget = e.value;
      }
      this.viewState.update(update, scrollTarget);
      this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
      if (!update.empty) {
        this.updatePlugins(update);
        this.inputState.update(update);
      }
      redrawn = this.docView.update(update);
      if (this.state.facet(styleModule) != this.styleModules)
        this.mountStyles();
      attrsChanged = this.updateAttrs();
      this.showAnnouncements(transactions);
      this.docView.updateSelection(redrawn, transactions.some((tr) => tr.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (update.startState.facet(theme$5) != update.state.facet(theme$5))
      this.viewState.mustMeasureContent = true;
    if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
      this.requestMeasure();
    if (!update.empty)
      for (let listener of this.state.facet(updateListener))
        listener(update);
    if (domChange) {
      if (!applyDOMChange(this, domChange) && pendingKey.force)
        dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
    }
  }
  setState(newState) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = newState;
      return;
    }
    this.updateState = 2;
    let hadFocus = this.hasFocus;
    try {
      for (let plugin of this.plugins)
        plugin.destroy(this);
      this.viewState = new ViewState(newState);
      this.plugins = newState.facet(viewPlugin).map((spec) => new PluginInstance(spec));
      this.pluginMap.clear();
      for (let plugin of this.plugins)
        plugin.update(this);
      this.docView = new DocView(this);
      this.inputState.ensureHandlers(this, this.plugins);
      this.mountStyles();
      this.updateAttrs();
      this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    if (hadFocus)
      this.focus();
    this.requestMeasure();
  }
  updatePlugins(update) {
    let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
    if (prevSpecs != specs) {
      let newPlugins = [];
      for (let spec of specs) {
        let found = prevSpecs.indexOf(spec);
        if (found < 0) {
          newPlugins.push(new PluginInstance(spec));
        } else {
          let plugin = this.plugins[found];
          plugin.mustUpdate = update;
          newPlugins.push(plugin);
        }
      }
      for (let plugin of this.plugins)
        if (plugin.mustUpdate != update)
          plugin.destroy(this);
      this.plugins = newPlugins;
      this.pluginMap.clear();
      this.inputState.ensureHandlers(this, this.plugins);
    } else {
      for (let p of this.plugins)
        p.mustUpdate = update;
    }
    for (let i = 0; i < this.plugins.length; i++)
      this.plugins[i].update(this);
  }
  measure(flush = true) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1)
      cancelAnimationFrame(this.measureScheduled);
    this.measureScheduled = 0;
    if (flush)
      this.observer.forceFlush();
    let updated = null;
    let { scrollHeight, scrollTop, clientHeight } = this.scrollDOM;
    let refHeight = scrollTop > scrollHeight - clientHeight - 4 ? scrollHeight : scrollTop;
    try {
      for (let i = 0; ; i++) {
        this.updateState = 1;
        let oldViewport = this.viewport;
        let refBlock = this.viewState.lineBlockAtHeight(refHeight);
        let changed = this.viewState.measure(this);
        if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (i > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let measuring = [];
        if (!(changed & 4))
          [this.measureRequests, measuring] = [measuring, this.measureRequests];
        let measured = measuring.map((m) => {
          try {
            return m.read(this);
          } catch (e) {
            logException(this.state, e);
            return BadMeasure;
          }
        });
        let update = ViewUpdate.create(this, this.state, []), redrawn = false, scrolled = false;
        update.flags |= changed;
        if (!updated)
          updated = update;
        else
          updated.flags |= changed;
        this.updateState = 2;
        if (!update.empty) {
          this.updatePlugins(update);
          this.inputState.update(update);
          this.updateAttrs();
          redrawn = this.docView.update(update);
        }
        for (let i2 = 0; i2 < measuring.length; i2++)
          if (measured[i2] != BadMeasure) {
            try {
              let m = measuring[i2];
              if (m.write)
                m.write(measured[i2], this);
            } catch (e) {
              logException(this.state, e);
            }
          }
        if (this.viewState.editorHeight) {
          if (this.viewState.scrollTarget) {
            this.docView.scrollIntoView(this.viewState.scrollTarget);
            this.viewState.scrollTarget = null;
            scrolled = true;
          } else {
            let diff = this.viewState.lineBlockAt(refBlock.from).top - refBlock.top;
            if (diff > 1 || diff < -1) {
              this.scrollDOM.scrollTop += diff;
              scrolled = true;
            }
          }
        }
        if (redrawn)
          this.docView.updateSelection(true);
        if (this.viewport.from == oldViewport.from && this.viewport.to == oldViewport.to && !scrolled && this.measureRequests.length == 0)
          break;
      }
    } finally {
      this.updateState = 0;
      this.measureScheduled = -1;
    }
    if (updated && !updated.empty)
      for (let listener of this.state.facet(updateListener))
        listener(updated);
  }
  get themeClasses() {
    return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme$5);
  }
  updateAttrs() {
    let editorAttrs = attrsFromFacet(this, editorAttributes, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    });
    let contentAttrs = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: !this.state.facet(editable) ? "false" : "true",
      class: "cm-content",
      style: `${browser.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    if (this.state.readOnly)
      contentAttrs["aria-readonly"] = "true";
    attrsFromFacet(this, contentAttributes, contentAttrs);
    let changed = this.observer.ignore(() => {
      let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
      let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
      return changedContent || changedEditor;
    });
    this.editorAttrs = editorAttrs;
    this.contentAttrs = contentAttrs;
    return changed;
  }
  showAnnouncements(trs) {
    let first = true;
    for (let tr of trs)
      for (let effect of tr.effects)
        if (effect.is(EditorView.announce)) {
          if (first)
            this.announceDOM.textContent = "";
          first = false;
          let div = this.announceDOM.appendChild(document.createElement("div"));
          div.textContent = effect.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(styleModule);
    StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1$1).reverse());
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    if (this.updateState == 0 && this.measureScheduled > -1)
      this.measure(false);
  }
  requestMeasure(request) {
    if (this.measureScheduled < 0)
      this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
    if (request) {
      if (request.key != null)
        for (let i = 0; i < this.measureRequests.length; i++) {
          if (this.measureRequests[i].key === request.key) {
            this.measureRequests[i] = request;
            return;
          }
        }
      this.measureRequests.push(request);
    }
  }
  plugin(plugin) {
    let known = this.pluginMap.get(plugin);
    if (known === void 0 || known && known.spec != plugin)
      this.pluginMap.set(plugin, known = this.plugins.find((p) => p.spec == plugin) || null);
    return known && known.update(this).value;
  }
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  elementAtHeight(height2) {
    this.readMeasured();
    return this.viewState.elementAtHeight(height2);
  }
  lineBlockAtHeight(height2) {
    this.readMeasured();
    return this.viewState.lineBlockAtHeight(height2);
  }
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  lineBlockAt(pos) {
    return this.viewState.lineBlockAt(pos);
  }
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  moveByChar(start2, forward, by) {
    return skipAtoms(this, start2, moveByChar(this, start2, forward, by));
  }
  moveByGroup(start2, forward) {
    return skipAtoms(this, start2, moveByChar(this, start2, forward, (initial) => byGroup(this, start2.head, initial)));
  }
  moveToLineBoundary(start2, forward, includeWrap = true) {
    return moveToLineBoundary(this, start2, forward, includeWrap);
  }
  moveVertically(start2, forward, distance2) {
    return skipAtoms(this, start2, moveVertically(this, start2, forward, distance2));
  }
  domAtPos(pos) {
    return this.docView.domAtPos(pos);
  }
  posAtDOM(node2, offset = 0) {
    return this.docView.posFromDOM(node2, offset);
  }
  posAtCoords(coords, precise = true) {
    this.readMeasured();
    return posAtCoords(this, coords, precise);
  }
  coordsAtPos(pos, side = 1) {
    this.readMeasured();
    let rect2 = this.docView.coordsAt(pos, side);
    if (!rect2 || rect2.left == rect2.right)
      return rect2;
    let line2 = this.state.doc.lineAt(pos), order2 = this.bidiSpans(line2);
    let span = order2[BidiSpan.find(order2, pos - line2.from, -1, side)];
    return flattenRect(rect2, span.dir == Direction.LTR == side > 0);
  }
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  textDirectionAt(pos) {
    let perLine = this.state.facet(perLineTextDirection);
    if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
      return this.textDirection;
    this.readMeasured();
    return this.docView.textDirectionAt(pos);
  }
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  bidiSpans(line2) {
    if (line2.length > MaxBidiLine)
      return trivialOrder(line2.length);
    let dir = this.textDirectionAt(line2.from);
    for (let entry of this.bidiCache)
      if (entry.from == line2.from && entry.dir == dir)
        return entry.order;
    let order2 = computeOrder(line2.text, dir);
    this.bidiCache.push(new CachedOrder(line2.from, line2.to, dir, order2));
    return order2;
  }
  get hasFocus() {
    var _a2;
    return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a2 = this.inputState) === null || _a2 === void 0 ? void 0 : _a2.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  focus() {
    this.observer.ignore(() => {
      focusPreventScroll(this.contentDOM);
      this.docView.updateSelection();
    });
  }
  setRoot(root2) {
    if (this._root != root2) {
      this._root = root2;
      this.observer.setWindow((root2.nodeType == 9 ? root2 : root2.ownerDocument).defaultView || window);
      this.mountStyles();
    }
  }
  destroy() {
    for (let plugin of this.plugins)
      plugin.destroy(this);
    this.plugins = [];
    this.inputState.destroy();
    this.dom.remove();
    this.observer.destroy();
    if (this.measureScheduled > -1)
      cancelAnimationFrame(this.measureScheduled);
    this.destroyed = true;
  }
  static scrollIntoView(pos, options2 = {}) {
    return scrollIntoView$1.of(new ScrollTarget(typeof pos == "number" ? EditorSelection.cursor(pos) : pos, options2.y, options2.x, options2.yMargin, options2.xMargin));
  }
  static domEventHandlers(handlers2) {
    return ViewPlugin.define(() => ({}), { eventHandlers: handlers2 });
  }
  static theme(spec, options2) {
    let prefix2 = StyleModule.newName();
    let result = [theme$5.of(prefix2), styleModule.of(buildTheme(`.${prefix2}`, spec))];
    if (options2 && options2.dark)
      result.push(darkTheme.of(true));
    return result;
  }
  static baseTheme(spec) {
    return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
  }
  static findFromDOM(dom) {
    var _a2;
    let content2 = dom.querySelector(".cm-content");
    let cView = content2 && ContentView.get(content2) || ContentView.get(dom);
    return ((_a2 = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a2 === void 0 ? void 0 : _a2.view) || null;
  }
}
EditorView.styleModule = styleModule;
EditorView.inputHandler = inputHandler$1;
EditorView.perLineTextDirection = perLineTextDirection;
EditorView.exceptionSink = exceptionSink;
EditorView.updateListener = updateListener;
EditorView.editable = editable;
EditorView.mouseSelectionStyle = mouseSelectionStyle;
EditorView.dragMovesSelection = dragMovesSelection$1;
EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
EditorView.decorations = decorations;
EditorView.atomicRanges = atomicRanges;
EditorView.scrollMargins = scrollMargins;
EditorView.darkTheme = darkTheme;
EditorView.contentAttributes = contentAttributes;
EditorView.editorAttributes = editorAttributes;
EditorView.lineWrapping = /* @__PURE__ */ EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
EditorView.announce = /* @__PURE__ */ StateEffect.define();
const MaxBidiLine = 4096;
const BadMeasure = {};
class CachedOrder {
  constructor(from2, to2, dir, order2) {
    this.from = from2;
    this.to = to2;
    this.dir = dir;
    this.order = order2;
  }
  static update(cache2, changes) {
    if (changes.empty)
      return cache2;
    let result = [], lastDir = cache2.length ? cache2[cache2.length - 1].dir : Direction.LTR;
    for (let i = Math.max(0, cache2.length - 10); i < cache2.length; i++) {
      let entry = cache2[i];
      if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
        result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.order));
    }
    return result;
  }
}
function attrsFromFacet(view, facet, base2) {
  for (let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--) {
    let source = sources[i], value = typeof source == "function" ? source(view) : source;
    if (value)
      combineAttrs(value, base2);
  }
  return base2;
}
const currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
function normalizeKeyName(name2, platform) {
  const parts = name2.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift2, meta2;
  for (let i = 0; i < parts.length - 1; ++i) {
    const mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta2 = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift2 = true;
    else if (/^mod$/i.test(mod)) {
      if (platform == "mac")
        meta2 = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta2)
    result = "Meta-" + result;
  if (shift2)
    result = "Shift-" + result;
  return result;
}
function modifiers(name2, event2, shift2) {
  if (event2.altKey)
    name2 = "Alt-" + name2;
  if (event2.ctrlKey)
    name2 = "Ctrl-" + name2;
  if (event2.metaKey)
    name2 = "Meta-" + name2;
  if (shift2 !== false && event2.shiftKey)
    name2 = "Shift-" + name2;
  return name2;
}
const handleKeyEvents = /* @__PURE__ */ Prec.default(/* @__PURE__ */ EditorView.domEventHandlers({
  keydown(event2, view) {
    return runHandlers(getKeymap(view.state), event2, view, "editor");
  }
}));
const keymap = /* @__PURE__ */ Facet.define({ enables: handleKeyEvents });
const Keymaps = /* @__PURE__ */ new WeakMap();
function getKeymap(state) {
  let bindings = state.facet(keymap);
  let map2 = Keymaps.get(bindings);
  if (!map2)
    Keymaps.set(bindings, map2 = buildKeymap(bindings.reduce((a2, b) => a2.concat(b), [])));
  return map2;
}
let storedPrefix = null;
const PrefixTimeout = 4e3;
function buildKeymap(bindings, platform = currentPlatform) {
  let bound = /* @__PURE__ */ Object.create(null);
  let isPrefix = /* @__PURE__ */ Object.create(null);
  let checkPrefix = (name2, is) => {
    let current = isPrefix[name2];
    if (current == null)
      isPrefix[name2] = is;
    else if (current != is)
      throw new Error("Key binding " + name2 + " is used both as a regular binding and as a multi-stroke prefix");
  };
  let add2 = (scope, key, command2, preventDefault) => {
    var _a2, _b;
    let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
    let parts = key.split(/ (?!$)/).map((k2) => normalizeKeyName(k2, platform));
    for (let i = 1; i < parts.length; i++) {
      let prefix2 = parts.slice(0, i).join(" ");
      checkPrefix(prefix2, true);
      if (!scopeObj[prefix2])
        scopeObj[prefix2] = {
          preventDefault: true,
          run: [(view) => {
            let ourObj = storedPrefix = { view, prefix: prefix2, scope };
            setTimeout(() => {
              if (storedPrefix == ourObj)
                storedPrefix = null;
            }, PrefixTimeout);
            return true;
          }]
        };
    }
    let full = parts.join(" ");
    checkPrefix(full, false);
    let binding = scopeObj[full] || (scopeObj[full] = { preventDefault: false, run: ((_b = (_a2 = scopeObj._any) === null || _a2 === void 0 ? void 0 : _a2.run) === null || _b === void 0 ? void 0 : _b.slice()) || [] });
    if (command2)
      binding.run.push(command2);
    if (preventDefault)
      binding.preventDefault = true;
  };
  for (let b of bindings) {
    let scopes = b.scope ? b.scope.split(" ") : ["editor"];
    if (b.any)
      for (let scope of scopes) {
        let scopeObj = bound[scope] || (bound[scope] = /* @__PURE__ */ Object.create(null));
        if (!scopeObj._any)
          scopeObj._any = { preventDefault: false, run: [] };
        for (let key in scopeObj)
          scopeObj[key].run.push(b.any);
      }
    let name2 = b[platform] || b.key;
    if (!name2)
      continue;
    for (let scope of scopes) {
      add2(scope, name2, b.run, b.preventDefault);
      if (b.shift)
        add2(scope, "Shift-" + name2, b.shift, b.preventDefault);
    }
  }
  return bound;
}
function runHandlers(map2, event2, view, scope) {
  let name2 = keyName(event2);
  let charCode = codePointAt(name2, 0), isChar = codePointSize(charCode) == name2.length && name2 != " ";
  let prefix2 = "", fallthrough = false;
  if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
    prefix2 = storedPrefix.prefix + " ";
    if (fallthrough = modifierCodes.indexOf(event2.keyCode) < 0)
      storedPrefix = null;
  }
  let ran = /* @__PURE__ */ new Set();
  let runFor = (binding) => {
    if (binding) {
      for (let cmd2 of binding.run)
        if (!ran.has(cmd2)) {
          ran.add(cmd2);
          if (cmd2(view, event2))
            return true;
        }
      if (binding.preventDefault)
        fallthrough = true;
    }
    return false;
  };
  let scopeObj = map2[scope], baseName, shiftName;
  if (scopeObj) {
    if (runFor(scopeObj[prefix2 + modifiers(name2, event2, !isChar)]))
      return true;
    if (isChar && (event2.shiftKey || event2.altKey || event2.metaKey || charCode > 127) && (baseName = base[event2.keyCode]) && baseName != name2) {
      if (runFor(scopeObj[prefix2 + modifiers(baseName, event2, true)]))
        return true;
      else if (event2.shiftKey && (shiftName = shift[event2.keyCode]) != name2 && shiftName != baseName && runFor(scopeObj[prefix2 + modifiers(shiftName, event2, false)]))
        return true;
    } else if (isChar && event2.shiftKey) {
      if (runFor(scopeObj[prefix2 + modifiers(name2, event2, true)]))
        return true;
    }
    if (runFor(scopeObj._any))
      return true;
  }
  return fallthrough;
}
const CanHidePrimary = !browser.ios;
const themeSpec = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
if (CanHidePrimary)
  themeSpec[".cm-line"].caretColor = "transparent !important";
const Outside = "-10000px";
class TooltipViewManager {
  constructor(view, facet, createTooltipView) {
    this.facet = facet;
    this.createTooltipView = createTooltipView;
    this.input = view.state.facet(facet);
    this.tooltips = this.input.filter((t4) => t4);
    this.tooltipViews = this.tooltips.map(createTooltipView);
  }
  update(update) {
    var _a2;
    let input = update.state.facet(this.facet);
    let tooltips2 = input.filter((x2) => x2);
    if (input === this.input) {
      for (let t4 of this.tooltipViews)
        if (t4.update)
          t4.update(update);
      return false;
    }
    let tooltipViews = [];
    for (let i = 0; i < tooltips2.length; i++) {
      let tip = tooltips2[i], known = -1;
      if (!tip)
        continue;
      for (let i2 = 0; i2 < this.tooltips.length; i2++) {
        let other = this.tooltips[i2];
        if (other && other.create == tip.create)
          known = i2;
      }
      if (known < 0) {
        tooltipViews[i] = this.createTooltipView(tip);
      } else {
        let tooltipView = tooltipViews[i] = this.tooltipViews[known];
        if (tooltipView.update)
          tooltipView.update(update);
      }
    }
    for (let t4 of this.tooltipViews)
      if (tooltipViews.indexOf(t4) < 0) {
        t4.dom.remove();
        (_a2 = t4.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(t4);
      }
    this.input = input;
    this.tooltips = tooltips2;
    this.tooltipViews = tooltipViews;
    return true;
  }
}
function windowSpace(view) {
  let { win } = view;
  return { top: 0, left: 0, bottom: win.innerHeight, right: win.innerWidth };
}
const tooltipConfig = /* @__PURE__ */ Facet.define({
  combine: (values2) => {
    var _a2, _b, _c;
    return {
      position: browser.ios ? "absolute" : ((_a2 = values2.find((conf2) => conf2.position)) === null || _a2 === void 0 ? void 0 : _a2.position) || "fixed",
      parent: ((_b = values2.find((conf2) => conf2.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
      tooltipSpace: ((_c = values2.find((conf2) => conf2.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace
    };
  }
});
const tooltipPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.inView = true;
    this.lastTransaction = 0;
    this.measureTimeout = -1;
    let config2 = view.state.facet(tooltipConfig);
    this.position = config2.position;
    this.parent = config2.parent;
    this.classes = view.themeClasses;
    this.createContainer();
    this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };
    this.manager = new TooltipViewManager(view, showTooltip, (t4) => this.createTooltip(t4));
    this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((entries2) => {
      if (Date.now() > this.lastTransaction - 50 && entries2.length > 0 && entries2[entries2.length - 1].intersectionRatio < 1)
        this.measureSoon();
    }, { threshold: [1] }) : null;
    this.observeIntersection();
    view.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
    this.maybeMeasure();
  }
  createContainer() {
    if (this.parent) {
      this.container = document.createElement("div");
      this.container.style.position = "relative";
      this.container.className = this.view.themeClasses;
      this.parent.appendChild(this.container);
    } else {
      this.container = this.view.dom;
    }
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let tooltip of this.manager.tooltipViews)
        this.intersectionObserver.observe(tooltip.dom);
    }
  }
  measureSoon() {
    if (this.measureTimeout < 0)
      this.measureTimeout = setTimeout(() => {
        this.measureTimeout = -1;
        this.maybeMeasure();
      }, 50);
  }
  update(update) {
    if (update.transactions.length)
      this.lastTransaction = Date.now();
    let updated = this.manager.update(update);
    if (updated)
      this.observeIntersection();
    let shouldMeasure = updated || update.geometryChanged;
    let newConfig = update.state.facet(tooltipConfig);
    if (newConfig.position != this.position) {
      this.position = newConfig.position;
      for (let t4 of this.manager.tooltipViews)
        t4.dom.style.position = this.position;
      shouldMeasure = true;
    }
    if (newConfig.parent != this.parent) {
      if (this.parent)
        this.container.remove();
      this.parent = newConfig.parent;
      this.createContainer();
      for (let t4 of this.manager.tooltipViews)
        this.container.appendChild(t4.dom);
      shouldMeasure = true;
    } else if (this.parent && this.view.themeClasses != this.classes) {
      this.classes = this.container.className = this.view.themeClasses;
    }
    if (shouldMeasure)
      this.maybeMeasure();
  }
  createTooltip(tooltip) {
    let tooltipView = tooltip.create(this.view);
    tooltipView.dom.classList.add("cm-tooltip");
    if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let arrow = document.createElement("div");
      arrow.className = "cm-tooltip-arrow";
      tooltipView.dom.appendChild(arrow);
    }
    tooltipView.dom.style.position = this.position;
    tooltipView.dom.style.top = Outside;
    this.container.appendChild(tooltipView.dom);
    if (tooltipView.mount)
      tooltipView.mount(this.view);
    return tooltipView;
  }
  destroy() {
    var _a2, _b;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let tooltipView of this.manager.tooltipViews) {
      tooltipView.dom.remove();
      (_a2 = tooltipView.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(tooltipView);
    }
    (_b = this.intersectionObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
    clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let editor = this.view.dom.getBoundingClientRect();
    return {
      editor,
      parent: this.parent ? this.container.getBoundingClientRect() : editor,
      pos: this.manager.tooltips.map((t4, i) => {
        let tv = this.manager.tooltipViews[i];
        return tv.getCoords ? tv.getCoords(t4.pos) : this.view.coordsAtPos(t4.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),
      space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view)
    };
  }
  writeMeasure(measured) {
    let { editor, space: space2 } = measured;
    let others = [];
    for (let i = 0; i < this.manager.tooltips.length; i++) {
      let tooltip = this.manager.tooltips[i], tView = this.manager.tooltipViews[i], { dom } = tView;
      let pos = measured.pos[i], size = measured.size[i];
      if (!pos || pos.bottom <= Math.max(editor.top, space2.top) || pos.top >= Math.min(editor.bottom, space2.bottom) || pos.right < Math.max(editor.left, space2.left) - 0.1 || pos.left > Math.min(editor.right, space2.right) + 0.1) {
        dom.style.top = Outside;
        continue;
      }
      let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
      let arrowHeight = arrow ? 7 : 0;
      let width2 = size.right - size.left, height2 = size.bottom - size.top;
      let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;
      let left2 = size.width > space2.right - space2.left ? ltr ? space2.left : space2.right - size.width : ltr ? Math.min(pos.left - (arrow ? 14 : 0) + offset.x, space2.right - width2) : Math.max(space2.left, pos.left - width2 + (arrow ? 14 : 0) - offset.x);
      let above = !!tooltip.above;
      if (!tooltip.strictSide && (above ? pos.top - (size.bottom - size.top) - offset.y < space2.top : pos.bottom + (size.bottom - size.top) + offset.y > space2.bottom) && above == space2.bottom - pos.bottom > pos.top - space2.top)
        above = !above;
      let top2 = above ? pos.top - height2 - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
      let right2 = left2 + width2;
      if (tView.overlap !== true) {
        for (let r of others)
          if (r.left < right2 && r.right > left2 && r.top < top2 + height2 && r.bottom > top2)
            top2 = above ? r.top - height2 - 2 - arrowHeight : r.bottom + arrowHeight + 2;
      }
      if (this.position == "absolute") {
        dom.style.top = top2 - measured.parent.top + "px";
        dom.style.left = left2 - measured.parent.left + "px";
      } else {
        dom.style.top = top2 + "px";
        dom.style.left = left2 + "px";
      }
      if (arrow)
        arrow.style.left = `${pos.left + (ltr ? offset.x : -offset.x) - (left2 + 14 - 7)}px`;
      if (tView.overlap !== true)
        others.push({ left: left2, top: top2, right: right2, bottom: top2 + height2 });
      dom.classList.toggle("cm-tooltip-above", above);
      dom.classList.toggle("cm-tooltip-below", !above);
      if (tView.positioned)
        tView.positioned();
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length) {
      if (this.view.inView)
        this.view.requestMeasure(this.measureReq);
      if (this.inView != this.view.inView) {
        this.inView = this.view.inView;
        if (!this.inView)
          for (let tv of this.manager.tooltipViews)
            tv.dom.style.top = Outside;
      }
    }
  }
}, {
  eventHandlers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
const baseTheme$2 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-tooltip": {
    zIndex: 100
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: `${7}px`,
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: `${7}px solid transparent`,
      borderRight: `${7}px solid transparent`
    },
    ".cm-tooltip-above &": {
      bottom: `-${7}px`,
      "&:before": {
        borderTop: `${7}px solid #bbb`
      },
      "&:after": {
        borderTop: `${7}px solid #f5f5f5`,
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: `-${7}px`,
      "&:before": {
        borderBottom: `${7}px solid #bbb`
      },
      "&:after": {
        borderBottom: `${7}px solid #f5f5f5`,
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
});
const noOffset = { x: 0, y: 0 };
const showTooltip = /* @__PURE__ */ Facet.define({
  enables: [tooltipPlugin, baseTheme$2]
});
function getTooltip$2(view, tooltip) {
  let plugin = view.plugin(tooltipPlugin);
  if (!plugin)
    return null;
  let found = plugin.manager.tooltips.indexOf(tooltip);
  return found < 0 ? null : plugin.manager.tooltipViews[found];
}
const panelConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    let topContainer, bottomContainer;
    for (let c2 of configs) {
      topContainer = topContainer || c2.topContainer;
      bottomContainer = bottomContainer || c2.bottomContainer;
    }
    return { topContainer, bottomContainer };
  }
});
const panelPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.input = view.state.facet(showPanel);
    this.specs = this.input.filter((s2) => s2);
    this.panels = this.specs.map((spec) => spec(view));
    let conf2 = view.state.facet(panelConfig);
    this.top = new PanelGroup(view, true, conf2.topContainer);
    this.bottom = new PanelGroup(view, false, conf2.bottomContainer);
    this.top.sync(this.panels.filter((p) => p.top));
    this.bottom.sync(this.panels.filter((p) => !p.top));
    for (let p of this.panels) {
      p.dom.classList.add("cm-panel");
      if (p.mount)
        p.mount();
    }
  }
  update(update) {
    let conf2 = update.state.facet(panelConfig);
    if (this.top.container != conf2.topContainer) {
      this.top.sync([]);
      this.top = new PanelGroup(update.view, true, conf2.topContainer);
    }
    if (this.bottom.container != conf2.bottomContainer) {
      this.bottom.sync([]);
      this.bottom = new PanelGroup(update.view, false, conf2.bottomContainer);
    }
    this.top.syncClasses();
    this.bottom.syncClasses();
    let input = update.state.facet(showPanel);
    if (input != this.input) {
      let specs = input.filter((x2) => x2);
      let panels = [], top2 = [], bottom2 = [], mount = [];
      for (let spec of specs) {
        let known = this.specs.indexOf(spec), panel;
        if (known < 0) {
          panel = spec(update.view);
          mount.push(panel);
        } else {
          panel = this.panels[known];
          if (panel.update)
            panel.update(update);
        }
        panels.push(panel);
        (panel.top ? top2 : bottom2).push(panel);
      }
      this.specs = specs;
      this.panels = panels;
      this.top.sync(top2);
      this.bottom.sync(bottom2);
      for (let p of mount) {
        p.dom.classList.add("cm-panel");
        if (p.mount)
          p.mount();
      }
    } else {
      for (let p of this.panels)
        if (p.update)
          p.update(update);
    }
  }
  destroy() {
    this.top.sync([]);
    this.bottom.sync([]);
  }
}, {
  provide: (plugin) => EditorView.scrollMargins.of((view) => {
    let value = view.plugin(plugin);
    return value && { top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() };
  })
});
class PanelGroup {
  constructor(view, top2, container) {
    this.view = view;
    this.top = top2;
    this.container = container;
    this.dom = void 0;
    this.classes = "";
    this.panels = [];
    this.syncClasses();
  }
  sync(panels) {
    for (let p of this.panels)
      if (p.destroy && panels.indexOf(p) < 0)
        p.destroy();
    this.panels = panels;
    this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      if (this.dom) {
        this.dom.remove();
        this.dom = void 0;
      }
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div");
      this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
      this.dom.style[this.top ? "top" : "bottom"] = "0";
      let parent = this.container || this.view.dom;
      parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
    }
    let curDOM = this.dom.firstChild;
    for (let panel of this.panels) {
      if (panel.dom.parentNode == this.dom) {
        while (curDOM != panel.dom)
          curDOM = rm(curDOM);
        curDOM = curDOM.nextSibling;
      } else {
        this.dom.insertBefore(panel.dom, curDOM);
      }
    }
    while (curDOM)
      curDOM = rm(curDOM);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!this.container || this.classes == this.view.themeClasses)
      return;
    for (let cls of this.classes.split(" "))
      if (cls)
        this.container.classList.remove(cls);
    for (let cls of (this.classes = this.view.themeClasses).split(" "))
      if (cls)
        this.container.classList.add(cls);
  }
}
function rm(node2) {
  let next2 = node2.nextSibling;
  node2.remove();
  return next2;
}
const showPanel = /* @__PURE__ */ Facet.define({
  enables: panelPlugin
});
class GutterMarker extends RangeValue {
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  eq(other) {
    return false;
  }
  destroy(dom) {
  }
}
GutterMarker.prototype.elementClass = "";
GutterMarker.prototype.toDOM = void 0;
GutterMarker.prototype.mapMode = MapMode.TrackBefore;
GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
GutterMarker.prototype.point = true;
const DefaultBufferLength = 1024;
let nextPropID = 0;
class Range {
  constructor(from2, to2) {
    this.from = from2;
    this.to = to2;
  }
}
class NodeProp {
  constructor(config2 = {}) {
    this.id = nextPropID++;
    this.perNode = !!config2.perNode;
    this.deserialize = config2.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  add(match) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    if (typeof match != "function")
      match = NodeType.match(match);
    return (type2) => {
      let result = match(type2);
      return result === void 0 ? null : [this, result];
    };
  }
}
NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.contextHash = new NodeProp({ perNode: true });
NodeProp.lookAhead = new NodeProp({ perNode: true });
NodeProp.mounted = new NodeProp({ perNode: true });
class MountedTree {
  constructor(tree2, overlay, parser2) {
    this.tree = tree2;
    this.overlay = overlay;
    this.parser = parser2;
  }
}
const noProps = /* @__PURE__ */ Object.create(null);
class NodeType {
  constructor(name2, props, id2, flags = 0) {
    this.name = name2;
    this.props = props;
    this.id = id2;
    this.flags = flags;
  }
  static define(spec) {
    let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
    let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
    let type2 = new NodeType(spec.name || "", props, spec.id, flags);
    if (spec.props)
      for (let src of spec.props) {
        if (!Array.isArray(src))
          src = src(type2);
        if (src) {
          if (src[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          props[src[0].id] = src[1];
        }
      }
    return type2;
  }
  prop(prop) {
    return this.props[prop.id];
  }
  get isTop() {
    return (this.flags & 1) > 0;
  }
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  get isError() {
    return (this.flags & 4) > 0;
  }
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  is(name2) {
    if (typeof name2 == "string") {
      if (this.name == name2)
        return true;
      let group = this.prop(NodeProp.group);
      return group ? group.indexOf(name2) > -1 : false;
    }
    return this.id == name2;
  }
  static match(map2) {
    let direct = /* @__PURE__ */ Object.create(null);
    for (let prop in map2)
      for (let name2 of prop.split(" "))
        direct[name2] = map2[prop];
    return (node2) => {
      for (let groups = node2.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
        let found = direct[i < 0 ? node2.name : groups[i]];
        if (found)
          return found;
      }
    };
  }
}
NodeType.none = new NodeType("", /* @__PURE__ */ Object.create(null), 0, 8);
class NodeSet {
  constructor(types2) {
    this.types = types2;
    for (let i = 0; i < types2.length; i++)
      if (types2[i].id != i)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  extend(...props) {
    let newTypes = [];
    for (let type2 of this.types) {
      let newProps = null;
      for (let source of props) {
        let add2 = source(type2);
        if (add2) {
          if (!newProps)
            newProps = Object.assign({}, type2.props);
          newProps[add2[0].id] = add2[1];
        }
      }
      newTypes.push(newProps ? new NodeType(type2.name, newProps, type2.id, type2.flags) : type2);
    }
    return new NodeSet(newTypes);
  }
}
const CachedNode = /* @__PURE__ */ new WeakMap(), CachedInnerNode = /* @__PURE__ */ new WeakMap();
var IterMode;
(function(IterMode2) {
  IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
  IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
  IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
  IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
})(IterMode || (IterMode = {}));
class Tree {
  constructor(type2, children2, positions, length2, props) {
    this.type = type2;
    this.children = children2;
    this.positions = positions;
    this.length = length2;
    this.props = null;
    if (props && props.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [prop, value] of props)
        this.props[typeof prop == "number" ? prop : prop.id] = value;
    }
  }
  toString() {
    let mounted = this.prop(NodeProp.mounted);
    if (mounted && !mounted.overlay)
      return mounted.tree.toString();
    let children2 = "";
    for (let ch of this.children) {
      let str = ch.toString();
      if (str) {
        if (children2)
          children2 += ",";
        children2 += str;
      }
    }
    return !this.type.name ? children2 : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children2.length ? "(" + children2 + ")" : "");
  }
  cursor(mode = 0) {
    return new TreeCursor(this.topNode, mode);
  }
  cursorAt(pos, side = 0, mode = 0) {
    let scope = CachedNode.get(this) || this.topNode;
    let cursor = new TreeCursor(scope);
    cursor.moveTo(pos, side);
    CachedNode.set(this, cursor._tree);
    return cursor;
  }
  get topNode() {
    return new TreeNode$1(this, 0, 0, null);
  }
  resolve(pos, side = 0) {
    let node2 = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
    CachedNode.set(this, node2);
    return node2;
  }
  resolveInner(pos, side = 0) {
    let node2 = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
    CachedInnerNode.set(this, node2);
    return node2;
  }
  iterate(spec) {
    let { enter, leave, from: from2 = 0, to: to2 = this.length } = spec;
    for (let c2 = this.cursor((spec.mode || 0) | IterMode.IncludeAnonymous); ; ) {
      let entered = false;
      if (c2.from <= to2 && c2.to >= from2 && (c2.type.isAnonymous || enter(c2) !== false)) {
        if (c2.firstChild())
          continue;
        entered = true;
      }
      for (; ; ) {
        if (entered && leave && !c2.type.isAnonymous)
          leave(c2);
        if (c2.nextSibling())
          break;
        if (!c2.parent())
          return;
        entered = true;
      }
    }
  }
  prop(prop) {
    return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
  }
  get propValues() {
    let result = [];
    if (this.props)
      for (let id2 in this.props)
        result.push([+id2, this.props[id2]]);
    return result;
  }
  balance(config2 = {}) {
    return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children2, positions, length2) => new Tree(this.type, children2, positions, length2, this.propValues), config2.makeTree || ((children2, positions, length2) => new Tree(NodeType.none, children2, positions, length2)));
  }
  static build(data2) {
    return buildTree(data2);
  }
}
Tree.empty = new Tree(NodeType.none, [], [], 0);
class FlatBufferCursor {
  constructor(buffer2, index2) {
    this.buffer = buffer2;
    this.index = index2;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new FlatBufferCursor(this.buffer, this.index);
  }
}
class TreeBuffer {
  constructor(buffer2, length2, set2) {
    this.buffer = buffer2;
    this.length = length2;
    this.set = set2;
  }
  get type() {
    return NodeType.none;
  }
  toString() {
    let result = [];
    for (let index2 = 0; index2 < this.buffer.length; ) {
      result.push(this.childString(index2));
      index2 = this.buffer[index2 + 3];
    }
    return result.join(",");
  }
  childString(index2) {
    let id2 = this.buffer[index2], endIndex = this.buffer[index2 + 3];
    let type2 = this.set.types[id2], result = type2.name;
    if (/\W/.test(result) && !type2.isError)
      result = JSON.stringify(result);
    index2 += 4;
    if (endIndex == index2)
      return result;
    let children2 = [];
    while (index2 < endIndex) {
      children2.push(this.childString(index2));
      index2 = this.buffer[index2 + 3];
    }
    return result + "(" + children2.join(",") + ")";
  }
  findChild(startIndex, endIndex, dir, pos, side) {
    let { buffer: buffer2 } = this, pick = -1;
    for (let i = startIndex; i != endIndex; i = buffer2[i + 3]) {
      if (checkSide(side, pos, buffer2[i + 1], buffer2[i + 2])) {
        pick = i;
        if (dir > 0)
          break;
      }
    }
    return pick;
  }
  slice(startI, endI, from2, to2) {
    let b = this.buffer;
    let copy2 = new Uint16Array(endI - startI);
    for (let i = startI, j2 = 0; i < endI; ) {
      copy2[j2++] = b[i++];
      copy2[j2++] = b[i++] - from2;
      copy2[j2++] = b[i++] - from2;
      copy2[j2++] = b[i++] - startI;
    }
    return new TreeBuffer(copy2, to2 - from2, this.set);
  }
}
function checkSide(side, pos, from2, to2) {
  switch (side) {
    case -2:
      return from2 < pos;
    case -1:
      return to2 >= pos && from2 < pos;
    case 0:
      return from2 < pos && to2 > pos;
    case 1:
      return from2 <= pos && to2 > pos;
    case 2:
      return to2 > pos;
    case 4:
      return true;
  }
}
function enterUnfinishedNodesBefore(node2, pos) {
  let scan2 = node2.childBefore(pos);
  while (scan2) {
    let last = scan2.lastChild;
    if (!last || last.to != scan2.to)
      break;
    if (last.type.isError && last.from == last.to) {
      node2 = scan2;
      scan2 = last.prevSibling;
    } else {
      scan2 = last;
    }
  }
  return node2;
}
function resolveNode(node2, pos, side, overlays) {
  var _a2;
  while (node2.from == node2.to || (side < 1 ? node2.from >= pos : node2.from > pos) || (side > -1 ? node2.to <= pos : node2.to < pos)) {
    let parent = !overlays && node2 instanceof TreeNode$1 && node2.index < 0 ? null : node2.parent;
    if (!parent)
      return node2;
    node2 = parent;
  }
  let mode = overlays ? 0 : IterMode.IgnoreOverlays;
  if (overlays)
    for (let scan2 = node2, parent = scan2.parent; parent; scan2 = parent, parent = scan2.parent) {
      if (scan2 instanceof TreeNode$1 && scan2.index < 0 && ((_a2 = parent.enter(pos, side, mode)) === null || _a2 === void 0 ? void 0 : _a2.from) != scan2.from)
        node2 = parent;
    }
  for (; ; ) {
    let inner = node2.enter(pos, side, mode);
    if (!inner)
      return node2;
    node2 = inner;
  }
}
class TreeNode$1 {
  constructor(_tree, from2, index2, _parent) {
    this._tree = _tree;
    this.from = from2;
    this.index = index2;
    this._parent = _parent;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(i, dir, pos, side, mode = 0) {
    for (let parent = this; ; ) {
      for (let { children: children2, positions } = parent._tree, e = dir > 0 ? children2.length : -1; i != e; i += dir) {
        let next2 = children2[i], start2 = positions[i] + parent.from;
        if (!checkSide(side, pos, start2, start2 + next2.length))
          continue;
        if (next2 instanceof TreeBuffer) {
          if (mode & IterMode.ExcludeBuffers)
            continue;
          let index2 = next2.findChild(0, next2.buffer.length, dir, pos - start2, side);
          if (index2 > -1)
            return new BufferNode(new BufferContext(parent, next2, i, start2), null, index2);
        } else if (mode & IterMode.IncludeAnonymous || (!next2.type.isAnonymous || hasChild(next2))) {
          let mounted;
          if (!(mode & IterMode.IgnoreMounts) && next2.props && (mounted = next2.prop(NodeProp.mounted)) && !mounted.overlay)
            return new TreeNode$1(mounted.tree, start2, i, parent);
          let inner = new TreeNode$1(next2, start2, i, parent);
          return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next2.children.length - 1 : 0, dir, pos, side);
        }
      }
      if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
        return null;
      if (parent.index >= 0)
        i = parent.index + dir;
      else
        i = dir < 0 ? -1 : parent._parent._tree.children.length;
      parent = parent._parent;
      if (!parent)
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(0, 1, 0, 4);
  }
  get lastChild() {
    return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
  }
  childAfter(pos) {
    return this.nextChild(0, 1, pos, 2);
  }
  childBefore(pos) {
    return this.nextChild(this._tree.children.length - 1, -1, pos, -2);
  }
  enter(pos, side, mode = 0) {
    let mounted;
    if (!(mode & IterMode.IgnoreOverlays) && (mounted = this._tree.prop(NodeProp.mounted)) && mounted.overlay) {
      let rPos = pos - this.from;
      for (let { from: from2, to: to2 } of mounted.overlay) {
        if ((side > 0 ? from2 <= rPos : from2 < rPos) && (side < 0 ? to2 >= rPos : to2 > rPos))
          return new TreeNode$1(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
      }
    }
    return this.nextChild(0, 1, pos, side, mode);
  }
  nextSignificantParent() {
    let val = this;
    while (val.type.isAnonymous && val._parent)
      val = val._parent;
    return val;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
  }
  cursor(mode = 0) {
    return new TreeCursor(this, mode);
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  resolve(pos, side = 0) {
    return resolveNode(this, pos, side, false);
  }
  resolveInner(pos, side = 0) {
    return resolveNode(this, pos, side, true);
  }
  enterUnfinishedNodesBefore(pos) {
    return enterUnfinishedNodesBefore(this, pos);
  }
  getChild(type2, before = null, after = null) {
    let r = getChildren(this, type2, before, after);
    return r.length ? r[0] : null;
  }
  getChildren(type2, before = null, after = null) {
    return getChildren(this, type2, before, after);
  }
  toString() {
    return this._tree.toString();
  }
  get node() {
    return this;
  }
  matchContext(context) {
    return matchNodeContext(this, context);
  }
}
function getChildren(node2, type2, before, after) {
  let cur2 = node2.cursor(), result = [];
  if (!cur2.firstChild())
    return result;
  if (before != null) {
    while (!cur2.type.is(before))
      if (!cur2.nextSibling())
        return result;
  }
  for (; ; ) {
    if (after != null && cur2.type.is(after))
      return result;
    if (cur2.type.is(type2))
      result.push(cur2.node);
    if (!cur2.nextSibling())
      return after == null ? result : [];
  }
}
function matchNodeContext(node2, context, i = context.length - 1) {
  for (let p = node2.parent; i >= 0; p = p.parent) {
    if (!p)
      return false;
    if (!p.type.isAnonymous) {
      if (context[i] && context[i] != p.name)
        return false;
      i--;
    }
  }
  return true;
}
class BufferContext {
  constructor(parent, buffer2, index2, start2) {
    this.parent = parent;
    this.buffer = buffer2;
    this.index = index2;
    this.start = start2;
  }
}
class BufferNode {
  constructor(context, _parent, index2) {
    this.context = context;
    this._parent = _parent;
    this.index = index2;
    this.type = context.buffer.set.types[context.buffer.buffer[index2]];
  }
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  child(dir, pos, side) {
    let { buffer: buffer2 } = this.context;
    let index2 = buffer2.findChild(this.index + 4, buffer2.buffer[this.index + 3], dir, pos - this.context.start, side);
    return index2 < 0 ? null : new BufferNode(this.context, this, index2);
  }
  get firstChild() {
    return this.child(1, 0, 4);
  }
  get lastChild() {
    return this.child(-1, 0, 4);
  }
  childAfter(pos) {
    return this.child(1, pos, 2);
  }
  childBefore(pos) {
    return this.child(-1, pos, -2);
  }
  enter(pos, side, mode = 0) {
    if (mode & IterMode.ExcludeBuffers)
      return null;
    let { buffer: buffer2 } = this.context;
    let index2 = buffer2.findChild(this.index + 4, buffer2.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
    return index2 < 0 ? null : new BufferNode(this.context, this, index2);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(dir) {
    return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4);
  }
  get nextSibling() {
    let { buffer: buffer2 } = this.context;
    let after = buffer2.buffer[this.index + 3];
    if (after < (this._parent ? buffer2.buffer[this._parent.index + 3] : buffer2.buffer.length))
      return new BufferNode(this.context, this._parent, after);
    return this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: buffer2 } = this.context;
    let parentStart = this._parent ? this._parent.index + 4 : 0;
    if (this.index == parentStart)
      return this.externalSibling(-1);
    return new BufferNode(this.context, this._parent, buffer2.findChild(parentStart, this.index, -1, 0, 4));
  }
  cursor(mode = 0) {
    return new TreeCursor(this, mode);
  }
  get tree() {
    return null;
  }
  toTree() {
    let children2 = [], positions = [];
    let { buffer: buffer2 } = this.context;
    let startI = this.index + 4, endI = buffer2.buffer[this.index + 3];
    if (endI > startI) {
      let from2 = buffer2.buffer[this.index + 1], to2 = buffer2.buffer[this.index + 2];
      children2.push(buffer2.slice(startI, endI, from2, to2));
      positions.push(0);
    }
    return new Tree(this.type, children2, positions, this.to - this.from);
  }
  resolve(pos, side = 0) {
    return resolveNode(this, pos, side, false);
  }
  resolveInner(pos, side = 0) {
    return resolveNode(this, pos, side, true);
  }
  enterUnfinishedNodesBefore(pos) {
    return enterUnfinishedNodesBefore(this, pos);
  }
  toString() {
    return this.context.buffer.childString(this.index);
  }
  getChild(type2, before = null, after = null) {
    let r = getChildren(this, type2, before, after);
    return r.length ? r[0] : null;
  }
  getChildren(type2, before = null, after = null) {
    return getChildren(this, type2, before, after);
  }
  get node() {
    return this;
  }
  matchContext(context) {
    return matchNodeContext(this, context);
  }
}
class TreeCursor {
  constructor(node2, mode = 0) {
    this.mode = mode;
    this.buffer = null;
    this.stack = [];
    this.index = 0;
    this.bufferNode = null;
    if (node2 instanceof TreeNode$1) {
      this.yieldNode(node2);
    } else {
      this._tree = node2.context.parent;
      this.buffer = node2.context;
      for (let n = node2._parent; n; n = n._parent)
        this.stack.unshift(n.index);
      this.bufferNode = node2;
      this.yieldBuf(node2.index);
    }
  }
  get name() {
    return this.type.name;
  }
  yieldNode(node2) {
    if (!node2)
      return false;
    this._tree = node2;
    this.type = node2.type;
    this.from = node2.from;
    this.to = node2.to;
    return true;
  }
  yieldBuf(index2, type2) {
    this.index = index2;
    let { start: start2, buffer: buffer2 } = this.buffer;
    this.type = type2 || buffer2.set.types[buffer2.buffer[index2]];
    this.from = start2 + buffer2.buffer[index2 + 1];
    this.to = start2 + buffer2.buffer[index2 + 2];
    return true;
  }
  yield(node2) {
    if (!node2)
      return false;
    if (node2 instanceof TreeNode$1) {
      this.buffer = null;
      return this.yieldNode(node2);
    }
    this.buffer = node2.context;
    return this.yieldBuf(node2.index, node2.type);
  }
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  enterChild(dir, pos, side) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
    let { buffer: buffer2 } = this.buffer;
    let index2 = buffer2.findChild(this.index + 4, buffer2.buffer[this.index + 3], dir, pos - this.buffer.start, side);
    if (index2 < 0)
      return false;
    this.stack.push(this.index);
    return this.yieldBuf(index2);
  }
  firstChild() {
    return this.enterChild(1, 0, 4);
  }
  lastChild() {
    return this.enterChild(-1, 0, 4);
  }
  childAfter(pos) {
    return this.enterChild(1, pos, 2);
  }
  childBefore(pos) {
    return this.enterChild(-1, pos, -2);
  }
  enter(pos, side, mode = this.mode) {
    if (!this.buffer)
      return this.yield(this._tree.enter(pos, side, mode));
    return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
  }
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    this.buffer = null;
    return this.yieldNode(parent);
  }
  sibling(dir) {
    if (!this.buffer)
      return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
    let { buffer: buffer2 } = this.buffer, d = this.stack.length - 1;
    if (dir < 0) {
      let parentStart = d < 0 ? 0 : this.stack[d] + 4;
      if (this.index != parentStart)
        return this.yieldBuf(buffer2.findChild(parentStart, this.index, -1, 0, 4));
    } else {
      let after = buffer2.buffer[this.index + 3];
      if (after < (d < 0 ? buffer2.buffer.length : buffer2.buffer[this.stack[d] + 3]))
        return this.yieldBuf(after);
    }
    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
  }
  nextSibling() {
    return this.sibling(1);
  }
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(dir) {
    let index2, parent, { buffer: buffer2 } = this;
    if (buffer2) {
      if (dir > 0) {
        if (this.index < buffer2.buffer.buffer.length)
          return false;
      } else {
        for (let i = 0; i < this.index; i++)
          if (buffer2.buffer.buffer[i + 3] < this.index)
            return false;
      }
      ({ index: index2, parent } = buffer2);
    } else {
      ({ index: index2, _parent: parent } = this._tree);
    }
    for (; parent; { index: index2, _parent: parent } = parent) {
      if (index2 > -1)
        for (let i = index2 + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {
          let child = parent._tree.children[i];
          if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
            return false;
        }
    }
    return true;
  }
  move(dir, enter) {
    if (enter && this.enterChild(dir, 0, 4))
      return true;
    for (; ; ) {
      if (this.sibling(dir))
        return true;
      if (this.atLastNode(dir) || !this.parent())
        return false;
    }
  }
  next(enter = true) {
    return this.move(1, enter);
  }
  prev(enter = true) {
    return this.move(-1, enter);
  }
  moveTo(pos, side = 0) {
    while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
      if (!this.parent())
        break;
    while (this.enterChild(1, pos, side)) {
    }
    return this;
  }
  get node() {
    if (!this.buffer)
      return this._tree;
    let cache2 = this.bufferNode, result = null, depth = 0;
    if (cache2 && cache2.context == this.buffer) {
      scan:
        for (let index2 = this.index, d = this.stack.length; d >= 0; ) {
          for (let c2 = cache2; c2; c2 = c2._parent)
            if (c2.index == index2) {
              if (index2 == this.index)
                return c2;
              result = c2;
              depth = d + 1;
              break scan;
            }
          index2 = this.stack[--d];
        }
    }
    for (let i = depth; i < this.stack.length; i++)
      result = new BufferNode(this.buffer, result, this.stack[i]);
    return this.bufferNode = new BufferNode(this.buffer, result, this.index);
  }
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  iterate(enter, leave) {
    for (let depth = 0; ; ) {
      let mustLeave = false;
      if (this.type.isAnonymous || enter(this) !== false) {
        if (this.firstChild()) {
          depth++;
          continue;
        }
        if (!this.type.isAnonymous)
          mustLeave = true;
      }
      for (; ; ) {
        if (mustLeave && leave)
          leave(this);
        mustLeave = this.type.isAnonymous;
        if (this.nextSibling())
          break;
        if (!depth)
          return;
        this.parent();
        depth--;
        mustLeave = true;
      }
    }
  }
  matchContext(context) {
    if (!this.buffer)
      return matchNodeContext(this.node, context);
    let { buffer: buffer2 } = this.buffer, { types: types2 } = buffer2.set;
    for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {
      if (d < 0)
        return matchNodeContext(this.node, context, i);
      let type2 = types2[buffer2.buffer[this.stack[d]]];
      if (!type2.isAnonymous) {
        if (context[i] && context[i] != type2.name)
          return false;
        i--;
      }
    }
    return true;
  }
}
function hasChild(tree2) {
  return tree2.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data2) {
  var _a2;
  let { buffer: buffer2, nodeSet: nodeSet2, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet2.types.length } = data2;
  let cursor = Array.isArray(buffer2) ? new FlatBufferCursor(buffer2, buffer2.length) : buffer2;
  let types2 = nodeSet2.types;
  let contextHash = 0, lookAhead = 0;
  function takeNode(parentStart, minPos, children3, positions2, inRepeat) {
    let { id: id2, start: start2, end: end2, size } = cursor;
    let lookAheadAtStart = lookAhead;
    while (size < 0) {
      cursor.next();
      if (size == -1) {
        let node3 = reused[id2];
        children3.push(node3);
        positions2.push(start2 - parentStart);
        return;
      } else if (size == -3) {
        contextHash = id2;
        return;
      } else if (size == -4) {
        lookAhead = id2;
        return;
      } else {
        throw new RangeError(`Unrecognized record size: ${size}`);
      }
    }
    let type2 = types2[id2], node2, buffer3;
    let startPos = start2 - parentStart;
    if (end2 - start2 <= maxBufferLength && (buffer3 = findBufferSize(cursor.pos - minPos, inRepeat))) {
      let data3 = new Uint16Array(buffer3.size - buffer3.skip);
      let endPos = cursor.pos - buffer3.size, index2 = data3.length;
      while (cursor.pos > endPos)
        index2 = copyToBuffer(buffer3.start, data3, index2);
      node2 = new TreeBuffer(data3, end2 - buffer3.start, nodeSet2);
      startPos = buffer3.start - parentStart;
    } else {
      let endPos = cursor.pos - size;
      cursor.next();
      let localChildren = [], localPositions = [];
      let localInRepeat = id2 >= minRepeatType ? id2 : -1;
      let lastGroup = 0, lastEnd = end2;
      while (cursor.pos > endPos) {
        if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
          if (cursor.end <= lastEnd - maxBufferLength) {
            makeRepeatLeaf(localChildren, localPositions, start2, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
            lastGroup = localChildren.length;
            lastEnd = cursor.end;
          }
          cursor.next();
        } else {
          takeNode(start2, endPos, localChildren, localPositions, localInRepeat);
        }
      }
      if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
        makeRepeatLeaf(localChildren, localPositions, start2, lastGroup, start2, lastEnd, localInRepeat, lookAheadAtStart);
      localChildren.reverse();
      localPositions.reverse();
      if (localInRepeat > -1 && lastGroup > 0) {
        let make = makeBalanced(type2);
        node2 = balanceRange(type2, localChildren, localPositions, 0, localChildren.length, 0, end2 - start2, make, make);
      } else {
        node2 = makeTree(type2, localChildren, localPositions, end2 - start2, lookAheadAtStart - end2);
      }
    }
    children3.push(node2);
    positions2.push(startPos);
  }
  function makeBalanced(type2) {
    return (children3, positions2, length3) => {
      let lookAhead2 = 0, lastI = children3.length - 1, last, lookAheadProp;
      if (lastI >= 0 && (last = children3[lastI]) instanceof Tree) {
        if (!lastI && last.type == type2 && last.length == length3)
          return last;
        if (lookAheadProp = last.prop(NodeProp.lookAhead))
          lookAhead2 = positions2[lastI] + last.length + lookAheadProp;
      }
      return makeTree(type2, children3, positions2, length3, lookAhead2);
    };
  }
  function makeRepeatLeaf(children3, positions2, base2, i, from2, to2, type2, lookAhead2) {
    let localChildren = [], localPositions = [];
    while (children3.length > i) {
      localChildren.push(children3.pop());
      localPositions.push(positions2.pop() + base2 - from2);
    }
    children3.push(makeTree(nodeSet2.types[type2], localChildren, localPositions, to2 - from2, lookAhead2 - to2));
    positions2.push(from2 - base2);
  }
  function makeTree(type2, children3, positions2, length3, lookAhead2 = 0, props) {
    if (contextHash) {
      let pair2 = [NodeProp.contextHash, contextHash];
      props = props ? [pair2].concat(props) : [pair2];
    }
    if (lookAhead2 > 25) {
      let pair2 = [NodeProp.lookAhead, lookAhead2];
      props = props ? [pair2].concat(props) : [pair2];
    }
    return new Tree(type2, children3, positions2, length3, props);
  }
  function findBufferSize(maxSize, inRepeat) {
    let fork = cursor.fork();
    let size = 0, start2 = 0, skip = 0, minStart = fork.end - maxBufferLength;
    let result = { size: 0, start: 0, skip: 0 };
    scan:
      for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
        let nodeSize2 = fork.size;
        if (fork.id == inRepeat && nodeSize2 >= 0) {
          result.size = size;
          result.start = start2;
          result.skip = skip;
          skip += 4;
          size += 4;
          fork.next();
          continue;
        }
        let startPos = fork.pos - nodeSize2;
        if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
          break;
        let localSkipped = fork.id >= minRepeatType ? 4 : 0;
        let nodeStart2 = fork.start;
        fork.next();
        while (fork.pos > startPos) {
          if (fork.size < 0) {
            if (fork.size == -3)
              localSkipped += 4;
            else
              break scan;
          } else if (fork.id >= minRepeatType) {
            localSkipped += 4;
          }
          fork.next();
        }
        start2 = nodeStart2;
        size += nodeSize2;
        skip += localSkipped;
      }
    if (inRepeat < 0 || size == maxSize) {
      result.size = size;
      result.start = start2;
      result.skip = skip;
    }
    return result.size > 4 ? result : void 0;
  }
  function copyToBuffer(bufferStart, buffer3, index2) {
    let { id: id2, start: start2, end: end2, size } = cursor;
    cursor.next();
    if (size >= 0 && id2 < minRepeatType) {
      let startIndex = index2;
      if (size > 4) {
        let endPos = cursor.pos - (size - 4);
        while (cursor.pos > endPos)
          index2 = copyToBuffer(bufferStart, buffer3, index2);
      }
      buffer3[--index2] = startIndex;
      buffer3[--index2] = end2 - bufferStart;
      buffer3[--index2] = start2 - bufferStart;
      buffer3[--index2] = id2;
    } else if (size == -3) {
      contextHash = id2;
    } else if (size == -4) {
      lookAhead = id2;
    }
    return index2;
  }
  let children2 = [], positions = [];
  while (cursor.pos > 0)
    takeNode(data2.start || 0, data2.bufferStart || 0, children2, positions, -1);
  let length2 = (_a2 = data2.length) !== null && _a2 !== void 0 ? _a2 : children2.length ? positions[0] + children2[0].length : 0;
  return new Tree(types2[data2.topID], children2.reverse(), positions.reverse(), length2);
}
const nodeSizeCache = /* @__PURE__ */ new WeakMap();
function nodeSize(balanceType, node2) {
  if (!balanceType.isAnonymous || node2 instanceof TreeBuffer || node2.type != balanceType)
    return 1;
  let size = nodeSizeCache.get(node2);
  if (size == null) {
    size = 1;
    for (let child of node2.children) {
      if (child.type != balanceType || !(child instanceof Tree)) {
        size = 1;
        break;
      }
      size += nodeSize(balanceType, child);
    }
    nodeSizeCache.set(node2, size);
  }
  return size;
}
function balanceRange(balanceType, children2, positions, from2, to2, start2, length2, mkTop, mkTree) {
  let total = 0;
  for (let i = from2; i < to2; i++)
    total += nodeSize(balanceType, children2[i]);
  let maxChild = Math.ceil(total * 1.5 / 8);
  let localChildren = [], localPositions = [];
  function divide(children3, positions2, from3, to3, offset) {
    for (let i = from3; i < to3; ) {
      let groupFrom = i, groupStart = positions2[i], groupSize = nodeSize(balanceType, children3[i]);
      i++;
      for (; i < to3; i++) {
        let nextSize = nodeSize(balanceType, children3[i]);
        if (groupSize + nextSize >= maxChild)
          break;
        groupSize += nextSize;
      }
      if (i == groupFrom + 1) {
        if (groupSize > maxChild) {
          let only = children3[groupFrom];
          divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
          continue;
        }
        localChildren.push(children3[groupFrom]);
      } else {
        let length3 = positions2[i - 1] + children3[i - 1].length - groupStart;
        localChildren.push(balanceRange(balanceType, children3, positions2, groupFrom, i, groupStart, length3, null, mkTree));
      }
      localPositions.push(groupStart + offset - start2);
    }
  }
  divide(children2, positions, from2, to2, 0);
  return (mkTop || mkTree)(localChildren, localPositions, length2);
}
class NodeWeakMap {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(buffer2, index2, value) {
    let inner = this.map.get(buffer2);
    if (!inner)
      this.map.set(buffer2, inner = /* @__PURE__ */ new Map());
    inner.set(index2, value);
  }
  getBuffer(buffer2, index2) {
    let inner = this.map.get(buffer2);
    return inner && inner.get(index2);
  }
  set(node2, value) {
    if (node2 instanceof BufferNode)
      this.setBuffer(node2.context.buffer, node2.index, value);
    else if (node2 instanceof TreeNode$1)
      this.map.set(node2.tree, value);
  }
  get(node2) {
    return node2 instanceof BufferNode ? this.getBuffer(node2.context.buffer, node2.index) : node2 instanceof TreeNode$1 ? this.map.get(node2.tree) : void 0;
  }
  cursorSet(cursor, value) {
    if (cursor.buffer)
      this.setBuffer(cursor.buffer.buffer, cursor.index, value);
    else
      this.map.set(cursor.tree, value);
  }
  cursorGet(cursor) {
    return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);
  }
}
class TreeFragment {
  constructor(from2, to2, tree2, offset, openStart = false, openEnd = false) {
    this.from = from2;
    this.to = to2;
    this.tree = tree2;
    this.offset = offset;
    this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
  }
  get openStart() {
    return (this.open & 1) > 0;
  }
  get openEnd() {
    return (this.open & 2) > 0;
  }
  static addTree(tree2, fragments = [], partial = false) {
    let result = [new TreeFragment(0, tree2.length, tree2, 0, false, partial)];
    for (let f2 of fragments)
      if (f2.to > tree2.length)
        result.push(f2);
    return result;
  }
  static applyChanges(fragments, changes, minGap = 128) {
    if (!changes.length)
      return fragments;
    let result = [];
    let fI = 1, nextF = fragments.length ? fragments[0] : null;
    for (let cI = 0, pos = 0, off = 0; ; cI++) {
      let nextC = cI < changes.length ? changes[cI] : null;
      let nextPos = nextC ? nextC.fromA : 1e9;
      if (nextPos - pos >= minGap)
        while (nextF && nextF.from < nextPos) {
          let cut = nextF;
          if (pos >= cut.from || nextPos <= cut.to || off) {
            let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
            cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
          }
          if (cut)
            result.push(cut);
          if (nextF.to > nextPos)
            break;
          nextF = fI < fragments.length ? fragments[fI++] : null;
        }
      if (!nextC)
        break;
      pos = nextC.toA;
      off = nextC.toA - nextC.toB;
    }
    return result;
  }
}
class Parser {
  startParse(input, fragments, ranges2) {
    if (typeof input == "string")
      input = new StringInput(input);
    ranges2 = !ranges2 ? [new Range(0, input.length)] : ranges2.length ? ranges2.map((r) => new Range(r.from, r.to)) : [new Range(0, 0)];
    return this.createParse(input, fragments || [], ranges2);
  }
  parse(input, fragments, ranges2) {
    let parse2 = this.startParse(input, fragments, ranges2);
    for (; ; ) {
      let done = parse2.advance();
      if (done)
        return done;
    }
  }
}
class StringInput {
  constructor(string2) {
    this.string = string2;
  }
  get length() {
    return this.string.length;
  }
  chunk(from2) {
    return this.string.slice(from2);
  }
  get lineChunks() {
    return false;
  }
  read(from2, to2) {
    return this.string.slice(from2, to2);
  }
}
function parseMixed(nest2) {
  return (parse2, input, fragments, ranges2) => new MixedParse(parse2, nest2, input, fragments, ranges2);
}
class InnerParse {
  constructor(parser2, parse2, overlay, target, ranges2) {
    this.parser = parser2;
    this.parse = parse2;
    this.overlay = overlay;
    this.target = target;
    this.ranges = ranges2;
  }
}
class ActiveOverlay {
  constructor(parser2, predicate, mounts, index2, start2, target, prev2) {
    this.parser = parser2;
    this.predicate = predicate;
    this.mounts = mounts;
    this.index = index2;
    this.start = start2;
    this.target = target;
    this.prev = prev2;
    this.depth = 0;
    this.ranges = [];
  }
}
const stoppedInner = new NodeProp({ perNode: true });
class MixedParse {
  constructor(base2, nest2, input, fragments, ranges2) {
    this.nest = nest2;
    this.input = input;
    this.fragments = fragments;
    this.ranges = ranges2;
    this.inner = [];
    this.innerDone = 0;
    this.baseTree = null;
    this.stoppedAt = null;
    this.baseParse = base2;
  }
  advance() {
    if (this.baseParse) {
      let done2 = this.baseParse.advance();
      if (!done2)
        return null;
      this.baseParse = null;
      this.baseTree = done2;
      this.startInner();
      if (this.stoppedAt != null)
        for (let inner2 of this.inner)
          inner2.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let result = this.baseTree;
      if (this.stoppedAt != null)
        result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));
      return result;
    }
    let inner = this.inner[this.innerDone], done = inner.parse.advance();
    if (done) {
      this.innerDone++;
      let props = Object.assign(/* @__PURE__ */ Object.create(null), inner.target.props);
      props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);
      inner.target.props = props;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let pos = this.input.length;
    for (let i = this.innerDone; i < this.inner.length; i++) {
      if (this.inner[i].ranges[0].from < pos)
        pos = Math.min(pos, this.inner[i].parse.parsedPos);
    }
    return pos;
  }
  stopAt(pos) {
    this.stoppedAt = pos;
    if (this.baseParse)
      this.baseParse.stopAt(pos);
    else
      for (let i = this.innerDone; i < this.inner.length; i++)
        this.inner[i].parse.stopAt(pos);
  }
  startInner() {
    let fragmentCursor = new FragmentCursor$2(this.fragments);
    let overlay = null;
    let covered = null;
    let cursor = new TreeCursor(new TreeNode$1(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);
    scan:
      for (let nest2, isCovered; this.stoppedAt == null || cursor.from < this.stoppedAt; ) {
        let enter = true, range2;
        if (fragmentCursor.hasNode(cursor)) {
          if (overlay) {
            let match = overlay.mounts.find((m) => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);
            if (match)
              for (let r of match.mount.overlay) {
                let from2 = r.from + match.pos, to2 = r.to + match.pos;
                if (from2 >= cursor.from && to2 <= cursor.to && !overlay.ranges.some((r2) => r2.from < to2 && r2.to > from2))
                  overlay.ranges.push({ from: from2, to: to2 });
              }
          }
          enter = false;
        } else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {
          enter = isCovered != 2;
        } else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (nest2 = this.nest(cursor, this.input))) {
          if (!cursor.tree)
            materialize(cursor);
          let oldMounts = fragmentCursor.findMounts(cursor.from, nest2.parser);
          if (typeof nest2.overlay == "function") {
            overlay = new ActiveOverlay(nest2.parser, nest2.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);
          } else {
            let ranges2 = punchRanges(this.ranges, nest2.overlay || [new Range(cursor.from, cursor.to)]);
            if (ranges2.length)
              this.inner.push(new InnerParse(nest2.parser, nest2.parser.startParse(this.input, enterFragments(oldMounts, ranges2), ranges2), nest2.overlay ? nest2.overlay.map((r) => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges2));
            if (!nest2.overlay)
              enter = false;
            else if (ranges2.length)
              covered = { ranges: ranges2, depth: 0, prev: covered };
          }
        } else if (overlay && (range2 = overlay.predicate(cursor))) {
          if (range2 === true)
            range2 = new Range(cursor.from, cursor.to);
          if (range2.from < range2.to)
            overlay.ranges.push(range2);
        }
        if (enter && cursor.firstChild()) {
          if (overlay)
            overlay.depth++;
          if (covered)
            covered.depth++;
        } else {
          for (; ; ) {
            if (cursor.nextSibling())
              break;
            if (!cursor.parent())
              break scan;
            if (overlay && !--overlay.depth) {
              let ranges2 = punchRanges(this.ranges, overlay.ranges);
              if (ranges2.length)
                this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges2), ranges2), overlay.ranges.map((r) => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges2));
              overlay = overlay.prev;
            }
            if (covered && !--covered.depth)
              covered = covered.prev;
          }
        }
      }
  }
}
function checkCover(covered, from2, to2) {
  for (let range2 of covered) {
    if (range2.from >= to2)
      break;
    if (range2.to > from2)
      return range2.from <= from2 && range2.to >= to2 ? 2 : 1;
  }
  return 0;
}
function sliceBuf(buf, startI, endI, nodes, positions, off) {
  if (startI < endI) {
    let from2 = buf.buffer[startI + 1], to2 = buf.buffer[endI - 2];
    nodes.push(buf.slice(startI, endI, from2, to2));
    positions.push(from2 - off);
  }
}
function materialize(cursor) {
  let { node: node2 } = cursor, depth = 0;
  do {
    cursor.parent();
    depth++;
  } while (!cursor.tree);
  let i = 0, base2 = cursor.tree, off = 0;
  for (; ; i++) {
    off = base2.positions[i] + cursor.from;
    if (off <= node2.from && off + base2.children[i].length >= node2.to)
      break;
  }
  let buf = base2.children[i], b = buf.buffer;
  function split(startI, endI, type2, innerOffset, length2) {
    let i2 = startI;
    while (b[i2 + 2] + off <= node2.from)
      i2 = b[i2 + 3];
    let children2 = [], positions = [];
    sliceBuf(buf, startI, i2, children2, positions, innerOffset);
    let from2 = b[i2 + 1], to2 = b[i2 + 2];
    let isTarget = from2 + off == node2.from && to2 + off == node2.to && b[i2] == node2.type.id;
    children2.push(isTarget ? node2.toTree() : split(i2 + 4, b[i2 + 3], buf.set.types[b[i2]], from2, to2 - from2));
    positions.push(from2 - innerOffset);
    sliceBuf(buf, b[i2 + 3], endI, children2, positions, innerOffset);
    return new Tree(type2, children2, positions, length2);
  }
  base2.children[i] = split(0, b.length, NodeType.none, 0, buf.length);
  for (let d = 0; d <= depth; d++)
    cursor.childAfter(node2.from);
}
class StructureCursor {
  constructor(root2, offset) {
    this.offset = offset;
    this.done = false;
    this.cursor = root2.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);
  }
  moveTo(pos) {
    let { cursor } = this, p = pos - this.offset;
    while (!this.done && cursor.from < p) {
      if (cursor.to >= pos && cursor.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers))
        ;
      else if (!cursor.next(false))
        this.done = true;
    }
  }
  hasNode(cursor) {
    this.moveTo(cursor.from);
    if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {
      for (let tree2 = this.cursor.tree; ; ) {
        if (tree2 == cursor.tree)
          return true;
        if (tree2.children.length && tree2.positions[0] == 0 && tree2.children[0] instanceof Tree)
          tree2 = tree2.children[0];
        else
          break;
      }
    }
    return false;
  }
}
class FragmentCursor$2 {
  constructor(fragments) {
    var _a2;
    this.fragments = fragments;
    this.curTo = 0;
    this.fragI = 0;
    if (fragments.length) {
      let first = this.curFrag = fragments[0];
      this.curTo = (_a2 = first.tree.prop(stoppedInner)) !== null && _a2 !== void 0 ? _a2 : first.to;
      this.inner = new StructureCursor(first.tree, -first.offset);
    } else {
      this.curFrag = this.inner = null;
    }
  }
  hasNode(node2) {
    while (this.curFrag && node2.from >= this.curTo)
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= node2.from && this.curTo >= node2.to && this.inner.hasNode(node2);
  }
  nextFrag() {
    var _a2;
    this.fragI++;
    if (this.fragI == this.fragments.length) {
      this.curFrag = this.inner = null;
    } else {
      let frag = this.curFrag = this.fragments[this.fragI];
      this.curTo = (_a2 = frag.tree.prop(stoppedInner)) !== null && _a2 !== void 0 ? _a2 : frag.to;
      this.inner = new StructureCursor(frag.tree, -frag.offset);
    }
  }
  findMounts(pos, parser2) {
    var _a2;
    let result = [];
    if (this.inner) {
      this.inner.cursor.moveTo(pos, 1);
      for (let pos2 = this.inner.cursor.node; pos2; pos2 = pos2.parent) {
        let mount = (_a2 = pos2.tree) === null || _a2 === void 0 ? void 0 : _a2.prop(NodeProp.mounted);
        if (mount && mount.parser == parser2) {
          for (let i = this.fragI; i < this.fragments.length; i++) {
            let frag = this.fragments[i];
            if (frag.from >= pos2.to)
              break;
            if (frag.tree == this.curFrag.tree)
              result.push({
                frag,
                pos: pos2.from - frag.offset,
                mount
              });
          }
        }
      }
    }
    return result;
  }
}
function punchRanges(outer, ranges2) {
  let copy2 = null, current = ranges2;
  for (let i = 1, j2 = 0; i < outer.length; i++) {
    let gapFrom = outer[i - 1].to, gapTo = outer[i].from;
    for (; j2 < current.length; j2++) {
      let r = current[j2];
      if (r.from >= gapTo)
        break;
      if (r.to <= gapFrom)
        continue;
      if (!copy2)
        current = copy2 = ranges2.slice();
      if (r.from < gapFrom) {
        copy2[j2] = new Range(r.from, gapFrom);
        if (r.to > gapTo)
          copy2.splice(j2 + 1, 0, new Range(gapTo, r.to));
      } else if (r.to > gapTo) {
        copy2[j2--] = new Range(gapTo, r.to);
      } else {
        copy2.splice(j2--, 1);
      }
    }
  }
  return current;
}
function findCoverChanges(a2, b, from2, to2) {
  let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;
  let result = [];
  for (; ; ) {
    let nextA = iA == a2.length ? 1e9 : inA ? a2[iA].to : a2[iA].from;
    let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;
    if (inA != inB) {
      let start2 = Math.max(pos, from2), end2 = Math.min(nextA, nextB, to2);
      if (start2 < end2)
        result.push(new Range(start2, end2));
    }
    pos = Math.min(nextA, nextB);
    if (pos == 1e9)
      break;
    if (nextA == pos) {
      if (!inA)
        inA = true;
      else {
        inA = false;
        iA++;
      }
    }
    if (nextB == pos) {
      if (!inB)
        inB = true;
      else {
        inB = false;
        iB++;
      }
    }
  }
  return result;
}
function enterFragments(mounts, ranges2) {
  let result = [];
  for (let { pos, mount, frag } of mounts) {
    let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;
    let from2 = Math.max(frag.from, startPos), to2 = Math.min(frag.to, endPos);
    if (mount.overlay) {
      let overlay = mount.overlay.map((r) => new Range(r.from + pos, r.to + pos));
      let changes = findCoverChanges(ranges2, overlay, from2, to2);
      for (let i = 0, pos2 = from2; ; i++) {
        let last = i == changes.length, end2 = last ? to2 : changes[i].from;
        if (end2 > pos2)
          result.push(new TreeFragment(pos2, end2, mount.tree, -startPos, frag.from >= pos2 || frag.openStart, frag.to <= end2 || frag.openEnd));
        if (last)
          break;
        pos2 = changes[i].to;
      }
    } else {
      result.push(new TreeFragment(from2, to2, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));
    }
  }
  return result;
}
let nextTagID = 0;
class Tag {
  constructor(set2, base2, modified) {
    this.set = set2;
    this.base = base2;
    this.modified = modified;
    this.id = nextTagID++;
  }
  static define(parent) {
    if (parent === null || parent === void 0 ? void 0 : parent.base)
      throw new Error("Can not derive from a modified tag");
    let tag = new Tag([], null, []);
    tag.set.push(tag);
    if (parent)
      for (let t4 of parent.set)
        tag.set.push(t4);
    return tag;
  }
  static defineModifier() {
    let mod = new Modifier();
    return (tag) => {
      if (tag.modified.indexOf(mod) > -1)
        return tag;
      return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a2, b) => a2.id - b.id));
    };
  }
}
let nextModifierID = 0;
class Modifier {
  constructor() {
    this.instances = [];
    this.id = nextModifierID++;
  }
  static get(base2, mods) {
    if (!mods.length)
      return base2;
    let exists2 = mods[0].instances.find((t4) => t4.base == base2 && sameArray(mods, t4.modified));
    if (exists2)
      return exists2;
    let set2 = [], tag = new Tag(set2, base2, mods);
    for (let m of mods)
      m.instances.push(tag);
    let configs = powerSet(mods);
    for (let parent of base2.set)
      if (!parent.modified.length)
        for (let config2 of configs)
          set2.push(Modifier.get(parent, config2));
    return tag;
  }
}
function sameArray(a2, b) {
  return a2.length == b.length && a2.every((x2, i) => x2 == b[i]);
}
function powerSet(array2) {
  let sets = [[]];
  for (let i = 0; i < array2.length; i++) {
    for (let j2 = 0, e = sets.length; j2 < e; j2++) {
      sets.push(sets[j2].concat(array2[i]));
    }
  }
  return sets.sort((a2, b) => b.length - a2.length);
}
function styleTags(spec) {
  let byName = /* @__PURE__ */ Object.create(null);
  for (let prop in spec) {
    let tags2 = spec[prop];
    if (!Array.isArray(tags2))
      tags2 = [tags2];
    for (let part of prop.split(" "))
      if (part) {
        let pieces = [], mode = 2, rest = part;
        for (let pos = 0; ; ) {
          if (rest == "..." && pos > 0 && pos + 3 == part.length) {
            mode = 1;
            break;
          }
          let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
          if (!m)
            throw new RangeError("Invalid path: " + part);
          pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
          pos += m[0].length;
          if (pos == part.length)
            break;
          let next2 = part[pos++];
          if (pos == part.length && next2 == "!") {
            mode = 0;
            break;
          }
          if (next2 != "/")
            throw new RangeError("Invalid path: " + part);
          rest = part.slice(pos);
        }
        let last = pieces.length - 1, inner = pieces[last];
        if (!inner)
          throw new RangeError("Invalid path: " + part);
        let rule = new Rule(tags2, mode, last > 0 ? pieces.slice(0, last) : null);
        byName[inner] = rule.sort(byName[inner]);
      }
  }
  return ruleNodeProp.add(byName);
}
const ruleNodeProp = new NodeProp();
class Rule {
  constructor(tags2, mode, context, next2) {
    this.tags = tags2;
    this.mode = mode;
    this.context = context;
    this.next = next2;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(other) {
    if (!other || other.depth < this.depth) {
      this.next = other;
      return this;
    }
    other.next = this.sort(other.next);
    return other;
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
Rule.empty = new Rule([], 2, null);
function tagHighlighter(tags2, options2) {
  let map2 = /* @__PURE__ */ Object.create(null);
  for (let style2 of tags2) {
    if (!Array.isArray(style2.tag))
      map2[style2.tag.id] = style2.class;
    else
      for (let tag of style2.tag)
        map2[tag.id] = style2.class;
  }
  let { scope, all = null } = options2 || {};
  return {
    style: (tags3) => {
      let cls = all;
      for (let tag of tags3) {
        for (let sub of tag.set) {
          let tagClass = map2[sub.id];
          if (tagClass) {
            cls = cls ? cls + " " + tagClass : tagClass;
            break;
          }
        }
      }
      return cls;
    },
    scope
  };
}
function highlightTags(highlighters, tags2) {
  let result = null;
  for (let highlighter of highlighters) {
    let value = highlighter.style(tags2);
    if (value)
      result = result ? result + " " + value : value;
  }
  return result;
}
function highlightTree(tree2, highlighter, putStyle, from2 = 0, to2 = tree2.length) {
  let builder = new HighlightBuilder(from2, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
  builder.highlightRange(tree2.cursor(), from2, to2, "", builder.highlighters);
  builder.flush(to2);
}
class HighlightBuilder {
  constructor(at, highlighters, span) {
    this.at = at;
    this.highlighters = highlighters;
    this.span = span;
    this.class = "";
  }
  startSpan(at, cls) {
    if (cls != this.class) {
      this.flush(at);
      if (at > this.at)
        this.at = at;
      this.class = cls;
    }
  }
  flush(to2) {
    if (to2 > this.at && this.class)
      this.span(this.at, to2, this.class);
  }
  highlightRange(cursor, from2, to2, inheritedClass, highlighters) {
    let { type: type2, from: start2, to: end2 } = cursor;
    if (start2 >= to2 || end2 <= from2)
      return;
    if (type2.isTop)
      highlighters = this.highlighters.filter((h2) => !h2.scope || h2.scope(type2));
    let cls = inheritedClass;
    let rule = getStyleTags(cursor) || Rule.empty;
    let tagCls = highlightTags(highlighters, rule.tags);
    if (tagCls) {
      if (cls)
        cls += " ";
      cls += tagCls;
      if (rule.mode == 1)
        inheritedClass += (inheritedClass ? " " : "") + tagCls;
    }
    this.startSpan(cursor.from, cls);
    if (rule.opaque)
      return;
    let mounted = cursor.tree && cursor.tree.prop(NodeProp.mounted);
    if (mounted && mounted.overlay) {
      let inner = cursor.node.enter(mounted.overlay[0].from + start2, 1);
      let innerHighlighters = this.highlighters.filter((h2) => !h2.scope || h2.scope(mounted.tree.type));
      let hasChild2 = cursor.firstChild();
      for (let i = 0, pos = start2; ; i++) {
        let next2 = i < mounted.overlay.length ? mounted.overlay[i] : null;
        let nextPos = next2 ? next2.from + start2 : end2;
        let rangeFrom = Math.max(from2, pos), rangeTo = Math.min(to2, nextPos);
        if (rangeFrom < rangeTo && hasChild2) {
          while (cursor.from < rangeTo) {
            this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);
            this.startSpan(Math.min(to2, cursor.to), cls);
            if (cursor.to >= nextPos || !cursor.nextSibling())
              break;
          }
        }
        if (!next2 || nextPos > to2)
          break;
        pos = next2.to + start2;
        if (pos > from2) {
          this.highlightRange(inner.cursor(), Math.max(from2, next2.from + start2), Math.min(to2, pos), inheritedClass, innerHighlighters);
          this.startSpan(pos, cls);
        }
      }
      if (hasChild2)
        cursor.parent();
    } else if (cursor.firstChild()) {
      do {
        if (cursor.to <= from2)
          continue;
        if (cursor.from >= to2)
          break;
        this.highlightRange(cursor, from2, to2, inheritedClass, highlighters);
        this.startSpan(Math.min(to2, cursor.to), cls);
      } while (cursor.nextSibling());
      cursor.parent();
    }
  }
}
function getStyleTags(node2) {
  let rule = node2.type.prop(ruleNodeProp);
  while (rule && rule.context && !node2.matchContext(rule.context))
    rule = rule.next;
  return rule || null;
}
const t = Tag.define;
const comment$1 = t(), name$1 = t(), typeName = t(name$1), propertyName = t(name$1), literal = t(), string = t(literal), number$8 = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();
const tags$5 = {
  comment: comment$1,
  lineComment: t(comment$1),
  blockComment: t(comment$1),
  docComment: t(comment$1),
  name: name$1,
  variableName: t(name$1),
  typeName,
  tagName: t(typeName),
  propertyName,
  attributeName: t(propertyName),
  className: t(name$1),
  labelName: t(name$1),
  namespace: t(name$1),
  macroName: t(name$1),
  literal,
  string,
  docString: t(string),
  character: t(string),
  attributeValue: t(string),
  number: number$8,
  integer: t(number$8),
  float: t(number$8),
  bool: t(literal),
  regexp: t(literal),
  escape: t(literal),
  color: t(literal),
  url: t(literal),
  keyword,
  self: t(keyword),
  null: t(keyword),
  atom: t(keyword),
  unit: t(keyword),
  modifier: t(keyword),
  operatorKeyword: t(keyword),
  controlKeyword: t(keyword),
  definitionKeyword: t(keyword),
  moduleKeyword: t(keyword),
  operator,
  derefOperator: t(operator),
  arithmeticOperator: t(operator),
  logicOperator: t(operator),
  bitwiseOperator: t(operator),
  compareOperator: t(operator),
  updateOperator: t(operator),
  definitionOperator: t(operator),
  typeOperator: t(operator),
  controlOperator: t(operator),
  punctuation,
  separator: t(punctuation),
  bracket,
  angleBracket: t(bracket),
  squareBracket: t(bracket),
  paren: t(bracket),
  brace: t(bracket),
  content,
  heading,
  heading1: t(heading),
  heading2: t(heading),
  heading3: t(heading),
  heading4: t(heading),
  heading5: t(heading),
  heading6: t(heading),
  contentSeparator: t(content),
  list: t(content),
  quote: t(content),
  emphasis: t(content),
  strong: t(content),
  link: t(content),
  monospace: t(content),
  strikethrough: t(content),
  inserted: t(),
  deleted: t(),
  changed: t(),
  invalid: t(),
  meta,
  documentMeta: t(meta),
  annotation: t(meta),
  processingInstruction: t(meta),
  definition: Tag.defineModifier(),
  constant: Tag.defineModifier(),
  function: Tag.defineModifier(),
  standard: Tag.defineModifier(),
  local: Tag.defineModifier(),
  special: Tag.defineModifier()
};
tagHighlighter([
  { tag: tags$5.link, class: "tok-link" },
  { tag: tags$5.heading, class: "tok-heading" },
  { tag: tags$5.emphasis, class: "tok-emphasis" },
  { tag: tags$5.strong, class: "tok-strong" },
  { tag: tags$5.keyword, class: "tok-keyword" },
  { tag: tags$5.atom, class: "tok-atom" },
  { tag: tags$5.bool, class: "tok-bool" },
  { tag: tags$5.url, class: "tok-url" },
  { tag: tags$5.labelName, class: "tok-labelName" },
  { tag: tags$5.inserted, class: "tok-inserted" },
  { tag: tags$5.deleted, class: "tok-deleted" },
  { tag: tags$5.literal, class: "tok-literal" },
  { tag: tags$5.string, class: "tok-string" },
  { tag: tags$5.number, class: "tok-number" },
  { tag: [tags$5.regexp, tags$5.escape, tags$5.special(tags$5.string)], class: "tok-string2" },
  { tag: tags$5.variableName, class: "tok-variableName" },
  { tag: tags$5.local(tags$5.variableName), class: "tok-variableName tok-local" },
  { tag: tags$5.definition(tags$5.variableName), class: "tok-variableName tok-definition" },
  { tag: tags$5.special(tags$5.variableName), class: "tok-variableName2" },
  { tag: tags$5.definition(tags$5.propertyName), class: "tok-propertyName tok-definition" },
  { tag: tags$5.typeName, class: "tok-typeName" },
  { tag: tags$5.namespace, class: "tok-namespace" },
  { tag: tags$5.className, class: "tok-className" },
  { tag: tags$5.macroName, class: "tok-macroName" },
  { tag: tags$5.propertyName, class: "tok-propertyName" },
  { tag: tags$5.operator, class: "tok-operator" },
  { tag: tags$5.comment, class: "tok-comment" },
  { tag: tags$5.meta, class: "tok-meta" },
  { tag: tags$5.invalid, class: "tok-invalid" },
  { tag: tags$5.punctuation, class: "tok-punctuation" }
]);
var _a;
const languageDataProp = /* @__PURE__ */ new NodeProp();
function defineLanguageFacet(baseData) {
  return Facet.define({
    combine: baseData ? (values2) => values2.concat(baseData) : void 0
  });
}
class Language {
  constructor(data2, parser2, extraExtensions = [], name2 = "") {
    this.data = data2;
    this.name = name2;
    if (!EditorState.prototype.hasOwnProperty("tree"))
      Object.defineProperty(EditorState.prototype, "tree", { get() {
        return syntaxTree(this);
      } });
    this.parser = parser2;
    this.extension = [
      language.of(this),
      EditorState.languageData.of((state, pos, side) => state.facet(languageDataFacetAt(state, pos, side)))
    ].concat(extraExtensions);
  }
  isActiveAt(state, pos, side = -1) {
    return languageDataFacetAt(state, pos, side) == this.data;
  }
  findRegions(state) {
    let lang2 = state.facet(language);
    if ((lang2 === null || lang2 === void 0 ? void 0 : lang2.data) == this.data)
      return [{ from: 0, to: state.doc.length }];
    if (!lang2 || !lang2.allowsNesting)
      return [];
    let result = [];
    let explore = (tree2, from2) => {
      if (tree2.prop(languageDataProp) == this.data) {
        result.push({ from: from2, to: from2 + tree2.length });
        return;
      }
      let mount = tree2.prop(NodeProp.mounted);
      if (mount) {
        if (mount.tree.prop(languageDataProp) == this.data) {
          if (mount.overlay)
            for (let r of mount.overlay)
              result.push({ from: r.from + from2, to: r.to + from2 });
          else
            result.push({ from: from2, to: from2 + tree2.length });
          return;
        } else if (mount.overlay) {
          let size = result.length;
          explore(mount.tree, mount.overlay[0].from + from2);
          if (result.length > size)
            return;
        }
      }
      for (let i = 0; i < tree2.children.length; i++) {
        let ch = tree2.children[i];
        if (ch instanceof Tree)
          explore(ch, tree2.positions[i] + from2);
      }
    };
    explore(syntaxTree(state), 0);
    return result;
  }
  get allowsNesting() {
    return true;
  }
}
Language.setState = /* @__PURE__ */ StateEffect.define();
function languageDataFacetAt(state, pos, side) {
  let topLang = state.facet(language);
  if (!topLang)
    return null;
  let facet = topLang.data;
  if (topLang.allowsNesting) {
    for (let node2 = syntaxTree(state).topNode; node2; node2 = node2.enter(pos, side, IterMode.ExcludeBuffers))
      facet = node2.type.prop(languageDataProp) || facet;
  }
  return facet;
}
class LRLanguage extends Language {
  constructor(data2, parser2, name2) {
    super(data2, parser2, [], name2);
    this.parser = parser2;
  }
  static define(spec) {
    let data2 = defineLanguageFacet(spec.languageData);
    return new LRLanguage(data2, spec.parser.configure({
      props: [languageDataProp.add((type2) => type2.isTop ? data2 : void 0)]
    }), spec.name);
  }
  configure(options2, name2) {
    return new LRLanguage(this.data, this.parser.configure(options2), name2 || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function syntaxTree(state) {
  let field = state.field(Language.state, false);
  return field ? field.tree : Tree.empty;
}
function ensureSyntaxTree(state, upto, timeout2 = 50) {
  var _a2;
  let parse2 = (_a2 = state.field(Language.state, false)) === null || _a2 === void 0 ? void 0 : _a2.context;
  return !parse2 ? null : parse2.isDone(upto) || parse2.work(timeout2, upto) ? parse2.tree : null;
}
class DocInput {
  constructor(doc2, length2 = doc2.length) {
    this.doc = doc2;
    this.length = length2;
    this.cursorPos = 0;
    this.string = "";
    this.cursor = doc2.iter();
  }
  syncTo(pos) {
    this.string = this.cursor.next(pos - this.cursorPos).value;
    this.cursorPos = pos + this.string.length;
    return this.cursorPos - this.string.length;
  }
  chunk(pos) {
    this.syncTo(pos);
    return this.string;
  }
  get lineChunks() {
    return true;
  }
  read(from2, to2) {
    let stringStart = this.cursorPos - this.string.length;
    if (from2 < stringStart || to2 >= this.cursorPos)
      return this.doc.sliceString(from2, to2);
    else
      return this.string.slice(from2 - stringStart, to2 - stringStart);
  }
}
let currentContext = null;
class ParseContext {
  constructor(parser2, state, fragments = [], tree2, treeLen, viewport, skipped, scheduleOn) {
    this.parser = parser2;
    this.state = state;
    this.fragments = fragments;
    this.tree = tree2;
    this.treeLen = treeLen;
    this.viewport = viewport;
    this.skipped = skipped;
    this.scheduleOn = scheduleOn;
    this.parse = null;
    this.tempSkipped = [];
  }
  static create(parser2, state, viewport) {
    return new ParseContext(parser2, state, [], Tree.empty, 0, viewport, [], null);
  }
  startParse() {
    return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
  }
  work(until, upto) {
    if (upto != null && upto >= this.state.doc.length)
      upto = void 0;
    if (this.tree != Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
      this.takeTree();
      return true;
    }
    return this.withContext(() => {
      var _a2;
      if (typeof until == "number") {
        let endTime = Date.now() + until;
        until = () => Date.now() > endTime;
      }
      if (!this.parse)
        this.parse = this.startParse();
      if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length)
        this.parse.stopAt(upto);
      for (; ; ) {
        let done = this.parse.advance();
        if (done) {
          this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
          this.treeLen = (_a2 = this.parse.stoppedAt) !== null && _a2 !== void 0 ? _a2 : this.state.doc.length;
          this.tree = done;
          this.parse = null;
          if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
            this.parse = this.startParse();
          else
            return true;
        }
        if (until())
          return false;
      }
    });
  }
  takeTree() {
    let pos, tree2;
    if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
      if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
        this.parse.stopAt(pos);
      this.withContext(() => {
        while (!(tree2 = this.parse.advance())) {
        }
      });
      this.treeLen = pos;
      this.tree = tree2;
      this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
      this.parse = null;
    }
  }
  withContext(f2) {
    let prev2 = currentContext;
    currentContext = this;
    try {
      return f2();
    } finally {
      currentContext = prev2;
    }
  }
  withoutTempSkipped(fragments) {
    for (let r; r = this.tempSkipped.pop(); )
      fragments = cutFragments(fragments, r.from, r.to);
    return fragments;
  }
  changes(changes, newState) {
    let { fragments, tree: tree2, treeLen, viewport, skipped } = this;
    this.takeTree();
    if (!changes.empty) {
      let ranges2 = [];
      changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges2.push({ fromA, toA, fromB, toB }));
      fragments = TreeFragment.applyChanges(fragments, ranges2);
      tree2 = Tree.empty;
      treeLen = 0;
      viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
      if (this.skipped.length) {
        skipped = [];
        for (let r of this.skipped) {
          let from2 = changes.mapPos(r.from, 1), to2 = changes.mapPos(r.to, -1);
          if (from2 < to2)
            skipped.push({ from: from2, to: to2 });
        }
      }
    }
    return new ParseContext(this.parser, newState, fragments, tree2, treeLen, viewport, skipped, this.scheduleOn);
  }
  updateViewport(viewport) {
    if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
      return false;
    this.viewport = viewport;
    let startLen = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let { from: from2, to: to2 } = this.skipped[i];
      if (from2 < viewport.to && to2 > viewport.from) {
        this.fragments = cutFragments(this.fragments, from2, to2);
        this.skipped.splice(i--, 1);
      }
    }
    if (this.skipped.length >= startLen)
      return false;
    this.reset();
    return true;
  }
  reset() {
    if (this.parse) {
      this.takeTree();
      this.parse = null;
    }
  }
  skipUntilInView(from2, to2) {
    this.skipped.push({ from: from2, to: to2 });
  }
  static getSkippingParser(until) {
    return new class extends Parser {
      createParse(input, fragments, ranges2) {
        let from2 = ranges2[0].from, to2 = ranges2[ranges2.length - 1].to;
        let parser2 = {
          parsedPos: from2,
          advance() {
            let cx = currentContext;
            if (cx) {
              for (let r of ranges2)
                cx.tempSkipped.push(r);
              if (until)
                cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
            }
            this.parsedPos = to2;
            return new Tree(NodeType.none, [], [], to2 - from2);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
        return parser2;
      }
    }();
  }
  isDone(upto) {
    upto = Math.min(upto, this.state.doc.length);
    let frags = this.fragments;
    return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
  }
  static get() {
    return currentContext;
  }
}
function cutFragments(fragments, from2, to2) {
  return TreeFragment.applyChanges(fragments, [{ fromA: from2, toA: to2, fromB: from2, toB: to2 }]);
}
class LanguageState {
  constructor(context) {
    this.context = context;
    this.tree = context.tree;
  }
  apply(tr) {
    if (!tr.docChanged && this.tree == this.context.tree)
      return this;
    let newCx = this.context.changes(tr.changes, tr.state);
    let upto = this.context.treeLen == tr.startState.doc.length ? void 0 : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
    if (!newCx.work(20, upto))
      newCx.takeTree();
    return new LanguageState(newCx);
  }
  static init(state) {
    let vpTo = Math.min(3e3, state.doc.length);
    let parseState = ParseContext.create(state.facet(language).parser, state, { from: 0, to: vpTo });
    if (!parseState.work(20, vpTo))
      parseState.takeTree();
    return new LanguageState(parseState);
  }
}
Language.state = /* @__PURE__ */ StateField.define({
  create: LanguageState.init,
  update(value, tr) {
    for (let e of tr.effects)
      if (e.is(Language.setState))
        return e.value;
    if (tr.startState.facet(language) != tr.state.facet(language))
      return LanguageState.init(tr.state);
    return value.apply(tr);
  }
});
let requestIdle = (callback) => {
  let timeout2 = setTimeout(() => callback(), 500);
  return () => clearTimeout(timeout2);
};
if (typeof requestIdleCallback != "undefined")
  requestIdle = (callback) => {
    let idle = -1, timeout2 = setTimeout(() => {
      idle = requestIdleCallback(callback, { timeout: 500 - 100 });
    }, 100);
    return () => idle < 0 ? clearTimeout(timeout2) : cancelIdleCallback(idle);
  };
const isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
const parseWorker = /* @__PURE__ */ ViewPlugin.fromClass(class ParseWorker {
  constructor(view) {
    this.view = view;
    this.working = null;
    this.workScheduled = 0;
    this.chunkEnd = -1;
    this.chunkBudget = -1;
    this.work = this.work.bind(this);
    this.scheduleWork();
  }
  update(update) {
    let cx = this.view.state.field(Language.state).context;
    if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)
      this.scheduleWork();
    if (update.docChanged) {
      if (this.view.hasFocus)
        this.chunkBudget += 50;
      this.scheduleWork();
    }
    this.checkAsyncSchedule(cx);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state } = this.view, field = state.field(Language.state);
    if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))
      this.working = requestIdle(this.work);
  }
  work(deadline) {
    this.working = null;
    let now2 = Date.now();
    if (this.chunkEnd < now2 && (this.chunkEnd < 0 || this.view.hasFocus)) {
      this.chunkEnd = now2 + 3e4;
      this.chunkBudget = 3e3;
    }
    if (this.chunkBudget <= 0)
      return;
    let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);
    if (field.tree == field.context.tree && field.context.isDone(vpTo + 1e5))
      return;
    let endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
    let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1e3;
    let done = field.context.work(() => {
      return isInputPending && isInputPending() || Date.now() > endTime;
    }, vpTo + (viewportFirst ? 0 : 1e5));
    this.chunkBudget -= Date.now() - now2;
    if (done || this.chunkBudget <= 0) {
      field.context.takeTree();
      this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
    }
    if (this.chunkBudget > 0 && !(done && !viewportFirst))
      this.scheduleWork();
    this.checkAsyncSchedule(field.context);
  }
  checkAsyncSchedule(cx) {
    if (cx.scheduleOn) {
      this.workScheduled++;
      cx.scheduleOn.then(() => this.scheduleWork()).catch((err) => logException(this.view.state, err)).then(() => this.workScheduled--);
      cx.scheduleOn = null;
    }
  }
  destroy() {
    if (this.working)
      this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
});
const language = /* @__PURE__ */ Facet.define({
  combine(languages2) {
    return languages2.length ? languages2[0] : null;
  },
  enables: (language2) => [
    Language.state,
    parseWorker,
    EditorView.contentAttributes.compute([language2], (state) => {
      let lang2 = state.facet(language2);
      return lang2 && lang2.name ? { "data-language": lang2.name } : {};
    })
  ]
});
class LanguageSupport {
  constructor(language2, support = []) {
    this.language = language2;
    this.support = support;
    this.extension = [language2, support];
  }
}
class LanguageDescription {
  constructor(name2, alias, extensions, filename, loadFunc, support = void 0) {
    this.name = name2;
    this.alias = alias;
    this.extensions = extensions;
    this.filename = filename;
    this.loadFunc = loadFunc;
    this.support = support;
    this.loading = null;
  }
  load() {
    return this.loading || (this.loading = this.loadFunc().then((support) => this.support = support, (err) => {
      this.loading = null;
      throw err;
    }));
  }
  static of(spec) {
    let { load, support } = spec;
    if (!load) {
      if (!support)
        throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
      load = () => Promise.resolve(support);
    }
    return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map((s2) => s2.toLowerCase()), spec.extensions || [], spec.filename, load, support);
  }
  static matchFilename(descs, filename) {
    for (let d of descs)
      if (d.filename && d.filename.test(filename))
        return d;
    let ext = /\.([^.]+)$/.exec(filename);
    if (ext) {
      for (let d of descs)
        if (d.extensions.indexOf(ext[1]) > -1)
          return d;
    }
    return null;
  }
  static matchLanguageName(descs, name2, fuzzy = true) {
    name2 = name2.toLowerCase();
    for (let d of descs)
      if (d.alias.some((a2) => a2 == name2))
        return d;
    if (fuzzy)
      for (let d of descs)
        for (let a2 of d.alias) {
          let found = name2.indexOf(a2);
          if (found > -1 && (a2.length > 2 || !/\w/.test(name2[found - 1]) && !/\w/.test(name2[found + a2.length])))
            return d;
        }
    return null;
  }
}
const indentService = /* @__PURE__ */ Facet.define();
const indentUnit = /* @__PURE__ */ Facet.define({
  combine: (values2) => {
    if (!values2.length)
      return "  ";
    if (!/^(?: +|\t+)$/.test(values2[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(values2[0]));
    return values2[0];
  }
});
function getIndentUnit(state) {
  let unit2 = state.facet(indentUnit);
  return unit2.charCodeAt(0) == 9 ? state.tabSize * unit2.length : unit2.length;
}
function indentString(state, cols) {
  let result = "", ts = state.tabSize;
  if (state.facet(indentUnit).charCodeAt(0) == 9)
    while (cols >= ts) {
      result += "	";
      cols -= ts;
    }
  for (let i = 0; i < cols; i++)
    result += " ";
  return result;
}
function getIndentation(context, pos) {
  if (context instanceof EditorState)
    context = new IndentContext(context);
  for (let service of context.state.facet(indentService)) {
    let result = service(context, pos);
    if (result != null)
      return result;
  }
  let tree2 = syntaxTree(context.state);
  return tree2 ? syntaxIndentation(context, tree2, pos) : null;
}
class IndentContext {
  constructor(state, options2 = {}) {
    this.state = state;
    this.options = options2;
    this.unit = getIndentUnit(state);
  }
  lineAt(pos, bias = 1) {
    let line2 = this.state.doc.lineAt(pos);
    let { simulateBreak, simulateDoubleBreak } = this.options;
    if (simulateBreak != null && simulateBreak >= line2.from && simulateBreak <= line2.to) {
      if (simulateDoubleBreak && simulateBreak == pos)
        return { text: "", from: pos };
      else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
        return { text: line2.text.slice(simulateBreak - line2.from), from: simulateBreak };
      else
        return { text: line2.text.slice(0, simulateBreak - line2.from), from: line2.from };
    }
    return line2;
  }
  textAfterPos(pos, bias = 1) {
    if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
      return "";
    let { text: text2, from: from2 } = this.lineAt(pos, bias);
    return text2.slice(pos - from2, Math.min(text2.length, pos + 100 - from2));
  }
  column(pos, bias = 1) {
    let { text: text2, from: from2 } = this.lineAt(pos, bias);
    let result = this.countColumn(text2, pos - from2);
    let override = this.options.overrideIndentation ? this.options.overrideIndentation(from2) : -1;
    if (override > -1)
      result += override - this.countColumn(text2, text2.search(/\S|$/));
    return result;
  }
  countColumn(line2, pos = line2.length) {
    return countColumn(line2, this.state.tabSize, pos);
  }
  lineIndent(pos, bias = 1) {
    let { text: text2, from: from2 } = this.lineAt(pos, bias);
    let override = this.options.overrideIndentation;
    if (override) {
      let overriden = override(from2);
      if (overriden > -1)
        return overriden;
    }
    return this.countColumn(text2, text2.search(/\S|$/));
  }
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const indentNodeProp = /* @__PURE__ */ new NodeProp();
function syntaxIndentation(cx, ast, pos) {
  return indentFrom(ast.resolveInner(pos).enterUnfinishedNodesBefore(pos), pos, cx);
}
function ignoreClosed(cx) {
  return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
}
function indentStrategy(tree2) {
  let strategy = tree2.type.prop(indentNodeProp);
  if (strategy)
    return strategy;
  let first = tree2.firstChild, close;
  if (first && (close = first.type.prop(NodeProp.closedBy))) {
    let last = tree2.lastChild, closed = last && close.indexOf(last.name) > -1;
    return (cx) => delimitedStrategy(cx, true, 1, void 0, closed && !ignoreClosed(cx) ? last.from : void 0);
  }
  return tree2.parent == null ? topIndent : null;
}
function indentFrom(node2, pos, base2) {
  for (; node2; node2 = node2.parent) {
    let strategy = indentStrategy(node2);
    if (strategy)
      return strategy(TreeIndentContext.create(base2, pos, node2));
  }
  return null;
}
function topIndent() {
  return 0;
}
class TreeIndentContext extends IndentContext {
  constructor(base2, pos, node2) {
    super(base2.state, base2.options);
    this.base = base2;
    this.pos = pos;
    this.node = node2;
  }
  static create(base2, pos, node2) {
    return new TreeIndentContext(base2, pos, node2);
  }
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  get baseIndent() {
    let line2 = this.state.doc.lineAt(this.node.from);
    for (; ; ) {
      let atBreak = this.node.resolve(line2.from);
      while (atBreak.parent && atBreak.parent.from == atBreak.from)
        atBreak = atBreak.parent;
      if (isParent(atBreak, this.node))
        break;
      line2 = this.state.doc.lineAt(atBreak.from);
    }
    return this.lineIndent(line2.from);
  }
  continue() {
    let parent = this.node.parent;
    return parent ? indentFrom(parent, this.pos, this.base) : 0;
  }
}
function isParent(parent, of) {
  for (let cur2 = of; cur2; cur2 = cur2.parent)
    if (parent == cur2)
      return true;
  return false;
}
function bracketedAligned(context) {
  let tree2 = context.node;
  let openToken = tree2.childAfter(tree2.from), last = tree2.lastChild;
  if (!openToken)
    return null;
  let sim = context.options.simulateBreak;
  let openLine = context.state.doc.lineAt(openToken.from);
  let lineEnd2 = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
  for (let pos = openToken.to; ; ) {
    let next2 = tree2.childAfter(pos);
    if (!next2 || next2 == last)
      return null;
    if (!next2.type.isSkipped)
      return next2.from < lineEnd2 ? openToken : null;
    pos = next2.to;
  }
}
function delimitedIndent({ closing: closing2, align = true, units = 1 }) {
  return (context) => delimitedStrategy(context, align, units, closing2);
}
function delimitedStrategy(context, align, units, closing2, closedAt) {
  let after = context.textAfter, space2 = after.match(/^\s*/)[0].length;
  let closed = closing2 && after.slice(space2, space2 + closing2.length) == closing2 || closedAt == context.pos + space2;
  let aligned = align ? bracketedAligned(context) : null;
  if (aligned)
    return closed ? context.column(aligned.from) : context.column(aligned.to);
  return context.baseIndent + (closed ? 0 : context.unit * units);
}
const flatIndent = (context) => context.baseIndent;
function continuedIndent({ except, units = 1 } = {}) {
  return (context) => {
    let matchExcept = except && except.test(context.textAfter);
    return context.baseIndent + (matchExcept ? 0 : units * context.unit);
  };
}
const foldService = /* @__PURE__ */ Facet.define();
const foldNodeProp = /* @__PURE__ */ new NodeProp();
function foldInside(node2) {
  let first = node2.firstChild, last = node2.lastChild;
  return first && first.to < last.from ? { from: first.to, to: last.type.isError ? node2.to : last.from } : null;
}
function syntaxFolding(state, start2, end2) {
  let tree2 = syntaxTree(state);
  if (tree2.length < end2)
    return null;
  let inner = tree2.resolveInner(end2);
  let found = null;
  for (let cur2 = inner; cur2; cur2 = cur2.parent) {
    if (cur2.to <= end2 || cur2.from > end2)
      continue;
    if (found && cur2.from < start2)
      break;
    let prop = cur2.type.prop(foldNodeProp);
    if (prop && (cur2.to < tree2.length - 50 || tree2.length == state.doc.length || !isUnfinished(cur2))) {
      let value = prop(cur2, state);
      if (value && value.from <= end2 && value.from >= start2 && value.to > end2)
        found = value;
    }
  }
  return found;
}
function isUnfinished(node2) {
  let ch = node2.lastChild;
  return ch && ch.to == node2.to && ch.type.isError;
}
function foldable(state, lineStart, lineEnd2) {
  for (let service of state.facet(foldService)) {
    let result = service(state, lineStart, lineEnd2);
    if (result)
      return result;
  }
  return syntaxFolding(state, lineStart, lineEnd2);
}
function mapRange(range2, mapping) {
  let from2 = mapping.mapPos(range2.from, 1), to2 = mapping.mapPos(range2.to, -1);
  return from2 >= to2 ? void 0 : { from: from2, to: to2 };
}
const foldEffect = /* @__PURE__ */ StateEffect.define({ map: mapRange });
const unfoldEffect = /* @__PURE__ */ StateEffect.define({ map: mapRange });
function selectedLines(view) {
  let lines = [];
  for (let { head: head2 } of view.state.selection.ranges) {
    if (lines.some((l2) => l2.from <= head2 && l2.to >= head2))
      continue;
    lines.push(view.lineBlockAt(head2));
  }
  return lines;
}
const foldState = /* @__PURE__ */ StateField.define({
  create() {
    return Decoration.none;
  },
  update(folded, tr) {
    folded = folded.map(tr.changes);
    for (let e of tr.effects) {
      if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to))
        folded = folded.update({ add: [foldWidget.range(e.value.from, e.value.to)] });
      else if (e.is(unfoldEffect))
        folded = folded.update({
          filter: (from2, to2) => e.value.from != from2 || e.value.to != to2,
          filterFrom: e.value.from,
          filterTo: e.value.to
        });
    }
    if (tr.selection) {
      let onSelection = false, { head: head2 } = tr.selection.main;
      folded.between(head2, head2, (a2, b) => {
        if (a2 < head2 && b > head2)
          onSelection = true;
      });
      if (onSelection)
        folded = folded.update({
          filterFrom: head2,
          filterTo: head2,
          filter: (a2, b) => b <= head2 || a2 >= head2
        });
    }
    return folded;
  },
  provide: (f2) => EditorView.decorations.from(f2),
  toJSON(folded, state) {
    let ranges2 = [];
    folded.between(0, state.doc.length, (from2, to2) => {
      ranges2.push(from2, to2);
    });
    return ranges2;
  },
  fromJSON(value) {
    if (!Array.isArray(value) || value.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let ranges2 = [];
    for (let i = 0; i < value.length; ) {
      let from2 = value[i++], to2 = value[i++];
      if (typeof from2 != "number" || typeof to2 != "number")
        throw new RangeError("Invalid JSON for fold state");
      ranges2.push(foldWidget.range(from2, to2));
    }
    return Decoration.set(ranges2, true);
  }
});
function findFold(state, from2, to2) {
  var _a2;
  let found = null;
  (_a2 = state.field(foldState, false)) === null || _a2 === void 0 ? void 0 : _a2.between(from2, to2, (from3, to3) => {
    if (!found || found.from > from3)
      found = { from: from3, to: to3 };
  });
  return found;
}
function foldExists(folded, from2, to2) {
  let found = false;
  folded.between(from2, from2, (a2, b) => {
    if (a2 == from2 && b == to2)
      found = true;
  });
  return found;
}
function maybeEnable(state, other) {
  return state.field(foldState, false) ? other : other.concat(StateEffect.appendConfig.of(codeFolding()));
}
const foldCode = (view) => {
  for (let line2 of selectedLines(view)) {
    let range2 = foldable(view.state, line2.from, line2.to);
    if (range2) {
      view.dispatch({ effects: maybeEnable(view.state, [foldEffect.of(range2), announceFold(view, range2)]) });
      return true;
    }
  }
  return false;
};
function announceFold(view, range2, fold = true) {
  let lineFrom = view.state.doc.lineAt(range2.from).number, lineTo = view.state.doc.lineAt(range2.to).number;
  return EditorView.announce.of(`${view.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view.state.phrase("to")} ${lineTo}.`);
}
const defaultConfig$1 = {
  placeholderDOM: null,
  placeholderText: "\u2026"
};
const foldConfig = /* @__PURE__ */ Facet.define({
  combine(values2) {
    return combineConfig(values2, defaultConfig$1);
  }
});
function codeFolding(config2) {
  let result = [foldState, baseTheme$1];
  if (config2)
    result.push(foldConfig.of(config2));
  return result;
}
const foldWidget = /* @__PURE__ */ Decoration.replace({ widget: /* @__PURE__ */ new class extends WidgetType {
  toDOM(view) {
    let { state } = view, conf2 = state.facet(foldConfig);
    let onclick = (event2) => {
      let line2 = view.lineBlockAt(view.posAtDOM(event2.target));
      let folded = findFold(view.state, line2.from, line2.to);
      if (folded)
        view.dispatch({ effects: unfoldEffect.of(folded) });
      event2.preventDefault();
    };
    if (conf2.placeholderDOM)
      return conf2.placeholderDOM(view, onclick);
    let element = document.createElement("span");
    element.textContent = conf2.placeholderText;
    element.setAttribute("aria-label", state.phrase("folded code"));
    element.title = state.phrase("unfold");
    element.className = "cm-foldPlaceholder";
    element.onclick = onclick;
    return element;
  }
}() });
const baseTheme$1 = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class HighlightStyle {
  constructor(specs, options2) {
    this.specs = specs;
    let modSpec;
    function def(spec) {
      let cls = StyleModule.newName();
      (modSpec || (modSpec = /* @__PURE__ */ Object.create(null)))["." + cls] = spec;
      return cls;
    }
    const all = typeof options2.all == "string" ? options2.all : options2.all ? def(options2.all) : void 0;
    const scopeOpt = options2.scope;
    this.scope = scopeOpt instanceof Language ? (type2) => type2.prop(languageDataProp) == scopeOpt.data : scopeOpt ? (type2) => type2 == scopeOpt : void 0;
    this.style = tagHighlighter(specs.map((style2) => ({
      tag: style2.tag,
      class: style2.class || def(Object.assign({}, style2, { tag: null }))
    })), {
      all
    }).style;
    this.module = modSpec ? new StyleModule(modSpec) : null;
    this.themeType = options2.themeType;
  }
  static define(specs, options2) {
    return new HighlightStyle(specs, options2 || {});
  }
}
const highlighterFacet = /* @__PURE__ */ Facet.define();
const fallbackHighlighter = /* @__PURE__ */ Facet.define({
  combine(values2) {
    return values2.length ? [values2[0]] : null;
  }
});
function getHighlighters(state) {
  let main2 = state.facet(highlighterFacet);
  return main2.length ? main2 : state.facet(fallbackHighlighter);
}
function syntaxHighlighting(highlighter, options2) {
  let ext = [treeHighlighter], themeType;
  if (highlighter instanceof HighlightStyle) {
    if (highlighter.module)
      ext.push(EditorView.styleModule.of(highlighter.module));
    themeType = highlighter.themeType;
  }
  if (options2 === null || options2 === void 0 ? void 0 : options2.fallback)
    ext.push(fallbackHighlighter.of(highlighter));
  else if (themeType)
    ext.push(highlighterFacet.computeN([EditorView.darkTheme], (state) => {
      return state.facet(EditorView.darkTheme) == (themeType == "dark") ? [highlighter] : [];
    }));
  else
    ext.push(highlighterFacet.of(highlighter));
  return ext;
}
class TreeHighlighter {
  constructor(view) {
    this.markCache = /* @__PURE__ */ Object.create(null);
    this.tree = syntaxTree(view.state);
    this.decorations = this.buildDeco(view, getHighlighters(view.state));
  }
  update(update) {
    let tree2 = syntaxTree(update.state), highlighters = getHighlighters(update.state);
    let styleChange = highlighters != getHighlighters(update.startState);
    if (tree2.length < update.view.viewport.to && !styleChange && tree2.type == this.tree.type) {
      this.decorations = this.decorations.map(update.changes);
    } else if (tree2 != this.tree || update.viewportChanged || styleChange) {
      this.tree = tree2;
      this.decorations = this.buildDeco(update.view, highlighters);
    }
  }
  buildDeco(view, highlighters) {
    if (!highlighters || !this.tree.length)
      return Decoration.none;
    let builder = new RangeSetBuilder();
    for (let { from: from2, to: to2 } of view.visibleRanges) {
      highlightTree(this.tree, highlighters, (from3, to3, style2) => {
        builder.add(from3, to3, this.markCache[style2] || (this.markCache[style2] = Decoration.mark({ class: style2 })));
      }, from2, to2);
    }
    return builder.finish();
  }
}
const treeHighlighter = /* @__PURE__ */ Prec.high(/* @__PURE__ */ ViewPlugin.fromClass(TreeHighlighter, {
  decorations: (v) => v.decorations
}));
/* @__PURE__ */ HighlightStyle.define([
  {
    tag: tags$5.meta,
    color: "#7a757a"
  },
  {
    tag: tags$5.link,
    textDecoration: "underline"
  },
  {
    tag: tags$5.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: tags$5.emphasis,
    fontStyle: "italic"
  },
  {
    tag: tags$5.strong,
    fontWeight: "bold"
  },
  {
    tag: tags$5.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: tags$5.keyword,
    color: "#708"
  },
  {
    tag: [tags$5.atom, tags$5.bool, tags$5.url, tags$5.contentSeparator, tags$5.labelName],
    color: "#219"
  },
  {
    tag: [tags$5.literal, tags$5.inserted],
    color: "#164"
  },
  {
    tag: [tags$5.string, tags$5.deleted],
    color: "#a11"
  },
  {
    tag: [tags$5.regexp, tags$5.escape, /* @__PURE__ */ tags$5.special(tags$5.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ tags$5.definition(tags$5.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ tags$5.local(tags$5.variableName),
    color: "#30a"
  },
  {
    tag: [tags$5.typeName, tags$5.namespace],
    color: "#085"
  },
  {
    tag: tags$5.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ tags$5.special(tags$5.variableName), tags$5.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ tags$5.definition(tags$5.propertyName),
    color: "#00c"
  },
  {
    tag: tags$5.comment,
    color: "#940"
  },
  {
    tag: tags$5.invalid,
    color: "#f00"
  }
]);
const DefaultScanDist = 1e4, DefaultBrackets = "()[]{}";
function matchingNodes(node2, dir, brackets) {
  let byProp = node2.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);
  if (byProp)
    return byProp;
  if (node2.name.length == 1) {
    let index2 = brackets.indexOf(node2.name);
    if (index2 > -1 && index2 % 2 == (dir < 0 ? 1 : 0))
      return [brackets[index2 + dir]];
  }
  return null;
}
function matchBrackets(state, pos, dir, config2 = {}) {
  let maxScanDistance = config2.maxScanDistance || DefaultScanDist, brackets = config2.brackets || DefaultBrackets;
  let tree2 = syntaxTree(state), node2 = tree2.resolveInner(pos, dir);
  for (let cur2 = node2; cur2; cur2 = cur2.parent) {
    let matches = matchingNodes(cur2.type, dir, brackets);
    if (matches && cur2.from < cur2.to)
      return matchMarkedBrackets(state, pos, dir, cur2, matches, brackets);
  }
  return matchPlainBrackets(state, pos, dir, tree2, node2.type, maxScanDistance, brackets);
}
function matchMarkedBrackets(_state, _pos, dir, token2, matching, brackets) {
  let parent = token2.parent, firstToken = { from: token2.from, to: token2.to };
  let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();
  if (cursor && (dir < 0 ? cursor.childBefore(token2.from) : cursor.childAfter(token2.to)))
    do {
      if (dir < 0 ? cursor.to <= token2.from : cursor.from >= token2.to) {
        if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {
          return { start: firstToken, end: { from: cursor.from, to: cursor.to }, matched: true };
        } else if (matchingNodes(cursor.type, dir, brackets)) {
          depth++;
        } else if (matchingNodes(cursor.type, -dir, brackets)) {
          if (depth == 0)
            return {
              start: firstToken,
              end: cursor.from == cursor.to ? void 0 : { from: cursor.from, to: cursor.to },
              matched: false
            };
          depth--;
        }
      }
    } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());
  return { start: firstToken, matched: false };
}
function matchPlainBrackets(state, pos, dir, tree2, tokenType, maxScanDistance, brackets) {
  let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
  let bracket2 = brackets.indexOf(startCh);
  if (bracket2 < 0 || bracket2 % 2 == 0 != dir > 0)
    return null;
  let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };
  let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;
  for (let distance2 = 0; !iter.next().done && distance2 <= maxScanDistance; ) {
    let text2 = iter.value;
    if (dir < 0)
      distance2 += text2.length;
    let basePos = pos + distance2 * dir;
    for (let pos2 = dir > 0 ? 0 : text2.length - 1, end2 = dir > 0 ? text2.length : -1; pos2 != end2; pos2 += dir) {
      let found = brackets.indexOf(text2[pos2]);
      if (found < 0 || tree2.resolveInner(basePos + pos2, 1).type != tokenType)
        continue;
      if (found % 2 == 0 == dir > 0) {
        depth++;
      } else if (depth == 1) {
        return { start: startToken, end: { from: basePos + pos2, to: basePos + pos2 + 1 }, matched: found >> 1 == bracket2 >> 1 };
      } else {
        depth--;
      }
    }
    if (dir > 0)
      distance2 += text2.length;
  }
  return iter.done ? { start: startToken, matched: false } : null;
}
function countCol(string2, end2, tabSize, startIndex = 0, startValue = 0) {
  if (end2 == null) {
    end2 = string2.search(/[^\s\u00a0]/);
    if (end2 == -1)
      end2 = string2.length;
  }
  let n = startValue;
  for (let i = startIndex; i < end2; i++) {
    if (string2.charCodeAt(i) == 9)
      n += tabSize - n % tabSize;
    else
      n++;
  }
  return n;
}
class StringStream {
  constructor(string2, tabSize, indentUnit2) {
    this.string = string2;
    this.tabSize = tabSize;
    this.indentUnit = indentUnit2;
    this.pos = 0;
    this.start = 0;
    this.lastColumnPos = 0;
    this.lastColumnValue = 0;
  }
  eol() {
    return this.pos >= this.string.length;
  }
  sol() {
    return this.pos == 0;
  }
  peek() {
    return this.string.charAt(this.pos) || void 0;
  }
  next() {
    if (this.pos < this.string.length)
      return this.string.charAt(this.pos++);
  }
  eat(match) {
    let ch = this.string.charAt(this.pos);
    let ok;
    if (typeof match == "string")
      ok = ch == match;
    else
      ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch));
    if (ok) {
      ++this.pos;
      return ch;
    }
  }
  eatWhile(match) {
    let start2 = this.pos;
    while (this.eat(match)) {
    }
    return this.pos > start2;
  }
  eatSpace() {
    let start2 = this.pos;
    while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))
      ++this.pos;
    return this.pos > start2;
  }
  skipToEnd() {
    this.pos = this.string.length;
  }
  skipTo(ch) {
    let found = this.string.indexOf(ch, this.pos);
    if (found > -1) {
      this.pos = found;
      return true;
    }
  }
  backUp(n) {
    this.pos -= n;
  }
  column() {
    if (this.lastColumnPos < this.start) {
      this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
      this.lastColumnPos = this.start;
    }
    return this.lastColumnValue;
  }
  indentation() {
    return countCol(this.string, null, this.tabSize);
  }
  match(pattern, consume, caseInsensitive) {
    if (typeof pattern == "string") {
      let cased = (str) => caseInsensitive ? str.toLowerCase() : str;
      let substr2 = this.string.substr(this.pos, pattern.length);
      if (cased(substr2) == cased(pattern)) {
        if (consume !== false)
          this.pos += pattern.length;
        return true;
      } else
        return null;
    } else {
      let match = this.string.slice(this.pos).match(pattern);
      if (match && match.index > 0)
        return null;
      if (match && consume !== false)
        this.pos += match[0].length;
      return match;
    }
  }
  current() {
    return this.string.slice(this.start, this.pos);
  }
}
function fullParser(spec) {
  return {
    name: spec.name || "",
    token: spec.token,
    blankLine: spec.blankLine || (() => {
    }),
    startState: spec.startState || (() => true),
    copyState: spec.copyState || defaultCopyState,
    indent: spec.indent || (() => null),
    languageData: spec.languageData || {},
    tokenTable: spec.tokenTable || noTokens
  };
}
function defaultCopyState(state) {
  if (typeof state != "object")
    return state;
  let newState = {};
  for (let prop in state) {
    let val = state[prop];
    newState[prop] = val instanceof Array ? val.slice() : val;
  }
  return newState;
}
class StreamLanguage extends Language {
  constructor(parser2) {
    let data2 = defineLanguageFacet(parser2.languageData);
    let p = fullParser(parser2), self2;
    let impl = new class extends Parser {
      createParse(input, fragments, ranges2) {
        return new Parse$1(self2, input, fragments, ranges2);
      }
    }();
    super(data2, impl, [indentService.of((cx, pos) => this.getIndent(cx, pos))], parser2.name);
    this.topNode = docID(data2);
    self2 = this;
    this.streamParser = p;
    this.stateAfter = new NodeProp({ perNode: true });
    this.tokenTable = parser2.tokenTable ? new TokenTable(p.tokenTable) : defaultTokenTable;
  }
  static define(spec) {
    return new StreamLanguage(spec);
  }
  getIndent(cx, pos) {
    let tree2 = syntaxTree(cx.state), at = tree2.resolve(pos);
    while (at && at.type != this.topNode)
      at = at.parent;
    if (!at)
      return null;
    let start2 = findState(this, tree2, 0, at.from, pos), statePos, state;
    if (start2) {
      state = start2.state;
      statePos = start2.pos + 1;
    } else {
      state = this.streamParser.startState(cx.unit);
      statePos = 0;
    }
    if (pos - statePos > 1e4)
      return null;
    while (statePos < pos) {
      let line2 = cx.state.doc.lineAt(statePos), end2 = Math.min(pos, line2.to);
      if (line2.length) {
        let stream = new StringStream(line2.text, cx.state.tabSize, cx.unit);
        while (stream.pos < end2 - line2.from)
          readToken$1(this.streamParser.token, stream, state);
      } else {
        this.streamParser.blankLine(state, cx.unit);
      }
      if (end2 == pos)
        break;
      statePos = line2.to + 1;
    }
    let { text: text2 } = cx.lineAt(pos);
    return this.streamParser.indent(state, /^\s*(.*)/.exec(text2)[1], cx);
  }
  get allowsNesting() {
    return false;
  }
}
function findState(lang2, tree2, off, startPos, before) {
  let state = off >= startPos && off + tree2.length <= before && tree2.prop(lang2.stateAfter);
  if (state)
    return { state: lang2.streamParser.copyState(state), pos: off + tree2.length };
  for (let i = tree2.children.length - 1; i >= 0; i--) {
    let child = tree2.children[i], pos = off + tree2.positions[i];
    let found = child instanceof Tree && pos < before && findState(lang2, child, pos, startPos, before);
    if (found)
      return found;
  }
  return null;
}
function cutTree(lang2, tree2, from2, to2, inside2) {
  if (inside2 && from2 <= 0 && to2 >= tree2.length)
    return tree2;
  if (!inside2 && tree2.type == lang2.topNode)
    inside2 = true;
  for (let i = tree2.children.length - 1; i >= 0; i--) {
    let pos = tree2.positions[i], child = tree2.children[i], inner;
    if (pos < to2 && child instanceof Tree) {
      if (!(inner = cutTree(lang2, child, from2 - pos, to2 - pos, inside2)))
        break;
      return !inside2 ? inner : new Tree(tree2.type, tree2.children.slice(0, i).concat(inner), tree2.positions.slice(0, i + 1), pos + inner.length);
    }
  }
  return null;
}
function findStartInFragments(lang2, fragments, startPos, editorState) {
  for (let f2 of fragments) {
    let from2 = f2.from + (f2.openStart ? 25 : 0), to2 = f2.to - (f2.openEnd ? 25 : 0);
    let found = from2 <= startPos && to2 > startPos && findState(lang2, f2.tree, 0 - f2.offset, startPos, to2), tree2;
    if (found && (tree2 = cutTree(lang2, f2.tree, startPos + f2.offset, found.pos + f2.offset, false)))
      return { state: found.state, tree: tree2 };
  }
  return { state: lang2.streamParser.startState(editorState ? getIndentUnit(editorState) : 4), tree: Tree.empty };
}
class Parse$1 {
  constructor(lang2, input, fragments, ranges2) {
    this.lang = lang2;
    this.input = input;
    this.fragments = fragments;
    this.ranges = ranges2;
    this.stoppedAt = null;
    this.chunks = [];
    this.chunkPos = [];
    this.chunk = [];
    this.chunkReused = void 0;
    this.rangeIndex = 0;
    this.to = ranges2[ranges2.length - 1].to;
    let context = ParseContext.get(), from2 = ranges2[0].from;
    let { state, tree: tree2 } = findStartInFragments(lang2, fragments, from2, context === null || context === void 0 ? void 0 : context.state);
    this.state = state;
    this.parsedPos = this.chunkStart = from2 + tree2.length;
    for (let i = 0; i < tree2.children.length; i++) {
      this.chunks.push(tree2.children[i]);
      this.chunkPos.push(tree2.positions[i]);
    }
    if (context && this.parsedPos < context.viewport.from - 1e5) {
      this.state = this.lang.streamParser.startState(getIndentUnit(context.state));
      context.skipUntilInView(this.parsedPos, context.viewport.from);
      this.parsedPos = context.viewport.from;
    }
    this.moveRangeIndex();
  }
  advance() {
    let context = ParseContext.get();
    let parseEnd = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt);
    let end2 = Math.min(parseEnd, this.chunkStart + 2048);
    if (context)
      end2 = Math.min(end2, context.viewport.to);
    while (this.parsedPos < end2)
      this.parseLine(context);
    if (this.chunkStart < this.parsedPos)
      this.finishChunk();
    if (this.parsedPos >= parseEnd)
      return this.finish();
    if (context && this.parsedPos >= context.viewport.to) {
      context.skipUntilInView(this.parsedPos, parseEnd);
      return this.finish();
    }
    return null;
  }
  stopAt(pos) {
    this.stoppedAt = pos;
  }
  lineAfter(pos) {
    let chunk = this.input.chunk(pos);
    if (!this.input.lineChunks) {
      let eol = chunk.indexOf("\n");
      if (eol > -1)
        chunk = chunk.slice(0, eol);
    } else if (chunk == "\n") {
      chunk = "";
    }
    return pos + chunk.length <= this.to ? chunk : chunk.slice(0, this.to - pos);
  }
  nextLine() {
    let from2 = this.parsedPos, line2 = this.lineAfter(from2), end2 = from2 + line2.length;
    for (let index2 = this.rangeIndex; ; ) {
      let rangeEnd2 = this.ranges[index2].to;
      if (rangeEnd2 >= end2)
        break;
      line2 = line2.slice(0, rangeEnd2 - (end2 - line2.length));
      index2++;
      if (index2 == this.ranges.length)
        break;
      let rangeStart = this.ranges[index2].from;
      let after = this.lineAfter(rangeStart);
      line2 += after;
      end2 = rangeStart + after.length;
    }
    return { line: line2, end: end2 };
  }
  skipGapsTo(pos, offset, side) {
    for (; ; ) {
      let end2 = this.ranges[this.rangeIndex].to, offPos = pos + offset;
      if (side > 0 ? end2 > offPos : end2 >= offPos)
        break;
      let start2 = this.ranges[++this.rangeIndex].from;
      offset += start2 - end2;
    }
    return offset;
  }
  moveRangeIndex() {
    while (this.ranges[this.rangeIndex].to < this.parsedPos)
      this.rangeIndex++;
  }
  emitToken(id2, from2, to2, size, offset) {
    if (this.ranges.length > 1) {
      offset = this.skipGapsTo(from2, offset, 1);
      from2 += offset;
      let len0 = this.chunk.length;
      offset = this.skipGapsTo(to2, offset, -1);
      to2 += offset;
      size += this.chunk.length - len0;
    }
    this.chunk.push(id2, from2, to2, size);
    return offset;
  }
  parseLine(context) {
    let { line: line2, end: end2 } = this.nextLine(), offset = 0, { streamParser } = this.lang;
    let stream = new StringStream(line2, context ? context.state.tabSize : 4, context ? getIndentUnit(context.state) : 2);
    if (stream.eol()) {
      streamParser.blankLine(this.state, stream.indentUnit);
    } else {
      while (!stream.eol()) {
        let token2 = readToken$1(streamParser.token, stream, this.state);
        if (token2)
          offset = this.emitToken(this.lang.tokenTable.resolve(token2), this.parsedPos + stream.start, this.parsedPos + stream.pos, 4, offset);
        if (stream.start > 1e4)
          break;
      }
    }
    this.parsedPos = end2;
    this.moveRangeIndex();
    if (this.parsedPos < this.to)
      this.parsedPos++;
  }
  finishChunk() {
    let tree2 = Tree.build({
      buffer: this.chunk,
      start: this.chunkStart,
      length: this.parsedPos - this.chunkStart,
      nodeSet,
      topID: 0,
      maxBufferLength: 2048,
      reused: this.chunkReused
    });
    tree2 = new Tree(tree2.type, tree2.children, tree2.positions, tree2.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]);
    this.chunks.push(tree2);
    this.chunkPos.push(this.chunkStart - this.ranges[0].from);
    this.chunk = [];
    this.chunkReused = void 0;
    this.chunkStart = this.parsedPos;
  }
  finish() {
    return new Tree(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();
  }
}
function readToken$1(token2, stream, state) {
  stream.start = stream.pos;
  for (let i = 0; i < 10; i++) {
    let result = token2(stream, state);
    if (stream.pos > stream.start)
      return result;
  }
  throw new Error("Stream parser failed to advance stream.");
}
const noTokens = /* @__PURE__ */ Object.create(null);
const typeArray = [NodeType.none];
const nodeSet = /* @__PURE__ */ new NodeSet(typeArray);
const warned = [];
const defaultTable = /* @__PURE__ */ Object.create(null);
for (let [legacyName, name2] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  defaultTable[legacyName] = /* @__PURE__ */ createTokenType(noTokens, name2);
class TokenTable {
  constructor(extra) {
    this.extra = extra;
    this.table = Object.assign(/* @__PURE__ */ Object.create(null), defaultTable);
  }
  resolve(tag) {
    return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag));
  }
}
const defaultTokenTable = /* @__PURE__ */ new TokenTable(noTokens);
function warnForPart(part, msg) {
  if (warned.indexOf(part) > -1)
    return;
  warned.push(part);
  console.warn(msg);
}
function createTokenType(extra, tagStr) {
  let tag = null;
  for (let part of tagStr.split(".")) {
    let value = extra[part] || tags$5[part];
    if (!value) {
      warnForPart(part, `Unknown highlighting tag ${part}`);
    } else if (typeof value == "function") {
      if (!tag)
        warnForPart(part, `Modifier ${part} used at start of tag`);
      else
        tag = value(tag);
    } else {
      if (tag)
        warnForPart(part, `Tag ${part} used as modifier`);
      else
        tag = value;
    }
  }
  if (!tag)
    return 0;
  let name2 = tagStr.replace(/ /g, "_"), type2 = NodeType.define({
    id: typeArray.length,
    name: name2,
    props: [styleTags({ [name2]: tag })]
  });
  typeArray.push(type2);
  return type2.id;
}
function docID(data2) {
  let type2 = NodeType.define({ id: typeArray.length, name: "Document", props: [languageDataProp.add(() => data2)] });
  typeArray.push(type2);
  return type2;
}
const toggleComment = (target) => {
  let config2 = getConfig$2(target.state);
  return config2.line ? toggleLineComment(target) : config2.block ? toggleBlockCommentByLine(target) : false;
};
function command(f2, option) {
  return ({ state, dispatch: dispatch2 }) => {
    if (state.readOnly)
      return false;
    let tr = f2(option, state);
    if (!tr)
      return false;
    dispatch2(state.update(tr));
    return true;
  };
}
const toggleLineComment = /* @__PURE__ */ command(changeLineComment, 0);
const toggleBlockComment = /* @__PURE__ */ command(changeBlockComment, 0);
const toggleBlockCommentByLine = /* @__PURE__ */ command((o, s2) => changeBlockComment(o, s2, selectedLineRanges(s2)), 0);
function getConfig$2(state, pos = state.selection.main.head) {
  let data2 = state.languageDataAt("commentTokens", pos);
  return data2.length ? data2[0] : {};
}
const SearchMargin = 50;
function findBlockComment(state, { open, close }, from2, to2) {
  let textBefore = state.sliceDoc(from2 - SearchMargin, from2);
  let textAfter = state.sliceDoc(to2, to2 + SearchMargin);
  let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
  let beforeOff = textBefore.length - spaceBefore;
  if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
    return {
      open: { pos: from2 - spaceBefore, margin: spaceBefore && 1 },
      close: { pos: to2 + spaceAfter, margin: spaceAfter && 1 }
    };
  }
  let startText, endText;
  if (to2 - from2 <= 2 * SearchMargin) {
    startText = endText = state.sliceDoc(from2, to2);
  } else {
    startText = state.sliceDoc(from2, from2 + SearchMargin);
    endText = state.sliceDoc(to2 - SearchMargin, to2);
  }
  let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
  let endOff = endText.length - endSpace - close.length;
  if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
    return {
      open: {
        pos: from2 + startSpace + open.length,
        margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
      },
      close: {
        pos: to2 - endSpace - close.length,
        margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
      }
    };
  }
  return null;
}
function selectedLineRanges(state) {
  let ranges2 = [];
  for (let r of state.selection.ranges) {
    let fromLine = state.doc.lineAt(r.from);
    let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);
    let last = ranges2.length - 1;
    if (last >= 0 && ranges2[last].to > fromLine.from)
      ranges2[last].to = toLine.to;
    else
      ranges2.push({ from: fromLine.from, to: toLine.to });
  }
  return ranges2;
}
function changeBlockComment(option, state, ranges2 = state.selection.ranges) {
  let tokens = ranges2.map((r) => getConfig$2(state, r.from).block);
  if (!tokens.every((c2) => c2))
    return null;
  let comments = ranges2.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));
  if (option != 2 && !comments.every((c2) => c2)) {
    return { changes: state.changes(ranges2.map((range2, i) => {
      if (comments[i])
        return [];
      return [{ from: range2.from, insert: tokens[i].open + " " }, { from: range2.to, insert: " " + tokens[i].close }];
    })) };
  } else if (option != 1 && comments.some((c2) => c2)) {
    let changes = [];
    for (let i = 0, comment2; i < comments.length; i++)
      if (comment2 = comments[i]) {
        let token2 = tokens[i], { open, close } = comment2;
        changes.push({ from: open.pos - token2.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token2.close.length });
      }
    return { changes };
  }
  return null;
}
function changeLineComment(option, state, ranges2 = state.selection.ranges) {
  let lines = [];
  let prevLine = -1;
  for (let { from: from2, to: to2 } of ranges2) {
    let startI = lines.length, minIndent = 1e9;
    for (let pos = from2; pos <= to2; ) {
      let line2 = state.doc.lineAt(pos);
      if (line2.from > prevLine && (from2 == to2 || to2 > line2.from)) {
        prevLine = line2.from;
        let token2 = getConfig$2(state, pos).line;
        if (!token2)
          continue;
        let indent = /^\s*/.exec(line2.text)[0].length;
        let empty2 = indent == line2.length;
        let comment2 = line2.text.slice(indent, indent + token2.length) == token2 ? indent : -1;
        if (indent < line2.text.length && indent < minIndent)
          minIndent = indent;
        lines.push({ line: line2, comment: comment2, token: token2, indent, empty: empty2, single: false });
      }
      pos = line2.to + 1;
    }
    if (minIndent < 1e9) {
      for (let i = startI; i < lines.length; i++)
        if (lines[i].indent < lines[i].line.text.length)
          lines[i].indent = minIndent;
    }
    if (lines.length == startI + 1)
      lines[startI].single = true;
  }
  if (option != 2 && lines.some((l2) => l2.comment < 0 && (!l2.empty || l2.single))) {
    let changes = [];
    for (let { line: line2, token: token2, indent, empty: empty2, single } of lines)
      if (single || !empty2)
        changes.push({ from: line2.from + indent, insert: token2 + " " });
    let changeSet = state.changes(changes);
    return { changes: changeSet, selection: state.selection.map(changeSet, 1) };
  } else if (option != 1 && lines.some((l2) => l2.comment >= 0)) {
    let changes = [];
    for (let { line: line2, comment: comment2, token: token2 } of lines)
      if (comment2 >= 0) {
        let from2 = line2.from + comment2, to2 = from2 + token2.length;
        if (line2.text[to2 - line2.from] == " ")
          to2++;
        changes.push({ from: from2, to: to2 });
      }
    return { changes };
  }
  return null;
}
const fromHistory = /* @__PURE__ */ Annotation.define();
const isolateHistory = /* @__PURE__ */ Annotation.define();
const invertedEffects = /* @__PURE__ */ Facet.define();
const historyConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      minDepth: 100,
      newGroupDelay: 500
    }, { minDepth: Math.max, newGroupDelay: Math.min });
  }
});
function changeEnd(changes) {
  let end2 = 0;
  changes.iterChangedRanges((_2, to2) => end2 = to2);
  return end2;
}
const historyField_ = /* @__PURE__ */ StateField.define({
  create() {
    return HistoryState.empty;
  },
  update(state, tr) {
    let config2 = tr.state.facet(historyConfig);
    let fromHist = tr.annotation(fromHistory);
    if (fromHist) {
      let selection2 = tr.docChanged ? EditorSelection.single(changeEnd(tr.changes)) : void 0;
      let item = HistEvent.fromTransaction(tr, selection2), from2 = fromHist.side;
      let other = from2 == 0 ? state.undone : state.done;
      if (item)
        other = updateBranch(other, other.length, config2.minDepth, item);
      else
        other = addSelection(other, tr.startState.selection);
      return new HistoryState(from2 == 0 ? fromHist.rest : other, from2 == 0 ? other : fromHist.rest);
    }
    let isolate = tr.annotation(isolateHistory);
    if (isolate == "full" || isolate == "before")
      state = state.isolate();
    if (tr.annotation(Transaction.addToHistory) === false)
      return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;
    let event2 = HistEvent.fromTransaction(tr);
    let time2 = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);
    if (event2)
      state = state.addChanges(event2, time2, userEvent, config2.newGroupDelay, config2.minDepth);
    else if (tr.selection)
      state = state.addSelection(tr.startState.selection, time2, userEvent, config2.newGroupDelay);
    if (isolate == "full" || isolate == "after")
      state = state.isolate();
    return state;
  },
  toJSON(value) {
    return { done: value.done.map((e) => e.toJSON()), undone: value.undone.map((e) => e.toJSON()) };
  },
  fromJSON(json2) {
    return new HistoryState(json2.done.map(HistEvent.fromJSON), json2.undone.map(HistEvent.fromJSON));
  }
});
function history(config2 = {}) {
  return [
    historyField_,
    historyConfig.of(config2),
    EditorView.domEventHandlers({
      beforeinput(e, view) {
        let command2 = e.inputType == "historyUndo" ? undo$3 : e.inputType == "historyRedo" ? redo : null;
        if (!command2)
          return false;
        e.preventDefault();
        return command2(view);
      }
    })
  ];
}
function cmd(side, selection2) {
  return function({ state, dispatch: dispatch2 }) {
    if (!selection2 && state.readOnly)
      return false;
    let historyState = state.field(historyField_, false);
    if (!historyState)
      return false;
    let tr = historyState.pop(side, state, selection2);
    if (!tr)
      return false;
    dispatch2(tr);
    return true;
  };
}
const undo$3 = /* @__PURE__ */ cmd(0, false);
const redo = /* @__PURE__ */ cmd(1, false);
const undoSelection = /* @__PURE__ */ cmd(0, true);
const redoSelection = /* @__PURE__ */ cmd(1, true);
class HistEvent {
  constructor(changes, effects, mapped, startSelection, selectionsAfter) {
    this.changes = changes;
    this.effects = effects;
    this.mapped = mapped;
    this.startSelection = startSelection;
    this.selectionsAfter = selectionsAfter;
  }
  setSelAfter(after) {
    return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
  }
  toJSON() {
    var _a2, _b, _c;
    return {
      changes: (_a2 = this.changes) === null || _a2 === void 0 ? void 0 : _a2.toJSON(),
      mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
      startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
      selectionsAfter: this.selectionsAfter.map((s2) => s2.toJSON())
    };
  }
  static fromJSON(json2) {
    return new HistEvent(json2.changes && ChangeSet.fromJSON(json2.changes), [], json2.mapped && ChangeDesc.fromJSON(json2.mapped), json2.startSelection && EditorSelection.fromJSON(json2.startSelection), json2.selectionsAfter.map(EditorSelection.fromJSON));
  }
  static fromTransaction(tr, selection2) {
    let effects = none$5;
    for (let invert2 of tr.startState.facet(invertedEffects)) {
      let result = invert2(tr);
      if (result.length)
        effects = effects.concat(result);
    }
    if (!effects.length && tr.changes.empty)
      return null;
    return new HistEvent(tr.changes.invert(tr.startState.doc), effects, void 0, selection2 || tr.startState.selection, none$5);
  }
  static selection(selections) {
    return new HistEvent(void 0, none$5, void 0, void 0, selections);
  }
}
function updateBranch(branch2, to2, maxLen, newEvent) {
  let start2 = to2 + 1 > maxLen + 20 ? to2 - maxLen - 1 : 0;
  let newBranch = branch2.slice(start2, to2);
  newBranch.push(newEvent);
  return newBranch;
}
function isAdjacent(a2, b) {
  let ranges2 = [], isAdjacent2 = false;
  a2.iterChangedRanges((f2, t4) => ranges2.push(f2, t4));
  b.iterChangedRanges((_f, _t, f2, t4) => {
    for (let i = 0; i < ranges2.length; ) {
      let from2 = ranges2[i++], to2 = ranges2[i++];
      if (t4 >= from2 && f2 <= to2)
        isAdjacent2 = true;
    }
  });
  return isAdjacent2;
}
function eqSelectionShape(a2, b) {
  return a2.ranges.length == b.ranges.length && a2.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;
}
function conc(a2, b) {
  return !a2.length ? b : !b.length ? a2 : a2.concat(b);
}
const none$5 = [];
const MaxSelectionsPerEvent = 200;
function addSelection(branch2, selection2) {
  if (!branch2.length) {
    return [HistEvent.selection([selection2])];
  } else {
    let lastEvent = branch2[branch2.length - 1];
    let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
    if (sels.length && sels[sels.length - 1].eq(selection2))
      return branch2;
    sels.push(selection2);
    return updateBranch(branch2, branch2.length - 1, 1e9, lastEvent.setSelAfter(sels));
  }
}
function popSelection(branch2) {
  let last = branch2[branch2.length - 1];
  let newBranch = branch2.slice();
  newBranch[branch2.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
  return newBranch;
}
function addMappingToBranch(branch2, mapping) {
  if (!branch2.length)
    return branch2;
  let length2 = branch2.length, selections = none$5;
  while (length2) {
    let event2 = mapEvent(branch2[length2 - 1], mapping, selections);
    if (event2.changes && !event2.changes.empty || event2.effects.length) {
      let result = branch2.slice(0, length2);
      result[length2 - 1] = event2;
      return result;
    } else {
      mapping = event2.mapped;
      length2--;
      selections = event2.selectionsAfter;
    }
  }
  return selections.length ? [HistEvent.selection(selections)] : none$5;
}
function mapEvent(event2, mapping, extraSelections) {
  let selections = conc(event2.selectionsAfter.length ? event2.selectionsAfter.map((s2) => s2.map(mapping)) : none$5, extraSelections);
  if (!event2.changes)
    return HistEvent.selection(selections);
  let mappedChanges = event2.changes.map(mapping), before = mapping.mapDesc(event2.changes, true);
  let fullMapping = event2.mapped ? event2.mapped.composeDesc(before) : before;
  return new HistEvent(mappedChanges, StateEffect.mapEffects(event2.effects, mapping), fullMapping, event2.startSelection.map(before), selections);
}
const joinableUserEvent = /^(input\.type|delete)($|\.)/;
class HistoryState {
  constructor(done, undone, prevTime = 0, prevUserEvent = void 0) {
    this.done = done;
    this.undone = undone;
    this.prevTime = prevTime;
    this.prevUserEvent = prevUserEvent;
  }
  isolate() {
    return this.prevTime ? new HistoryState(this.done, this.undone) : this;
  }
  addChanges(event2, time2, userEvent, newGroupDelay, maxLen) {
    let done = this.done, lastEvent = done[done.length - 1];
    if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event2.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time2 - this.prevTime < newGroupDelay && isAdjacent(lastEvent.changes, event2.changes) || userEvent == "input.type.compose")) {
      done = updateBranch(done, done.length - 1, maxLen, new HistEvent(event2.changes.compose(lastEvent.changes), conc(event2.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none$5));
    } else {
      done = updateBranch(done, done.length, maxLen, event2);
    }
    return new HistoryState(done, none$5, time2, userEvent);
  }
  addSelection(selection2, time2, userEvent, newGroupDelay) {
    let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none$5;
    if (last.length > 0 && time2 - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection2))
      return this;
    return new HistoryState(addSelection(this.done, selection2), this.undone, time2, userEvent);
  }
  addMapping(mapping) {
    return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
  }
  pop(side, state, selection2) {
    let branch2 = side == 0 ? this.done : this.undone;
    if (branch2.length == 0)
      return null;
    let event2 = branch2[branch2.length - 1];
    if (selection2 && event2.selectionsAfter.length) {
      return state.update({
        selection: event2.selectionsAfter[event2.selectionsAfter.length - 1],
        annotations: fromHistory.of({ side, rest: popSelection(branch2) }),
        userEvent: side == 0 ? "select.undo" : "select.redo",
        scrollIntoView: true
      });
    } else if (!event2.changes) {
      return null;
    } else {
      let rest = branch2.length == 1 ? none$5 : branch2.slice(0, branch2.length - 1);
      if (event2.mapped)
        rest = addMappingToBranch(rest, event2.mapped);
      return state.update({
        changes: event2.changes,
        selection: event2.startSelection,
        effects: event2.effects,
        annotations: fromHistory.of({ side, rest }),
        filter: false,
        userEvent: side == 0 ? "undo" : "redo",
        scrollIntoView: true
      });
    }
  }
}
HistoryState.empty = /* @__PURE__ */ new HistoryState(none$5, none$5);
const historyKeymap = [
  { key: "Mod-z", run: undo$3, preventDefault: true },
  { key: "Mod-y", mac: "Mod-Shift-z", run: redo, preventDefault: true },
  { linux: "Ctrl-Shift-z", run: redo, preventDefault: true },
  { key: "Mod-u", run: undoSelection, preventDefault: true },
  { key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true }
];
function updateSel(sel, by) {
  return EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
}
function setSel(state, selection2) {
  return state.update({ selection: selection2, scrollIntoView: true, userEvent: "select" });
}
function moveSel({ state, dispatch: dispatch2 }, how) {
  let selection2 = updateSel(state.selection, how);
  if (selection2.eq(state.selection))
    return false;
  dispatch2(setSel(state, selection2));
  return true;
}
function rangeEnd(range2, forward) {
  return EditorSelection.cursor(forward ? range2.to : range2.from);
}
function cursorByChar(view, forward) {
  return moveSel(view, (range2) => range2.empty ? view.moveByChar(range2, forward) : rangeEnd(range2, forward));
}
function ltrAtCursor(view) {
  return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;
}
const cursorCharLeft = (view) => cursorByChar(view, !ltrAtCursor(view));
const cursorCharRight = (view) => cursorByChar(view, ltrAtCursor(view));
const cursorCharBackward = (view) => cursorByChar(view, false);
function cursorByGroup(view, forward) {
  return moveSel(view, (range2) => range2.empty ? view.moveByGroup(range2, forward) : rangeEnd(range2, forward));
}
const cursorGroupLeft = (view) => cursorByGroup(view, !ltrAtCursor(view));
const cursorGroupRight = (view) => cursorByGroup(view, ltrAtCursor(view));
function interestingNode(state, node2, bracketProp) {
  if (node2.type.prop(bracketProp))
    return true;
  let len = node2.to - node2.from;
  return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node2.from, node2.to))) || node2.firstChild;
}
function moveBySyntax(state, start2, forward) {
  let pos = syntaxTree(state).resolveInner(start2.head);
  let bracketProp = forward ? NodeProp.closedBy : NodeProp.openedBy;
  for (let at = start2.head; ; ) {
    let next2 = forward ? pos.childAfter(at) : pos.childBefore(at);
    if (!next2)
      break;
    if (interestingNode(state, next2, bracketProp))
      pos = next2;
    else
      at = forward ? next2.to : next2.from;
  }
  let bracket2 = pos.type.prop(bracketProp), match, newPos;
  if (bracket2 && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched)
    newPos = forward ? match.end.to : match.end.from;
  else
    newPos = forward ? pos.to : pos.from;
  return EditorSelection.cursor(newPos, forward ? -1 : 1);
}
const cursorSyntaxLeft = (view) => moveSel(view, (range2) => moveBySyntax(view.state, range2, !ltrAtCursor(view)));
const cursorSyntaxRight = (view) => moveSel(view, (range2) => moveBySyntax(view.state, range2, ltrAtCursor(view)));
function cursorByLine(view, forward) {
  return moveSel(view, (range2) => {
    if (!range2.empty)
      return rangeEnd(range2, forward);
    let moved = view.moveVertically(range2, forward);
    return moved.head != range2.head ? moved : view.moveToLineBoundary(range2, forward);
  });
}
const cursorLineUp = (view) => cursorByLine(view, false);
const cursorLineDown = (view) => cursorByLine(view, true);
function pageHeight(view) {
  return Math.max(view.defaultLineHeight, Math.min(view.dom.clientHeight, innerHeight) - 5);
}
function cursorByPage(view, forward) {
  let { state } = view, selection2 = updateSel(state.selection, (range2) => {
    return range2.empty ? view.moveVertically(range2, forward, pageHeight(view)) : rangeEnd(range2, forward);
  });
  if (selection2.eq(state.selection))
    return false;
  let startPos = view.coordsAtPos(state.selection.main.head);
  let scrollRect = view.scrollDOM.getBoundingClientRect();
  let effect;
  if (startPos && startPos.top > scrollRect.top && startPos.bottom < scrollRect.bottom && startPos.top - scrollRect.top <= view.scrollDOM.scrollHeight - view.scrollDOM.scrollTop - view.scrollDOM.clientHeight)
    effect = EditorView.scrollIntoView(selection2.main.head, { y: "start", yMargin: startPos.top - scrollRect.top });
  view.dispatch(setSel(state, selection2), { effects: effect });
  return true;
}
const cursorPageUp = (view) => cursorByPage(view, false);
const cursorPageDown = (view) => cursorByPage(view, true);
function moveByLineBoundary(view, start2, forward) {
  let line2 = view.lineBlockAt(start2.head), moved = view.moveToLineBoundary(start2, forward);
  if (moved.head == start2.head && moved.head != (forward ? line2.to : line2.from))
    moved = view.moveToLineBoundary(start2, forward, false);
  if (!forward && moved.head == line2.from && line2.length) {
    let space2 = /^\s*/.exec(view.state.sliceDoc(line2.from, Math.min(line2.from + 100, line2.to)))[0].length;
    if (space2 && start2.head != line2.from + space2)
      moved = EditorSelection.cursor(line2.from + space2);
  }
  return moved;
}
const cursorLineBoundaryForward = (view) => moveSel(view, (range2) => moveByLineBoundary(view, range2, true));
const cursorLineBoundaryBackward = (view) => moveSel(view, (range2) => moveByLineBoundary(view, range2, false));
const cursorLineBoundaryLeft = (view) => moveSel(view, (range2) => moveByLineBoundary(view, range2, !ltrAtCursor(view)));
const cursorLineBoundaryRight = (view) => moveSel(view, (range2) => moveByLineBoundary(view, range2, ltrAtCursor(view)));
const cursorLineStart = (view) => moveSel(view, (range2) => EditorSelection.cursor(view.lineBlockAt(range2.head).from, 1));
const cursorLineEnd = (view) => moveSel(view, (range2) => EditorSelection.cursor(view.lineBlockAt(range2.head).to, -1));
function toMatchingBracket(state, dispatch2, extend2) {
  let found = false, selection2 = updateSel(state.selection, (range2) => {
    let matching = matchBrackets(state, range2.head, -1) || matchBrackets(state, range2.head, 1) || range2.head > 0 && matchBrackets(state, range2.head - 1, 1) || range2.head < state.doc.length && matchBrackets(state, range2.head + 1, -1);
    if (!matching || !matching.end)
      return range2;
    found = true;
    let head2 = matching.start.from == range2.head ? matching.end.to : matching.end.from;
    return extend2 ? EditorSelection.range(range2.anchor, head2) : EditorSelection.cursor(head2);
  });
  if (!found)
    return false;
  dispatch2(setSel(state, selection2));
  return true;
}
const cursorMatchingBracket = ({ state, dispatch: dispatch2 }) => toMatchingBracket(state, dispatch2, false);
function extendSel(view, how) {
  let selection2 = updateSel(view.state.selection, (range2) => {
    let head2 = how(range2);
    return EditorSelection.range(range2.anchor, head2.head, head2.goalColumn);
  });
  if (selection2.eq(view.state.selection))
    return false;
  view.dispatch(setSel(view.state, selection2));
  return true;
}
function selectByChar(view, forward) {
  return extendSel(view, (range2) => view.moveByChar(range2, forward));
}
const selectCharLeft = (view) => selectByChar(view, !ltrAtCursor(view));
const selectCharRight = (view) => selectByChar(view, ltrAtCursor(view));
function selectByGroup(view, forward) {
  return extendSel(view, (range2) => view.moveByGroup(range2, forward));
}
const selectGroupLeft = (view) => selectByGroup(view, !ltrAtCursor(view));
const selectGroupRight = (view) => selectByGroup(view, ltrAtCursor(view));
const selectSyntaxLeft = (view) => extendSel(view, (range2) => moveBySyntax(view.state, range2, !ltrAtCursor(view)));
const selectSyntaxRight = (view) => extendSel(view, (range2) => moveBySyntax(view.state, range2, ltrAtCursor(view)));
function selectByLine(view, forward) {
  return extendSel(view, (range2) => view.moveVertically(range2, forward));
}
const selectLineUp = (view) => selectByLine(view, false);
const selectLineDown = (view) => selectByLine(view, true);
function selectByPage(view, forward) {
  return extendSel(view, (range2) => view.moveVertically(range2, forward, pageHeight(view)));
}
const selectPageUp = (view) => selectByPage(view, false);
const selectPageDown = (view) => selectByPage(view, true);
const selectLineBoundaryForward = (view) => extendSel(view, (range2) => moveByLineBoundary(view, range2, true));
const selectLineBoundaryBackward = (view) => extendSel(view, (range2) => moveByLineBoundary(view, range2, false));
const selectLineBoundaryLeft = (view) => extendSel(view, (range2) => moveByLineBoundary(view, range2, !ltrAtCursor(view)));
const selectLineBoundaryRight = (view) => extendSel(view, (range2) => moveByLineBoundary(view, range2, ltrAtCursor(view)));
const selectLineStart = (view) => extendSel(view, (range2) => EditorSelection.cursor(view.lineBlockAt(range2.head).from));
const selectLineEnd = (view) => extendSel(view, (range2) => EditorSelection.cursor(view.lineBlockAt(range2.head).to));
const cursorDocStart = ({ state, dispatch: dispatch2 }) => {
  dispatch2(setSel(state, { anchor: 0 }));
  return true;
};
const cursorDocEnd = ({ state, dispatch: dispatch2 }) => {
  dispatch2(setSel(state, { anchor: state.doc.length }));
  return true;
};
const selectDocStart = ({ state, dispatch: dispatch2 }) => {
  dispatch2(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));
  return true;
};
const selectDocEnd = ({ state, dispatch: dispatch2 }) => {
  dispatch2(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));
  return true;
};
const selectAll$2 = ({ state, dispatch: dispatch2 }) => {
  dispatch2(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: "select" }));
  return true;
};
const selectLine = ({ state, dispatch: dispatch2 }) => {
  let ranges2 = selectedLineBlocks(state).map(({ from: from2, to: to2 }) => EditorSelection.range(from2, Math.min(to2 + 1, state.doc.length)));
  dispatch2(state.update({ selection: EditorSelection.create(ranges2), userEvent: "select" }));
  return true;
};
const selectParentSyntax = ({ state, dispatch: dispatch2 }) => {
  let selection2 = updateSel(state.selection, (range2) => {
    var _a2;
    let context = syntaxTree(state).resolveInner(range2.head, 1);
    while (!(context.from < range2.from && context.to >= range2.to || context.to > range2.to && context.from <= range2.from || !((_a2 = context.parent) === null || _a2 === void 0 ? void 0 : _a2.parent)))
      context = context.parent;
    return EditorSelection.range(context.to, context.from);
  });
  dispatch2(setSel(state, selection2));
  return true;
};
const simplifySelection = ({ state, dispatch: dispatch2 }) => {
  let cur2 = state.selection, selection2 = null;
  if (cur2.ranges.length > 1)
    selection2 = EditorSelection.create([cur2.main]);
  else if (!cur2.main.empty)
    selection2 = EditorSelection.create([EditorSelection.cursor(cur2.main.head)]);
  if (!selection2)
    return false;
  dispatch2(setSel(state, selection2));
  return true;
};
function deleteBy(target, by) {
  if (target.state.readOnly)
    return false;
  let event2 = "delete.selection", { state } = target;
  let changes = state.changeByRange((range2) => {
    let { from: from2, to: to2 } = range2;
    if (from2 == to2) {
      let towards = by(from2);
      if (towards < from2) {
        event2 = "delete.backward";
        towards = skipAtomic(target, towards, false);
      } else if (towards > from2) {
        event2 = "delete.forward";
        towards = skipAtomic(target, towards, true);
      }
      from2 = Math.min(from2, towards);
      to2 = Math.max(to2, towards);
    } else {
      from2 = skipAtomic(target, from2, false);
      to2 = skipAtomic(target, to2, true);
    }
    return from2 == to2 ? { range: range2 } : { changes: { from: from2, to: to2 }, range: EditorSelection.cursor(from2) };
  });
  if (changes.changes.empty)
    return false;
  target.dispatch(state.update(changes, {
    scrollIntoView: true,
    userEvent: event2,
    effects: event2 == "delete.selection" ? EditorView.announce.of(state.phrase("Selection deleted")) : void 0
  }));
  return true;
}
function skipAtomic(target, pos, forward) {
  if (target instanceof EditorView)
    for (let ranges2 of target.state.facet(EditorView.atomicRanges).map((f2) => f2(target)))
      ranges2.between(pos, pos, (from2, to2) => {
        if (from2 < pos && to2 > pos)
          pos = forward ? to2 : from2;
      });
  return pos;
}
const deleteByChar = (target, forward) => deleteBy(target, (pos) => {
  let { state } = target, line2 = state.doc.lineAt(pos), before, targetPos;
  if (!forward && pos > line2.from && pos < line2.from + 200 && !/[^ \t]/.test(before = line2.text.slice(0, pos - line2.from))) {
    if (before[before.length - 1] == "	")
      return pos - 1;
    let col = countColumn(before, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);
    for (let i = 0; i < drop && before[before.length - 1 - i] == " "; i++)
      pos--;
    targetPos = pos;
  } else {
    targetPos = findClusterBreak(line2.text, pos - line2.from, forward, forward) + line2.from;
    if (targetPos == pos && line2.number != (forward ? state.doc.lines : 1))
      targetPos += forward ? 1 : -1;
  }
  return targetPos;
});
const deleteCharBackward = (view) => deleteByChar(view, false);
const deleteCharForward = (view) => deleteByChar(view, true);
const deleteByGroup = (target, forward) => deleteBy(target, (start2) => {
  let pos = start2, { state } = target, line2 = state.doc.lineAt(pos);
  let categorize = state.charCategorizer(pos);
  for (let cat = null; ; ) {
    if (pos == (forward ? line2.to : line2.from)) {
      if (pos == start2 && line2.number != (forward ? state.doc.lines : 1))
        pos += forward ? 1 : -1;
      break;
    }
    let next2 = findClusterBreak(line2.text, pos - line2.from, forward) + line2.from;
    let nextChar2 = line2.text.slice(Math.min(pos, next2) - line2.from, Math.max(pos, next2) - line2.from);
    let nextCat = categorize(nextChar2);
    if (cat != null && nextCat != cat)
      break;
    if (nextChar2 != " " || pos != start2)
      cat = nextCat;
    pos = next2;
  }
  return pos;
});
const deleteGroupBackward = (target) => deleteByGroup(target, false);
const deleteGroupForward = (target) => deleteByGroup(target, true);
const deleteToLineEnd = (view) => deleteBy(view, (pos) => {
  let lineEnd2 = view.lineBlockAt(pos).to;
  return pos < lineEnd2 ? lineEnd2 : Math.min(view.state.doc.length, pos + 1);
});
const deleteToLineStart = (view) => deleteBy(view, (pos) => {
  let lineStart = view.lineBlockAt(pos).from;
  return pos > lineStart ? lineStart : Math.max(0, pos - 1);
});
const splitLine = ({ state, dispatch: dispatch2 }) => {
  if (state.readOnly)
    return false;
  let changes = state.changeByRange((range2) => {
    return {
      changes: { from: range2.from, to: range2.to, insert: Text.of(["", ""]) },
      range: EditorSelection.cursor(range2.from)
    };
  });
  dispatch2(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
  return true;
};
const transposeChars = ({ state, dispatch: dispatch2 }) => {
  if (state.readOnly)
    return false;
  let changes = state.changeByRange((range2) => {
    if (!range2.empty || range2.from == 0 || range2.from == state.doc.length)
      return { range: range2 };
    let pos = range2.from, line2 = state.doc.lineAt(pos);
    let from2 = pos == line2.from ? pos - 1 : findClusterBreak(line2.text, pos - line2.from, false) + line2.from;
    let to2 = pos == line2.to ? pos + 1 : findClusterBreak(line2.text, pos - line2.from, true) + line2.from;
    return {
      changes: { from: from2, to: to2, insert: state.doc.slice(pos, to2).append(state.doc.slice(from2, pos)) },
      range: EditorSelection.cursor(to2)
    };
  });
  if (changes.changes.empty)
    return false;
  dispatch2(state.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
  return true;
};
function selectedLineBlocks(state) {
  let blocks = [], upto = -1;
  for (let range2 of state.selection.ranges) {
    let startLine = state.doc.lineAt(range2.from), endLine = state.doc.lineAt(range2.to);
    if (!range2.empty && range2.to == endLine.from)
      endLine = state.doc.lineAt(range2.to - 1);
    if (upto >= startLine.number) {
      let prev2 = blocks[blocks.length - 1];
      prev2.to = endLine.to;
      prev2.ranges.push(range2);
    } else {
      blocks.push({ from: startLine.from, to: endLine.to, ranges: [range2] });
    }
    upto = endLine.number + 1;
  }
  return blocks;
}
function moveLine(state, dispatch2, forward) {
  if (state.readOnly)
    return false;
  let changes = [], ranges2 = [];
  for (let block of selectedLineBlocks(state)) {
    if (forward ? block.to == state.doc.length : block.from == 0)
      continue;
    let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
    let size = nextLine.length + 1;
    if (forward) {
      changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });
      for (let r of block.ranges)
        ranges2.push(EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));
    } else {
      changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });
      for (let r of block.ranges)
        ranges2.push(EditorSelection.range(r.anchor - size, r.head - size));
    }
  }
  if (!changes.length)
    return false;
  dispatch2(state.update({
    changes,
    scrollIntoView: true,
    selection: EditorSelection.create(ranges2, state.selection.mainIndex),
    userEvent: "move.line"
  }));
  return true;
}
const moveLineUp = ({ state, dispatch: dispatch2 }) => moveLine(state, dispatch2, false);
const moveLineDown = ({ state, dispatch: dispatch2 }) => moveLine(state, dispatch2, true);
function copyLine(state, dispatch2, forward) {
  if (state.readOnly)
    return false;
  let changes = [];
  for (let block of selectedLineBlocks(state)) {
    if (forward)
      changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });
    else
      changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });
  }
  dispatch2(state.update({ changes, scrollIntoView: true, userEvent: "input.copyline" }));
  return true;
}
const copyLineUp = ({ state, dispatch: dispatch2 }) => copyLine(state, dispatch2, false);
const copyLineDown = ({ state, dispatch: dispatch2 }) => copyLine(state, dispatch2, true);
const deleteLine = (view) => {
  if (view.state.readOnly)
    return false;
  let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from: from2, to: to2 }) => {
    if (from2 > 0)
      from2--;
    else if (to2 < state.doc.length)
      to2++;
    return { from: from2, to: to2 };
  }));
  let selection2 = updateSel(state.selection, (range2) => view.moveVertically(range2, true)).map(changes);
  view.dispatch({ changes, selection: selection2, scrollIntoView: true, userEvent: "delete.line" });
  return true;
};
function isBetweenBrackets(state, pos) {
  if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
    return { from: pos, to: pos };
  let context = syntaxTree(state).resolveInner(pos);
  let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
  if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from)
    return { from: before.to, to: after.from };
  return null;
}
const insertNewlineAndIndent = /* @__PURE__ */ newlineAndIndent(false);
const insertBlankLine = /* @__PURE__ */ newlineAndIndent(true);
function newlineAndIndent(atEof) {
  return ({ state, dispatch: dispatch2 }) => {
    if (state.readOnly)
      return false;
    let changes = state.changeByRange((range2) => {
      let { from: from2, to: to2 } = range2, line2 = state.doc.lineAt(from2);
      let explode = !atEof && from2 == to2 && isBetweenBrackets(state, from2);
      if (atEof)
        from2 = to2 = (to2 <= line2.to ? line2 : state.doc.lineAt(to2)).to;
      let cx = new IndentContext(state, { simulateBreak: from2, simulateDoubleBreak: !!explode });
      let indent = getIndentation(cx, from2);
      if (indent == null)
        indent = /^\s*/.exec(state.doc.lineAt(from2).text)[0].length;
      while (to2 < line2.to && /\s/.test(line2.text[to2 - line2.from]))
        to2++;
      if (explode)
        ({ from: from2, to: to2 } = explode);
      else if (from2 > line2.from && from2 < line2.from + 100 && !/\S/.test(line2.text.slice(0, from2)))
        from2 = line2.from;
      let insert2 = ["", indentString(state, indent)];
      if (explode)
        insert2.push(indentString(state, cx.lineIndent(line2.from, -1)));
      return {
        changes: { from: from2, to: to2, insert: Text.of(insert2) },
        range: EditorSelection.cursor(from2 + 1 + insert2[1].length)
      };
    });
    dispatch2(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
    return true;
  };
}
function changeBySelectedLine(state, f2) {
  let atLine = -1;
  return state.changeByRange((range2) => {
    let changes = [];
    for (let pos = range2.from; pos <= range2.to; ) {
      let line2 = state.doc.lineAt(pos);
      if (line2.number > atLine && (range2.empty || range2.to > line2.from)) {
        f2(line2, changes, range2);
        atLine = line2.number;
      }
      pos = line2.to + 1;
    }
    let changeSet = state.changes(changes);
    return {
      changes,
      range: EditorSelection.range(changeSet.mapPos(range2.anchor, 1), changeSet.mapPos(range2.head, 1))
    };
  });
}
const indentSelection = ({ state, dispatch: dispatch2 }) => {
  if (state.readOnly)
    return false;
  let updated = /* @__PURE__ */ Object.create(null);
  let context = new IndentContext(state, { overrideIndentation: (start2) => {
    let found = updated[start2];
    return found == null ? -1 : found;
  } });
  let changes = changeBySelectedLine(state, (line2, changes2, range2) => {
    let indent = getIndentation(context, line2.from);
    if (indent == null)
      return;
    if (!/\S/.test(line2.text))
      indent = 0;
    let cur2 = /^\s*/.exec(line2.text)[0];
    let norm = indentString(state, indent);
    if (cur2 != norm || range2.from < line2.from + cur2.length) {
      updated[line2.from] = indent;
      changes2.push({ from: line2.from, to: line2.from + cur2.length, insert: norm });
    }
  });
  if (!changes.changes.empty)
    dispatch2(state.update(changes, { userEvent: "indent" }));
  return true;
};
const indentMore = ({ state, dispatch: dispatch2 }) => {
  if (state.readOnly)
    return false;
  dispatch2(state.update(changeBySelectedLine(state, (line2, changes) => {
    changes.push({ from: line2.from, insert: state.facet(indentUnit) });
  }), { userEvent: "input.indent" }));
  return true;
};
const indentLess = ({ state, dispatch: dispatch2 }) => {
  if (state.readOnly)
    return false;
  dispatch2(state.update(changeBySelectedLine(state, (line2, changes) => {
    let space2 = /^\s*/.exec(line2.text)[0];
    if (!space2)
      return;
    let col = countColumn(space2, state.tabSize), keep = 0;
    let insert2 = indentString(state, Math.max(0, col - getIndentUnit(state)));
    while (keep < space2.length && keep < insert2.length && space2.charCodeAt(keep) == insert2.charCodeAt(keep))
      keep++;
    changes.push({ from: line2.from + keep, to: line2.from + space2.length, insert: insert2.slice(keep) });
  }), { userEvent: "delete.dedent" }));
  return true;
};
const emacsStyleKeymap = [
  { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
  { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
  { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
  { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
  { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
  { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
  { key: "Ctrl-d", run: deleteCharForward },
  { key: "Ctrl-h", run: deleteCharBackward },
  { key: "Ctrl-k", run: deleteToLineEnd },
  { key: "Ctrl-Alt-h", run: deleteGroupBackward },
  { key: "Ctrl-o", run: splitLine },
  { key: "Ctrl-t", run: transposeChars },
  { key: "Ctrl-v", run: cursorPageDown }
];
const standardKeymap = /* @__PURE__ */ [
  { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },
  { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },
  { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },
  { mac: "Cmd-ArrowRight", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },
  { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
  { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
  { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
  { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
  { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
  { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
  { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
  { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
  { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
  { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
  { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
  { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
  { key: "Enter", run: insertNewlineAndIndent },
  { key: "Mod-a", run: selectAll$2 },
  { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward },
  { key: "Delete", run: deleteCharForward },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward },
  { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward },
  { mac: "Mod-Backspace", run: deleteToLineStart },
  { mac: "Mod-Delete", run: deleteToLineEnd }
].concat(/* @__PURE__ */ emacsStyleKeymap.map((b) => ({ mac: b.key, run: b.run, shift: b.shift })));
const defaultKeymap = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
  { key: "Alt-ArrowUp", run: moveLineUp },
  { key: "Shift-Alt-ArrowUp", run: copyLineUp },
  { key: "Alt-ArrowDown", run: moveLineDown },
  { key: "Shift-Alt-ArrowDown", run: copyLineDown },
  { key: "Escape", run: simplifySelection },
  { key: "Mod-Enter", run: insertBlankLine },
  { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
  { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
  { key: "Mod-[", run: indentLess },
  { key: "Mod-]", run: indentMore },
  { key: "Mod-Alt-\\", run: indentSelection },
  { key: "Shift-Mod-k", run: deleteLine },
  { key: "Shift-Mod-\\", run: cursorMatchingBracket },
  { key: "Mod-/", run: toggleComment },
  { key: "Alt-A", run: toggleBlockComment }
].concat(standardKeymap);
class CompositeBlock {
  constructor(type2, value, from2, hash2, end2, children2, positions) {
    this.type = type2;
    this.value = value;
    this.from = from2;
    this.hash = hash2;
    this.end = end2;
    this.children = children2;
    this.positions = positions;
    this.hashProp = [[NodeProp.contextHash, hash2]];
  }
  static create(type2, value, from2, parentHash, end2) {
    let hash2 = parentHash + (parentHash << 8) + type2 + (value << 4) | 0;
    return new CompositeBlock(type2, value, from2, hash2, end2, [], []);
  }
  addChild(child, pos) {
    if (child.prop(NodeProp.contextHash) != this.hash)
      child = new Tree(child.type, child.children, child.positions, child.length, this.hashProp);
    this.children.push(child);
    this.positions.push(pos);
  }
  toTree(nodeSet2, end2 = this.end) {
    let last = this.children.length - 1;
    if (last >= 0)
      end2 = Math.max(end2, this.positions[last] + this.children[last].length + this.from);
    let tree2 = new Tree(nodeSet2.types[this.type], this.children, this.positions, end2 - this.from).balance({
      makeTree: (children2, positions, length2) => new Tree(NodeType.none, children2, positions, length2, this.hashProp)
    });
    return tree2;
  }
}
var Type$2;
(function(Type2) {
  Type2[Type2["Document"] = 1] = "Document";
  Type2[Type2["CodeBlock"] = 2] = "CodeBlock";
  Type2[Type2["FencedCode"] = 3] = "FencedCode";
  Type2[Type2["Blockquote"] = 4] = "Blockquote";
  Type2[Type2["HorizontalRule"] = 5] = "HorizontalRule";
  Type2[Type2["BulletList"] = 6] = "BulletList";
  Type2[Type2["OrderedList"] = 7] = "OrderedList";
  Type2[Type2["ListItem"] = 8] = "ListItem";
  Type2[Type2["ATXHeading1"] = 9] = "ATXHeading1";
  Type2[Type2["ATXHeading2"] = 10] = "ATXHeading2";
  Type2[Type2["ATXHeading3"] = 11] = "ATXHeading3";
  Type2[Type2["ATXHeading4"] = 12] = "ATXHeading4";
  Type2[Type2["ATXHeading5"] = 13] = "ATXHeading5";
  Type2[Type2["ATXHeading6"] = 14] = "ATXHeading6";
  Type2[Type2["SetextHeading1"] = 15] = "SetextHeading1";
  Type2[Type2["SetextHeading2"] = 16] = "SetextHeading2";
  Type2[Type2["HTMLBlock"] = 17] = "HTMLBlock";
  Type2[Type2["LinkReference"] = 18] = "LinkReference";
  Type2[Type2["Paragraph"] = 19] = "Paragraph";
  Type2[Type2["CommentBlock"] = 20] = "CommentBlock";
  Type2[Type2["ProcessingInstructionBlock"] = 21] = "ProcessingInstructionBlock";
  Type2[Type2["Escape"] = 22] = "Escape";
  Type2[Type2["Entity"] = 23] = "Entity";
  Type2[Type2["HardBreak"] = 24] = "HardBreak";
  Type2[Type2["Emphasis"] = 25] = "Emphasis";
  Type2[Type2["StrongEmphasis"] = 26] = "StrongEmphasis";
  Type2[Type2["Link"] = 27] = "Link";
  Type2[Type2["Image"] = 28] = "Image";
  Type2[Type2["InlineCode"] = 29] = "InlineCode";
  Type2[Type2["HTMLTag"] = 30] = "HTMLTag";
  Type2[Type2["Comment"] = 31] = "Comment";
  Type2[Type2["ProcessingInstruction"] = 32] = "ProcessingInstruction";
  Type2[Type2["URL"] = 33] = "URL";
  Type2[Type2["HeaderMark"] = 34] = "HeaderMark";
  Type2[Type2["QuoteMark"] = 35] = "QuoteMark";
  Type2[Type2["ListMark"] = 36] = "ListMark";
  Type2[Type2["LinkMark"] = 37] = "LinkMark";
  Type2[Type2["EmphasisMark"] = 38] = "EmphasisMark";
  Type2[Type2["CodeMark"] = 39] = "CodeMark";
  Type2[Type2["CodeText"] = 40] = "CodeText";
  Type2[Type2["CodeInfo"] = 41] = "CodeInfo";
  Type2[Type2["LinkTitle"] = 42] = "LinkTitle";
  Type2[Type2["LinkLabel"] = 43] = "LinkLabel";
})(Type$2 || (Type$2 = {}));
class LeafBlock {
  constructor(start2, content2) {
    this.start = start2;
    this.content = content2;
    this.marks = [];
    this.parsers = [];
  }
}
class Line {
  constructor() {
    this.text = "";
    this.baseIndent = 0;
    this.basePos = 0;
    this.depth = 0;
    this.markers = [];
    this.pos = 0;
    this.indent = 0;
    this.next = -1;
  }
  forward() {
    if (this.basePos > this.pos)
      this.forwardInner();
  }
  forwardInner() {
    let newPos = this.skipSpace(this.basePos);
    this.indent = this.countIndent(newPos, this.pos, this.indent);
    this.pos = newPos;
    this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);
  }
  skipSpace(from2) {
    return skipSpace(this.text, from2);
  }
  reset(text2) {
    this.text = text2;
    this.baseIndent = this.basePos = this.pos = this.indent = 0;
    this.forwardInner();
    this.depth = 1;
    while (this.markers.length)
      this.markers.pop();
  }
  moveBase(to2) {
    this.basePos = to2;
    this.baseIndent = this.countIndent(to2, this.pos, this.indent);
  }
  moveBaseColumn(indent) {
    this.baseIndent = indent;
    this.basePos = this.findColumn(indent);
  }
  addMarker(elt2) {
    this.markers.push(elt2);
  }
  countIndent(to2, from2 = 0, indent = 0) {
    for (let i = from2; i < to2; i++)
      indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;
    return indent;
  }
  findColumn(goal) {
    let i = 0;
    for (let indent = 0; i < this.text.length && indent < goal; i++)
      indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;
    return i;
  }
  scrub() {
    if (!this.baseIndent)
      return this.text;
    let result = "";
    for (let i = 0; i < this.basePos; i++)
      result += " ";
    return result + this.text.slice(this.basePos);
  }
}
function skipForList(bl, cx, line2) {
  if (line2.pos == line2.text.length || bl != cx.block && line2.indent >= cx.stack[line2.depth + 1].value + line2.baseIndent)
    return true;
  if (line2.indent >= line2.baseIndent + 4)
    return false;
  let size = (bl.type == Type$2.OrderedList ? isOrderedList : isBulletList)(line2, cx, false);
  return size > 0 && (bl.type != Type$2.BulletList || isHorizontalRule(line2, cx, false) < 0) && line2.text.charCodeAt(line2.pos + size - 1) == bl.value;
}
const DefaultSkipMarkup = {
  [Type$2.Blockquote](bl, cx, line2) {
    if (line2.next != 62)
      return false;
    line2.markers.push(elt(Type$2.QuoteMark, cx.lineStart + line2.pos, cx.lineStart + line2.pos + 1));
    line2.moveBase(line2.pos + (space$2(line2.text.charCodeAt(line2.pos + 1)) ? 2 : 1));
    bl.end = cx.lineStart + line2.text.length;
    return true;
  },
  [Type$2.ListItem](bl, _cx, line2) {
    if (line2.indent < line2.baseIndent + bl.value && line2.next > -1)
      return false;
    line2.moveBaseColumn(line2.baseIndent + bl.value);
    return true;
  },
  [Type$2.OrderedList]: skipForList,
  [Type$2.BulletList]: skipForList,
  [Type$2.Document]() {
    return true;
  }
};
function space$2(ch) {
  return ch == 32 || ch == 9 || ch == 10 || ch == 13;
}
function skipSpace(line2, i = 0) {
  while (i < line2.length && space$2(line2.charCodeAt(i)))
    i++;
  return i;
}
function skipSpaceBack(line2, i, to2) {
  while (i > to2 && space$2(line2.charCodeAt(i - 1)))
    i--;
  return i;
}
function isFencedCode(line2) {
  if (line2.next != 96 && line2.next != 126)
    return -1;
  let pos = line2.pos + 1;
  while (pos < line2.text.length && line2.text.charCodeAt(pos) == line2.next)
    pos++;
  if (pos < line2.pos + 3)
    return -1;
  if (line2.next == 96) {
    for (let i = pos; i < line2.text.length; i++)
      if (line2.text.charCodeAt(i) == 96)
        return -1;
  }
  return pos;
}
function isBlockquote(line2) {
  return line2.next != 62 ? -1 : line2.text.charCodeAt(line2.pos + 1) == 32 ? 2 : 1;
}
function isHorizontalRule(line2, cx, breaking) {
  if (line2.next != 42 && line2.next != 45 && line2.next != 95)
    return -1;
  let count2 = 1;
  for (let pos = line2.pos + 1; pos < line2.text.length; pos++) {
    let ch = line2.text.charCodeAt(pos);
    if (ch == line2.next)
      count2++;
    else if (!space$2(ch))
      return -1;
  }
  if (breaking && line2.next == 45 && isSetextUnderline(line2) > -1 && line2.depth == cx.stack.length)
    return -1;
  return count2 < 3 ? -1 : 1;
}
function inList(cx, type2) {
  for (let i = cx.stack.length - 1; i >= 0; i--)
    if (cx.stack[i].type == type2)
      return true;
  return false;
}
function isBulletList(line2, cx, breaking) {
  return (line2.next == 45 || line2.next == 43 || line2.next == 42) && (line2.pos == line2.text.length - 1 || space$2(line2.text.charCodeAt(line2.pos + 1))) && (!breaking || inList(cx, Type$2.BulletList) || line2.skipSpace(line2.pos + 2) < line2.text.length) ? 1 : -1;
}
function isOrderedList(line2, cx, breaking) {
  let pos = line2.pos, next2 = line2.next;
  for (; ; ) {
    if (next2 >= 48 && next2 <= 57)
      pos++;
    else
      break;
    if (pos == line2.text.length)
      return -1;
    next2 = line2.text.charCodeAt(pos);
  }
  if (pos == line2.pos || pos > line2.pos + 9 || next2 != 46 && next2 != 41 || pos < line2.text.length - 1 && !space$2(line2.text.charCodeAt(pos + 1)) || breaking && !inList(cx, Type$2.OrderedList) && (line2.skipSpace(pos + 1) == line2.text.length || pos > line2.pos + 1 || line2.next != 49))
    return -1;
  return pos + 1 - line2.pos;
}
function isAtxHeading(line2) {
  if (line2.next != 35)
    return -1;
  let pos = line2.pos + 1;
  while (pos < line2.text.length && line2.text.charCodeAt(pos) == 35)
    pos++;
  if (pos < line2.text.length && line2.text.charCodeAt(pos) != 32)
    return -1;
  let size = pos - line2.pos;
  return size > 6 ? -1 : size;
}
function isSetextUnderline(line2) {
  if (line2.next != 45 && line2.next != 61 || line2.indent >= line2.baseIndent + 4)
    return -1;
  let pos = line2.pos + 1;
  while (pos < line2.text.length && line2.text.charCodeAt(pos) == line2.next)
    pos++;
  let end2 = pos;
  while (pos < line2.text.length && space$2(line2.text.charCodeAt(pos)))
    pos++;
  return pos == line2.text.length ? end2 : -1;
}
const EmptyLine = /^[ \t]*$/, CommentEnd = /-->/, ProcessingEnd = /\?>/;
const HTMLBlockStyle = [
  [/^<(?:script|pre|style)(?:\s|>|$)/i, /<\/(?:script|pre|style)>/i],
  [/^\s*<!--/, CommentEnd],
  [/^\s*<\?/, ProcessingEnd],
  [/^\s*<![A-Z]/, />/],
  [/^\s*<!\[CDATA\[/, /\]\]>/],
  [/^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i, EmptyLine],
  [/^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i, EmptyLine]
];
function isHTMLBlock(line2, _cx, breaking) {
  if (line2.next != 60)
    return -1;
  let rest = line2.text.slice(line2.pos);
  for (let i = 0, e = HTMLBlockStyle.length - (breaking ? 1 : 0); i < e; i++)
    if (HTMLBlockStyle[i][0].test(rest))
      return i;
  return -1;
}
function getListIndent(line2, pos) {
  let indentAfter = line2.countIndent(pos, line2.pos, line2.indent);
  let indented = line2.countIndent(line2.skipSpace(pos), pos, indentAfter);
  return indented >= indentAfter + 5 ? indentAfter + 1 : indented;
}
function addCodeText(marks, from2, to2) {
  let last = marks.length - 1;
  if (last >= 0 && marks[last].to == from2 && marks[last].type == Type$2.CodeText)
    marks[last].to = to2;
  else
    marks.push(elt(Type$2.CodeText, from2, to2));
}
const DefaultBlockParsers = {
  LinkReference: void 0,
  IndentedCode(cx, line2) {
    let base2 = line2.baseIndent + 4;
    if (line2.indent < base2)
      return false;
    let start2 = line2.findColumn(base2);
    let from2 = cx.lineStart + start2, to2 = cx.lineStart + line2.text.length;
    let marks = [], pendingMarks = [];
    addCodeText(marks, from2, to2);
    while (cx.nextLine() && line2.depth >= cx.stack.length) {
      if (line2.pos == line2.text.length) {
        addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);
        for (let m of line2.markers)
          pendingMarks.push(m);
      } else if (line2.indent < base2) {
        break;
      } else {
        if (pendingMarks.length) {
          for (let m of pendingMarks) {
            if (m.type == Type$2.CodeText)
              addCodeText(marks, m.from, m.to);
            else
              marks.push(m);
          }
          pendingMarks = [];
        }
        addCodeText(marks, cx.lineStart - 1, cx.lineStart);
        for (let m of line2.markers)
          marks.push(m);
        to2 = cx.lineStart + line2.text.length;
        let codeStart = cx.lineStart + line2.findColumn(line2.baseIndent + 4);
        if (codeStart < to2)
          addCodeText(marks, codeStart, to2);
      }
    }
    if (pendingMarks.length) {
      pendingMarks = pendingMarks.filter((m) => m.type != Type$2.CodeText);
      if (pendingMarks.length)
        line2.markers = pendingMarks.concat(line2.markers);
    }
    cx.addNode(cx.buffer.writeElements(marks, -from2).finish(Type$2.CodeBlock, to2 - from2), from2);
    return true;
  },
  FencedCode(cx, line2) {
    let fenceEnd = isFencedCode(line2);
    if (fenceEnd < 0)
      return false;
    let from2 = cx.lineStart + line2.pos, ch = line2.next, len = fenceEnd - line2.pos;
    let infoFrom = line2.skipSpace(fenceEnd), infoTo = skipSpaceBack(line2.text, line2.text.length, infoFrom);
    let marks = [elt(Type$2.CodeMark, from2, from2 + len)];
    if (infoFrom < infoTo)
      marks.push(elt(Type$2.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));
    for (let first = true; cx.nextLine() && line2.depth >= cx.stack.length; first = false) {
      let i = line2.pos;
      if (line2.indent - line2.baseIndent < 4)
        while (i < line2.text.length && line2.text.charCodeAt(i) == ch)
          i++;
      if (i - line2.pos >= len && line2.skipSpace(i) == line2.text.length) {
        for (let m of line2.markers)
          marks.push(m);
        marks.push(elt(Type$2.CodeMark, cx.lineStart + line2.pos, cx.lineStart + i));
        cx.nextLine();
        break;
      } else {
        if (!first)
          addCodeText(marks, cx.lineStart - 1, cx.lineStart);
        for (let m of line2.markers)
          marks.push(m);
        let textStart = cx.lineStart + line2.basePos, textEnd = cx.lineStart + line2.text.length;
        if (textStart < textEnd)
          addCodeText(marks, textStart, textEnd);
      }
    }
    cx.addNode(cx.buffer.writeElements(marks, -from2).finish(Type$2.FencedCode, cx.prevLineEnd() - from2), from2);
    return true;
  },
  Blockquote(cx, line2) {
    let size = isBlockquote(line2);
    if (size < 0)
      return false;
    cx.startContext(Type$2.Blockquote, line2.pos);
    cx.addNode(Type$2.QuoteMark, cx.lineStart + line2.pos, cx.lineStart + line2.pos + 1);
    line2.moveBase(line2.pos + size);
    return null;
  },
  HorizontalRule(cx, line2) {
    if (isHorizontalRule(line2, cx, false) < 0)
      return false;
    let from2 = cx.lineStart + line2.pos;
    cx.nextLine();
    cx.addNode(Type$2.HorizontalRule, from2);
    return true;
  },
  BulletList(cx, line2) {
    let size = isBulletList(line2, cx, false);
    if (size < 0)
      return false;
    if (cx.block.type != Type$2.BulletList)
      cx.startContext(Type$2.BulletList, line2.basePos, line2.next);
    let newBase = getListIndent(line2, line2.pos + 1);
    cx.startContext(Type$2.ListItem, line2.basePos, newBase - line2.baseIndent);
    cx.addNode(Type$2.ListMark, cx.lineStart + line2.pos, cx.lineStart + line2.pos + size);
    line2.moveBaseColumn(newBase);
    return null;
  },
  OrderedList(cx, line2) {
    let size = isOrderedList(line2, cx, false);
    if (size < 0)
      return false;
    if (cx.block.type != Type$2.OrderedList)
      cx.startContext(Type$2.OrderedList, line2.basePos, line2.text.charCodeAt(line2.pos + size - 1));
    let newBase = getListIndent(line2, line2.pos + size);
    cx.startContext(Type$2.ListItem, line2.basePos, newBase - line2.baseIndent);
    cx.addNode(Type$2.ListMark, cx.lineStart + line2.pos, cx.lineStart + line2.pos + size);
    line2.moveBaseColumn(newBase);
    return null;
  },
  ATXHeading(cx, line2) {
    let size = isAtxHeading(line2);
    if (size < 0)
      return false;
    let off = line2.pos, from2 = cx.lineStart + off;
    let endOfSpace = skipSpaceBack(line2.text, line2.text.length, off), after = endOfSpace;
    while (after > off && line2.text.charCodeAt(after - 1) == line2.next)
      after--;
    if (after == endOfSpace || after == off || !space$2(line2.text.charCodeAt(after - 1)))
      after = line2.text.length;
    let buf = cx.buffer.write(Type$2.HeaderMark, 0, size).writeElements(cx.parser.parseInline(line2.text.slice(off + size + 1, after), from2 + size + 1), -from2);
    if (after < line2.text.length)
      buf.write(Type$2.HeaderMark, after - off, endOfSpace - off);
    let node2 = buf.finish(Type$2.ATXHeading1 - 1 + size, line2.text.length - off);
    cx.nextLine();
    cx.addNode(node2, from2);
    return true;
  },
  HTMLBlock(cx, line2) {
    let type2 = isHTMLBlock(line2, cx, false);
    if (type2 < 0)
      return false;
    let from2 = cx.lineStart + line2.pos, end2 = HTMLBlockStyle[type2][1];
    let marks = [], trailing = end2 != EmptyLine;
    while (!end2.test(line2.text) && cx.nextLine()) {
      if (line2.depth < cx.stack.length) {
        trailing = false;
        break;
      }
      for (let m of line2.markers)
        marks.push(m);
    }
    if (trailing)
      cx.nextLine();
    let nodeType = end2 == CommentEnd ? Type$2.CommentBlock : end2 == ProcessingEnd ? Type$2.ProcessingInstructionBlock : Type$2.HTMLBlock;
    let to2 = cx.prevLineEnd();
    cx.addNode(cx.buffer.writeElements(marks, -from2).finish(nodeType, to2 - from2), from2);
    return true;
  },
  SetextHeading: void 0
};
class LinkReferenceParser {
  constructor(leaf) {
    this.stage = 0;
    this.elts = [];
    this.pos = 0;
    this.start = leaf.start;
    this.advance(leaf.content);
  }
  nextLine(cx, line2, leaf) {
    if (this.stage == -1)
      return false;
    let content2 = leaf.content + "\n" + line2.scrub();
    let finish = this.advance(content2);
    if (finish > -1 && finish < content2.length)
      return this.complete(cx, leaf, finish);
    return false;
  }
  finish(cx, leaf) {
    if ((this.stage == 2 || this.stage == 3) && skipSpace(leaf.content, this.pos) == leaf.content.length)
      return this.complete(cx, leaf, leaf.content.length);
    return false;
  }
  complete(cx, leaf, len) {
    cx.addLeafElement(leaf, elt(Type$2.LinkReference, this.start, this.start + len, this.elts));
    return true;
  }
  nextStage(elt2) {
    if (elt2) {
      this.pos = elt2.to - this.start;
      this.elts.push(elt2);
      this.stage++;
      return true;
    }
    if (elt2 === false)
      this.stage = -1;
    return false;
  }
  advance(content2) {
    for (; ; ) {
      if (this.stage == -1) {
        return -1;
      } else if (this.stage == 0) {
        if (!this.nextStage(parseLinkLabel(content2, this.pos, this.start, true)))
          return -1;
        if (content2.charCodeAt(this.pos) != 58)
          return this.stage = -1;
        this.elts.push(elt(Type$2.LinkMark, this.pos + this.start, this.pos + this.start + 1));
        this.pos++;
      } else if (this.stage == 1) {
        if (!this.nextStage(parseURL(content2, skipSpace(content2, this.pos), this.start)))
          return -1;
      } else if (this.stage == 2) {
        let skip = skipSpace(content2, this.pos), end2 = 0;
        if (skip > this.pos) {
          let title2 = parseLinkTitle(content2, skip, this.start);
          if (title2) {
            let titleEnd = lineEnd(content2, title2.to - this.start);
            if (titleEnd > 0) {
              this.nextStage(title2);
              end2 = titleEnd;
            }
          }
        }
        if (!end2)
          end2 = lineEnd(content2, this.pos);
        return end2 > 0 && end2 < content2.length ? end2 : -1;
      } else {
        return lineEnd(content2, this.pos);
      }
    }
  }
}
function lineEnd(text2, pos) {
  for (; pos < text2.length; pos++) {
    let next2 = text2.charCodeAt(pos);
    if (next2 == 10)
      break;
    if (!space$2(next2))
      return -1;
  }
  return pos;
}
class SetextHeadingParser {
  nextLine(cx, line2, leaf) {
    let underline = line2.depth < cx.stack.length ? -1 : isSetextUnderline(line2);
    let next2 = line2.next;
    if (underline < 0)
      return false;
    let underlineMark = elt(Type$2.HeaderMark, cx.lineStart + line2.pos, cx.lineStart + underline);
    cx.nextLine();
    cx.addLeafElement(leaf, elt(next2 == 61 ? Type$2.SetextHeading1 : Type$2.SetextHeading2, leaf.start, cx.prevLineEnd(), [
      ...cx.parser.parseInline(leaf.content, leaf.start),
      underlineMark
    ]));
    return true;
  }
  finish() {
    return false;
  }
}
const DefaultLeafBlocks = {
  LinkReference(_2, leaf) {
    return leaf.content.charCodeAt(0) == 91 ? new LinkReferenceParser(leaf) : null;
  },
  SetextHeading() {
    return new SetextHeadingParser();
  }
};
const DefaultEndLeaf = [
  (_2, line2) => isAtxHeading(line2) >= 0,
  (_2, line2) => isFencedCode(line2) >= 0,
  (_2, line2) => isBlockquote(line2) >= 0,
  (p, line2) => isBulletList(line2, p, true) >= 0,
  (p, line2) => isOrderedList(line2, p, true) >= 0,
  (p, line2) => isHorizontalRule(line2, p, true) >= 0,
  (p, line2) => isHTMLBlock(line2, p, true) >= 0
];
const scanLineResult = { text: "", end: 0 };
class BlockContext {
  constructor(parser2, input, fragments, ranges2) {
    this.parser = parser2;
    this.input = input;
    this.ranges = ranges2;
    this.line = new Line();
    this.atEnd = false;
    this.dontInject = /* @__PURE__ */ new Set();
    this.stoppedAt = null;
    this.rangeI = 0;
    this.to = ranges2[ranges2.length - 1].to;
    this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges2[0].from;
    this.block = CompositeBlock.create(Type$2.Document, 0, this.lineStart, 0, 0);
    this.stack = [this.block];
    this.fragments = fragments.length ? new FragmentCursor$1(fragments, input) : null;
    this.readLine();
  }
  get parsedPos() {
    return this.absoluteLineStart;
  }
  advance() {
    if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)
      return this.finish();
    let { line: line2 } = this;
    for (; ; ) {
      while (line2.depth < this.stack.length)
        this.finishContext();
      for (let mark of line2.markers)
        this.addNode(mark.type, mark.from, mark.to);
      if (line2.pos < line2.text.length)
        break;
      if (!this.nextLine())
        return this.finish();
    }
    if (this.fragments && this.reuseFragment(line2.basePos))
      return null;
    start:
      for (; ; ) {
        for (let type2 of this.parser.blockParsers)
          if (type2) {
            let result = type2(this, line2);
            if (result != false) {
              if (result == true)
                return null;
              line2.forward();
              continue start;
            }
          }
        break;
      }
    let leaf = new LeafBlock(this.lineStart + line2.pos, line2.text.slice(line2.pos));
    for (let parse2 of this.parser.leafBlockParsers)
      if (parse2) {
        let parser2 = parse2(this, leaf);
        if (parser2)
          leaf.parsers.push(parser2);
      }
    lines:
      while (this.nextLine()) {
        if (line2.pos == line2.text.length)
          break;
        if (line2.indent < line2.baseIndent + 4) {
          for (let stop of this.parser.endLeafBlock)
            if (stop(this, line2, leaf))
              break lines;
        }
        for (let parser2 of leaf.parsers)
          if (parser2.nextLine(this, line2, leaf))
            return null;
        leaf.content += "\n" + line2.scrub();
        for (let m of line2.markers)
          leaf.marks.push(m);
      }
    this.finishLeaf(leaf);
    return null;
  }
  stopAt(pos) {
    if (this.stoppedAt != null && this.stoppedAt < pos)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = pos;
  }
  reuseFragment(start2) {
    if (!this.fragments.moveTo(this.absoluteLineStart + start2, this.absoluteLineStart) || !this.fragments.matches(this.block.hash))
      return false;
    let taken = this.fragments.takeNodes(this);
    if (!taken)
      return false;
    let withoutGaps = taken, end2 = this.absoluteLineStart + taken;
    for (let i = 1; i < this.ranges.length; i++) {
      let gapFrom = this.ranges[i - 1].to, gapTo = this.ranges[i].from;
      if (gapFrom >= this.lineStart && gapTo < end2)
        withoutGaps -= gapTo - gapFrom;
    }
    this.lineStart += withoutGaps;
    this.absoluteLineStart += taken;
    this.moveRangeI();
    if (this.absoluteLineStart < this.to) {
      this.lineStart++;
      this.absoluteLineStart++;
      this.readLine();
    } else {
      this.atEnd = true;
      this.readLine();
    }
    return true;
  }
  get depth() {
    return this.stack.length;
  }
  parentType(depth = this.depth - 1) {
    return this.parser.nodeSet.types[this.stack[depth].type];
  }
  nextLine() {
    this.lineStart += this.line.text.length;
    if (this.absoluteLineEnd >= this.to) {
      this.absoluteLineStart = this.absoluteLineEnd;
      this.atEnd = true;
      this.readLine();
      return false;
    } else {
      this.lineStart++;
      this.absoluteLineStart = this.absoluteLineEnd + 1;
      this.moveRangeI();
      this.readLine();
      return true;
    }
  }
  moveRangeI() {
    while (this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to) {
      this.rangeI++;
      this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);
    }
  }
  scanLine(start2) {
    let r = scanLineResult;
    r.end = start2;
    if (start2 >= this.to) {
      r.text = "";
    } else {
      r.text = this.lineChunkAt(start2);
      r.end += r.text.length;
      if (this.ranges.length > 1) {
        let textOffset = this.absoluteLineStart, rangeI = this.rangeI;
        while (this.ranges[rangeI].to < r.end) {
          rangeI++;
          let nextFrom = this.ranges[rangeI].from;
          let after = this.lineChunkAt(nextFrom);
          r.end = nextFrom + after.length;
          r.text = r.text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;
          textOffset = r.end - r.text.length;
        }
      }
    }
    return r;
  }
  readLine() {
    let { line: line2 } = this, { text: text2, end: end2 } = this.scanLine(this.absoluteLineStart);
    this.absoluteLineEnd = end2;
    line2.reset(text2);
    for (; line2.depth < this.stack.length; line2.depth++) {
      let cx = this.stack[line2.depth], handler = this.parser.skipContextMarkup[cx.type];
      if (!handler)
        throw new Error("Unhandled block context " + Type$2[cx.type]);
      if (!handler(cx, this, line2))
        break;
      line2.forward();
    }
  }
  lineChunkAt(pos) {
    let next2 = this.input.chunk(pos), text2;
    if (!this.input.lineChunks) {
      let eol = next2.indexOf("\n");
      text2 = eol < 0 ? next2 : next2.slice(0, eol);
    } else {
      text2 = next2 == "\n" ? "" : next2;
    }
    return pos + text2.length > this.to ? text2.slice(0, this.to - pos) : text2;
  }
  prevLineEnd() {
    return this.atEnd ? this.lineStart : this.lineStart - 1;
  }
  startContext(type2, start2, value = 0) {
    this.block = CompositeBlock.create(type2, value, this.lineStart + start2, this.block.hash, this.lineStart + this.line.text.length);
    this.stack.push(this.block);
  }
  startComposite(type2, start2, value = 0) {
    this.startContext(this.parser.getNodeType(type2), start2, value);
  }
  addNode(block, from2, to2) {
    if (typeof block == "number")
      block = new Tree(this.parser.nodeSet.types[block], none$4, none$4, (to2 !== null && to2 !== void 0 ? to2 : this.prevLineEnd()) - from2);
    this.block.addChild(block, from2 - this.block.from);
  }
  addElement(elt2) {
    this.block.addChild(elt2.toTree(this.parser.nodeSet), elt2.from - this.block.from);
  }
  addLeafElement(leaf, elt2) {
    this.addNode(this.buffer.writeElements(injectMarks(elt2.children, leaf.marks), -elt2.from).finish(elt2.type, elt2.to - elt2.from), elt2.from);
  }
  finishContext() {
    let cx = this.stack.pop();
    let top2 = this.stack[this.stack.length - 1];
    top2.addChild(cx.toTree(this.parser.nodeSet), cx.from - top2.from);
    this.block = top2;
  }
  finish() {
    while (this.stack.length > 1)
      this.finishContext();
    return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));
  }
  addGaps(tree2) {
    return this.ranges.length > 1 ? injectGaps(this.ranges, 0, tree2.topNode, this.ranges[0].from, this.dontInject) : tree2;
  }
  finishLeaf(leaf) {
    for (let parser2 of leaf.parsers)
      if (parser2.finish(this, leaf))
        return;
    let inline = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);
    this.addNode(this.buffer.writeElements(inline, -leaf.start).finish(Type$2.Paragraph, leaf.content.length), leaf.start);
  }
  elt(type2, from2, to2, children2) {
    if (typeof type2 == "string")
      return elt(this.parser.getNodeType(type2), from2, to2, children2);
    return new TreeElement(type2, from2);
  }
  get buffer() {
    return new Buffer(this.parser.nodeSet);
  }
}
function injectGaps(ranges2, rangeI, tree2, offset, dont) {
  if (dont.has(tree2.tree))
    return tree2.tree;
  let rangeEnd2 = ranges2[rangeI].to;
  let children2 = [], positions = [], start2 = tree2.from + offset;
  function movePastNext(upto, inclusive) {
    while (inclusive ? upto >= rangeEnd2 : upto > rangeEnd2) {
      let size = ranges2[rangeI + 1].from - rangeEnd2;
      offset += size;
      upto += size;
      rangeI++;
      rangeEnd2 = ranges2[rangeI].to;
    }
  }
  for (let ch = tree2.firstChild; ch; ch = ch.nextSibling) {
    movePastNext(ch.from + offset, true);
    let from2 = ch.from + offset, node2;
    if (ch.to + offset > rangeEnd2) {
      node2 = injectGaps(ranges2, rangeI, ch, offset, dont);
      movePastNext(ch.to + offset, false);
    } else {
      node2 = ch.toTree();
    }
    children2.push(node2);
    positions.push(from2 - start2);
  }
  movePastNext(tree2.to + offset, false);
  return new Tree(tree2.type, children2, positions, tree2.to + offset - start2, tree2.tree ? tree2.tree.propValues : void 0);
}
class MarkdownParser extends Parser {
  constructor(nodeSet2, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers) {
    super();
    this.nodeSet = nodeSet2;
    this.blockParsers = blockParsers;
    this.leafBlockParsers = leafBlockParsers;
    this.blockNames = blockNames;
    this.endLeafBlock = endLeafBlock;
    this.skipContextMarkup = skipContextMarkup;
    this.inlineParsers = inlineParsers;
    this.inlineNames = inlineNames;
    this.wrappers = wrappers;
    this.nodeTypes = /* @__PURE__ */ Object.create(null);
    for (let t4 of nodeSet2.types)
      this.nodeTypes[t4.name] = t4.id;
  }
  createParse(input, fragments, ranges2) {
    let parse2 = new BlockContext(this, input, fragments, ranges2);
    for (let w2 of this.wrappers)
      parse2 = w2(parse2, input, fragments, ranges2);
    return parse2;
  }
  configure(spec) {
    let config2 = resolveConfig(spec);
    if (!config2)
      return this;
    let { nodeSet: nodeSet2, skipContextMarkup } = this;
    let blockParsers = this.blockParsers.slice(), leafBlockParsers = this.leafBlockParsers.slice(), blockNames = this.blockNames.slice(), inlineParsers = this.inlineParsers.slice(), inlineNames = this.inlineNames.slice(), endLeafBlock = this.endLeafBlock.slice(), wrappers = this.wrappers;
    if (nonEmpty(config2.defineNodes)) {
      skipContextMarkup = Object.assign({}, skipContextMarkup);
      let nodeTypes2 = nodeSet2.types.slice(), styles;
      for (let s2 of config2.defineNodes) {
        let { name: name2, block, composite, style: style2 } = typeof s2 == "string" ? { name: s2 } : s2;
        if (nodeTypes2.some((t4) => t4.name == name2))
          continue;
        if (composite)
          skipContextMarkup[nodeTypes2.length] = (bl, cx, line2) => composite(cx, line2, bl.value);
        let id2 = nodeTypes2.length;
        let group = composite ? ["Block", "BlockContext"] : !block ? void 0 : id2 >= Type$2.ATXHeading1 && id2 <= Type$2.SetextHeading2 ? ["Block", "LeafBlock", "Heading"] : ["Block", "LeafBlock"];
        nodeTypes2.push(NodeType.define({
          id: id2,
          name: name2,
          props: group && [[NodeProp.group, group]]
        }));
        if (style2) {
          if (!styles)
            styles = {};
          if (Array.isArray(style2) || style2 instanceof Tag)
            styles[name2] = style2;
          else
            Object.assign(styles, style2);
        }
      }
      nodeSet2 = new NodeSet(nodeTypes2);
      if (styles)
        nodeSet2 = nodeSet2.extend(styleTags(styles));
    }
    if (nonEmpty(config2.props))
      nodeSet2 = nodeSet2.extend(...config2.props);
    if (nonEmpty(config2.remove)) {
      for (let rm2 of config2.remove) {
        let block = this.blockNames.indexOf(rm2), inline = this.inlineNames.indexOf(rm2);
        if (block > -1)
          blockParsers[block] = leafBlockParsers[block] = void 0;
        if (inline > -1)
          inlineParsers[inline] = void 0;
      }
    }
    if (nonEmpty(config2.parseBlock)) {
      for (let spec2 of config2.parseBlock) {
        let found = blockNames.indexOf(spec2.name);
        if (found > -1) {
          blockParsers[found] = spec2.parse;
          leafBlockParsers[found] = spec2.leaf;
        } else {
          let pos = spec2.before ? findName(blockNames, spec2.before) : spec2.after ? findName(blockNames, spec2.after) + 1 : blockNames.length - 1;
          blockParsers.splice(pos, 0, spec2.parse);
          leafBlockParsers.splice(pos, 0, spec2.leaf);
          blockNames.splice(pos, 0, spec2.name);
        }
        if (spec2.endLeaf)
          endLeafBlock.push(spec2.endLeaf);
      }
    }
    if (nonEmpty(config2.parseInline)) {
      for (let spec2 of config2.parseInline) {
        let found = inlineNames.indexOf(spec2.name);
        if (found > -1) {
          inlineParsers[found] = spec2.parse;
        } else {
          let pos = spec2.before ? findName(inlineNames, spec2.before) : spec2.after ? findName(inlineNames, spec2.after) + 1 : inlineNames.length - 1;
          inlineParsers.splice(pos, 0, spec2.parse);
          inlineNames.splice(pos, 0, spec2.name);
        }
      }
    }
    if (config2.wrap)
      wrappers = wrappers.concat(config2.wrap);
    return new MarkdownParser(nodeSet2, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);
  }
  getNodeType(name2) {
    let found = this.nodeTypes[name2];
    if (found == null)
      throw new RangeError(`Unknown node type '${name2}'`);
    return found;
  }
  parseInline(text2, offset) {
    let cx = new InlineContext(this, text2, offset);
    outer:
      for (let pos = offset; pos < cx.end; ) {
        let next2 = cx.char(pos);
        for (let token2 of this.inlineParsers)
          if (token2) {
            let result = token2(cx, next2, pos);
            if (result >= 0) {
              pos = result;
              continue outer;
            }
          }
        pos++;
      }
    return cx.resolveMarkers(0);
  }
}
function nonEmpty(a2) {
  return a2 != null && a2.length > 0;
}
function resolveConfig(spec) {
  if (!Array.isArray(spec))
    return spec;
  if (spec.length == 0)
    return null;
  let conf2 = resolveConfig(spec[0]);
  if (spec.length == 1)
    return conf2;
  let rest = resolveConfig(spec.slice(1));
  if (!rest || !conf2)
    return conf2 || rest;
  let conc2 = (a2, b) => (a2 || none$4).concat(b || none$4);
  let wrapA = conf2.wrap, wrapB = rest.wrap;
  return {
    props: conc2(conf2.props, rest.props),
    defineNodes: conc2(conf2.defineNodes, rest.defineNodes),
    parseBlock: conc2(conf2.parseBlock, rest.parseBlock),
    parseInline: conc2(conf2.parseInline, rest.parseInline),
    remove: conc2(conf2.remove, rest.remove),
    wrap: !wrapA ? wrapB : !wrapB ? wrapA : (inner, input, fragments, ranges2) => wrapA(wrapB(inner, input, fragments, ranges2), input, fragments, ranges2)
  };
}
function findName(names, name2) {
  let found = names.indexOf(name2);
  if (found < 0)
    throw new RangeError(`Position specified relative to unknown parser ${name2}`);
  return found;
}
let nodeTypes = [NodeType.none];
for (let i = 1, name2; name2 = Type$2[i]; i++) {
  nodeTypes[i] = NodeType.define({
    id: i,
    name: name2,
    props: i >= Type$2.Escape ? [] : [[NodeProp.group, i in DefaultSkipMarkup ? ["Block", "BlockContext"] : ["Block", "LeafBlock"]]]
  });
}
const none$4 = [];
class Buffer {
  constructor(nodeSet2) {
    this.nodeSet = nodeSet2;
    this.content = [];
    this.nodes = [];
  }
  write(type2, from2, to2, children2 = 0) {
    this.content.push(type2, from2, to2, 4 + children2 * 4);
    return this;
  }
  writeElements(elts, offset = 0) {
    for (let e of elts)
      e.writeTo(this, offset);
    return this;
  }
  finish(type2, length2) {
    return Tree.build({
      buffer: this.content,
      nodeSet: this.nodeSet,
      reused: this.nodes,
      topID: type2,
      length: length2
    });
  }
}
class Element$1 {
  constructor(type2, from2, to2, children2 = none$4) {
    this.type = type2;
    this.from = from2;
    this.to = to2;
    this.children = children2;
  }
  writeTo(buf, offset) {
    let startOff = buf.content.length;
    buf.writeElements(this.children, offset);
    buf.content.push(this.type, this.from + offset, this.to + offset, buf.content.length + 4 - startOff);
  }
  toTree(nodeSet2) {
    return new Buffer(nodeSet2).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);
  }
}
class TreeElement {
  constructor(tree2, from2) {
    this.tree = tree2;
    this.from = from2;
  }
  get to() {
    return this.from + this.tree.length;
  }
  get type() {
    return this.tree.type.id;
  }
  get children() {
    return none$4;
  }
  writeTo(buf, offset) {
    buf.nodes.push(this.tree);
    buf.content.push(buf.nodes.length - 1, this.from + offset, this.to + offset, -1);
  }
  toTree() {
    return this.tree;
  }
}
function elt(type2, from2, to2, children2) {
  return new Element$1(type2, from2, to2, children2);
}
const EmphasisUnderscore = { resolve: "Emphasis", mark: "EmphasisMark" };
const EmphasisAsterisk = { resolve: "Emphasis", mark: "EmphasisMark" };
const LinkStart = {}, ImageStart = {};
class InlineDelimiter {
  constructor(type2, from2, to2, side) {
    this.type = type2;
    this.from = from2;
    this.to = to2;
    this.side = side;
  }
}
const Escapable = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
let Punctuation = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/;
try {
  Punctuation = new RegExp("[\\p{Pc}|\\p{Pd}|\\p{Pe}|\\p{Pf}|\\p{Pi}|\\p{Po}|\\p{Ps}]", "u");
} catch (_2) {
}
const DefaultInline = {
  Escape(cx, next2, start2) {
    if (next2 != 92 || start2 == cx.end - 1)
      return -1;
    let escaped = cx.char(start2 + 1);
    for (let i = 0; i < Escapable.length; i++)
      if (Escapable.charCodeAt(i) == escaped)
        return cx.append(elt(Type$2.Escape, start2, start2 + 2));
    return -1;
  },
  Entity(cx, next2, start2) {
    if (next2 != 38)
      return -1;
    let m = /^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(cx.slice(start2 + 1, start2 + 31));
    return m ? cx.append(elt(Type$2.Entity, start2, start2 + 1 + m[0].length)) : -1;
  },
  InlineCode(cx, next2, start2) {
    if (next2 != 96 || start2 && cx.char(start2 - 1) == 96)
      return -1;
    let pos = start2 + 1;
    while (pos < cx.end && cx.char(pos) == 96)
      pos++;
    let size = pos - start2, curSize = 0;
    for (; pos < cx.end; pos++) {
      if (cx.char(pos) == 96) {
        curSize++;
        if (curSize == size && cx.char(pos + 1) != 96)
          return cx.append(elt(Type$2.InlineCode, start2, pos + 1, [
            elt(Type$2.CodeMark, start2, start2 + size),
            elt(Type$2.CodeMark, pos + 1 - size, pos + 1)
          ]));
      } else {
        curSize = 0;
      }
    }
    return -1;
  },
  HTMLTag(cx, next2, start2) {
    if (next2 != 60 || start2 == cx.end - 1)
      return -1;
    let after = cx.slice(start2 + 1, cx.end);
    let url = /^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(after);
    if (url)
      return cx.append(elt(Type$2.URL, start2, start2 + 1 + url[0].length));
    let comment2 = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);
    if (comment2)
      return cx.append(elt(Type$2.Comment, start2, start2 + 1 + comment2[0].length));
    let procInst = /^\?[^]*?\?>/.exec(after);
    if (procInst)
      return cx.append(elt(Type$2.ProcessingInstruction, start2, start2 + 1 + procInst[0].length));
    let m = /^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(after);
    if (!m)
      return -1;
    return cx.append(elt(Type$2.HTMLTag, start2, start2 + 1 + m[0].length));
  },
  Emphasis(cx, next2, start2) {
    if (next2 != 95 && next2 != 42)
      return -1;
    let pos = start2 + 1;
    while (cx.char(pos) == next2)
      pos++;
    let before = cx.slice(start2 - 1, start2), after = cx.slice(pos, pos + 1);
    let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);
    let sBefore = /\s|^$/.test(before), sAfter = /\s|^$/.test(after);
    let leftFlanking = !sAfter && (!pAfter || sBefore || pBefore);
    let rightFlanking = !sBefore && (!pBefore || sAfter || pAfter);
    let canOpen = leftFlanking && (next2 == 42 || !rightFlanking || pBefore);
    let canClose = rightFlanking && (next2 == 42 || !leftFlanking || pAfter);
    return cx.append(new InlineDelimiter(next2 == 95 ? EmphasisUnderscore : EmphasisAsterisk, start2, pos, (canOpen ? 1 : 0) | (canClose ? 2 : 0)));
  },
  HardBreak(cx, next2, start2) {
    if (next2 == 92 && cx.char(start2 + 1) == 10)
      return cx.append(elt(Type$2.HardBreak, start2, start2 + 2));
    if (next2 == 32) {
      let pos = start2 + 1;
      while (cx.char(pos) == 32)
        pos++;
      if (cx.char(pos) == 10 && pos >= start2 + 2)
        return cx.append(elt(Type$2.HardBreak, start2, pos + 1));
    }
    return -1;
  },
  Link(cx, next2, start2) {
    return next2 == 91 ? cx.append(new InlineDelimiter(LinkStart, start2, start2 + 1, 1)) : -1;
  },
  Image(cx, next2, start2) {
    return next2 == 33 && cx.char(start2 + 1) == 91 ? cx.append(new InlineDelimiter(ImageStart, start2, start2 + 2, 1)) : -1;
  },
  LinkEnd(cx, next2, start2) {
    if (next2 != 93)
      return -1;
    for (let i = cx.parts.length - 1; i >= 0; i--) {
      let part = cx.parts[i];
      if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart)) {
        if (!part.side || cx.skipSpace(part.to) == start2 && !/[(\[]/.test(cx.slice(start2 + 1, start2 + 2))) {
          cx.parts[i] = null;
          return -1;
        }
        let content2 = cx.takeContent(i);
        let link2 = cx.parts[i] = finishLink(cx, content2, part.type == LinkStart ? Type$2.Link : Type$2.Image, part.from, start2 + 1);
        if (part.type == LinkStart)
          for (let j2 = 0; j2 < i; j2++) {
            let p = cx.parts[j2];
            if (p instanceof InlineDelimiter && p.type == LinkStart)
              p.side = 0;
          }
        return link2.to;
      }
    }
    return -1;
  }
};
function finishLink(cx, content2, type2, start2, startPos) {
  let { text: text2 } = cx, next2 = cx.char(startPos), endPos = startPos;
  content2.unshift(elt(Type$2.LinkMark, start2, start2 + (type2 == Type$2.Image ? 2 : 1)));
  content2.push(elt(Type$2.LinkMark, startPos - 1, startPos));
  if (next2 == 40) {
    let pos = cx.skipSpace(startPos + 1);
    let dest = parseURL(text2, pos - cx.offset, cx.offset), title2;
    if (dest) {
      pos = cx.skipSpace(dest.to);
      title2 = parseLinkTitle(text2, pos - cx.offset, cx.offset);
      if (title2)
        pos = cx.skipSpace(title2.to);
    }
    if (cx.char(pos) == 41) {
      content2.push(elt(Type$2.LinkMark, startPos, startPos + 1));
      endPos = pos + 1;
      if (dest)
        content2.push(dest);
      if (title2)
        content2.push(title2);
      content2.push(elt(Type$2.LinkMark, pos, endPos));
    }
  } else if (next2 == 91) {
    let label = parseLinkLabel(text2, startPos - cx.offset, cx.offset, false);
    if (label) {
      content2.push(label);
      endPos = label.to;
    }
  }
  return elt(type2, start2, endPos, content2);
}
function parseURL(text2, start2, offset) {
  let next2 = text2.charCodeAt(start2);
  if (next2 == 60) {
    for (let pos = start2 + 1; pos < text2.length; pos++) {
      let ch = text2.charCodeAt(pos);
      if (ch == 62)
        return elt(Type$2.URL, start2 + offset, pos + 1 + offset);
      if (ch == 60 || ch == 10)
        return false;
    }
    return null;
  } else {
    let depth = 0, pos = start2;
    for (let escaped = false; pos < text2.length; pos++) {
      let ch = text2.charCodeAt(pos);
      if (space$2(ch)) {
        break;
      } else if (escaped) {
        escaped = false;
      } else if (ch == 40) {
        depth++;
      } else if (ch == 41) {
        if (!depth)
          break;
        depth--;
      } else if (ch == 92) {
        escaped = true;
      }
    }
    return pos > start2 ? elt(Type$2.URL, start2 + offset, pos + offset) : pos == text2.length ? null : false;
  }
}
function parseLinkTitle(text2, start2, offset) {
  let next2 = text2.charCodeAt(start2);
  if (next2 != 39 && next2 != 34 && next2 != 40)
    return false;
  let end2 = next2 == 40 ? 41 : next2;
  for (let pos = start2 + 1, escaped = false; pos < text2.length; pos++) {
    let ch = text2.charCodeAt(pos);
    if (escaped)
      escaped = false;
    else if (ch == end2)
      return elt(Type$2.LinkTitle, start2 + offset, pos + 1 + offset);
    else if (ch == 92)
      escaped = true;
  }
  return null;
}
function parseLinkLabel(text2, start2, offset, requireNonWS) {
  for (let escaped = false, pos = start2 + 1, end2 = Math.min(text2.length, pos + 999); pos < end2; pos++) {
    let ch = text2.charCodeAt(pos);
    if (escaped)
      escaped = false;
    else if (ch == 93)
      return requireNonWS ? false : elt(Type$2.LinkLabel, start2 + offset, pos + 1 + offset);
    else {
      if (requireNonWS && !space$2(ch))
        requireNonWS = false;
      if (ch == 91)
        return false;
      else if (ch == 92)
        escaped = true;
    }
  }
  return null;
}
class InlineContext {
  constructor(parser2, text2, offset) {
    this.parser = parser2;
    this.text = text2;
    this.offset = offset;
    this.parts = [];
  }
  char(pos) {
    return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset);
  }
  get end() {
    return this.offset + this.text.length;
  }
  slice(from2, to2) {
    return this.text.slice(from2 - this.offset, to2 - this.offset);
  }
  append(elt2) {
    this.parts.push(elt2);
    return elt2.to;
  }
  addDelimiter(type2, from2, to2, open, close) {
    return this.append(new InlineDelimiter(type2, from2, to2, (open ? 1 : 0) | (close ? 2 : 0)));
  }
  addElement(elt2) {
    return this.append(elt2);
  }
  resolveMarkers(from2) {
    for (let i = from2; i < this.parts.length; i++) {
      let close = this.parts[i];
      if (!(close instanceof InlineDelimiter && close.type.resolve && close.side & 2))
        continue;
      let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;
      let closeSize = close.to - close.from;
      let open, j2 = i - 1;
      for (; j2 >= from2; j2--) {
        let part = this.parts[j2];
        if (part instanceof InlineDelimiter && part.side & 1 && part.type == close.type && !(emp && (close.side & 1 || part.side & 2) && (part.to - part.from + closeSize) % 3 == 0 && ((part.to - part.from) % 3 || closeSize % 3))) {
          open = part;
          break;
        }
      }
      if (!open)
        continue;
      let type2 = close.type.resolve, content2 = [];
      let start2 = open.from, end2 = close.to;
      if (emp) {
        let size = Math.min(2, open.to - open.from, closeSize);
        start2 = open.to - size;
        end2 = close.from + size;
        type2 = size == 1 ? "Emphasis" : "StrongEmphasis";
      }
      if (open.type.mark)
        content2.push(this.elt(open.type.mark, start2, open.to));
      for (let k2 = j2 + 1; k2 < i; k2++) {
        if (this.parts[k2] instanceof Element$1)
          content2.push(this.parts[k2]);
        this.parts[k2] = null;
      }
      if (close.type.mark)
        content2.push(this.elt(close.type.mark, close.from, end2));
      let element = this.elt(type2, start2, end2, content2);
      this.parts[j2] = emp && open.from != start2 ? new InlineDelimiter(open.type, open.from, start2, open.side) : null;
      let keep = this.parts[i] = emp && close.to != end2 ? new InlineDelimiter(close.type, end2, close.to, close.side) : null;
      if (keep)
        this.parts.splice(i, 0, element);
      else
        this.parts[i] = element;
    }
    let result = [];
    for (let i = from2; i < this.parts.length; i++) {
      let part = this.parts[i];
      if (part instanceof Element$1)
        result.push(part);
    }
    return result;
  }
  findOpeningDelimiter(type2) {
    for (let i = this.parts.length - 1; i >= 0; i--) {
      let part = this.parts[i];
      if (part instanceof InlineDelimiter && part.type == type2)
        return i;
    }
    return null;
  }
  takeContent(startIndex) {
    let content2 = this.resolveMarkers(startIndex);
    this.parts.length = startIndex;
    return content2;
  }
  skipSpace(from2) {
    return skipSpace(this.text, from2 - this.offset) + this.offset;
  }
  elt(type2, from2, to2, children2) {
    if (typeof type2 == "string")
      return elt(this.parser.getNodeType(type2), from2, to2, children2);
    return new TreeElement(type2, from2);
  }
}
function injectMarks(elements2, marks) {
  if (!marks.length)
    return elements2;
  if (!elements2.length)
    return marks;
  let elts = elements2.slice(), eI = 0;
  for (let mark of marks) {
    while (eI < elts.length && elts[eI].to < mark.to)
      eI++;
    if (eI < elts.length && elts[eI].from < mark.from) {
      let e = elts[eI];
      if (e instanceof Element$1)
        elts[eI] = new Element$1(e.type, e.from, e.to, injectMarks(e.children, [mark]));
    } else {
      elts.splice(eI++, 0, mark);
    }
  }
  return elts;
}
const NotLast = [Type$2.CodeBlock, Type$2.ListItem, Type$2.OrderedList, Type$2.BulletList];
class FragmentCursor$1 {
  constructor(fragments, input) {
    this.fragments = fragments;
    this.input = input;
    this.i = 0;
    this.fragment = null;
    this.fragmentEnd = -1;
    this.cursor = null;
    if (fragments.length)
      this.fragment = fragments[this.i++];
  }
  nextFragment() {
    this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null;
    this.cursor = null;
    this.fragmentEnd = -1;
  }
  moveTo(pos, lineStart) {
    while (this.fragment && this.fragment.to <= pos)
      this.nextFragment();
    if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0))
      return false;
    if (this.fragmentEnd < 0) {
      let end2 = this.fragment.to;
      while (end2 > 0 && this.input.read(end2 - 1, end2) != "\n")
        end2--;
      this.fragmentEnd = end2 ? end2 - 1 : 0;
    }
    let c2 = this.cursor;
    if (!c2) {
      c2 = this.cursor = this.fragment.tree.cursor();
      c2.firstChild();
    }
    let rPos = pos + this.fragment.offset;
    while (c2.to <= rPos)
      if (!c2.parent())
        return false;
    for (; ; ) {
      if (c2.from >= rPos)
        return this.fragment.from <= lineStart;
      if (!c2.childAfter(rPos))
        return false;
    }
  }
  matches(hash2) {
    let tree2 = this.cursor.tree;
    return tree2 && tree2.prop(NodeProp.contextHash) == hash2;
  }
  takeNodes(cx) {
    let cur2 = this.cursor, off = this.fragment.offset, fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);
    let start2 = cx.absoluteLineStart, end2 = start2, blockI = cx.block.children.length;
    let prevEnd = end2, prevI = blockI;
    for (; ; ) {
      if (cur2.to - off > fragEnd) {
        if (cur2.type.isAnonymous && cur2.firstChild())
          continue;
        break;
      }
      cx.dontInject.add(cur2.tree);
      cx.addNode(cur2.tree, cur2.from - off);
      if (cur2.type.is("Block")) {
        if (NotLast.indexOf(cur2.type.id) < 0) {
          end2 = cur2.to - off;
          blockI = cx.block.children.length;
        } else {
          end2 = prevEnd;
          blockI = prevI;
          prevEnd = cur2.to - off;
          prevI = cx.block.children.length;
        }
      }
      if (!cur2.nextSibling())
        break;
    }
    while (cx.block.children.length > blockI) {
      cx.block.children.pop();
      cx.block.positions.pop();
    }
    return end2 - start2;
  }
}
const markdownHighlighting = styleTags({
  "Blockquote/...": tags$5.quote,
  HorizontalRule: tags$5.contentSeparator,
  "ATXHeading1/... SetextHeading1/...": tags$5.heading1,
  "ATXHeading2/... SetextHeading2/...": tags$5.heading2,
  "ATXHeading3/...": tags$5.heading3,
  "ATXHeading4/...": tags$5.heading4,
  "ATXHeading5/...": tags$5.heading5,
  "ATXHeading6/...": tags$5.heading6,
  "Comment CommentBlock": tags$5.comment,
  Escape: tags$5.escape,
  Entity: tags$5.character,
  "Emphasis/...": tags$5.emphasis,
  "StrongEmphasis/...": tags$5.strong,
  "Link/... Image/...": tags$5.link,
  "OrderedList/... BulletList/...": tags$5.list,
  "BlockQuote/...": tags$5.quote,
  "InlineCode CodeText": tags$5.monospace,
  URL: tags$5.url,
  "HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark": tags$5.processingInstruction,
  "CodeInfo LinkLabel": tags$5.labelName,
  LinkTitle: tags$5.string,
  Paragraph: tags$5.content
});
const parser$g = new MarkdownParser(new NodeSet(nodeTypes).extend(markdownHighlighting), Object.keys(DefaultBlockParsers).map((n) => DefaultBlockParsers[n]), Object.keys(DefaultBlockParsers).map((n) => DefaultLeafBlocks[n]), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map((n) => DefaultInline[n]), Object.keys(DefaultInline), []);
function leftOverSpace(node2, from2, to2) {
  let ranges2 = [];
  for (let n = node2.firstChild, pos = from2; ; n = n.nextSibling) {
    let nextPos = n ? n.from : to2;
    if (nextPos > pos)
      ranges2.push({ from: pos, to: nextPos });
    if (!n)
      break;
    pos = n.to;
  }
  return ranges2;
}
function parseCode(config2) {
  let { codeParser, htmlParser } = config2;
  let wrap = parseMixed((node2, input) => {
    let id2 = node2.type.id;
    if (codeParser && (id2 == Type$2.CodeBlock || id2 == Type$2.FencedCode)) {
      let info2 = "";
      if (id2 == Type$2.FencedCode) {
        let infoNode = node2.node.getChild(Type$2.CodeInfo);
        if (infoNode)
          info2 = input.read(infoNode.from, infoNode.to);
      }
      let parser2 = codeParser(info2);
      if (parser2)
        return { parser: parser2, overlay: (node3) => node3.type.id == Type$2.CodeText };
    } else if (htmlParser && (id2 == Type$2.HTMLBlock || id2 == Type$2.HTMLTag)) {
      return { parser: htmlParser, overlay: leftOverSpace(node2.node, node2.from, node2.to) };
    }
    return null;
  });
  return { wrap };
}
const StrikethroughDelim = { resolve: "Strikethrough", mark: "StrikethroughMark" };
const Strikethrough = {
  defineNodes: [{
    name: "Strikethrough",
    style: { "Strikethrough/...": tags$5.strikethrough }
  }, {
    name: "StrikethroughMark",
    style: tags$5.processingInstruction
  }],
  parseInline: [{
    name: "Strikethrough",
    parse(cx, next2, pos) {
      if (next2 != 126 || cx.char(pos + 1) != 126 || cx.char(pos + 2) == 126)
        return -1;
      let before = cx.slice(pos - 1, pos), after = cx.slice(pos + 2, pos + 3);
      let sBefore = /\s|^$/.test(before), sAfter = /\s|^$/.test(after);
      let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);
      return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, !sAfter && (!pAfter || sBefore || pBefore), !sBefore && (!pBefore || sAfter || pAfter));
    },
    after: "Emphasis"
  }]
};
function parseRow(cx, line2, startI = 0, elts, offset = 0) {
  let count2 = 0, first = true, cellStart = -1, cellEnd = -1, esc = false;
  let parseCell = () => {
    elts.push(cx.elt("TableCell", offset + cellStart, offset + cellEnd, cx.parser.parseInline(line2.slice(cellStart, cellEnd), offset + cellStart)));
  };
  for (let i = startI; i < line2.length; i++) {
    let next2 = line2.charCodeAt(i);
    if (next2 == 124 && !esc) {
      if (!first || cellStart > -1)
        count2++;
      first = false;
      if (elts) {
        if (cellStart > -1)
          parseCell();
        elts.push(cx.elt("TableDelimiter", i + offset, i + offset + 1));
      }
      cellStart = cellEnd = -1;
    } else if (esc || next2 != 32 && next2 != 9) {
      if (cellStart < 0)
        cellStart = i;
      cellEnd = i + 1;
    }
    esc = !esc && next2 == 92;
  }
  if (cellStart > -1) {
    count2++;
    if (elts)
      parseCell();
  }
  return count2;
}
function hasPipe(str, start2) {
  for (let i = start2; i < str.length; i++) {
    let next2 = str.charCodeAt(i);
    if (next2 == 124)
      return true;
    if (next2 == 92)
      i++;
  }
  return false;
}
const delimiterLine = /^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/;
class TableParser {
  constructor() {
    this.rows = null;
  }
  nextLine(cx, line2, leaf) {
    if (this.rows == null) {
      this.rows = false;
      let lineText;
      if ((line2.next == 45 || line2.next == 58 || line2.next == 124) && delimiterLine.test(lineText = line2.text.slice(line2.pos))) {
        let firstRow = [], firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);
        if (firstCount == parseRow(cx, lineText, line2.pos))
          this.rows = [
            cx.elt("TableHeader", leaf.start, leaf.start + leaf.content.length, firstRow),
            cx.elt("TableDelimiter", cx.lineStart + line2.pos, cx.lineStart + line2.text.length)
          ];
      }
    } else if (this.rows) {
      let content2 = [];
      parseRow(cx, line2.text, line2.pos, content2, cx.lineStart);
      this.rows.push(cx.elt("TableRow", cx.lineStart + line2.pos, cx.lineStart + line2.text.length, content2));
    }
    return false;
  }
  finish(cx, leaf) {
    if (!this.rows)
      return false;
    cx.addLeafElement(leaf, cx.elt("Table", leaf.start, leaf.start + leaf.content.length, this.rows));
    return true;
  }
}
const Table = {
  defineNodes: [
    { name: "Table", block: true },
    { name: "TableHeader", style: { "TableHeader/...": tags$5.heading } },
    "TableRow",
    { name: "TableCell", style: tags$5.content },
    { name: "TableDelimiter", style: tags$5.processingInstruction }
  ],
  parseBlock: [{
    name: "Table",
    leaf(_2, leaf) {
      return hasPipe(leaf.content, 0) ? new TableParser() : null;
    },
    endLeaf(cx, line2, leaf) {
      if (leaf.parsers.some((p) => p instanceof TableParser) || !hasPipe(line2.text, line2.basePos))
        return false;
      let next2 = cx.scanLine(cx.absoluteLineEnd + 1).text;
      return delimiterLine.test(next2) && parseRow(cx, line2.text, line2.basePos) == parseRow(cx, next2, line2.basePos);
    },
    before: "SetextHeading"
  }]
};
class TaskParser {
  nextLine() {
    return false;
  }
  finish(cx, leaf) {
    cx.addLeafElement(leaf, cx.elt("Task", leaf.start, leaf.start + leaf.content.length, [
      cx.elt("TaskMarker", leaf.start, leaf.start + 3),
      ...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)
    ]));
    return true;
  }
}
const TaskList = {
  defineNodes: [
    { name: "Task", block: true, style: tags$5.list },
    { name: "TaskMarker", style: tags$5.atom }
  ],
  parseBlock: [{
    name: "TaskList",
    leaf(cx, leaf) {
      return /^\[[ xX]\]/.test(leaf.content) && cx.parentType().name == "ListItem" ? new TaskParser() : null;
    },
    after: "SetextHeading"
  }]
};
const GFM = [Table, TaskList, Strikethrough];
function parseSubSuper(ch, node2, mark) {
  return (cx, next2, pos) => {
    if (next2 != ch || cx.char(pos + 1) == ch)
      return -1;
    let elts = [cx.elt(mark, pos, pos + 1)];
    for (let i = pos + 1; i < cx.end; i++) {
      let next3 = cx.char(i);
      if (next3 == ch)
        return cx.addElement(cx.elt(node2, pos, i + 1, elts.concat(cx.elt(mark, i, i + 1))));
      if (next3 == 92)
        elts.push(cx.elt("Escape", i, i++ + 2));
      if (space$2(next3))
        break;
    }
    return -1;
  };
}
const Superscript = {
  defineNodes: [
    { name: "Superscript", style: tags$5.special(tags$5.content) },
    { name: "SuperscriptMark", style: tags$5.processingInstruction }
  ],
  parseInline: [{
    name: "Superscript",
    parse: parseSubSuper(94, "Superscript", "SuperscriptMark")
  }]
};
const Subscript = {
  defineNodes: [
    { name: "Subscript", style: tags$5.special(tags$5.content) },
    { name: "SubscriptMark", style: tags$5.processingInstruction }
  ],
  parseInline: [{
    name: "Subscript",
    parse: parseSubSuper(126, "Subscript", "SubscriptMark")
  }]
};
const Emoji = {
  defineNodes: [{ name: "Emoji", style: tags$5.character }],
  parseInline: [{
    name: "Emoji",
    parse(cx, next2, pos) {
      let match;
      if (next2 != 58 || !(match = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end))))
        return -1;
      return cx.addElement(cx.elt("Emoji", pos, pos + 1 + match[0].length));
    }
  }]
};
class Stack {
  constructor(p, stack2, state, reducePos, pos, score2, buffer2, bufferBase, curContext, lookAhead = 0, parent) {
    this.p = p;
    this.stack = stack2;
    this.state = state;
    this.reducePos = reducePos;
    this.pos = pos;
    this.score = score2;
    this.buffer = buffer2;
    this.bufferBase = bufferBase;
    this.curContext = curContext;
    this.lookAhead = lookAhead;
    this.parent = parent;
  }
  toString() {
    return `[${this.stack.filter((_2, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  static start(p, state, pos = 0) {
    let cx = p.parser.context;
    return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
  }
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  pushState(state, start2) {
    this.stack.push(this.state, start2, this.bufferBase + this.buffer.length);
    this.state = state;
  }
  reduce(action) {
    let depth = action >> 19, type2 = action & 65535;
    let { parser: parser2 } = this.p;
    let dPrec = parser2.dynamicPrecedence(type2);
    if (dPrec)
      this.score += dPrec;
    if (depth == 0) {
      this.pushState(parser2.getGoto(this.state, type2, true), this.reducePos);
      if (type2 < parser2.minRepeatTerm)
        this.storeNode(type2, this.reducePos, this.reducePos, 4, true);
      this.reduceContext(type2, this.reducePos);
      return;
    }
    let base2 = this.stack.length - (depth - 1) * 3 - (action & 262144 ? 6 : 0);
    let start2 = this.stack[base2 - 2];
    let bufferBase = this.stack[base2 - 1], count2 = this.bufferBase + this.buffer.length - bufferBase;
    if (type2 < parser2.minRepeatTerm || action & 131072) {
      let pos = parser2.stateFlag(this.state, 1) ? this.pos : this.reducePos;
      this.storeNode(type2, start2, pos, count2 + 4, true);
    }
    if (action & 262144) {
      this.state = this.stack[base2];
    } else {
      let baseStateID = this.stack[base2 - 3];
      this.state = parser2.getGoto(baseStateID, type2, true);
    }
    while (this.stack.length > base2)
      this.stack.pop();
    this.reduceContext(type2, start2);
  }
  storeNode(term, start2, end2, size = 4, isReduce = false) {
    if (term == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let cur2 = this, top2 = this.buffer.length;
      if (top2 == 0 && cur2.parent) {
        top2 = cur2.bufferBase - cur2.parent.bufferBase;
        cur2 = cur2.parent;
      }
      if (top2 > 0 && cur2.buffer[top2 - 4] == 0 && cur2.buffer[top2 - 1] > -1) {
        if (start2 == end2)
          return;
        if (cur2.buffer[top2 - 2] >= start2) {
          cur2.buffer[top2 - 2] = end2;
          return;
        }
      }
    }
    if (!isReduce || this.pos == end2) {
      this.buffer.push(term, start2, end2, size);
    } else {
      let index2 = this.buffer.length;
      if (index2 > 0 && this.buffer[index2 - 4] != 0)
        while (index2 > 0 && this.buffer[index2 - 2] > end2) {
          this.buffer[index2] = this.buffer[index2 - 4];
          this.buffer[index2 + 1] = this.buffer[index2 - 3];
          this.buffer[index2 + 2] = this.buffer[index2 - 2];
          this.buffer[index2 + 3] = this.buffer[index2 - 1];
          index2 -= 4;
          if (size > 4)
            size -= 4;
        }
      this.buffer[index2] = term;
      this.buffer[index2 + 1] = start2;
      this.buffer[index2 + 2] = end2;
      this.buffer[index2 + 3] = size;
    }
  }
  shift(action, next2, nextEnd) {
    let start2 = this.pos;
    if (action & 131072) {
      this.pushState(action & 65535, this.pos);
    } else if ((action & 262144) == 0) {
      let nextState = action, { parser: parser2 } = this.p;
      if (nextEnd > this.pos || next2 <= parser2.maxNode) {
        this.pos = nextEnd;
        if (!parser2.stateFlag(nextState, 1))
          this.reducePos = nextEnd;
      }
      this.pushState(nextState, start2);
      this.shiftContext(next2, start2);
      if (next2 <= parser2.maxNode)
        this.buffer.push(next2, start2, nextEnd, 4);
    } else {
      this.pos = nextEnd;
      this.shiftContext(next2, start2);
      if (next2 <= this.p.parser.maxNode)
        this.buffer.push(next2, start2, nextEnd, 4);
    }
  }
  apply(action, next2, nextEnd) {
    if (action & 65536)
      this.reduce(action);
    else
      this.shift(action, next2, nextEnd);
  }
  useNode(value, next2) {
    let index2 = this.p.reused.length - 1;
    if (index2 < 0 || this.p.reused[index2] != value) {
      this.p.reused.push(value);
      index2++;
    }
    let start2 = this.pos;
    this.reducePos = this.pos = start2 + value.length;
    this.pushState(next2, start2);
    this.buffer.push(index2, start2, this.reducePos, -1);
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
  }
  split() {
    let parent = this;
    let off = parent.buffer.length;
    while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
      off -= 4;
    let buffer2 = parent.buffer.slice(off), base2 = parent.bufferBase + off;
    while (parent && base2 == parent.bufferBase)
      parent = parent.parent;
    return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer2, base2, this.curContext, this.lookAhead, parent);
  }
  recoverByDelete(next2, nextEnd) {
    let isNode = next2 <= this.p.parser.maxNode;
    if (isNode)
      this.storeNode(next2, this.pos, nextEnd, 4);
    this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
    this.pos = this.reducePos = nextEnd;
    this.score -= 190;
  }
  canShift(term) {
    for (let sim = new SimulatedStack(this); ; ) {
      let action = this.p.parser.stateSlot(sim.state, 4) || this.p.parser.hasAction(sim.state, term);
      if ((action & 65536) == 0)
        return true;
      if (action == 0)
        return false;
      sim.reduce(action);
    }
  }
  recoverByInsert(next2) {
    if (this.stack.length >= 300)
      return [];
    let nextStates = this.p.parser.nextStates(this.state);
    if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
      let best = [];
      for (let i = 0, s2; i < nextStates.length; i += 2) {
        if ((s2 = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s2, next2))
          best.push(nextStates[i], s2);
      }
      if (this.stack.length < 120)
        for (let i = 0; best.length < 4 << 1 && i < nextStates.length; i += 2) {
          let s2 = nextStates[i + 1];
          if (!best.some((v, i2) => i2 & 1 && v == s2))
            best.push(nextStates[i], s2);
        }
      nextStates = best;
    }
    let result = [];
    for (let i = 0; i < nextStates.length && result.length < 4; i += 2) {
      let s2 = nextStates[i + 1];
      if (s2 == this.state)
        continue;
      let stack2 = this.split();
      stack2.pushState(s2, this.pos);
      stack2.storeNode(0, stack2.pos, stack2.pos, 4, true);
      stack2.shiftContext(nextStates[i], this.pos);
      stack2.score -= 200;
      result.push(stack2);
    }
    return result;
  }
  forceReduce() {
    let reduce = this.p.parser.stateSlot(this.state, 5);
    if ((reduce & 65536) == 0)
      return false;
    let { parser: parser2 } = this.p;
    if (!parser2.validAction(this.state, reduce)) {
      let depth = reduce >> 19, term = reduce & 65535;
      let target = this.stack.length - depth * 3;
      if (target < 0 || parser2.getGoto(this.stack[target], term, false) < 0)
        return false;
      this.storeNode(0, this.reducePos, this.reducePos, 4, true);
      this.score -= 100;
    }
    this.reducePos = this.pos;
    this.reduce(reduce);
    return true;
  }
  forceAll() {
    while (!this.p.parser.stateFlag(this.state, 2)) {
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, true);
        break;
      }
    }
    return this;
  }
  get deadEnd() {
    if (this.stack.length != 3)
      return false;
    let { parser: parser2 } = this.p;
    return parser2.data[parser2.stateSlot(this.state, 1)] == 65535 && !parser2.stateSlot(this.state, 4);
  }
  restart() {
    this.state = this.stack[0];
    this.stack.length = 0;
  }
  sameState(other) {
    if (this.state != other.state || this.stack.length != other.stack.length)
      return false;
    for (let i = 0; i < this.stack.length; i += 3)
      if (this.stack[i] != other.stack[i])
        return false;
    return true;
  }
  get parser() {
    return this.p.parser;
  }
  dialectEnabled(dialectID) {
    return this.p.parser.dialect.flags[dialectID];
  }
  shiftContext(term, start2) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start2)));
  }
  reduceContext(term, start2) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start2)));
  }
  emitContext() {
    let last = this.buffer.length - 1;
    if (last < 0 || this.buffer[last] != -3)
      this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);
  }
  emitLookAhead() {
    let last = this.buffer.length - 1;
    if (last < 0 || this.buffer[last] != -4)
      this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);
  }
  updateContext(context) {
    if (context != this.curContext.context) {
      let newCx = new StackContext(this.curContext.tracker, context);
      if (newCx.hash != this.curContext.hash)
        this.emitContext();
      this.curContext = newCx;
    }
  }
  setLookAhead(lookAhead) {
    if (lookAhead > this.lookAhead) {
      this.emitLookAhead();
      this.lookAhead = lookAhead;
    }
  }
  close() {
    if (this.curContext && this.curContext.tracker.strict)
      this.emitContext();
    if (this.lookAhead > 0)
      this.emitLookAhead();
  }
}
class StackContext {
  constructor(tracker, context) {
    this.tracker = tracker;
    this.context = context;
    this.hash = tracker.strict ? tracker.hash(context) : 0;
  }
}
var Recover;
(function(Recover2) {
  Recover2[Recover2["Insert"] = 200] = "Insert";
  Recover2[Recover2["Delete"] = 190] = "Delete";
  Recover2[Recover2["Reduce"] = 100] = "Reduce";
  Recover2[Recover2["MaxNext"] = 4] = "MaxNext";
  Recover2[Recover2["MaxInsertStackDepth"] = 300] = "MaxInsertStackDepth";
  Recover2[Recover2["DampenInsertStackDepth"] = 120] = "DampenInsertStackDepth";
})(Recover || (Recover = {}));
class SimulatedStack {
  constructor(start2) {
    this.start = start2;
    this.state = start2.state;
    this.stack = start2.stack;
    this.base = this.stack.length;
  }
  reduce(action) {
    let term = action & 65535, depth = action >> 19;
    if (depth == 0) {
      if (this.stack == this.start.stack)
        this.stack = this.stack.slice();
      this.stack.push(this.state, 0, 0);
      this.base += 3;
    } else {
      this.base -= (depth - 1) * 3;
    }
    let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
    this.state = goto;
  }
}
class StackBufferCursor {
  constructor(stack2, pos, index2) {
    this.stack = stack2;
    this.pos = pos;
    this.index = index2;
    this.buffer = stack2.buffer;
    if (this.index == 0)
      this.maybeNext();
  }
  static create(stack2, pos = stack2.bufferBase + stack2.buffer.length) {
    return new StackBufferCursor(stack2, pos, pos - stack2.bufferBase);
  }
  maybeNext() {
    let next2 = this.stack.parent;
    if (next2 != null) {
      this.index = this.stack.bufferBase - next2.bufferBase;
      this.stack = next2;
      this.buffer = next2.buffer;
    }
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4;
    this.pos -= 4;
    if (this.index == 0)
      this.maybeNext();
  }
  fork() {
    return new StackBufferCursor(this.stack, this.pos, this.index);
  }
}
class CachedToken {
  constructor() {
    this.start = -1;
    this.value = -1;
    this.end = -1;
    this.extended = -1;
    this.lookAhead = 0;
    this.mask = 0;
    this.context = 0;
  }
}
const nullToken = new CachedToken();
class InputStream {
  constructor(input, ranges2) {
    this.input = input;
    this.ranges = ranges2;
    this.chunk = "";
    this.chunkOff = 0;
    this.chunk2 = "";
    this.chunk2Pos = 0;
    this.next = -1;
    this.token = nullToken;
    this.rangeIndex = 0;
    this.pos = this.chunkPos = ranges2[0].from;
    this.range = ranges2[0];
    this.end = ranges2[ranges2.length - 1].to;
    this.readNext();
  }
  resolveOffset(offset, assoc) {
    let range2 = this.range, index2 = this.rangeIndex;
    let pos = this.pos + offset;
    while (pos < range2.from) {
      if (!index2)
        return null;
      let next2 = this.ranges[--index2];
      pos -= range2.from - next2.to;
      range2 = next2;
    }
    while (assoc < 0 ? pos > range2.to : pos >= range2.to) {
      if (index2 == this.ranges.length - 1)
        return null;
      let next2 = this.ranges[++index2];
      pos += next2.from - range2.to;
      range2 = next2;
    }
    return pos;
  }
  peek(offset) {
    let idx = this.chunkOff + offset, pos, result;
    if (idx >= 0 && idx < this.chunk.length) {
      pos = this.pos + offset;
      result = this.chunk.charCodeAt(idx);
    } else {
      let resolved = this.resolveOffset(offset, 1);
      if (resolved == null)
        return -1;
      pos = resolved;
      if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
        result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
      } else {
        let i = this.rangeIndex, range2 = this.range;
        while (range2.to <= pos)
          range2 = this.ranges[++i];
        this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
        if (pos + this.chunk2.length > range2.to)
          this.chunk2 = this.chunk2.slice(0, range2.to - pos);
        result = this.chunk2.charCodeAt(0);
      }
    }
    if (pos >= this.token.lookAhead)
      this.token.lookAhead = pos + 1;
    return result;
  }
  acceptToken(token2, endOffset = 0) {
    let end2 = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
    if (end2 == null || end2 < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = token2;
    this.token.end = end2;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk, chunkPos } = this;
      this.chunk = this.chunk2;
      this.chunkPos = this.chunk2Pos;
      this.chunk2 = chunk;
      this.chunk2Pos = chunkPos;
      this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk;
      this.chunk2Pos = this.chunkPos;
      let nextChunk = this.input.chunk(this.pos);
      let end2 = this.pos + nextChunk.length;
      this.chunk = end2 > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
      this.chunkPos = this.pos;
      this.chunkOff = 0;
    }
  }
  readNext() {
    if (this.chunkOff >= this.chunk.length) {
      this.getChunk();
      if (this.chunkOff == this.chunk.length)
        return this.next = -1;
    }
    return this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  advance(n = 1) {
    this.chunkOff += n;
    while (this.pos + n >= this.range.to) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      n -= this.range.to - this.pos;
      this.range = this.ranges[++this.rangeIndex];
      this.pos = this.range.from;
    }
    this.pos += n;
    if (this.pos >= this.token.lookAhead)
      this.token.lookAhead = this.pos + 1;
    return this.readNext();
  }
  setDone() {
    this.pos = this.chunkPos = this.end;
    this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
    this.chunk = "";
    return this.next = -1;
  }
  reset(pos, token2) {
    if (token2) {
      this.token = token2;
      token2.start = pos;
      token2.lookAhead = pos + 1;
      token2.value = token2.extended = -1;
    } else {
      this.token = nullToken;
    }
    if (this.pos != pos) {
      this.pos = pos;
      if (pos == this.end) {
        this.setDone();
        return this;
      }
      while (pos < this.range.from)
        this.range = this.ranges[--this.rangeIndex];
      while (pos >= this.range.to)
        this.range = this.ranges[++this.rangeIndex];
      if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
        this.chunkOff = pos - this.chunkPos;
      } else {
        this.chunk = "";
        this.chunkOff = 0;
      }
      this.readNext();
    }
    return this;
  }
  read(from2, to2) {
    if (from2 >= this.chunkPos && to2 <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(from2 - this.chunkPos, to2 - this.chunkPos);
    if (from2 >= this.chunk2Pos && to2 <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(from2 - this.chunk2Pos, to2 - this.chunk2Pos);
    if (from2 >= this.range.from && to2 <= this.range.to)
      return this.input.read(from2, to2);
    let result = "";
    for (let r of this.ranges) {
      if (r.from >= to2)
        break;
      if (r.to > from2)
        result += this.input.read(Math.max(r.from, from2), Math.min(r.to, to2));
    }
    return result;
  }
}
class TokenGroup {
  constructor(data2, id2) {
    this.data = data2;
    this.id = id2;
  }
  token(input, stack2) {
    readToken(this.data, input, stack2, this.id);
  }
}
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
class ExternalTokenizer {
  constructor(token2, options2 = {}) {
    this.token = token2;
    this.contextual = !!options2.contextual;
    this.fallback = !!options2.fallback;
    this.extend = !!options2.extend;
  }
}
function readToken(data2, input, stack2, group) {
  let state = 0, groupMask = 1 << group, { parser: parser2 } = stack2.p, { dialect } = parser2;
  scan:
    for (; ; ) {
      if ((groupMask & data2[state]) == 0)
        break;
      let accEnd = data2[state + 1];
      for (let i = state + 3; i < accEnd; i += 2)
        if ((data2[i + 1] & groupMask) > 0) {
          let term = data2[i];
          if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || parser2.overrides(term, input.token.value))) {
            input.acceptToken(term);
            break;
          }
        }
      let next2 = input.next, low = 0, high = data2[state + 2];
      if (input.next < 0 && high > low && data2[accEnd + high * 3 - 3] == 65535) {
        state = data2[accEnd + high * 3 - 1];
        continue scan;
      }
      for (; low < high; ) {
        let mid = low + high >> 1;
        let index2 = accEnd + mid + (mid << 1);
        let from2 = data2[index2], to2 = data2[index2 + 1];
        if (next2 < from2)
          high = mid;
        else if (next2 >= to2)
          low = mid + 1;
        else {
          state = data2[index2 + 2];
          input.advance();
          continue scan;
        }
      }
      break;
    }
}
function decodeArray(input, Type2 = Uint16Array) {
  if (typeof input != "string")
    return input;
  let array2 = null;
  for (let pos = 0, out = 0; pos < input.length; ) {
    let value = 0;
    for (; ; ) {
      let next2 = input.charCodeAt(pos++), stop = false;
      if (next2 == 126) {
        value = 65535;
        break;
      }
      if (next2 >= 92)
        next2--;
      if (next2 >= 34)
        next2--;
      let digit = next2 - 32;
      if (digit >= 46) {
        digit -= 46;
        stop = true;
      }
      value += digit;
      if (stop)
        break;
      value *= 46;
    }
    if (array2)
      array2[out++] = value;
    else
      array2 = new Type2(value);
  }
  return array2;
}
const verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
let stackIDs = null;
var Safety;
(function(Safety2) {
  Safety2[Safety2["Margin"] = 25] = "Margin";
})(Safety || (Safety = {}));
function cutAt(tree2, pos, side) {
  let cursor = tree2.cursor(IterMode.IncludeAnonymous);
  cursor.moveTo(pos);
  for (; ; ) {
    if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
      for (; ; ) {
        if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)
          return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25)) : Math.min(tree2.length, Math.max(cursor.from + 1, pos + 25));
        if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
          break;
        if (!cursor.parent())
          return side < 0 ? 0 : tree2.length;
      }
  }
}
class FragmentCursor {
  constructor(fragments, nodeSet2) {
    this.fragments = fragments;
    this.nodeSet = nodeSet2;
    this.i = 0;
    this.fragment = null;
    this.safeFrom = -1;
    this.safeTo = -1;
    this.trees = [];
    this.start = [];
    this.index = [];
    this.nextFragment();
  }
  nextFragment() {
    let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (fr) {
      this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
      this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
      while (this.trees.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
      }
      this.trees.push(fr.tree);
      this.start.push(-fr.offset);
      this.index.push(0);
      this.nextStart = this.safeFrom;
    } else {
      this.nextStart = 1e9;
    }
  }
  nodeAt(pos) {
    if (pos < this.nextStart)
      return null;
    while (this.fragment && this.safeTo <= pos)
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let last = this.trees.length - 1;
      if (last < 0) {
        this.nextFragment();
        return null;
      }
      let top2 = this.trees[last], index2 = this.index[last];
      if (index2 == top2.children.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
        continue;
      }
      let next2 = top2.children[index2];
      let start2 = this.start[last] + top2.positions[index2];
      if (start2 > pos) {
        this.nextStart = start2;
        return null;
      }
      if (next2 instanceof Tree) {
        if (start2 == pos) {
          if (start2 < this.safeFrom)
            return null;
          let end2 = start2 + next2.length;
          if (end2 <= this.safeTo) {
            let lookAhead = next2.prop(NodeProp.lookAhead);
            if (!lookAhead || end2 + lookAhead < this.fragment.to)
              return next2;
          }
        }
        this.index[last]++;
        if (start2 + next2.length >= Math.max(this.safeFrom, pos)) {
          this.trees.push(next2);
          this.start.push(start2);
          this.index.push(0);
        }
      } else {
        this.index[last]++;
        this.nextStart = start2 + next2.length;
      }
    }
  }
}
class TokenCache {
  constructor(parser2, stream) {
    this.stream = stream;
    this.tokens = [];
    this.mainToken = null;
    this.actions = [];
    this.tokens = parser2.tokenizers.map((_2) => new CachedToken());
  }
  getActions(stack2) {
    let actionIndex = 0;
    let main2 = null;
    let { parser: parser2 } = stack2.p, { tokenizers } = parser2;
    let mask = parser2.stateSlot(stack2.state, 3);
    let context = stack2.curContext ? stack2.curContext.hash : 0;
    let lookAhead = 0;
    for (let i = 0; i < tokenizers.length; i++) {
      if ((1 << i & mask) == 0)
        continue;
      let tokenizer = tokenizers[i], token2 = this.tokens[i];
      if (main2 && !tokenizer.fallback)
        continue;
      if (tokenizer.contextual || token2.start != stack2.pos || token2.mask != mask || token2.context != context) {
        this.updateCachedToken(token2, tokenizer, stack2);
        token2.mask = mask;
        token2.context = context;
      }
      if (token2.lookAhead > token2.end + 25)
        lookAhead = Math.max(token2.lookAhead, lookAhead);
      if (token2.value != 0) {
        let startIndex = actionIndex;
        if (token2.extended > -1)
          actionIndex = this.addActions(stack2, token2.extended, token2.end, actionIndex);
        actionIndex = this.addActions(stack2, token2.value, token2.end, actionIndex);
        if (!tokenizer.extend) {
          main2 = token2;
          if (actionIndex > startIndex)
            break;
        }
      }
    }
    while (this.actions.length > actionIndex)
      this.actions.pop();
    if (lookAhead)
      stack2.setLookAhead(lookAhead);
    if (!main2 && stack2.pos == this.stream.end) {
      main2 = new CachedToken();
      main2.value = stack2.p.parser.eofTerm;
      main2.start = main2.end = stack2.pos;
      actionIndex = this.addActions(stack2, main2.value, main2.end, actionIndex);
    }
    this.mainToken = main2;
    return this.actions;
  }
  getMainToken(stack2) {
    if (this.mainToken)
      return this.mainToken;
    let main2 = new CachedToken(), { pos, p } = stack2;
    main2.start = pos;
    main2.end = Math.min(pos + 1, p.stream.end);
    main2.value = pos == p.stream.end ? p.parser.eofTerm : 0;
    return main2;
  }
  updateCachedToken(token2, tokenizer, stack2) {
    tokenizer.token(this.stream.reset(stack2.pos, token2), stack2);
    if (token2.value > -1) {
      let { parser: parser2 } = stack2.p;
      for (let i = 0; i < parser2.specialized.length; i++)
        if (parser2.specialized[i] == token2.value) {
          let result = parser2.specializers[i](this.stream.read(token2.start, token2.end), stack2);
          if (result >= 0 && stack2.p.parser.dialect.allows(result >> 1)) {
            if ((result & 1) == 0)
              token2.value = result >> 1;
            else
              token2.extended = result >> 1;
            break;
          }
        }
    } else {
      token2.value = 0;
      token2.end = Math.min(stack2.p.stream.end, stack2.pos + 1);
    }
  }
  putAction(action, token2, end2, index2) {
    for (let i = 0; i < index2; i += 3)
      if (this.actions[i] == action)
        return index2;
    this.actions[index2++] = action;
    this.actions[index2++] = token2;
    this.actions[index2++] = end2;
    return index2;
  }
  addActions(stack2, token2, end2, index2) {
    let { state } = stack2, { parser: parser2 } = stack2.p, { data: data2 } = parser2;
    for (let set2 = 0; set2 < 2; set2++) {
      for (let i = parser2.stateSlot(state, set2 ? 2 : 1); ; i += 3) {
        if (data2[i] == 65535) {
          if (data2[i + 1] == 1) {
            i = pair$1(data2, i + 2);
          } else {
            if (index2 == 0 && data2[i + 1] == 2)
              index2 = this.putAction(pair$1(data2, i + 2), token2, end2, index2);
            break;
          }
        }
        if (data2[i] == token2)
          index2 = this.putAction(pair$1(data2, i + 1), token2, end2, index2);
      }
    }
    return index2;
  }
}
var Rec;
(function(Rec2) {
  Rec2[Rec2["Distance"] = 5] = "Distance";
  Rec2[Rec2["MaxRemainingPerStep"] = 3] = "MaxRemainingPerStep";
  Rec2[Rec2["MinBufferLengthPrune"] = 500] = "MinBufferLengthPrune";
  Rec2[Rec2["ForceReduceLimit"] = 10] = "ForceReduceLimit";
  Rec2[Rec2["CutDepth"] = 15e3] = "CutDepth";
  Rec2[Rec2["CutTo"] = 9e3] = "CutTo";
})(Rec || (Rec = {}));
class Parse {
  constructor(parser2, input, fragments, ranges2) {
    this.parser = parser2;
    this.input = input;
    this.ranges = ranges2;
    this.recovering = 0;
    this.nextStackID = 9812;
    this.minStackPos = 0;
    this.reused = [];
    this.stoppedAt = null;
    this.stream = new InputStream(input, ranges2);
    this.tokens = new TokenCache(parser2, this.stream);
    this.topTerm = parser2.top[1];
    let { from: from2 } = ranges2[0];
    this.stacks = [Stack.start(this, parser2.top[0], from2)];
    this.fragments = fragments.length && this.stream.end - from2 > parser2.bufferLength * 4 ? new FragmentCursor(fragments, parser2.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  advance() {
    let stacks = this.stacks, pos = this.minStackPos;
    let newStacks = this.stacks = [];
    let stopped, stoppedTokens;
    for (let i = 0; i < stacks.length; i++) {
      let stack2 = stacks[i];
      for (; ; ) {
        this.tokens.mainToken = null;
        if (stack2.pos > pos) {
          newStacks.push(stack2);
        } else if (this.advanceStack(stack2, newStacks, stacks)) {
          continue;
        } else {
          if (!stopped) {
            stopped = [];
            stoppedTokens = [];
          }
          stopped.push(stack2);
          let tok = this.tokens.getMainToken(stack2);
          stoppedTokens.push(tok.value, tok.end);
        }
        break;
      }
    }
    if (!newStacks.length) {
      let finished = stopped && findFinished(stopped);
      if (finished)
        return this.stackToTree(finished);
      if (this.parser.strict) {
        if (verbose && stopped)
          console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
        throw new SyntaxError("No parse at " + pos);
      }
      if (!this.recovering)
        this.recovering = 5;
    }
    if (this.recovering && stopped) {
      let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
      if (finished)
        return this.stackToTree(finished.forceAll());
    }
    if (this.recovering) {
      let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
      if (newStacks.length > maxRemaining) {
        newStacks.sort((a2, b) => b.score - a2.score);
        while (newStacks.length > maxRemaining)
          newStacks.pop();
      }
      if (newStacks.some((s2) => s2.reducePos > pos))
        this.recovering--;
    } else if (newStacks.length > 1) {
      outer:
        for (let i = 0; i < newStacks.length - 1; i++) {
          let stack2 = newStacks[i];
          for (let j2 = i + 1; j2 < newStacks.length; j2++) {
            let other = newStacks[j2];
            if (stack2.sameState(other) || stack2.buffer.length > 500 && other.buffer.length > 500) {
              if ((stack2.score - other.score || stack2.buffer.length - other.buffer.length) > 0) {
                newStacks.splice(j2--, 1);
              } else {
                newStacks.splice(i--, 1);
                continue outer;
              }
            }
          }
        }
    }
    this.minStackPos = newStacks[0].pos;
    for (let i = 1; i < newStacks.length; i++)
      if (newStacks[i].pos < this.minStackPos)
        this.minStackPos = newStacks[i].pos;
    return null;
  }
  stopAt(pos) {
    if (this.stoppedAt != null && this.stoppedAt < pos)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = pos;
  }
  advanceStack(stack2, stacks, split) {
    let start2 = stack2.pos, { parser: parser2 } = this;
    let base2 = verbose ? this.stackID(stack2) + " -> " : "";
    if (this.stoppedAt != null && start2 > this.stoppedAt)
      return stack2.forceReduce() ? stack2 : null;
    if (this.fragments) {
      let strictCx = stack2.curContext && stack2.curContext.tracker.strict, cxHash = strictCx ? stack2.curContext.hash : 0;
      for (let cached = this.fragments.nodeAt(start2); cached; ) {
        let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser2.getGoto(stack2.state, cached.type.id) : -1;
        if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {
          stack2.useNode(cached, match);
          if (verbose)
            console.log(base2 + this.stackID(stack2) + ` (via reuse of ${parser2.getName(cached.type.id)})`);
          return true;
        }
        if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)
          break;
        let inner = cached.children[0];
        if (inner instanceof Tree && cached.positions[0] == 0)
          cached = inner;
        else
          break;
      }
    }
    let defaultReduce = parser2.stateSlot(stack2.state, 4);
    if (defaultReduce > 0) {
      stack2.reduce(defaultReduce);
      if (verbose)
        console.log(base2 + this.stackID(stack2) + ` (via always-reduce ${parser2.getName(defaultReduce & 65535)})`);
      return true;
    }
    if (stack2.stack.length >= 15e3) {
      while (stack2.stack.length > 9e3 && stack2.forceReduce()) {
      }
    }
    let actions = this.tokens.getActions(stack2);
    for (let i = 0; i < actions.length; ) {
      let action = actions[i++], term = actions[i++], end2 = actions[i++];
      let last = i == actions.length || !split;
      let localStack = last ? stack2 : stack2.split();
      localStack.apply(action, term, end2);
      if (verbose)
        console.log(base2 + this.stackID(localStack) + ` (via ${(action & 65536) == 0 ? "shift" : `reduce of ${parser2.getName(action & 65535)}`} for ${parser2.getName(term)} @ ${start2}${localStack == stack2 ? "" : ", split"})`);
      if (last)
        return true;
      else if (localStack.pos > start2)
        stacks.push(localStack);
      else
        split.push(localStack);
    }
    return false;
  }
  advanceFully(stack2, newStacks) {
    let pos = stack2.pos;
    for (; ; ) {
      if (!this.advanceStack(stack2, null, null))
        return false;
      if (stack2.pos > pos) {
        pushStackDedup(stack2, newStacks);
        return true;
      }
    }
  }
  runRecovery(stacks, tokens, newStacks) {
    let finished = null, restarted = false;
    for (let i = 0; i < stacks.length; i++) {
      let stack2 = stacks[i], token2 = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
      let base2 = verbose ? this.stackID(stack2) + " -> " : "";
      if (stack2.deadEnd) {
        if (restarted)
          continue;
        restarted = true;
        stack2.restart();
        if (verbose)
          console.log(base2 + this.stackID(stack2) + " (restarted)");
        let done = this.advanceFully(stack2, newStacks);
        if (done)
          continue;
      }
      let force = stack2.split(), forceBase = base2;
      for (let j2 = 0; force.forceReduce() && j2 < 10; j2++) {
        if (verbose)
          console.log(forceBase + this.stackID(force) + " (via force-reduce)");
        let done = this.advanceFully(force, newStacks);
        if (done)
          break;
        if (verbose)
          forceBase = this.stackID(force) + " -> ";
      }
      for (let insert2 of stack2.recoverByInsert(token2)) {
        if (verbose)
          console.log(base2 + this.stackID(insert2) + " (via recover-insert)");
        this.advanceFully(insert2, newStacks);
      }
      if (this.stream.end > stack2.pos) {
        if (tokenEnd == stack2.pos) {
          tokenEnd++;
          token2 = 0;
        }
        stack2.recoverByDelete(token2, tokenEnd);
        if (verbose)
          console.log(base2 + this.stackID(stack2) + ` (via recover-delete ${this.parser.getName(token2)})`);
        pushStackDedup(stack2, newStacks);
      } else if (!finished || finished.score < stack2.score) {
        finished = stack2;
      }
    }
    return finished;
  }
  stackToTree(stack2) {
    stack2.close();
    return Tree.build({
      buffer: StackBufferCursor.create(stack2),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: stack2.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(stack2) {
    let id2 = (stackIDs || (stackIDs = /* @__PURE__ */ new WeakMap())).get(stack2);
    if (!id2)
      stackIDs.set(stack2, id2 = String.fromCodePoint(this.nextStackID++));
    return id2 + stack2;
  }
}
function pushStackDedup(stack2, newStacks) {
  for (let i = 0; i < newStacks.length; i++) {
    let other = newStacks[i];
    if (other.pos == stack2.pos && other.sameState(stack2)) {
      if (newStacks[i].score < stack2.score)
        newStacks[i] = stack2;
      return;
    }
  }
  newStacks.push(stack2);
}
class Dialect {
  constructor(source, flags, disabled) {
    this.source = source;
    this.flags = flags;
    this.disabled = disabled;
  }
  allows(term) {
    return !this.disabled || this.disabled[term] == 0;
  }
}
const id$1 = (x2) => x2;
class ContextTracker {
  constructor(spec) {
    this.start = spec.start;
    this.shift = spec.shift || id$1;
    this.reduce = spec.reduce || id$1;
    this.reuse = spec.reuse || id$1;
    this.hash = spec.hash || (() => 0);
    this.strict = spec.strict !== false;
  }
}
class LRParser extends Parser {
  constructor(spec) {
    super();
    this.wrappers = [];
    if (spec.version != 14)
      throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14})`);
    let nodeNames = spec.nodeNames.split(" ");
    this.minRepeatTerm = nodeNames.length;
    for (let i = 0; i < spec.repeatNodeCount; i++)
      nodeNames.push("");
    let topTerms = Object.keys(spec.topRules).map((r) => spec.topRules[r][1]);
    let nodeProps = [];
    for (let i = 0; i < nodeNames.length; i++)
      nodeProps.push([]);
    function setProp(nodeID, prop, value) {
      nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
    }
    if (spec.nodeProps)
      for (let propSpec of spec.nodeProps) {
        let prop = propSpec[0];
        if (typeof prop == "string")
          prop = NodeProp[prop];
        for (let i = 1; i < propSpec.length; ) {
          let next2 = propSpec[i++];
          if (next2 >= 0) {
            setProp(next2, prop, propSpec[i++]);
          } else {
            let value = propSpec[i + -next2];
            for (let j2 = -next2; j2 > 0; j2--)
              setProp(propSpec[i++], prop, value);
            i++;
          }
        }
      }
    this.nodeSet = new NodeSet(nodeNames.map((name2, i) => NodeType.define({
      name: i >= this.minRepeatTerm ? void 0 : name2,
      id: i,
      props: nodeProps[i],
      top: topTerms.indexOf(i) > -1,
      error: i == 0,
      skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
    })));
    if (spec.propSources)
      this.nodeSet = this.nodeSet.extend(...spec.propSources);
    this.strict = false;
    this.bufferLength = DefaultBufferLength;
    let tokenArray = decodeArray(spec.tokenData);
    this.context = spec.context;
    this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0);
    this.specializers = [];
    if (spec.specialized)
      for (let i = 0; i < spec.specialized.length; i++) {
        this.specialized[i] = spec.specialized[i].term;
        this.specializers[i] = spec.specialized[i].get;
      }
    this.states = decodeArray(spec.states, Uint32Array);
    this.data = decodeArray(spec.stateData);
    this.goto = decodeArray(spec.goto);
    this.maxTerm = spec.maxTerm;
    this.tokenizers = spec.tokenizers.map((value) => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
    this.topRules = spec.topRules;
    this.dialects = spec.dialects || {};
    this.dynamicPrecedences = spec.dynamicPrecedences || null;
    this.tokenPrecTable = spec.tokenPrec;
    this.termNames = spec.termNames || null;
    this.maxNode = this.nodeSet.types.length - 1;
    this.dialect = this.parseDialect();
    this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(input, fragments, ranges2) {
    let parse2 = new Parse(this, input, fragments, ranges2);
    for (let w2 of this.wrappers)
      parse2 = w2(parse2, input, fragments, ranges2);
    return parse2;
  }
  getGoto(state, term, loose = false) {
    let table = this.goto;
    if (term >= table[0])
      return -1;
    for (let pos = table[term + 1]; ; ) {
      let groupTag = table[pos++], last = groupTag & 1;
      let target = table[pos++];
      if (last && loose)
        return target;
      for (let end2 = pos + (groupTag >> 1); pos < end2; pos++)
        if (table[pos] == state)
          return target;
      if (last)
        return -1;
    }
  }
  hasAction(state, terminal) {
    let data2 = this.data;
    for (let set2 = 0; set2 < 2; set2++) {
      for (let i = this.stateSlot(state, set2 ? 2 : 1), next2; ; i += 3) {
        if ((next2 = data2[i]) == 65535) {
          if (data2[i + 1] == 1)
            next2 = data2[i = pair$1(data2, i + 2)];
          else if (data2[i + 1] == 2)
            return pair$1(data2, i + 2);
          else
            break;
        }
        if (next2 == terminal || next2 == 0)
          return pair$1(data2, i + 1);
      }
    }
    return 0;
  }
  stateSlot(state, slot) {
    return this.states[state * 6 + slot];
  }
  stateFlag(state, flag) {
    return (this.stateSlot(state, 0) & flag) > 0;
  }
  validAction(state, action) {
    if (action == this.stateSlot(state, 4))
      return true;
    for (let i = this.stateSlot(state, 1); ; i += 3) {
      if (this.data[i] == 65535) {
        if (this.data[i + 1] == 1)
          i = pair$1(this.data, i + 2);
        else
          return false;
      }
      if (action == pair$1(this.data, i + 1))
        return true;
    }
  }
  nextStates(state) {
    let result = [];
    for (let i = this.stateSlot(state, 1); ; i += 3) {
      if (this.data[i] == 65535) {
        if (this.data[i + 1] == 1)
          i = pair$1(this.data, i + 2);
        else
          break;
      }
      if ((this.data[i + 2] & 65536 >> 16) == 0) {
        let value = this.data[i + 1];
        if (!result.some((v, i2) => i2 & 1 && v == value))
          result.push(this.data[i], value);
      }
    }
    return result;
  }
  overrides(token2, prev2) {
    let iPrev = findOffset(this.data, this.tokenPrecTable, prev2);
    return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token2) < iPrev;
  }
  configure(config2) {
    let copy2 = Object.assign(Object.create(LRParser.prototype), this);
    if (config2.props)
      copy2.nodeSet = this.nodeSet.extend(...config2.props);
    if (config2.top) {
      let info2 = this.topRules[config2.top];
      if (!info2)
        throw new RangeError(`Invalid top rule name ${config2.top}`);
      copy2.top = info2;
    }
    if (config2.tokenizers)
      copy2.tokenizers = this.tokenizers.map((t4) => {
        let found = config2.tokenizers.find((r) => r.from == t4);
        return found ? found.to : t4;
      });
    if (config2.specializers)
      copy2.specializers = this.specializers.map((s2) => {
        let found = config2.specializers.find((r) => r.from == s2);
        return found ? found.to : s2;
      });
    if (config2.contextTracker)
      copy2.context = config2.contextTracker;
    if (config2.dialect)
      copy2.dialect = this.parseDialect(config2.dialect);
    if (config2.strict != null)
      copy2.strict = config2.strict;
    if (config2.wrap)
      copy2.wrappers = copy2.wrappers.concat(config2.wrap);
    if (config2.bufferLength != null)
      copy2.bufferLength = config2.bufferLength;
    return copy2;
  }
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  getName(term) {
    return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
  }
  get eofTerm() {
    return this.maxNode + 1;
  }
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  dynamicPrecedence(term) {
    let prec2 = this.dynamicPrecedences;
    return prec2 == null ? 0 : prec2[term] || 0;
  }
  parseDialect(dialect) {
    let values2 = Object.keys(this.dialects), flags = values2.map(() => false);
    if (dialect)
      for (let part of dialect.split(" ")) {
        let id2 = values2.indexOf(part);
        if (id2 >= 0)
          flags[id2] = true;
      }
    let disabled = null;
    for (let i = 0; i < values2.length; i++)
      if (!flags[i]) {
        for (let j2 = this.dialects[values2[i]], id2; (id2 = this.data[j2++]) != 65535; )
          (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id2] = 1;
      }
    return new Dialect(dialect, flags, disabled);
  }
  static deserialize(spec) {
    return new LRParser(spec);
  }
}
function pair$1(data2, off) {
  return data2[off] | data2[off + 1] << 16;
}
function findOffset(data2, start2, term) {
  for (let i = start2, next2; (next2 = data2[i]) != 65535; i++)
    if (next2 == term)
      return i - start2;
  return -1;
}
function findFinished(stacks) {
  let best = null;
  for (let stack2 of stacks) {
    let stopped = stack2.p.stoppedAt;
    if ((stack2.pos == stack2.p.stream.end || stopped != null && stack2.pos > stopped) && stack2.p.parser.stateFlag(stack2.state, 2) && (!best || best.score < stack2.score))
      best = stack2;
  }
  return best;
}
const scriptText = 53, StartCloseScriptTag = 1, styleText = 54, StartCloseStyleTag = 2, textareaText = 55, StartCloseTextareaTag = 3, StartTag = 4, StartScriptTag = 5, StartStyleTag = 6, StartTextareaTag = 7, StartSelfClosingTag = 8, StartCloseTag = 9, NoMatchStartCloseTag = 10, MismatchedStartCloseTag = 11, missingCloseTag = 56, IncompleteCloseTag = 12, commentContent$1 = 57, Element = 18, ScriptText = 27, StyleText = 30, TextareaText = 33, OpenTag = 35, Dialect_noMatch = 0;
const selfClosers = {
  area: true,
  base: true,
  br: true,
  col: true,
  command: true,
  embed: true,
  frame: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true,
  menuitem: true
};
const implicitlyClosed = {
  dd: true,
  li: true,
  optgroup: true,
  option: true,
  p: true,
  rp: true,
  rt: true,
  tbody: true,
  td: true,
  tfoot: true,
  th: true,
  tr: true
};
const closeOnOpen = {
  dd: { dd: true, dt: true },
  dt: { dd: true, dt: true },
  li: { li: true },
  option: { option: true, optgroup: true },
  optgroup: { optgroup: true },
  p: {
    address: true,
    article: true,
    aside: true,
    blockquote: true,
    dir: true,
    div: true,
    dl: true,
    fieldset: true,
    footer: true,
    form: true,
    h1: true,
    h2: true,
    h3: true,
    h4: true,
    h5: true,
    h6: true,
    header: true,
    hgroup: true,
    hr: true,
    menu: true,
    nav: true,
    ol: true,
    p: true,
    pre: true,
    section: true,
    table: true,
    ul: true
  },
  rp: { rp: true, rt: true },
  rt: { rp: true, rt: true },
  tbody: { tbody: true, tfoot: true },
  td: { td: true, th: true },
  tfoot: { tbody: true },
  th: { td: true, th: true },
  thead: { tbody: true, tfoot: true },
  tr: { tr: true }
};
function nameChar(ch) {
  return ch == 45 || ch == 46 || ch == 58 || ch >= 65 && ch <= 90 || ch == 95 || ch >= 97 && ch <= 122 || ch >= 161;
}
function isSpace(ch) {
  return ch == 9 || ch == 10 || ch == 13 || ch == 32;
}
let cachedName = null, cachedInput = null, cachedPos = 0;
function tagNameAfter(input, offset) {
  let pos = input.pos + offset;
  if (cachedPos == pos && cachedInput == input)
    return cachedName;
  let next2 = input.peek(offset);
  while (isSpace(next2))
    next2 = input.peek(++offset);
  let name2 = "";
  for (; ; ) {
    if (!nameChar(next2))
      break;
    name2 += String.fromCharCode(next2);
    next2 = input.peek(++offset);
  }
  cachedInput = input;
  cachedPos = pos;
  return cachedName = name2 ? name2.toLowerCase() : next2 == question$2 || next2 == bang ? void 0 : null;
}
const lessThan = 60, greaterThan = 62, slash$1 = 47, question$2 = 63, bang = 33, dash$1 = 45;
function ElementContext(name2, parent) {
  this.name = name2;
  this.parent = parent;
  this.hash = parent ? parent.hash : 0;
  for (let i = 0; i < name2.length; i++)
    this.hash += (this.hash << 4) + name2.charCodeAt(i) + (name2.charCodeAt(i) << 8);
}
const startTagTerms = [StartTag, StartSelfClosingTag, StartScriptTag, StartStyleTag, StartTextareaTag];
const elementContext = new ContextTracker({
  start: null,
  shift(context, term, stack2, input) {
    return startTagTerms.indexOf(term) > -1 ? new ElementContext(tagNameAfter(input, 1) || "", context) : context;
  },
  reduce(context, term) {
    return term == Element && context ? context.parent : context;
  },
  reuse(context, node2, stack2, input) {
    let type2 = node2.type.id;
    return type2 == StartTag || type2 == OpenTag ? new ElementContext(tagNameAfter(input, 1) || "", context) : context;
  },
  hash(context) {
    return context ? context.hash : 0;
  },
  strict: false
});
const tagStart = new ExternalTokenizer((input, stack2) => {
  if (input.next != lessThan) {
    if (input.next < 0 && stack2.context)
      input.acceptToken(missingCloseTag);
    return;
  }
  input.advance();
  let close = input.next == slash$1;
  if (close)
    input.advance();
  let name2 = tagNameAfter(input, 0);
  if (name2 === void 0)
    return;
  if (!name2)
    return input.acceptToken(close ? IncompleteCloseTag : StartTag);
  let parent = stack2.context ? stack2.context.name : null;
  if (close) {
    if (name2 == parent)
      return input.acceptToken(StartCloseTag);
    if (parent && implicitlyClosed[parent])
      return input.acceptToken(missingCloseTag, -2);
    if (stack2.dialectEnabled(Dialect_noMatch))
      return input.acceptToken(NoMatchStartCloseTag);
    for (let cx = stack2.context; cx; cx = cx.parent)
      if (cx.name == name2)
        return;
    input.acceptToken(MismatchedStartCloseTag);
  } else {
    if (name2 == "script")
      return input.acceptToken(StartScriptTag);
    if (name2 == "style")
      return input.acceptToken(StartStyleTag);
    if (name2 == "textarea")
      return input.acceptToken(StartTextareaTag);
    if (selfClosers.hasOwnProperty(name2))
      return input.acceptToken(StartSelfClosingTag);
    if (parent && closeOnOpen[parent] && closeOnOpen[parent][name2])
      input.acceptToken(missingCloseTag, -1);
    else
      input.acceptToken(StartTag);
  }
}, { contextual: true });
const commentContent = new ExternalTokenizer((input) => {
  for (let dashes = 0, i = 0; ; i++) {
    if (input.next < 0) {
      if (i)
        input.acceptToken(commentContent$1);
      break;
    }
    if (input.next == dash$1) {
      dashes++;
    } else if (input.next == greaterThan && dashes >= 2) {
      if (i > 3)
        input.acceptToken(commentContent$1, -2);
      break;
    } else {
      dashes = 0;
    }
    input.advance();
  }
});
function contentTokenizer(tag, textToken, endToken) {
  let lastState = 2 + tag.length;
  return new ExternalTokenizer((input) => {
    for (let state = 0, matchedLen = 0, i = 0; ; i++) {
      if (input.next < 0) {
        if (i)
          input.acceptToken(textToken);
        break;
      }
      if (state == 0 && input.next == lessThan || state == 1 && input.next == slash$1 || state >= 2 && state < lastState && input.next == tag.charCodeAt(state - 2)) {
        state++;
        matchedLen++;
      } else if ((state == 2 || state == lastState) && isSpace(input.next)) {
        matchedLen++;
      } else if (state == lastState && input.next == greaterThan) {
        if (i > matchedLen)
          input.acceptToken(textToken, -matchedLen);
        else
          input.acceptToken(endToken, -(matchedLen - 2));
        break;
      } else if ((input.next == 10 || input.next == 13) && i) {
        input.acceptToken(textToken, 1);
        break;
      } else {
        state = matchedLen = 0;
      }
      input.advance();
    }
  });
}
const scriptTokens = contentTokenizer("script", scriptText, StartCloseScriptTag);
const styleTokens = contentTokenizer("style", styleText, StartCloseStyleTag);
const textareaTokens = contentTokenizer("textarea", textareaText, StartCloseTextareaTag);
const htmlHighlighting = styleTags({
  "Text RawText": tags$5.content,
  "StartTag StartCloseTag SelfCloserEndTag EndTag SelfCloseEndTag": tags$5.angleBracket,
  TagName: tags$5.tagName,
  "MismatchedCloseTag/TagName": [tags$5.tagName, tags$5.invalid],
  AttributeName: tags$5.attributeName,
  "AttributeValue UnquotedAttributeValue": tags$5.attributeValue,
  Is: tags$5.definitionOperator,
  "EntityReference CharacterReference": tags$5.character,
  Comment: tags$5.blockComment,
  ProcessingInst: tags$5.processingInstruction,
  DoctypeDecl: tags$5.documentMeta
});
const parser$f = LRParser.deserialize({
  version: 14,
  states: ",xOVOxOOO!WQ!bO'#CoO!]Q!bO'#CyO!bQ!bO'#C|O!gQ!bO'#DPO!lQ!bO'#DRO!qOXO'#CnO!|OYO'#CnO#XO[O'#CnO$eOxO'#CnOOOW'#Cn'#CnO$lO!rO'#DSO$tQ!bO'#DUO$yQ!bO'#DVOOOW'#Dj'#DjOOOW'#DX'#DXQVOxOOO%OQ#tO,59ZO%WQ#tO,59eO%`Q#tO,59hO%hQ#tO,59kO%pQ#tO,59mOOOX'#D]'#D]O%xOXO'#CwO&TOXO,59YOOOY'#D^'#D^O&]OYO'#CzO&hOYO,59YOOO['#D_'#D_O&pO[O'#C}O&{O[O,59YOOOW'#D`'#D`O'TOxO,59YO'[Q!bO'#DQOOOW,59Y,59YOOO`'#Da'#DaO'aO!rO,59nOOOW,59n,59nO'iQ!bO,59pO'nQ!bO,59qOOOW-E7V-E7VO'sQ#tO'#CqOOQO'#DY'#DYO(OQ#tO1G.uOOOX1G.u1G.uO(WQ#tO1G/POOOY1G/P1G/PO(`Q#tO1G/SOOO[1G/S1G/SO(hQ#tO1G/VOOOW1G/V1G/VO(pQ#tO1G/XOOOW1G/X1G/XOOOX-E7Z-E7ZO(xQ!bO'#CxOOOW1G.t1G.tOOOY-E7[-E7[O(}Q!bO'#C{OOO[-E7]-E7]O)SQ!bO'#DOOOOW-E7^-E7^O)XQ!bO,59lOOO`-E7_-E7_OOOW1G/Y1G/YOOOW1G/[1G/[OOOW1G/]1G/]O)^Q&jO,59]OOQO-E7W-E7WOOOX7+$a7+$aOOOY7+$k7+$kOOO[7+$n7+$nOOOW7+$q7+$qOOOW7+$s7+$sO)iQ!bO,59dO)nQ!bO,59gO)sQ!bO,59jOOOW1G/W1G/WO)xO,UO'#CtO*WO7[O'#CtOOQO1G.w1G.wOOOW1G/O1G/OOOOW1G/R1G/ROOOW1G/U1G/UOOOO'#DZ'#DZO*fO,UO,59`OOQO,59`,59`OOOO'#D['#D[O*tO7[O,59`OOOO-E7X-E7XOOQO1G.z1G.zOOOO-E7Y-E7Y",
  stateData: "+[~O!]OS~OSSOTPOUQOVROWTOY]OZ[O[^O^^O_^O`^Oa^Ow^Oz_O!cZO~OdaO~OdbO~OdcO~OddO~OdeO~O!VfOPkP!YkP~O!WiOQnP!YnP~O!XlORqP!YqP~OSSOTPOUQOVROWTOXqOY]OZ[O[^O^^O_^O`^Oa^Ow^O!cZO~O!YrO~P#dO!ZsO!duO~OdvO~OdwO~OfyOj|O~OfyOj!OO~OfyOj!QO~OfyOj!SO~OfyOj!UO~O!VfOPkX!YkX~OP!WO!Y!XO~O!WiOQnX!YnX~OQ!ZO!Y!XO~O!XlORqX!YqX~OR!]O!Y!XO~O!Y!XO~P#dOd!_O~O!ZsO!d!aO~Oj!bO~Oj!cO~Og!dOfeXjeX~OfyOj!fO~OfyOj!gO~OfyOj!hO~OfyOj!iO~OfyOj!jO~Od!kO~Od!lO~Od!mO~Oj!nO~Oi!qO!_!oO!a!pO~Oj!rO~Oj!sO~Oj!tO~O_!uO`!uO!_!wO!`!uO~O_!xO`!xO!a!wO!b!xO~O_!uO`!uO!_!{O!`!uO~O_!xO`!xO!a!{O!b!xO~O`_a!cwz!c~",
  goto: "%o!_PPPPPPPPPPPPPPPPPP!`!fP!lPP!xPP!{#O#R#X#[#_#e#h#k#q#w!`P!`!`P#}$T$k$q$w$}%T%Z%aPPPPPPPP%gX^OX`pXUOX`pezabcde{}!P!R!TR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ}bQ!PcQ!RdQ!TeZ!e{}!P!R!TQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: "\u26A0 StartCloseTag StartCloseTag StartCloseTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue EndTag ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 66,
  context: elementContext,
  nodeProps: [
    ["closedBy", -11, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, "EndTag", -4, 19, 29, 32, 35, "CloseTag"],
    ["group", -9, 12, 15, 16, 17, 18, 38, 39, 40, 41, "Entity", 14, "Entity TextContent", -3, 27, 30, 33, "TextContent Entity"],
    ["openedBy", 26, "StartTag StartCloseTag", -4, 28, 31, 34, 36, "OpenTag"]
  ],
  propSources: [htmlHighlighting],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!#b!aR!WOX$kXY)sYZ)sZ]$k]^)s^p$kpq)sqr$krs*zsv$kvw+dwx2yx}$k}!O3f!O!P$k!P!Q7_!Q![$k![!]8u!]!^$k!^!_>b!_!`!!p!`!a8T!a!c$k!c!}8u!}#R$k#R#S8u#S#T$k#T#o8u#o$f$k$f$g&R$g%W$k%W%o8u%o%p$k%p&a8u&a&b$k&b1p8u1p4U$k4U4d8u4d4e$k4e$IS8u$IS$I`$k$I`$Ib8u$Ib$Kh$k$Kh%#t8u%#t&/x$k&/x&Et8u&Et&FV$k&FV;'S8u;'S;:j<t;:j?&r$k?&r?Ah8u?Ah?BY$k?BY?Mn8u?Mn~$k!Z$vc^PiW!``!bpOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx!P$k!P!Q&R!Q!^$k!^!_(k!_!a&R!a$f$k$f$g&R$g~$k!R&[V^P!``!bpOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&Rq&xT^P!bpOv&qwx'Xx!^&q!^!_'g!_~&qP'^R^POv'Xw!^'X!_~'Xp'lQ!bpOv'gx~'ga'yU^P!``Or'rrs'Xsv'rw!^'r!^!_(]!_~'r`(bR!``Or(]sv(]w~(]!Q(rT!``!bpOr(krs'gsv(kwx(]x~(kW)WXiWOX)RZ])R^p)Rqr)Rsw)Rx!P)R!Q!^)R!a$f)R$g~)R!a*O^^P!``!bp!]^OX&RXY)sYZ)sZ]&R]^)s^p&Rpq)sqr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R!Z+TT!_h^P!bpOv&qwx'Xx!^&q!^!_'g!_~&q!Z+kbiWaPOX,sXZ.QZ],s]^.Q^p,sqr,srs.Qst/]tw,swx.Qx!P,s!P!Q.Q!Q!],s!]!^)R!^!a.Q!a$f,s$f$g.Q$g~,s!Z,xbiWOX,sXZ.QZ],s]^.Q^p,sqr,srs.Qst)Rtw,swx.Qx!P,s!P!Q.Q!Q!],s!]!^.i!^!a.Q!a$f,s$f$g.Q$g~,s!R.TTOp.Qqs.Qt!].Q!]!^.d!^~.Q!R.iO_!R!Z.pXiW_!ROX)RZ])R^p)Rqr)Rsw)Rx!P)R!Q!^)R!a$f)R$g~)R!Z/baiWOX0gXZ1qZ]0g]^1q^p0gqr0grs1qsw0gwx1qx!P0g!P!Q1q!Q!]0g!]!^)R!^!a1q!a$f0g$f$g1q$g~0g!Z0laiWOX0gXZ1qZ]0g]^1q^p0gqr0grs1qsw0gwx1qx!P0g!P!Q1q!Q!]0g!]!^2V!^!a1q!a$f0g$f$g1q$g~0g!R1tSOp1qq!]1q!]!^2Q!^~1q!R2VO`!R!Z2^XiW`!ROX)RZ])R^p)Rqr)Rsw)Rx!P)R!Q!^)R!a$f)R$g~)R!Z3SU!ax^P!``Or'rrs'Xsv'rw!^'r!^!_(]!_~'r!]3qe^PiW!``!bpOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx}$k}!O5S!O!P$k!P!Q&R!Q!^$k!^!_(k!_!a&R!a$f$k$f$g&R$g~$k!]5_d^PiW!``!bpOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx!P$k!P!Q&R!Q!^$k!^!_(k!_!`&R!`!a6m!a$f$k$f$g&R$g~$k!T6xV^P!``!bp!dQOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R!X7hX^P!``!bpOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_!`&R!`!a8T!a~&R!X8`VjU^P!``!bpOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R!a9U!YfSdQ^PiW!``!bpOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx}$k}!O8u!O!P8u!P!Q&R!Q![8u![!]8u!]!^$k!^!_(k!_!a&R!a!c$k!c!}8u!}#R$k#R#S8u#S#T$k#T#o8u#o$f$k$f$g&R$g$}$k$}%O8u%O%W$k%W%o8u%o%p$k%p&a8u&a&b$k&b1p8u1p4U8u4U4d8u4d4e$k4e$IS8u$IS$I`$k$I`$Ib8u$Ib$Je$k$Je$Jg8u$Jg$Kh$k$Kh%#t8u%#t&/x$k&/x&Et8u&Et&FV$k&FV;'S8u;'S;:j<t;:j?&r$k?&r?Ah8u?Ah?BY$k?BY?Mn8u?Mn~$k!a=Pe^PiW!``!bpOX$kXZ&RZ]$k]^&R^p$kpq&Rqr$krs&qsv$kvw)Rwx'rx!P$k!P!Q&R!Q!^$k!^!_(k!_!a&R!a$f$k$f$g&R$g;=`$k;=`<%l8u<%l~$k!R>iW!``!bpOq(kqr?Rrs'gsv(kwx(]x!a(k!a!bKj!b~(k!R?YZ!``!bpOr(krs'gsv(kwx(]x}(k}!O?{!O!f(k!f!gAR!g#W(k#W#XGz#X~(k!R@SV!``!bpOr(krs'gsv(kwx(]x}(k}!O@i!O~(k!R@rT!``!bp!cPOr(krs'gsv(kwx(]x~(k!RAYV!``!bpOr(krs'gsv(kwx(]x!q(k!q!rAo!r~(k!RAvV!``!bpOr(krs'gsv(kwx(]x!e(k!e!fB]!f~(k!RBdV!``!bpOr(krs'gsv(kwx(]x!v(k!v!wBy!w~(k!RCQV!``!bpOr(krs'gsv(kwx(]x!{(k!{!|Cg!|~(k!RCnV!``!bpOr(krs'gsv(kwx(]x!r(k!r!sDT!s~(k!RD[V!``!bpOr(krs'gsv(kwx(]x!g(k!g!hDq!h~(k!RDxW!``!bpOrDqrsEbsvDqvwEvwxFfx!`Dq!`!aGb!a~DqqEgT!bpOvEbvxEvx!`Eb!`!aFX!a~EbPEyRO!`Ev!`!aFS!a~EvPFXOzPqF`Q!bpzPOv'gx~'gaFkV!``OrFfrsEvsvFfvwEvw!`Ff!`!aGQ!a~FfaGXR!``zPOr(]sv(]w~(]!RGkT!``!bpzPOr(krs'gsv(kwx(]x~(k!RHRV!``!bpOr(krs'gsv(kwx(]x#c(k#c#dHh#d~(k!RHoV!``!bpOr(krs'gsv(kwx(]x#V(k#V#WIU#W~(k!RI]V!``!bpOr(krs'gsv(kwx(]x#h(k#h#iIr#i~(k!RIyV!``!bpOr(krs'gsv(kwx(]x#m(k#m#nJ`#n~(k!RJgV!``!bpOr(krs'gsv(kwx(]x#d(k#d#eJ|#e~(k!RKTV!``!bpOr(krs'gsv(kwx(]x#X(k#X#YDq#Y~(k!RKqW!``!bpOrKjrsLZsvKjvwLowxNPx!aKj!a!b! g!b~KjqL`T!bpOvLZvxLox!aLZ!a!bM^!b~LZPLrRO!aLo!a!bL{!b~LoPMORO!`Lo!`!aMX!a~LoPM^OwPqMcT!bpOvLZvxLox!`LZ!`!aMr!a~LZqMyQ!bpwPOv'gx~'gaNUV!``OrNPrsLosvNPvwLow!aNP!a!bNk!b~NPaNpV!``OrNPrsLosvNPvwLow!`NP!`!a! V!a~NPa! ^R!``wPOr(]sv(]w~(]!R! nW!``!bpOrKjrsLZsvKjvwLowxNPx!`Kj!`!a!!W!a~Kj!R!!aT!``!bpwPOr(krs'gsv(kwx(]x~(k!V!!{VgS^P!``!bpOr&Rrs&qsv&Rwx'rx!^&R!^!_(k!_~&R",
  tokenizers: [scriptTokens, styleTokens, textareaTokens, tagStart, commentContent, 0, 1, 2, 3, 4, 5],
  topRules: { "Document": [0, 13] },
  dialects: { noMatch: 0 },
  tokenPrec: 464
});
function getAttrs(element, input) {
  let attrs = /* @__PURE__ */ Object.create(null);
  for (let att of element.firstChild.getChildren("Attribute")) {
    let name2 = att.getChild("AttributeName"), value = att.getChild("AttributeValue") || att.getChild("UnquotedAttributeValue");
    if (name2)
      attrs[input.read(name2.from, name2.to)] = !value ? "" : value.name == "AttributeValue" ? input.read(value.from + 1, value.to - 1) : input.read(value.from, value.to);
  }
  return attrs;
}
function maybeNest(node2, input, tags2) {
  let attrs;
  for (let tag of tags2) {
    if (!tag.attrs || tag.attrs(attrs || (attrs = getAttrs(node2.node.parent, input))))
      return { parser: tag.parser };
  }
  return null;
}
function configureNesting(tags2) {
  let script = [], style2 = [], textarea = [];
  for (let tag of tags2) {
    let array2 = tag.tag == "script" ? script : tag.tag == "style" ? style2 : tag.tag == "textarea" ? textarea : null;
    if (!array2)
      throw new RangeError("Only script, style, and textarea tags can host nested parsers");
    array2.push(tag);
  }
  return parseMixed((node2, input) => {
    let id2 = node2.type.id;
    if (id2 == ScriptText)
      return maybeNest(node2, input, script);
    if (id2 == StyleText)
      return maybeNest(node2, input, style2);
    if (id2 == TextareaText)
      return maybeNest(node2, input, textarea);
    return null;
  });
}
const descendantOp = 93, Unit$1 = 1, callee = 94, identifier$3 = 95, VariableName = 2;
const space$1 = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
];
const colon = 58, parenL = 40, underscore = 95, bracketL = 91, dash = 45, period$1 = 46, hash = 35, percent = 37;
function isAlpha(ch) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 161;
}
function isDigit(ch) {
  return ch >= 48 && ch <= 57;
}
const identifiers = new ExternalTokenizer((input, stack2) => {
  for (let inside2 = false, dashes = 0, i = 0; ; i++) {
    let { next: next2 } = input;
    if (isAlpha(next2) || next2 == dash || next2 == underscore || inside2 && isDigit(next2)) {
      if (!inside2 && (next2 != dash || i > 0))
        inside2 = true;
      if (dashes === i && next2 == dash)
        dashes++;
      input.advance();
    } else {
      if (inside2)
        input.acceptToken(next2 == parenL ? callee : dashes == 2 && stack2.canShift(VariableName) ? VariableName : identifier$3);
      break;
    }
  }
});
const descendant = new ExternalTokenizer((input) => {
  if (space$1.includes(input.peek(-1))) {
    let { next: next2 } = input;
    if (isAlpha(next2) || next2 == underscore || next2 == hash || next2 == period$1 || next2 == bracketL || next2 == colon || next2 == dash)
      input.acceptToken(descendantOp);
  }
});
const unitToken = new ExternalTokenizer((input) => {
  if (!space$1.includes(input.peek(-1))) {
    let { next: next2 } = input;
    if (next2 == percent) {
      input.advance();
      input.acceptToken(Unit$1);
    }
    if (isAlpha(next2)) {
      do {
        input.advance();
      } while (isAlpha(input.next));
      input.acceptToken(Unit$1);
    }
  }
});
const cssHighlighting = styleTags({
  "import charset namespace keyframes": tags$5.definitionKeyword,
  "media supports": tags$5.controlKeyword,
  "from to selector": tags$5.keyword,
  NamespaceName: tags$5.namespace,
  KeyframeName: tags$5.labelName,
  TagName: tags$5.tagName,
  ClassName: tags$5.className,
  PseudoClassName: tags$5.constant(tags$5.className),
  IdName: tags$5.labelName,
  "FeatureName PropertyName": tags$5.propertyName,
  AttributeName: tags$5.attributeName,
  NumberLiteral: tags$5.number,
  KeywordQuery: tags$5.keyword,
  UnaryQueryOp: tags$5.operatorKeyword,
  "CallTag ValueName": tags$5.atom,
  VariableName: tags$5.variableName,
  Callee: tags$5.operatorKeyword,
  Unit: tags$5.unit,
  "UniversalSelector NestingSelector": tags$5.definitionOperator,
  AtKeyword: tags$5.keyword,
  MatchOp: tags$5.compareOperator,
  "ChildOp SiblingOp, LogicOp": tags$5.logicOperator,
  BinOp: tags$5.arithmeticOperator,
  Important: tags$5.modifier,
  Comment: tags$5.blockComment,
  ParenthesizedContent: tags$5.special(tags$5.name),
  ColorLiteral: tags$5.color,
  StringLiteral: tags$5.string,
  ":": tags$5.punctuation,
  "PseudoOp #": tags$5.derefOperator,
  "; ,": tags$5.separator,
  "( )": tags$5.paren,
  "[ ]": tags$5.squareBracket,
  "{ }": tags$5.brace
});
const spec_callee = { __proto__: null, lang: 32, "nth-child": 32, "nth-last-child": 32, "nth-of-type": 32, dir: 32, url: 60, "url-prefix": 60, domain: 60, regexp: 60, selector: 134 };
const spec_AtKeyword = { __proto__: null, "@import": 114, "@media": 138, "@charset": 142, "@namespace": 146, "@keyframes": 152, "@supports": 164 };
const spec_identifier$1 = { __proto__: null, not: 128, only: 128, from: 158, to: 160 };
const parser$e = LRParser.deserialize({
  version: 14,
  states: "7WOYQ[OOOOQP'#Cd'#CdOOQP'#Cc'#CcO!ZQ[O'#CfO!}QXO'#CaO#UQ[O'#ChO#aQ[O'#DPO#fQ[O'#DTOOQP'#Ec'#EcO#kQdO'#DeO$VQ[O'#DrO#kQdO'#DtO$hQ[O'#DvO$sQ[O'#DyO$xQ[O'#EPO%WQ[O'#EROOQS'#Eb'#EbOOQS'#ES'#ESQYQ[OOOOQP'#Cg'#CgOOQP,59Q,59QO!ZQ[O,59QO%_Q[O'#EVO%yQWO,58{O&RQ[O,59SO#aQ[O,59kO#fQ[O,59oO%_Q[O,59sO%_Q[O,59uO%_Q[O,59vO'bQ[O'#D`OOQS,58{,58{OOQP'#Ck'#CkOOQO'#C}'#C}OOQP,59S,59SO'iQWO,59SO'nQWO,59SOOQP'#DR'#DROOQP,59k,59kOOQO'#DV'#DVO'sQ`O,59oOOQS'#Cp'#CpO#kQdO'#CqO'{QvO'#CsO)VQtO,5:POOQO'#Cx'#CxO'iQWO'#CwO)kQWO'#CyOOQS'#Ef'#EfOOQO'#Dh'#DhO)pQ[O'#DoO*OQWO'#EiO$xQ[O'#DmO*^QWO'#DpOOQO'#Ej'#EjO%|QWO,5:^O*cQpO,5:`OOQS'#Dx'#DxO*kQWO,5:bO*pQ[O,5:bOOQO'#D{'#D{O*xQWO,5:eO*}QWO,5:kO+VQWO,5:mOOQS-E8Q-E8QOOQP1G.l1G.lO+yQXO,5:qOOQO-E8T-E8TOOQS1G.g1G.gOOQP1G.n1G.nO'iQWO1G.nO'nQWO1G.nOOQP1G/V1G/VO,WQ`O1G/ZO,qQXO1G/_O-XQXO1G/aO-oQXO1G/bO.VQXO'#CdO.zQWO'#DaOOQS,59z,59zO/PQWO,59zO/XQ[O,59zO/`QdO'#CoO/gQ[O'#DOOOQP1G/Z1G/ZO#kQdO1G/ZO/nQpO,59]OOQS,59_,59_O#kQdO,59aO/vQWO1G/kOOQS,59c,59cO/{Q!bO,59eO0TQWO'#DhO0`QWO,5:TO0eQWO,5:ZO$xQ[O,5:VO$xQ[O'#EYO0mQWO,5;TO0xQWO,5:XO%_Q[O,5:[OOQS1G/x1G/xOOQS1G/z1G/zOOQS1G/|1G/|O1ZQWO1G/|O1`QdO'#D|OOQS1G0P1G0POOQS1G0V1G0VOOQS1G0X1G0XOOQP7+$Y7+$YOOQP7+$u7+$uO#kQdO7+$uO#kQdO,59{O1nQ[O'#EXO1xQWO1G/fOOQS1G/f1G/fO1xQWO1G/fO2QQtO'#ETO2uQdO'#EeO3PQWO,59ZO3UQXO'#EhO3]QWO,59jO3bQpO7+$uOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%V7+%VO3jQWO1G/PO#kQdO1G/oOOQO1G/u1G/uOOQO1G/q1G/qO3oQWO,5:tOOQO-E8W-E8WO3}QXO1G/vOOQS7+%h7+%hO4UQYO'#CsO%|QWO'#EZO4^QdO,5:hOOQS,5:h,5:hO4lQpO<<HaO4tQtO1G/gOOQO,5:s,5:sO5XQ[O,5:sOOQO-E8V-E8VOOQS7+%Q7+%QO5cQWO7+%QOOQS-E8R-E8RO#kQdO'#EUO5kQWO,5;POOQT1G.u1G.uO5sQWO,5;SOOQP1G/U1G/UOOQP<<Ha<<HaOOQS7+$k7+$kO5{QdO7+%ZOOQO7+%b7+%bOOQS,5:u,5:uOOQS-E8X-E8XOOQS1G0S1G0SOOQPAN={AN={O6SQtO'#EWO#kQdO'#EWO6}QdO7+%ROOQO7+%R7+%ROOQO1G0_1G0_OOQS<<Hl<<HlO7_QdO,5:pOOQO-E8S-E8SOOQO<<Hu<<HuO7iQtO,5:rOOQS-E8U-E8UOOQO<<Hm<<Hm",
  stateData: "8j~O#TOSROS~OUWOXWO]TO^TOtUOxVO!Y_O!ZXO!gYO!iZO!k[O!n]O!t^O#RPO#WRO~O#RcO~O]hO^hOpfOtiOxjO|kO!PmO#PlO#WeO~O!RnO~P!`O`sO#QqO#RpO~O#RuO~O#RwO~OQ!QObzOf!QOh!QOn!PO#Q}O#RyO#Z{O~Ob!SO!b!UO!e!VO#R!RO!R#]P~Oh![On!PO#R!ZO~O#R!^O~Ob!SO!b!UO!e!VO#R!RO~O!W#]P~P$VOUWOXWO]TO^TOtUOxVO#RPO#WRO~OpfO!RnO~O`!hO#QqO#RpO~OQ!pOUWOXWO]TO^TOtUOxVO!Y_O!ZXO!gYO!iZO!k[O!n]O!t^O#R!oO#WRO~O!Q!qO~P&^Ob!tO~Ob!uO~Ov!vOz!wO~OP!yObgXjgX!WgX!bgX!egX#RgXagXQgXfgXhgXngXpgX#QgX#ZgXvgX!QgX!VgX~Ob!SOj!zO!b!UO!e!VO#R!RO!W#]P~Ob!}O~Ob!SO!b!UO!e!VO#R#OO~Op#SO!`#RO!R#]X!W#]X~Ob#VO~Oj!zO!W#XO~O!W#YO~Oh#ZOn!PO~O!R#[O~O!RnO!`#RO~O!RnO!W#_O~O]hO^hOtiOxjO|kO!PmO#PlO#WeO~Op!ya!R!yaa!ya~P+_Ov#aOz#bO~O]hO^hOtiOxjO#WeO~Op{i|{i!P{i!R{i#P{ia{i~P,`Op}i|}i!P}i!R}i#P}ia}i~P,`Op!Oi|!Oi!P!Oi!R!Oi#P!Oia!Oi~P,`O]WX]!UX^WXpWXtWXxWX|WX!PWX!RWX#PWX#WWX~O]#cO~O!Q#fO!W#dO~O!Q#fO~P&^Oa#XP~P#kOa#[P~P%_Oa#nOj!zO~O!W#pO~Oh#qOo#qO~O]!^Xa![X!`![X~O]#rO~Oa#sO!`#RO~Op#SO!R#]a!W#]a~O!`#ROp!aa!R!aa!W!aaa!aa~O!W#xO~O!Q#|O!q#zO!r#zO#Z#yO~O!Q!{X!W!{X~P&^O!Q$SO!W#dO~Oj!zOQ!wXa!wXb!wXf!wXh!wXn!wXp!wX#Q!wX#R!wX#Z!wX~Op$VOa#XX~P#kOa$XO~Oa#[X~P!`Oa$ZO~Oj!zOv$[O~Oa$]O~O!`#ROp!|a!R!|a!W!|a~Oa$_O~P+_OP!yO!RgX~O!Q$bO!q#zO!r#zO#Z#yO~Oj!zOv$cO~Oj!zOp$eO!V$gO!Q!Ti!W!Ti~P#kO!Q!{a!W!{a~P&^O!Q$iO!W#dO~Op$VOa#Xa~OpfOa#[a~Oa$lO~P#kOj!zOQ!zXb!zXf!zXh!zXn!zXp!zX!Q!zX!V!zX!W!zX#Q!zX#R!zX#Z!zX~Op$eO!V$oO!Q!Tq!W!Tq~P#kOa!xap!xa~P#kOj!zOQ!zab!zaf!zah!zan!zap!za!Q!za!V!za!W!za#Q!za#R!za#Z!za~Oo#Zj!Pj~",
  goto: ",O#_PPPPP#`P#h#vP#h$U#hPP$[PPP$b$k$kP$}P$kP$k%e%wPPP&a&g#hP&mP#hP&sP#hP#h#hPPP&y']'iPP#`PP'o'o'y'oP'oP'o'oP#`P#`P#`P'|#`P(P(SPP#`P#`(V(e(s(y)T)Z)e)kPPPPPP)q)yP*e*hP+^+a+j]`Obn!s#d$QiWObfklmn!s!u#V#d$QiQObfklmn!s!u#V#d$QQdRR!ceQrTR!ghQ!gsQ!|!OR#`!hq!QXZz!t!w!z#b#c#i#r$O$V$^$e$f$jp!QXZz!t!w!z#b#c#i#r$O$V$^$e$f$jT#z#[#{q!OXZz!t!w!z#b#c#i#r$O$V$^$e$f$jp!QXZz!t!w!z#b#c#i#r$O$V$^$e$f$jQ![[R#Z!]QtTR!ihQ!gtR#`!iQvUR!jiQxVR!kjQoSQ!fgQ#W!XQ#^!`Q#_!aR$`#zQ!rnQ#g!sQ$P#dR$h$QX!pn!s#d$Qa!WY^_|!S!U#R#SR#P!SR!][R!_]R#]!_QbOU!bb!s$QQ!snR$Q#dQ#i!tU$U#i$^$jQ$^#rR$j$VQ$W#iR$k$WQgSS!eg$YR$Y#kQ$f$OR$n$fQ#e!rS$R#e$TR$T#gQ#T!TR#v#TQ#{#[R$a#{]aObn!s#d$Q[SObn!s#d$QQ!dfQ!lkQ!mlQ!nmQ#k!uR#w#VR#j!tQ|XQ!YZQ!xz[#h!t#i#r$V$^$jQ#m!wQ#o!zQ#}#bQ$O#cS$d$O$fR$m$eR#l!uQ!XYQ!a_R!{|U!TY_|Q!`^Q#Q!SQ#U!UQ#t#RR#u#S",
  nodeNames: "\u26A0 Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent , PseudoClassName ArgList IdSelector # IdName ] AttributeSelector [ AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList from to SupportsStatement supports AtRule",
  maxTerm: 106,
  nodeProps: [
    ["openedBy", 17, "(", 48, "{"],
    ["closedBy", 18, ")", 49, "}"]
  ],
  propSources: [cssHighlighting],
  skippedNodes: [0, 3],
  repeatNodeCount: 8,
  tokenData: "Ay~R![OX$wX^%]^p$wpq%]qr(crs+}st,otu2Uuv$wvw2rwx2}xy3jyz3uz{3z{|4_|}8U}!O8a!O!P8x!P!Q9Z!Q![;e![!]<Y!]!^<x!^!_$w!_!`=T!`!a=`!a!b$w!b!c>O!c!}$w!}#O?[#O#P$w#P#Q?g#Q#R2U#R#T$w#T#U?r#U#c$w#c#d@q#d#o$w#o#pAQ#p#q2U#q#rA]#r#sAh#s#y$w#y#z%]#z$f$w$f$g%]$g#BY$w#BY#BZ%]#BZ$IS$w$IS$I_%]$I_$I|$w$I|$JO%]$JO$JT$w$JT$JU%]$JU$KV$w$KV$KW%]$KW&FU$w&FU&FV%]&FV~$wW$zQOy%Qz~%QW%VQoWOy%Qz~%Q~%bf#T~OX%QX^&v^p%Qpq&vqy%Qz#y%Q#y#z&v#z$f%Q$f$g&v$g#BY%Q#BY#BZ&v#BZ$IS%Q$IS$I_&v$I_$I|%Q$I|$JO&v$JO$JT%Q$JT$JU&v$JU$KV%Q$KV$KW&v$KW&FU%Q&FU&FV&v&FV~%Q~&}f#T~oWOX%QX^&v^p%Qpq&vqy%Qz#y%Q#y#z&v#z$f%Q$f$g&v$g#BY%Q#BY#BZ&v#BZ$IS%Q$IS$I_&v$I_$I|%Q$I|$JO&v$JO$JT%Q$JT$JU&v$JU$KV%Q$KV$KW&v$KW&FU%Q&FU&FV&v&FV~%Q^(fSOy%Qz#]%Q#]#^(r#^~%Q^(wSoWOy%Qz#a%Q#a#b)T#b~%Q^)YSoWOy%Qz#d%Q#d#e)f#e~%Q^)kSoWOy%Qz#c%Q#c#d)w#d~%Q^)|SoWOy%Qz#f%Q#f#g*Y#g~%Q^*_SoWOy%Qz#h%Q#h#i*k#i~%Q^*pSoWOy%Qz#T%Q#T#U*|#U~%Q^+RSoWOy%Qz#b%Q#b#c+_#c~%Q^+dSoWOy%Qz#h%Q#h#i+p#i~%Q^+wQ!VUoWOy%Qz~%Q~,QUOY+}Zr+}rs,ds#O+}#O#P,i#P~+}~,iOh~~,lPO~+}_,tWtPOy%Qz!Q%Q!Q![-^![!c%Q!c!i-^!i#T%Q#T#Z-^#Z~%Q^-cWoWOy%Qz!Q%Q!Q![-{![!c%Q!c!i-{!i#T%Q#T#Z-{#Z~%Q^.QWoWOy%Qz!Q%Q!Q![.j![!c%Q!c!i.j!i#T%Q#T#Z.j#Z~%Q^.qWfUoWOy%Qz!Q%Q!Q![/Z![!c%Q!c!i/Z!i#T%Q#T#Z/Z#Z~%Q^/bWfUoWOy%Qz!Q%Q!Q![/z![!c%Q!c!i/z!i#T%Q#T#Z/z#Z~%Q^0PWoWOy%Qz!Q%Q!Q![0i![!c%Q!c!i0i!i#T%Q#T#Z0i#Z~%Q^0pWfUoWOy%Qz!Q%Q!Q![1Y![!c%Q!c!i1Y!i#T%Q#T#Z1Y#Z~%Q^1_WoWOy%Qz!Q%Q!Q![1w![!c%Q!c!i1w!i#T%Q#T#Z1w#Z~%Q^2OQfUoWOy%Qz~%QY2XSOy%Qz!_%Q!_!`2e!`~%QY2lQzQoWOy%Qz~%QX2wQXPOy%Qz~%Q~3QUOY2}Zw2}wx,dx#O2}#O#P3d#P~2}~3gPO~2}_3oQbVOy%Qz~%Q~3zOa~_4RSUPjSOy%Qz!_%Q!_!`2e!`~%Q_4fUjS!PPOy%Qz!O%Q!O!P4x!P!Q%Q!Q![7_![~%Q^4}SoWOy%Qz!Q%Q!Q![5Z![~%Q^5bWoW#ZUOy%Qz!Q%Q!Q![5Z![!g%Q!g!h5z!h#X%Q#X#Y5z#Y~%Q^6PWoWOy%Qz{%Q{|6i|}%Q}!O6i!O!Q%Q!Q![6z![~%Q^6nSoWOy%Qz!Q%Q!Q![6z![~%Q^7RSoW#ZUOy%Qz!Q%Q!Q![6z![~%Q^7fYoW#ZUOy%Qz!O%Q!O!P5Z!P!Q%Q!Q![7_![!g%Q!g!h5z!h#X%Q#X#Y5z#Y~%Q_8ZQpVOy%Qz~%Q^8fUjSOy%Qz!O%Q!O!P4x!P!Q%Q!Q![7_![~%Q_8}S#WPOy%Qz!Q%Q!Q![5Z![~%Q~9`RjSOy%Qz{9i{~%Q~9nSoWOy9iyz9zz{:o{~9i~9}ROz9zz{:W{~9z~:ZTOz9zz{:W{!P9z!P!Q:j!Q~9z~:oOR~~:tUoWOy9iyz9zz{:o{!P9i!P!Q;W!Q~9i~;_QoWR~Oy%Qz~%Q^;jY#ZUOy%Qz!O%Q!O!P5Z!P!Q%Q!Q![7_![!g%Q!g!h5z!h#X%Q#X#Y5z#Y~%QX<_S]POy%Qz![%Q![!]<k!]~%QX<rQ^PoWOy%Qz~%Q_<}Q!WVOy%Qz~%QY=YQzQOy%Qz~%QX=eS|POy%Qz!`%Q!`!a=q!a~%QX=xQ|PoWOy%Qz~%QX>RUOy%Qz!c%Q!c!}>e!}#T%Q#T#o>e#o~%QX>lY!YPoWOy%Qz}%Q}!O>e!O!Q%Q!Q![>e![!c%Q!c!}>e!}#T%Q#T#o>e#o~%QX?aQxPOy%Qz~%Q^?lQvUOy%Qz~%QX?uSOy%Qz#b%Q#b#c@R#c~%QX@WSoWOy%Qz#W%Q#W#X@d#X~%QX@kQ!`PoWOy%Qz~%QX@tSOy%Qz#f%Q#f#g@d#g~%QXAVQ!RPOy%Qz~%Q_AbQ!QVOy%Qz~%QZAmS!PPOy%Qz!_%Q!_!`2e!`~%Q",
  tokenizers: [descendant, unitToken, identifiers, 0, 1, 2, 3],
  topRules: { "StyleSheet": [0, 4] },
  specialized: [{ term: 94, get: (value) => spec_callee[value] || -1 }, { term: 56, get: (value) => spec_AtKeyword[value] || -1 }, { term: 95, get: (value) => spec_identifier$1[value] || -1 }],
  tokenPrec: 1078
});
let _properties = null;
function properties() {
  if (!_properties && typeof document == "object" && document.body) {
    let names = [];
    for (let prop in document.body.style) {
      if (!/[A-Z]|^-|^(item|length)$/.test(prop))
        names.push(prop);
    }
    _properties = names.sort().map((name2) => ({ type: "property", label: name2 }));
  }
  return _properties || [];
}
const pseudoClasses = /* @__PURE__ */ [
  "active",
  "after",
  "before",
  "checked",
  "default",
  "disabled",
  "empty",
  "enabled",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "lang",
  "last-child",
  "last-of-type",
  "link",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-of-type",
  "only-child",
  "optional",
  "out-of-range",
  "placeholder",
  "read-only",
  "read-write",
  "required",
  "root",
  "selection",
  "target",
  "valid",
  "visited"
].map((name2) => ({ type: "class", label: name2 }));
const values$1 = /* @__PURE__ */ [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((name2) => ({ type: "keyword", label: name2 })).concat(/* @__PURE__ */ [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((name2) => ({ type: "constant", label: name2 })));
const tags$4 = /* @__PURE__ */ [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((name2) => ({ type: "type", label: name2 }));
const identifier$2 = /^[\w-]*/;
const cssCompletionSource = (context) => {
  let { state, pos } = context, node2 = syntaxTree(state).resolveInner(pos, -1);
  if (node2.name == "PropertyName")
    return { from: node2.from, options: properties(), validFor: identifier$2 };
  if (node2.name == "ValueName")
    return { from: node2.from, options: values$1, validFor: identifier$2 };
  if (node2.name == "PseudoClassName")
    return { from: node2.from, options: pseudoClasses, validFor: identifier$2 };
  if (node2.name == "TagName") {
    for (let { parent } = node2; parent; parent = parent.parent)
      if (parent.name == "Block")
        return { from: node2.from, options: properties(), validFor: identifier$2 };
    return { from: node2.from, options: tags$4, validFor: identifier$2 };
  }
  if (!context.explicit)
    return null;
  let above = node2.resolve(pos), before = above.childBefore(pos);
  if (before && before.name == ":" && above.name == "PseudoClassSelector")
    return { from: pos, options: pseudoClasses, validFor: identifier$2 };
  if (before && before.name == ":" && above.name == "Declaration" || above.name == "ArgList")
    return { from: pos, options: values$1, validFor: identifier$2 };
  if (above.name == "Block")
    return { from: pos, options: properties(), validFor: identifier$2 };
  return null;
};
const cssLanguage = /* @__PURE__ */ LRLanguage.define({
  parser: /* @__PURE__ */ parser$e.configure({
    props: [
      /* @__PURE__ */ indentNodeProp.add({
        Declaration: /* @__PURE__ */ continuedIndent()
      }),
      /* @__PURE__ */ foldNodeProp.add({
        Block: foldInside
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function css() {
  return new LanguageSupport(cssLanguage, cssLanguage.data.of({ autocomplete: cssCompletionSource }));
}
const index$7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  css,
  cssCompletionSource,
  cssLanguage
}, Symbol.toStringTag, { value: "Module" }));
const TSExtends = 1, noSemi = 281, incdec = 2, incdecPrefix = 3, templateContent = 282, InterpolationStart = 4, templateEnd = 283, insertSemi = 284, spaces = 286, newline = 287, LineComment = 5, BlockComment = 6, Dialect_ts = 1;
const space = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
];
const braceR = 125, braceL = 123, semicolon = 59, slash = 47, star$1 = 42, plus = 43, minus = 45, dollar = 36, backtick = 96, backslash = 92;
const trackNewline = new ContextTracker({
  start: false,
  shift(context, term) {
    return term == LineComment || term == BlockComment || term == spaces ? context : term == newline;
  },
  strict: false
});
const insertSemicolon = new ExternalTokenizer((input, stack2) => {
  let { next: next2 } = input;
  if ((next2 == braceR || next2 == -1 || stack2.context) && stack2.canShift(insertSemi))
    input.acceptToken(insertSemi);
}, { contextual: true, fallback: true });
const noSemicolon = new ExternalTokenizer((input, stack2) => {
  let { next: next2 } = input, after;
  if (space.indexOf(next2) > -1)
    return;
  if (next2 == slash && ((after = input.peek(1)) == slash || after == star$1))
    return;
  if (next2 != braceR && next2 != semicolon && next2 != -1 && !stack2.context && stack2.canShift(noSemi))
    input.acceptToken(noSemi);
}, { contextual: true });
const incdecToken = new ExternalTokenizer((input, stack2) => {
  let { next: next2 } = input;
  if (next2 == plus || next2 == minus) {
    input.advance();
    if (next2 == input.next) {
      input.advance();
      let mayPostfix = !stack2.context && stack2.canShift(incdec);
      input.acceptToken(mayPostfix ? incdec : incdecPrefix);
    }
  }
}, { contextual: true });
const template = new ExternalTokenizer((input) => {
  for (let afterDollar = false, i = 0; ; i++) {
    let { next: next2 } = input;
    if (next2 < 0) {
      if (i)
        input.acceptToken(templateContent);
      break;
    } else if (next2 == backtick) {
      if (i)
        input.acceptToken(templateContent);
      else
        input.acceptToken(templateEnd, 1);
      break;
    } else if (next2 == braceL && afterDollar) {
      if (i == 1)
        input.acceptToken(InterpolationStart, 1);
      else
        input.acceptToken(templateContent, -1);
      break;
    } else if (next2 == 10 && i) {
      input.advance();
      input.acceptToken(templateContent);
      break;
    } else if (next2 == backslash) {
      input.advance();
    }
    afterDollar = next2 == dollar;
    input.advance();
  }
});
const tsExtends = new ExternalTokenizer((input, stack2) => {
  if (input.next != 101 || !stack2.dialectEnabled(Dialect_ts))
    return;
  input.advance();
  for (let i = 0; i < 6; i++) {
    if (input.next != "xtends".charCodeAt(i))
      return;
    input.advance();
  }
  if (input.next >= 57 && input.next <= 65 || input.next >= 48 && input.next <= 90 || input.next == 95 || input.next >= 97 && input.next <= 122 || input.next > 160)
    return;
  input.acceptToken(TSExtends);
});
const jsHighlight = styleTags({
  "get set async static": tags$5.modifier,
  "for while do if else switch try catch finally return throw break continue default case": tags$5.controlKeyword,
  "in of await yield void typeof delete instanceof": tags$5.operatorKeyword,
  "let var const function class extends": tags$5.definitionKeyword,
  "import export from": tags$5.moduleKeyword,
  "with debugger as new": tags$5.keyword,
  TemplateString: tags$5.special(tags$5.string),
  Super: tags$5.atom,
  BooleanLiteral: tags$5.bool,
  this: tags$5.self,
  null: tags$5.null,
  Star: tags$5.modifier,
  VariableName: tags$5.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": tags$5.function(tags$5.variableName),
  VariableDefinition: tags$5.definition(tags$5.variableName),
  Label: tags$5.labelName,
  PropertyName: tags$5.propertyName,
  PrivatePropertyName: tags$5.special(tags$5.propertyName),
  "CallExpression/MemberExpression/PropertyName": tags$5.function(tags$5.propertyName),
  "FunctionDeclaration/VariableDefinition": tags$5.function(tags$5.definition(tags$5.variableName)),
  "ClassDeclaration/VariableDefinition": tags$5.definition(tags$5.className),
  PropertyDefinition: tags$5.definition(tags$5.propertyName),
  PrivatePropertyDefinition: tags$5.definition(tags$5.special(tags$5.propertyName)),
  UpdateOp: tags$5.updateOperator,
  LineComment: tags$5.lineComment,
  BlockComment: tags$5.blockComment,
  Number: tags$5.number,
  String: tags$5.string,
  ArithOp: tags$5.arithmeticOperator,
  LogicOp: tags$5.logicOperator,
  BitOp: tags$5.bitwiseOperator,
  CompareOp: tags$5.compareOperator,
  RegExp: tags$5.regexp,
  Equals: tags$5.definitionOperator,
  "Arrow : Spread": tags$5.punctuation,
  "( )": tags$5.paren,
  "[ ]": tags$5.squareBracket,
  "{ }": tags$5.brace,
  "InterpolationStart InterpolationEnd": tags$5.special(tags$5.brace),
  ".": tags$5.derefOperator,
  ", ;": tags$5.separator,
  TypeName: tags$5.typeName,
  TypeDefinition: tags$5.definition(tags$5.typeName),
  "type enum interface implements namespace module declare": tags$5.definitionKeyword,
  "abstract global Privacy readonly override": tags$5.modifier,
  "is keyof unique infer": tags$5.operatorKeyword,
  JSXAttributeValue: tags$5.attributeValue,
  JSXText: tags$5.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": tags$5.angleBracket,
  "JSXIdentifier JSXNameSpacedName": tags$5.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": tags$5.attributeName
});
const spec_identifier = { __proto__: null, export: 18, as: 23, from: 29, default: 32, async: 37, function: 38, this: 48, true: 56, false: 56, void: 66, typeof: 70, null: 86, super: 88, new: 122, await: 139, yield: 141, delete: 142, class: 152, extends: 154, public: 197, private: 197, protected: 197, readonly: 199, instanceof: 220, in: 222, const: 224, import: 256, keyof: 307, unique: 311, infer: 317, is: 351, abstract: 371, implements: 373, type: 375, let: 378, var: 380, interface: 387, enum: 391, namespace: 397, module: 399, declare: 403, global: 407, for: 428, of: 437, while: 440, with: 444, do: 448, if: 452, else: 454, switch: 458, case: 464, try: 470, catch: 474, finally: 478, return: 482, throw: 486, break: 490, continue: 494, debugger: 498 };
const spec_word = { __proto__: null, async: 109, get: 111, set: 113, public: 161, private: 161, protected: 161, static: 163, abstract: 165, override: 167, readonly: 173, new: 355 };
const spec_LessThan = { __proto__: null, "<": 129 };
const parser$d = LRParser.deserialize({
  version: 14,
  states: "$8SO`QdOOO'QQ(C|O'#ChO'XOWO'#DVO)dQdO'#D]O)tQdO'#DhO){QdO'#DrO-xQdO'#DxOOQO'#E]'#E]O.]Q`O'#E[O.bQ`O'#E[OOQ(C['#Ef'#EfO0aQ(C|O'#ItO2wQ(C|O'#IuO3eQ`O'#EzO3jQ!bO'#FaOOQ(C['#FS'#FSO3rO#tO'#FSO4QQ&jO'#FhO5bQ`O'#FgOOQ(C['#Iu'#IuOOQ(CW'#It'#ItOOQS'#J^'#J^O5gQ`O'#HpO5lQ(ChO'#HqOOQS'#Ih'#IhOOQS'#Hr'#HrQ`QdOOO){QdO'#DjO5tQ`O'#G[O5yQ&jO'#CmO6XQ`O'#EZO6dQ`O'#EgO6iQ,UO'#FRO7TQ`O'#G[O7YQ`O'#G`O7eQ`O'#G`O7sQ`O'#GcO7sQ`O'#GdO7sQ`O'#GfO5tQ`O'#GiO8dQ`O'#GlO9rQ`O'#CdO:SQ`O'#GyO:[Q`O'#HPO:[Q`O'#HRO`QdO'#HTO:[Q`O'#HVO:[Q`O'#HYO:aQ`O'#H`O:fQ(CjO'#HfO){QdO'#HhO:qQ(CjO'#HjO:|Q(CjO'#HlO5lQ(ChO'#HnO){QdO'#DWOOOW'#Ht'#HtO;XOWO,59qOOQ(C[,59q,59qO=jQtO'#ChO=tQdO'#HuO>XQ`O'#IvO@WQtO'#IvO'dQdO'#IvO@_Q`O,59wO@uQ7[O'#DbOAnQ`O'#E]OA{Q`O'#JROBWQ`O'#JQOBWQ`O'#JQOB`Q`O,5:yOBeQ`O'#JPOBlQaO'#DyO5yQ&jO'#EZOBzQ`O'#EZOCVQpO'#FROOQ(C[,5:S,5:SOC_QdO,5:SOE]Q(C|O,5:^OEyQ`O,5:dOFdQ(ChO'#JOO7YQ`O'#I}OFkQ`O'#I}OFsQ`O,5:xOFxQ`O'#I}OGWQdO,5:vOIWQ&jO'#EWOJeQ`O,5:vOKwQ&jO'#DlOLOQdO'#DqOLYQ7[O,5;PO){QdO,5;POOQS'#Er'#ErOOQS'#Et'#EtO){QdO,5;RO){QdO,5;RO){QdO,5;RO){QdO,5;RO){QdO,5;RO){QdO,5;RO){QdO,5;RO){QdO,5;RO){QdO,5;RO){QdO,5;RO){QdO,5;ROOQS'#Ex'#ExOLbQdO,5;cOOQ(C[,5;h,5;hOOQ(C[,5;i,5;iONbQ`O,5;iOOQ(C[,5;j,5;jO){QdO'#IPONgQ(ChO,5<TO! RQ&jO,5;RO){QdO,5;fO! kQ!bO'#JVO! YQ!bO'#JVO! rQ!bO'#JVO!!TQ!bO,5;qOOOO,5;{,5;{O!!cQdO'#FcOOOO'#IO'#IOO3rO#tO,5;nO!!jQ!bO'#FeOOQ(C[,5;n,5;nO!#WQ,VO'#CrOOQ(C]'#Cu'#CuO!#kQ`O'#CuO!#pOWO'#CyO!$^Q,VO,5<QO!$eQ`O,5<SO!%tQ&jO'#FrO!&RQ`O'#FsO!&WQ`O'#FsO!&]Q&jO'#FwO!'[Q7[O'#F{O!'}Q,VO'#IqOOQ(C]'#Iq'#IqO!(XQaO'#IpO!(gQ`O'#IoO!(oQ`O'#CqOOQ(C]'#Cs'#CsOOQ(C]'#C|'#C|O!(wQ`O'#DOOJjQ&jO'#FjOJjQ&jO'#FlO!(|Q`O'#FnO!)RQ`O'#FoO!&WQ`O'#FuOJjQ&jO'#FzO!)WQ`O'#E^O!)oQ`O,5<RO`QdO,5>[OOQS'#Ik'#IkOOQS,5>],5>]OOQS-E;p-E;pO!+kQ(C|O,5:UOOQ(CX'#Cp'#CpO!,[Q&kO,5<vOOQO'#Cf'#CfO!,mQ(ChO'#IlO5bQ`O'#IlO:aQ`O,59XO!-OQ!bO,59XO!-WQ&jO,59XO5yQ&jO,59XO!-cQ`O,5:vO!-kQ`O'#GxO!-yQ`O'#JbO){QdO,5;kO!.RQ7[O,5;mO!.WQ`O,5=cO!.]Q`O,5=cO!.bQ`O,5=cO5lQ(ChO,5=cO5tQ`O,5<vO!.pQ`O'#E_O!/UQ7[O'#E`OOQ(CW'#JP'#JPO!/gQ(ChO'#J_O5lQ(ChO,5<zO7sQ`O,5=QOOQP'#Cr'#CrO!/rQ!bO,5<}O!/zQ!cO,5=OO!0VQ`O,5=QO!0[QpO,5=TO:aQ`O'#GnO5tQ`O'#GpO!0dQ`O'#GpO5yQ&jO'#GsO!0iQ`O'#GsOOQS,5=W,5=WO!0nQ`O'#GtO!0vQ`O'#CmO!0{Q`O,59OO!1VQ`O,59OO!3XQdO,59OOOQS,59O,59OO!3fQ(ChO,59OO){QdO,59OO!3qQdO'#G{OOQS'#G|'#G|OOQS'#G}'#G}O`QdO,5=eO!4RQ`O,5=eO){QdO'#DxO`QdO,5=kO`QdO,5=mO!4WQ`O,5=oO`QdO,5=qO!4]Q`O,5=tO!4bQdO,5=zOOQS,5>Q,5>QO){QdO,5>QO5lQ(ChO,5>SOOQS,5>U,5>UO!8cQ`O,5>UOOQS,5>W,5>WO!8cQ`O,5>WOOQS,5>Y,5>YO!8hQpO,59rOOOW-E;r-E;rOOQ(C[1G/]1G/]O!8mQtO,5>aO'dQdO,5>aOOQO,5>f,5>fO!8wQdO'#HuOOQO-E;s-E;sO!9UQ`O,5?bO!9^QtO,5?bO!9eQ`O,5?lOOQ(C[1G/c1G/cO!9mQ!bO'#DTOOQO'#Ix'#IxO){QdO'#IxO!:[Q!bO'#IxO!:yQ!bO'#DcO!;[Q7[O'#DcO!=gQdO'#DcO!=nQ`O'#IwO!=vQ`O,59|O!={Q`O'#EaO!>ZQ`O'#JSO!>cQ`O,5:zO!>yQ7[O'#DcO){QdO,5?mO!?TQ`O'#HzOOQO-E;x-E;xO!9eQ`O,5?lOOQ(CW1G0e1G0eO!@aQ7[O'#D|OOQ(C[,5:e,5:eO){QdO,5:eOIWQ&jO,5:eO!@hQaO,5:eO:aQ`O,5:uO!-OQ!bO,5:uO!-WQ&jO,5:uO5yQ&jO,5:uOOQ(C[1G/n1G/nOOQ(C[1G0O1G0OOOQ(CW'#EV'#EVO){QdO,5?jO!@sQ(ChO,5?jO!AUQ(ChO,5?jO!A]Q`O,5?iO!AeQ`O'#H|O!A]Q`O,5?iOOQ(CW1G0d1G0dO7YQ`O,5?iOOQ(C[1G0b1G0bO!BPQ(C|O1G0bO!CRQ(CyO,5:rOOQ(C]'#Fq'#FqO!CoQ(C}O'#IqOGWQdO1G0bO!EqQ,VO'#IyO!E{Q`O,5:WO!FQQtO'#IzO){QdO'#IzO!F[Q`O,5:]OOQ(C]'#DT'#DTOOQ(C[1G0k1G0kO!FaQ`O1G0kO!HrQ(C|O1G0mO!HyQ(C|O1G0mO!K^Q(C|O1G0mO!KeQ(C|O1G0mO!MlQ(C|O1G0mO!NPQ(C|O1G0mO#!pQ(C|O1G0mO#!wQ(C|O1G0mO#%[Q(C|O1G0mO#%cQ(C|O1G0mO#'WQ(C|O1G0mO#*QQMlO'#ChO#+{QMlO1G0}O#-vQMlO'#IuOOQ(C[1G1T1G1TO#.ZQ(C|O,5>kOOQ(CW-E;}-E;}O#.zQ(C}O1G0mOOQ(C[1G0m1G0mO#1PQ(C|O1G1QO#1pQ!bO,5;sO#1uQ!bO,5;tO#1zQ!bO'#F[O#2`Q`O'#FZOOQO'#JW'#JWOOQO'#H}'#H}O#2eQ!bO1G1]OOQ(C[1G1]1G1]OOOO1G1f1G1fO#2sQMlO'#ItO#2}Q`O,5;}OLbQdO,5;}OOOO-E;|-E;|OOQ(C[1G1Y1G1YOOQ(C[,5<P,5<PO#3SQ!bO,5<POOQ(C],59a,59aOIWQ&jO'#C{OOOW'#Hs'#HsO#3XOWO,59eOOQ(C],59e,59eO){QdO1G1lO!)RQ`O'#IRO#3dQ`O,5<eOOQ(C],5<b,5<bOOQO'#GV'#GVOJjQ&jO,5<pOOQO'#GX'#GXOJjQ&jO,5<rOIWQ&jO,5<tOOQO1G1n1G1nO#3oQqO'#CpO#4SQqO,5<^O#4ZQ`O'#JZO5tQ`O'#JZO#4iQ`O,5<`OJjQ&jO,5<_O#4nQ`O'#FtO#4yQ`O,5<_O#5OQqO'#FqO#5]QqO'#J[O#5gQ`O'#J[OIWQ&jO'#J[O#5lQ`O,5<cOOQ(CW'#Dg'#DgO#5qQ!bO'#F|O!'VQ7[O'#F|O!'VQ7[O'#GOO#6SQ`O'#GPO!&WQ`O'#GSO#6XQ(ChO'#ITO#6dQ7[O,5<gOOQ(C],5<g,5<gO#6kQ7[O'#F|O#6yQ7[O'#F}O#7RQ7[O'#F}OOQ(C],5<u,5<uOJjQ&jO,5?[OJjQ&jO,5?[O#7WQ`O'#IUO#7cQ`O,5?ZO#7kQ`O,59]OOQ(C]'#Ch'#ChO#8[Q,VO,59jOOQ(C],59j,59jO#8}Q,VO,5<UO#9pQ,VO,5<WO#9zQ`O,5<YOOQ(C],5<Z,5<ZO#:PQ`O,5<aO#:UQ,VO,5<fOGWQdO1G1mO#:fQ`O1G1mOOQS1G3v1G3vOOQ(C[1G/p1G/pONbQ`O1G/pOOQS1G2b1G2bOIWQ&jO1G2bO){QdO1G2bOIWQ&jO1G2bO#:kQaO1G2bO#<QQ&jO'#EWOOQ(CW,5?W,5?WO#<[Q(ChO,5?WOOQS1G.s1G.sO:aQ`O1G.sO!-OQ!bO1G.sO!-WQ&jO1G.sO#<mQ`O1G0bO#<rQ`O'#ChO#<}Q`O'#JcO#=VQ`O,5=dO#=[Q`O'#JcO#=aQ`O'#JcO#=iQ`O'#I^O#=wQ`O,5?|O#>PQtO1G1VOOQ(C[1G1X1G1XO5tQ`O1G2}O#>WQ`O1G2}O#>]Q`O1G2}O#>bQ`O1G2}OOQS1G2}1G2}O#>gQ&kO1G2bO7YQ`O'#JQO7YQ`O'#EaO7YQ`O'#IWO#>xQ(ChO,5?yOOQS1G2f1G2fO!0VQ`O1G2lOIWQ&jO1G2iO#?TQ`O1G2iOOQS1G2j1G2jOIWQ&jO1G2jO#?YQaO1G2jO#?bQ7[O'#GhOOQS1G2l1G2lO!'VQ7[O'#IYO!0[QpO1G2oOOQS1G2o1G2oOOQS,5=Y,5=YO#?jQ&kO,5=[O5tQ`O,5=[O#6SQ`O,5=_O5bQ`O,5=_O!-OQ!bO,5=_O!-WQ&jO,5=_O5yQ&jO,5=_O#?{Q`O'#JaO#@WQ`O,5=`OOQS1G.j1G.jO#@]Q(ChO1G.jO#@hQ`O1G.jO#@mQ`O1G.jO5lQ(ChO1G.jO#@uQtO,5@OO#APQ`O,5@OO#A[QdO,5=gO#AcQ`O,5=gO7YQ`O,5@OOOQS1G3P1G3PO`QdO1G3POOQS1G3V1G3VOOQS1G3X1G3XO:[Q`O1G3ZO#AhQdO1G3]O#EcQdO'#H[OOQS1G3`1G3`O#EpQ`O'#HbO:aQ`O'#HdOOQS1G3f1G3fO#ExQdO1G3fO5lQ(ChO1G3lOOQS1G3n1G3nOOQ(CW'#Fx'#FxO5lQ(ChO1G3pO5lQ(ChO1G3rOOOW1G/^1G/^O#IvQpO,5<TO#JOQtO1G3{OOQO1G4Q1G4QO){QdO,5>aO#JYQ`O1G4|O#JbQ`O1G5WO#JjQ`O,5?dOLbQdO,5:{O7YQ`O,5:{O:aQ`O,59}OLbQdO,59}O!-OQ!bO,59}O#JoQMlO,59}OOQO,5:{,5:{O#JyQ7[O'#HvO#KaQ`O,5?cOOQ(C[1G/h1G/hO#KiQ7[O'#H{O#K}Q`O,5?nOOQ(CW1G0f1G0fO!;[Q7[O,59}O#LVQtO1G5XO7YQ`O,5>fOOQ(CW'#ES'#ESO#LaQ(DjO'#ETO!@XQ7[O'#D}OOQO'#Hy'#HyO#L{Q7[O,5:hOOQ(C[,5:h,5:hO#MSQ7[O'#D}O#MeQ7[O'#D}O#MlQ7[O'#EYO#MoQ7[O'#ETO#M|Q7[O'#ETO!@XQ7[O'#ETO#NaQ`O1G0PO#NfQqO1G0POOQ(C[1G0P1G0PO){QdO1G0POIWQ&jO1G0POOQ(C[1G0a1G0aO:aQ`O1G0aO!-OQ!bO1G0aO!-WQ&jO1G0aO#NmQ(C|O1G5UO){QdO1G5UO#N}Q(ChO1G5UO$ `Q`O1G5TO7YQ`O,5>hOOQO,5>h,5>hO$ hQ`O,5>hOOQO-E;z-E;zO$ `Q`O1G5TO$ vQ(C}O,59jO$#xQ(C}O,5<UO$%}Q(C}O,5<WO$(SQ(C}O,5<fOOQ(C[7+%|7+%|O$*_Q(C|O7+%|O$+OQ&jO'#HwO$+YQ`O,5?eOOQ(C]1G/r1G/rO$+bQdO'#HxO$+oQ`O,5?fO$+wQtO,5?fOOQ(C[1G/w1G/wOOQ(C[7+&V7+&VO$,RQMlO,5:^O){QdO7+&iO$,]QMlO,5:UOOQO1G1_1G1_OOQO1G1`1G1`O$,jQ!LQO,5;vOLbQdO,5;uOOQO-E;{-E;{OOQ(C[7+&w7+&wOOOO7+'Q7+'QOOOO1G1i1G1iO$,uQ`O1G1iOOQ(C[1G1k1G1kO$,zQqO,59gOOOW-E;q-E;qOOQ(C]1G/P1G/PO$-RQ(C|O7+'WOOQ(C],5>m,5>mO$-rQ`O,5>mOOQ(C]1G2P1G2PP$-wQ`O'#IRPOQ(C]-E<P-E<PO$.hQ,VO1G2[O$/ZQ,VO1G2^O$/eQqO1G2`OOQ(C]1G1x1G1xO$/lQ`O'#IQO$/zQ`O,5?uO$/zQ`O,5?uO$0SQ`O,5?uO$0_Q`O,5?uOOQO1G1z1G1zO$0mQ,VO1G1yOJjQ&jO1G1yO$0}Q&jO'#ISO$1_Q`O,5?vOIWQ&jO,5?vO$1gQqO,5?vOOQ(C]1G1}1G1}OOQ(CW,5<h,5<hOOQ(CW,5<i,5<iO$1qQ`O,5<iO#5}Q`O,5<iO!-OQ!bO,5<hO$1vQ`O,5<jOOQ(CW,5<k,5<kO$1qQ`O,5<nOOQO,5>o,5>oOOQO-E<R-E<ROOQ(C]1G2R1G2RO!'VQ7[O,5<hO$2OQ`O,5<iO!'VQ7[O,5<jO!'VQ7[O,5<iO$2ZQ,VO1G4vO$2eQ,VO1G4vOOQO,5>p,5>pOOQO-E<S-E<SOOQP1G.w1G.wO!.RQ7[O,59lO){QdO,59lO$2rQ`O1G1tOJjQ&jO1G1{O$2wQ(C|O7+'XOOQ(C[7+'X7+'XOGWQdO7+'XOOQ(C[7+%[7+%[O$3hQqO'#J]O#NaQ`O7+'|O$3rQ`O7+'|O$3zQqO7+'|OOQS7+'|7+'|OIWQ&jO7+'|O){QdO7+'|OIWQ&jO7+'|O$4UQ(CyO'#ChO$4iQ(CyO,5<lO$5ZQ`O,5<lOOQ(CW1G4r1G4rOOQS7+$_7+$_O:aQ`O7+$_O!-OQ!bO7+$_OGWQdO7+%|O$5`Q`O'#I]O$5qQ`O,5?}OOQO1G3O1G3OO5tQ`O,5?}O$5qQ`O,5?}O$5yQ`O,5?}OOQO,5>x,5>xOOQO-E<[-E<[OOQ(C[7+&q7+&qO$6OQ`O7+(iO5lQ(ChO7+(iO5tQ`O7+(iO$6TQ`O7+(iO$6YQaO7+'|OOQ(CW,5>r,5>rOOQ(CW-E<U-E<UOOQS7+(W7+(WO$6hQ(CyO7+(TOIWQ&jO7+(TO$6rQqO7+(UOOQS7+(U7+(UOIWQ&jO7+(UO$6yQ`O'#J`O$7UQ`O,5=SOOQO,5>t,5>tOOQO-E<W-E<WOOQS7+(Z7+(ZO$8OQ7[O'#GqOOQS1G2v1G2vOIWQ&jO1G2vO){QdO1G2vOIWQ&jO1G2vO$8VQaO1G2vO$8eQ&kO1G2vO5lQ(ChO1G2yO#6SQ`O1G2yO5bQ`O1G2yO!-OQ!bO1G2yO!-WQ&jO1G2yO$8vQ`O'#I[O$9RQ`O,5?{O$9ZQ7[O,5?{OOQ(CW1G2z1G2zOOQS7+$U7+$UO$9cQ`O7+$UO5lQ(ChO7+$UO$9hQ`O7+$UO){QdO1G5jO){QdO1G5kO$9mQdO1G3RO$9tQ`O1G3RO$9yQdO1G3RO$:QQ(ChO1G5jOOQS7+(k7+(kO5lQ(ChO7+(uO`QdO7+(wOOQS'#Jf'#JfOOQS'#I_'#I_O$:[QdO,5=vOOQS,5=v,5=vO){QdO'#H]O$:iQ`O'#H_OOQS,5=|,5=|O7YQ`O,5=|OOQS,5>O,5>OOOQS7+)Q7+)QOOQS7+)W7+)WOOQS7+)[7+)[OOQS7+)^7+)^OOQO1G5O1G5OO$:nQMlO1G0gO$:xQ`O1G0gOOQO1G/i1G/iO$;TQMlO1G/iO:aQ`O1G/iOLbQdO'#DcOOQO,5>b,5>bOOQO-E;t-E;tOOQO,5>g,5>gOOQO-E;y-E;yO!-OQ!bO1G/iO:aQ`O,5:iOOQO,5:o,5:oO){QdO,5:oO$;_Q(ChO,5:oO$;jQ(ChO,5:oO!-OQ!bO,5:iOOQO-E;w-E;wOOQ(C[1G0S1G0SO!@XQ7[O,5:iO$;xQ7[O,5:iO$<ZQ(DjO,5:oO$<uQ7[O,5:iO!@XQ7[O,5:oOOQO,5:t,5:tO$<|Q7[O,5:oO$=ZQ(ChO,5:oOOQ(C[7+%k7+%kO#NaQ`O7+%kO#NfQqO7+%kOOQ(C[7+%{7+%{O:aQ`O7+%{O!-OQ!bO7+%{O$=oQ(C|O7+*pO){QdO7+*pOOQO1G4S1G4SO7YQ`O1G4SO$>PQ`O7+*oO$>XQ(C}O1G2[O$@^Q(C}O1G2^O$BcQ(C}O1G1yO$DnQ,VO,5>cOOQO-E;u-E;uO$DxQtO,5>dO){QdO,5>dOOQO-E;v-E;vO$ESQ`O1G5QO$E[QMlO1G0bO$GcQMlO1G0mO$GjQMlO1G0mO$IkQMlO1G0mO$IrQMlO1G0mO$KgQMlO1G0mO$KzQMlO1G0mO$NXQMlO1G0mO$N`QMlO1G0mO%!aQMlO1G0mO%!hQMlO1G0mO%$]QMlO1G0mO%$pQ(C|O<<JTO%%rQMmO1G0mO%'|QMmO'#IqO%)iQMlO1G1QOLbQdO'#F^OOQO'#JX'#JXOOQO1G1b1G1bO%)vQ`O1G1aO%){QMlO,5>kOOOO7+'T7+'TOOOW1G/R1G/ROOQ(C]1G4X1G4XOJjQ&jO7+'zO%*VQ`O,5>lO5tQ`O,5>lOOQO-E<O-E<OO%*eQ`O1G5aO%*eQ`O1G5aO%*mQ`O1G5aO%*xQ,VO7+'eO%+YQqO,5>nO%+dQ`O,5>nOIWQ&jO,5>nOOQO-E<Q-E<QO%+iQqO1G5bO%+sQ`O1G5bOOQ(CW1G2T1G2TO$1qQ`O1G2TOOQ(CW1G2S1G2SO%+{Q`O1G2UOIWQ&jO1G2UOOQ(CW1G2Y1G2YO!-OQ!bO1G2SO#5}Q`O1G2TO%,QQ`O1G2UO%,YQ`O1G2TOJjQ&jO7+*bOOQ(C]1G/W1G/WO%,eQ`O1G/WOOQ(C]7+'`7+'`O%,jQ,VO7+'gO%,zQ(C|O<<JsOOQ(C[<<Js<<JsOIWQ&jO'#IVO%-kQ`O,5?wOOQS<<Kh<<KhOIWQ&jO<<KhO#NaQ`O<<KhO%-sQ`O<<KhO%-{QqO<<KhOIWQ&jO1G2WOOQS<<Gy<<GyO:aQ`O<<GyO%.VQ(C|O<<IhOOQ(C[<<Ih<<IhOOQO,5>w,5>wO%.vQ`O,5>wO%.{Q`O,5>wOOQO-E<Z-E<ZO%/TQ`O1G5iO%/TQ`O1G5iO5tQ`O1G5iO%/]Q`O<<LTOOQS<<LT<<LTO%/bQ`O<<LTO5lQ(ChO<<LTO){QdO<<KhOIWQ&jO<<KhOOQS<<Ko<<KoO$6hQ(CyO<<KoOOQS<<Kp<<KpO$6rQqO<<KpO%/gQ7[O'#IXO%/rQ`O,5?zOLbQdO,5?zOOQS1G2n1G2nO#LaQ(DjO'#ETO!@XQ7[O'#GrOOQO'#IZ'#IZO%/zQ7[O,5=]OOQS,5=],5=]O%0RQ7[O'#ETO%0^Q7[O'#ETO%0uQ7[O'#ETO%1PQ7[O'#GrO%1bQ`O7+(bO%1gQ`O7+(bO%1oQqO7+(bOOQS7+(b7+(bOIWQ&jO7+(bO){QdO7+(bOIWQ&jO7+(bO%1yQaO7+(bOOQS7+(e7+(eO5lQ(ChO7+(eO#6SQ`O7+(eO5bQ`O7+(eO!-OQ!bO7+(eO%2XQ`O,5>vOOQO-E<Y-E<YOOQO'#Gu'#GuO%2dQ`O1G5gO5lQ(ChO<<GpOOQS<<Gp<<GpO%2lQ`O<<GpO%2qQ`O7++UO%2vQ`O7++VOOQS7+(m7+(mO%2{Q`O7+(mO%3QQdO7+(mO%3XQ`O7+(mO){QdO7++UO){QdO7++VOOQS<<La<<LaOOQS<<Lc<<LcOOQS-E<]-E<]OOQS1G3b1G3bO%3^Q`O,5=wOOQS,5=y,5=yO%3cQ`O1G3hOLbQdO7+&ROOQO7+%T7+%TO%3hQMlO1G5XO:aQ`O7+%TOOQO1G0T1G0TO%3rQ(C|O1G0ZOOQO1G0Z1G0ZO){QdO1G0ZO%3|Q(ChO1G0ZO:aQ`O1G0TO!-OQ!bO1G0TO!@XQ7[O1G0TO%4XQ(ChO1G0ZO%4gQ7[O1G0TO%4xQ(ChO1G0ZO%5^Q(DjO1G0ZO%5hQ7[O1G0TO!@XQ7[O1G0ZOOQ(C[<<IV<<IVOOQ(C[<<Ig<<IgO:aQ`O<<IgO%5oQ(C|O<<N[OOQO7+)n7+)nO%6PQ(C}O7+'eO%8[Q(C}O7+'gO%:gQtO1G4OO%:qQMlO7+%|O%;gQMmO,59jO%=hQMmO,5<UO%?lQMmO,5<WO%A[QMmO,5<fO%B}QMlO7+'WO%C[QMlO7+'XO%CiQ`O,5;xOOQO7+&{7+&{O%CnQ,VO<<KfOOQO1G4W1G4WO%CuQ`O1G4WO%DQQ`O1G4WO%D`Q`O7+*{O%D`Q`O7+*{OIWQ&jO1G4YO%DhQqO1G4YO%DrQ`O7+*|OOQ(CW7+'o7+'oO$1qQ`O7+'pO%DzQqO7+'pOOQ(CW7+'n7+'nO$1qQ`O7+'oO%ERQ`O7+'pOIWQ&jO7+'pO#5}Q`O7+'oO%EWQ,VO<<M|OOQ(C]7+$r7+$rO%EbQqO,5>qOOQO-E<T-E<TO#NaQ`OANASOOQSANASANASOIWQ&jOANASO%ElQ(CyO7+'rOOQSAN=eAN=eO5tQ`O1G4cOOQO1G4c1G4cO%E|Q`O1G4cO%FRQ`O7++TO%FRQ`O7++TO5lQ(ChOANAoO%FZQ`OANAoOOQSANAoANAoO%F`Q`OANASO%FhQqOANASOOQSANAZANAZOOQSANA[ANA[O%FrQ`O,5>sOOQO-E<V-E<VO%F}QMlO1G5fO#6SQ`O,5=^O5bQ`O,5=^O!-OQ!bO,5=^OOQO-E<X-E<XOOQS1G2w1G2wO$<ZQ(DjO,5:oO!@XQ7[O,5=^O%GXQ7[O,5=^O%GjQ7[O,5:oOOQS<<K|<<K|OIWQ&jO<<K|O%1bQ`O<<K|O%GtQ`O<<K|O%G|QqO<<K|O){QdO<<K|OIWQ&jO<<K|OOQS<<LP<<LPO5lQ(ChO<<LPO#6SQ`O<<LPO5bQ`O<<LPO%HWQ7[O1G4bO%H`Q`O7++ROOQSAN=[AN=[O5lQ(ChOAN=[OOQS<<Np<<NpOOQS<<Nq<<NqOOQS<<LX<<LXO%HhQ`O<<LXO%HmQdO<<LXO%HtQ`O<<NpO%HyQ`O<<NqOOQS1G3c1G3cO:aQ`O7+)SO%IOQMlO<<ImOOQO<<Ho<<HoOOQO7+%u7+%uO%3rQ(C|O7+%uO){QdO7+%uOOQO7+%o7+%oO:aQ`O7+%oO!-OQ!bO7+%oO%IYQ(ChO7+%uO!@XQ7[O7+%oO%IeQ(ChO7+%uO%IsQ7[O7+%oO%JUQ(ChO7+%uOOQ(C[AN?RAN?RO%JjQMlO<<JTO%JwQMmO1G1yO%MOQMmO1G2[O& SQMmO1G2^O&!rQMlO<<JsO&#PQMlO<<IhOOQO1G1d1G1dOJjQ&jOANAQOOQO7+)r7+)rO&#^Q`O7+)rO&#iQ`O<<NgO&#qQqO7+)tOOQ(CW<<K[<<K[O$1qQ`O<<K[OOQ(CW<<KZ<<KZO&#{QqO<<K[O$1qQ`O<<KZOOQSG26nG26nO#NaQ`OG26nOOQO7+)}7+)}O5tQ`O7+)}O&$SQ`O<<NoOOQSG27ZG27ZO5lQ(ChOG27ZOIWQ&jOG26nOLbQdO1G4_O&$[Q`O7++QO5lQ(ChO1G2xO#6SQ`O1G2xO5bQ`O1G2xO!-OQ!bO1G2xO!@XQ7[O1G2xO%5^Q(DjO1G0ZO&$dQ7[O1G2xO%1bQ`OANAhOOQSANAhANAhOIWQ&jOANAhO&$uQ`OANAhO&$}QqOANAhOOQSANAkANAkO5lQ(ChOANAkO#6SQ`OANAkOOQO'#Gv'#GvOOQO7+)|7+)|OOQSG22vG22vOOQSANAsANAsO&%XQ`OANAsOOQSAND[AND[OOQSAND]AND]OOQS<<Ln<<LnOOQO<<Ia<<IaO%3rQ(C|O<<IaOOQO<<IZ<<IZO:aQ`O<<IZO){QdO<<IaO!-OQ!bO<<IZO&%^Q(ChO<<IaO!@XQ7[O<<IZO&%iQ(ChO<<IaO&%wQMmO7+'eO&'jQMmO7+'gO&)]Q,VOG26lOOQO<<M^<<M^OOQ(CWAN@vAN@vO$1qQ`OAN@vOOQ(CWAN@uAN@uOOQSLD,YLD,YOOQO<<Mi<<MiOOQSLD,uLD,uO#NaQ`OLD,YO&)mQMlO7+)yOOQO7+(d7+(dO5lQ(ChO7+(dO#6SQ`O7+(dO5bQ`O7+(dO!-OQ!bO7+(dO!@XQ7[O7+(dOOQSG27SG27SO%1bQ`OG27SOIWQ&jOG27SOOQSG27VG27VO5lQ(ChOG27VOOQSG27_G27_OOQOAN>{AN>{OOQOAN>uAN>uO%3rQ(C|OAN>{O:aQ`OAN>uO){QdOAN>{O!-OQ!bOAN>uO&)wQ(ChOAN>{O&*SQ(C}OG26lOOQ(CWG26bG26bOOQS!$( t!$( tOOQO<<LO<<LOO5lQ(ChO<<LOO#6SQ`O<<LOO5bQ`O<<LOO!-OQ!bO<<LOOOQSLD,nLD,nO%1bQ`OLD,nOOQSLD,qLD,qOOQOG24gG24gOOQOG24aG24aO%3rQ(C|OG24gO:aQ`OG24aO){QdOG24gO&,pQ!LRO,5:rO&-gQ$ITO'#IqOOQOANAjANAjO5lQ(ChOANAjO#6SQ`OANAjO5bQ`OANAjOOQS!$(!Y!$(!YOOQOLD*RLD*ROOQOLD){LD){O%3rQ(C|OLD*RO&.ZQMmOG26lO&/|Q!LRO,59jO&0pQ!LRO,5<UO&1dQ!LRO,5<WO&2WQ!LRO,5<fOOQOG27UG27UO5lQ(ChOG27UO#6SQ`OG27UOOQO!$'Mm!$'MmO&2}Q!LRO1G2[O&3qQ!LRO1G2^O&4eQ!LRO1G1yOOQOLD,pLD,pO5lQ(ChOLD,pO&5[Q!LRO7+'eO&6RQ!LRO7+'gOOQO!$(![!$(![O&6xQ!LROG26lOLbQdO'#DrO&7oQtO'#ItOLbQdO'#DjO&7vQ(C|O'#ChO&8aQtO'#ChO&8qQdO,5:vO&:qQ&jO'#EWOLbQdO,5;ROLbQdO,5;ROLbQdO,5;ROLbQdO,5;ROLbQdO,5;ROLbQdO,5;ROLbQdO,5;ROLbQdO,5;ROLbQdO,5;ROLbQdO,5;ROLbQdO,5;ROLbQdO'#IPO&<OQ`O,5<TO&=eQ&jO,5;ROLbQdO,5;fO!(wQ`O'#DOO!(wQ`O'#DOO!(wQ`O'#DOOIWQ&jO'#FjO&:qQ&jO'#FjO&<WQ&jO'#FjOIWQ&jO'#FlO&:qQ&jO'#FlO&<WQ&jO'#FlOIWQ&jO'#FzO&:qQ&jO'#FzO&<WQ&jO'#FzOLbQdO,5?mO&8qQdO1G0bO&=lQMlO'#ChOLbQdO1G1lOIWQ&jO,5<pO&:qQ&jO,5<pO&<WQ&jO,5<pOIWQ&jO,5<rO&:qQ&jO,5<rO&<WQ&jO,5<rOIWQ&jO,5<_O&:qQ&jO,5<_O&<WQ&jO,5<_O&8qQdO1G1mOLbQdO7+&iOIWQ&jO1G1yO&:qQ&jO1G1yO&<WQ&jO1G1yOIWQ&jO1G1{O&:qQ&jO1G1{O&<WQ&jO1G1{O&8qQdO7+'XO&8qQdO7+%|O&=vQ`O7+'pOIWQ&jOANAQO&:qQ&jOANAQO&<WQ&jOANAQO&=vQ`O<<K[O&=vQ`OAN@vO&={Q`O'#E[O&>QQ`O'#E[O&>YQ`O'#EzO&>_Q`O'#EgO&>dQ`O'#JRO&>oQ`O'#JPO&>zQ`O,5:vO&?PQ,VO,5<QO&?WQ`O'#FsO&?]Q`O'#FsO&?bQ`O'#FsO&?gQ`O,5<RO&?oQ`O,5:vO&?wQMlO1G0}O&@OQ`O,5<_O&@TQ`O,5<_O&@YQ`O,5<_O&@_Q`O,5<aO&@dQ`O,5<aO&@iQ`O,5<aO&@nQ`O1G1mO&@sQ`O1G0bO&@xQ`O1G2UO&@}Q,VO<<KfO&AUQ,VO<<KfO&A]Q,VO<<KfO&AdQqO7+'pO&AkQ`O7+'pO&ApQqO<<K[O4QQ&jO'#FhO5bQ`O'#FgOBzQ`O'#EZOLbQdO,5;cO!&WQ`O'#FsO!&WQ`O'#FsO!&WQ`O'#FsO!&WQ`O'#FuO!&WQ`O'#FuO!&WQ`O'#FuO&AwQ`O,5<jOJjQ&jO7+'zOJjQ&jO7+'zOJjQ&jO7+'zOIWQ&jO1G2UO&BPQ`O1G2UOIWQ&jO7+'pO!'VQ7[O'#GOO$/eQqO1G2`O$/eQqO1G2`O$/eQqO1G2`O!'VQ7[O,5<jOIWQ&jO,5<tOIWQ&jO,5<tOIWQ&jO,5<t",
  stateData: "&B}~O'YOS'ZOSTOSUOS~OQTORTOXyO]cO_hObnOcmOhcOjTOkcOlcOqTOsTOxRO{cO|cO}cO!TSO!_kO!dUO!gTO!hTO!iTO!jTO!kTO!nlO#dsO#tpO#x^O%PqO%RtO%TrO%UrO%XuO%ZvO%^wO%_wO%axO%nzO%t{O%v|O%x}O%z!OO%}!PO&T!QO&Z!RO&]!SO&_!TO&a!UO&c!VO']PO'fQO'oYO'|aO~OQ[XZ[X_[Xj[Xu[Xv[Xx[X!R[X!a[X!b[X!d[X!j[X!{[X#WdX#[[X#][X#^[X#_[X#`[X#a[X#b[X#c[X#e[X#g[X#i[X#j[X#o[X'W[X'f[X'p[X'w[X'x[X~O!]$lX~P$zOS!WO'U!XO'V!ZO~OQTORTO]cOb!kOc!jOhcOjTOkcOlcOqTOsTOxRO{cO|cO}cO!T!bO!_kO!dUO!gTO!hTO!iTO!jTO!kTO!n!iO#t!lO#x^O']![O'fQO'oYO'|aO~O!Q!`O!R!]O!O'jP!O'tP~P'dO!S!mO~P`OQTORTO]cOb!kOc!jOhcOjTOkcOlcOqTOsTOxRO{cO|cO}cO!T!bO!_kO!dUO!gTO!hTO!iTO!jTO!kTO!n!iO#t!lO#x^O']9aO'fQO'oYO'|aO~OQTORTO]cOb!kOc!jOhcOjTOkcOlcOqTOsTOxRO{cO|cO}cO!T!bO!_kO!dUO!gTO!hTO!iTO!jTO!kTO!n!iO#t!lO#x^O'fQO'oYO'|aO~O!Q!rO#U!uO#V!rO']9bO!c'qP~P+{O#W!vO~O!]!wO#W!vO~OQ#^OZ#dOj#ROu!{Ov!{Ox!|O!R#bO!a#TO!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO#`#SO#a#TO#b#TO#c#TO#e#UO#g#WO#i#YO#j#ZO'fQO'p#[O'w!}O'x#OO~O_'hX'W'hX!c'hX!O'hX!T'hX%Q'hX!]'hX~P.jO!{#eO#o#eOQ'iXZ'iX_'iXj'iXu'iXv'iXx'iX!R'iX!a'iX!b'iX!d'iX!j'iX#['iX#]'iX#^'iX#_'iX#`'iX#a'iX#b'iX#e'iX#g'iX#i'iX#j'iX'f'iX'p'iX'w'iX'x'iX~O#c'iX'W'iX!O'iX!c'iXn'iX!T'iX%Q'iX!]'iX~P0zO!{#eO~O#z#fO$R#jO~O!T#kO#x^O$U#lO$W#nO~O]#qOh$QOj#rOk#qOl#qOq$ROs$SOx#yO!T#zO!_$XO!d#vO#V$YO#t$VO$_$TO$a$UO$d$WO']#pO'b$PO'f#sO'a'cP~O!d$ZO~O!]$]O~O_$^O'W$^O~O']$bO~O!d$ZO']$bO'^$dO'b$PO~Oc$jO!d$ZO']$bO~O#c#TO~O]$sOu$oO!T$lO!d$nO%R$rO']$bO'^$dO^(UP~O!n$tO~Ox$uO!T$vO']$bO~Ox$uO!T$vO%Z$zO']$bO~O']${O~O#dsO%RtO%TrO%UrO%XuO%ZvO%^wO%_wO~Ob%UOc%TO!n%RO%P%SO%c%QO~P7xOb%XOcmO!T%WO!nlO#dsO%PqO%TrO%UrO%XuO%ZvO%^wO%_wO%axO~O`%[O!{%_O%R%YO'^$dO~P8wO!d%`O!g%dO~O!d%eO~O!TSO~O_$^O'T%mO'W$^O~O_$^O'T%pO'W$^O~O_$^O'T%rO'W$^O~OS!WO'U!XO'V%vO~OQ[XZ[Xj[Xu[Xv[Xx[X!R[X!RdX!a[X!b[X!d[X!j[X!{[X!{dX#WdX#[[X#][X#^[X#_[X#`[X#a[X#b[X#c[X#e[X#g[X#i[X#j[X#o[X'f[X'p[X'w[X'x[X~O!O[X!OdX~P;dO!Q%xO!O&iX!O&nX!R&iX!R&nX~P'dO!R%zO!O'jX~OQ#^OZ#dOj#ROu!{Ov!{Ox!|O!R%zO!a#TO!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO#`#SO#a#TO#b#TO#c#TO#e#UO#g#WO#i#YO#j#ZO'fQO'p#[O'w!}O'x#OO~O!O'jX~P>aO!O&PO~Ox&SO!W&^O!X&VO!Y&VO'^$dO~O]&TOk&TO!Q&WO'g&QO!S'kP!S'vP~P@dO!O'sX!R'sX!]'sX!c'sX'p'sX~O!{'sX#W#PX!S'sX~PA]O!{&_O!O'uX!R'uX~O!R&`O!O'tX~O!O&cO~O!{#eO~PA]OP&gO!T&dO!o&fO']$bO~Oc&lO!d$ZO']$bO~Ou$oO!d$nO~O!S&mO~P`Ou!{Ov!{Ox!|O!b!yO!d!zO'fQOQ!faZ!faj!fa!R!fa!a!fa!j!fa#[!fa#]!fa#^!fa#_!fa#`!fa#a!fa#b!fa#c!fa#e!fa#g!fa#i!fa#j!fa'p!fa'w!fa'x!fa~O_!fa'W!fa!O!fa!c!fan!fa!T!fa%Q!fa!]!fa~PCfO!c&nO~O!]!wO!{&pO'p&oO!R'rX_'rX'W'rX~O!c'rX~PFOO!R&tO!c'qX~O!c&vO~Ox$uO!T$vO#V&wO']$bO~OQTORTO]cOb!kOc!jOhcOjTOkcOlcOqTOsTOxRO{cO|cO}cO!TSO!_kO!dUO!gTO!hTO!iTO!jTO!kTO!n!iO#t!lO#x^O']9aO'fQO'oYO'|aO~O]#qOh$QOj#rOk#qOl#qOq$ROs9tOx#yO!T#zO!_;eO!d#vO#V9}O#t$VO$_9wO$a9zO$d$WO']&{O'b$PO'f#sO~O#W&}O~O]#qOh$QOj#rOk#qOl#qOq$ROs$SOx#yO!T#zO!_$XO!d#vO#V$YO#t$VO$_$TO$a$UO$d$WO']&{O'b$PO'f#sO~O'a'mP~PJjO!Q'RO!c'nP~P){O'g'TO'oYO~OQ9^OR9^O]cOb;`Oc!jOhcOj9^OkcOlcOq9^Os9^OxRO{cO|cO}cO!T!bO!_9`O!dUO!g9^O!h9^O!i9^O!j9^O!k9^O!n!iO#t!lO#x^O']'cO'fQO'oYO'|;^O~O!d!zO~O!R#bO_$]a'W$]a!c$]a!O$]a!T$]a%Q$]a!]$]a~O#d'jO~PIWO!]'lO!T'yX#w'yX#z'yX$R'yX~Ou'mO~P! YOu'mO!T'yX#w'yX#z'yX$R'yX~O!T'oO#w'sO#z'nO$R'tO~O!Q'wO~PLbO#z#fO$R'zO~OP$eXu$eXx$eX!b$eX'w$eX'x$eX~OPfX!RfX!{fX'afX'a$eX~P!!rOk'|O~OS'}O'U(OO'V(QO~OP(ZOu(SOx(TO'w(VO'x(XO~O'a(RO~P!#{O'a([O~O]#qOh$QOj#rOk#qOl#qOq$ROs9tOx#yO!T#zO!_;eO!d#vO#V9}O#t$VO$_9wO$a9zO$d$WO'b$PO'f#sO~O!Q(`O'](]O!c'}P~P!$jO#W(bO~O!d(cO~O!Q(hO'](eO!O(OP~P!$jOj(uOx(mO!W(sO!X(lO!Y(lO!d(cO!x(tO$w(oO'^$dO'g(jO~O!S(rO~P!&jO!b!yOP'eXu'eXx'eX'w'eX'x'eX!R'eX!{'eX~O'a'eX#m'eX~P!'cOP(xO!{(wO!R'dX'a'dX~O!R(yO'a'cX~O']${O'a'cP~O'](|O~O!d)RO~O']&{O~Ox$uO!Q!rO!T$vO#U!uO#V!rO']$bO!c'qP~O!]!wO#W)VO~OQ#^OZ#dOj#ROu!{Ov!{Ox!|O!a#TO!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO#`#SO#a#TO#b#TO#c#TO#e#UO#g#WO#i#YO#j#ZO'fQO'p#[O'w!}O'x#OO~O_!^a!R!^a'W!^a!O!^a!c!^an!^a!T!^a%Q!^a!]!^a~P!)wOP)_O!T&dO!o)^O%Q)]O'b$PO~O!])aO!T'`X_'`X!R'`X'W'`X~O!d$ZO'b$PO~O!d$ZO']$bO'b$PO~O!]!wO#W&}O~O])lO%R)mO'])iO!S(VP~O!R)nO^(UX~O'g'TO~OZ)rO~O^)sO~O!T$lO']$bO'^$dO^(UP~Ox$uO!Q)xO!R&`O!T$vO']$bO!O'tP~O]&ZOk&ZO!Q)yO'g'TO!S'vP~O!R)zO_(RX'W(RX~O!{*OO'b$PO~OP*RO!T#zO'b$PO~O!T*TO~Ou*VO!TSO~O!n*[O~Oc*aO~O'](|O!S(TP~Oc$jO~O%RtO']${O~P8wOZ*gO^*fO~OQTORTO]cObnOcmOhcOjTOkcOlcOqTOsTOxRO{cO|cO}cO!_kO!dUO!gTO!hTO!iTO!jTO!kTO!nlO#x^O%PqO'fQO'oYO'|aO~O!T!bO#t!lO']9aO~P!1_O^*fO_$^O'W$^O~O_*kO#d*mO%T*mO%U*mO~P){O!d%`O~O%t*rO~O!T*tO~O&V*vO&X*wOQ&SaR&SaX&Sa]&Sa_&Sab&Sac&Sah&Saj&Sak&Sal&Saq&Sas&Sax&Sa{&Sa|&Sa}&Sa!T&Sa!_&Sa!d&Sa!g&Sa!h&Sa!i&Sa!j&Sa!k&Sa!n&Sa#d&Sa#t&Sa#x&Sa%P&Sa%R&Sa%T&Sa%U&Sa%X&Sa%Z&Sa%^&Sa%_&Sa%a&Sa%n&Sa%t&Sa%v&Sa%x&Sa%z&Sa%}&Sa&T&Sa&Z&Sa&]&Sa&_&Sa&a&Sa&c&Sa'S&Sa']&Sa'f&Sa'o&Sa'|&Sa!S&Sa%{&Sa`&Sa&Q&Sa~O']*|O~On+PO~O!O&ia!R&ia~P!)wO!Q+TO!O&iX!R&iX~P){O!R%zO!O'ja~O!O'ja~P>aO!R&`O!O'ta~O!RwX!R!ZX!SwX!S!ZX!]wX!]!ZX!d!ZX!{wX'b!ZX~O!]+YO!{+XO!R#TX!R'lX!S#TX!S'lX!]'lX!d'lX'b'lX~O!]+[O!d$ZO'b$PO!R!VX!S!VX~O]&ROk&ROx&SO'g(jO~OQ9^OR9^O]cOb;`Oc!jOhcOj9^OkcOlcOq9^Os9^OxRO{cO|cO}cO!T!bO!_9`O!dUO!g9^O!h9^O!i9^O!j9^O!k9^O!n!iO#t!lO#x^O'fQO'oYO'|;^O~O']:SO~P!;jO!R+`O!S'kX~O!S+bO~O!]+YO!{+XO!R#TX!S#TX~O!R+cO!S'vX~O!S+eO~O]&ROk&ROx&SO'^$dO'g(jO~O!X+fO!Y+fO~P!>hOx$uO!Q+hO!T$vO']$bO!O&nX!R&nX~O_+lO!W+oO!X+kO!Y+kO!r+sO!s+qO!t+rO!u+pO!x+tO'^$dO'g(jO'o+iO~O!S+nO~P!?iOP+yO!T&dO!o+xO~O!{,PO!R'ra!c'ra_'ra'W'ra~O!]!wO~P!@sO!R&tO!c'qa~Ox$uO!Q,SO!T$vO#U,UO#V,SO']$bO!R&pX!c&pX~O_#Oi!R#Oi'W#Oi!O#Oi!c#Oin#Oi!T#Oi%Q#Oi!]#Oi~P!)wOP;tOu(SOx(TO'w(VO'x(XO~O#W!za!R!za!c!za!{!za!T!za_!za'W!za!O!za~P!BpO#W'eXQ'eXZ'eX_'eXj'eXv'eX!a'eX!d'eX!j'eX#['eX#]'eX#^'eX#_'eX#`'eX#a'eX#b'eX#c'eX#e'eX#g'eX#i'eX#j'eX'W'eX'f'eX'p'eX!c'eX!O'eX!T'eXn'eX%Q'eX!]'eX~P!'cO!R,_O'a'mX~P!#{O'a,aO~O!R,bO!c'nX~P!)wO!c,eO~O!O,fO~OQ#^Ou!{Ov!{Ox!|O!b!yO!d!zO!j#^O'fQOZ#Zi_#Zij#Zi!R#Zi!a#Zi#]#Zi#^#Zi#_#Zi#`#Zi#a#Zi#b#Zi#c#Zi#e#Zi#g#Zi#i#Zi#j#Zi'W#Zi'p#Zi'w#Zi'x#Zi!O#Zi!c#Zin#Zi!T#Zi%Q#Zi!]#Zi~O#[#Zi~P!FfO#[#PO~P!FfOQ#^Ou!{Ov!{Ox!|O!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO'fQOZ#Zi_#Zi!R#Zi!a#Zi#`#Zi#a#Zi#b#Zi#c#Zi#e#Zi#g#Zi#i#Zi#j#Zi'W#Zi'p#Zi'w#Zi'x#Zi!O#Zi!c#Zin#Zi!T#Zi%Q#Zi!]#Zi~Oj#Zi~P!IQOj#RO~P!IQOQ#^Oj#ROu!{Ov!{Ox!|O!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO#`#SO'fQO_#Zi!R#Zi#e#Zi#g#Zi#i#Zi#j#Zi'W#Zi'p#Zi'w#Zi'x#Zi!O#Zi!c#Zin#Zi!T#Zi%Q#Zi!]#Zi~OZ#Zi!a#Zi#a#Zi#b#Zi#c#Zi~P!KlOZ#dO!a#TO#a#TO#b#TO#c#TO~P!KlOQ#^OZ#dOj#ROu!{Ov!{Ox!|O!a#TO!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO#`#SO#a#TO#b#TO#c#TO#e#UO'fQO_#Zi!R#Zi#g#Zi#i#Zi#j#Zi'W#Zi'p#Zi'x#Zi!O#Zi!c#Zin#Zi!T#Zi%Q#Zi!]#Zi~O'w#Zi~P!NdO'w!}O~P!NdOQ#^OZ#dOj#ROu!{Ov!{Ox!|O!a#TO!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO#`#SO#a#TO#b#TO#c#TO#e#UO#g#WO'fQO'w!}O_#Zi!R#Zi#i#Zi#j#Zi'W#Zi'p#Zi!O#Zi!c#Zin#Zi!T#Zi%Q#Zi!]#Zi~O'x#Zi~P##OO'x#OO~P##OOQ#^OZ#dOj#ROu!{Ov!{Ox!|O!a#TO!b!yO!d!zO!j#^O#[#PO#]#QO#^#QO#_#QO#`#SO#a#TO#b#TO#c#TO#e#UO#g#WO#i#YO'fQO'w!}O'x#OO~O_#Zi!R#Zi#j#Zi'W#Zi'p#Zi!O#Zi!c#Zin#Zi!T#Zi%Q#Zi!]#Zi~P#%jOQ[XZ[Xj[Xu[Xv[Xx[X!a[X!b[X!d[X!j[X!{[X#WdX#[[X#][X#^[X#_[X#`[X#a[X#b[X#c[X#e[X#g[X#i[X#j[X#o[X'f[X'p[X'w[X'x[X!R[X!S[X~O#m[X~P#'}OQ#^OZ9rOj9gOu!{Ov!{Ox!|O!a9iO!b!yO!d!zO!j#^O#[9eO#]9fO#^9fO#_9fO#`9hO#a9iO#b9iO#c9iO#e9jO#g9lO#i9nO#j9oO'fQO'p#[O'w!}O'x#OO~O#m,hO~P#*XOQ'iXZ'iXj'iXu'iXv'iXx'iX!a'iX!b'iX!d'iX!j'iX#['iX#]'iX#^'iX#_'iX#`'iX#a'iX#b'iX#e'iX#g'iX#i'iX#j'iX'f'iX'p'iX'w'iX'x'iX!R'iX~O!{9sO#o9sO#c'iX#m'iX!S'iX~P#,SO_&sa!R&sa'W&sa!c&san&sa!O&sa!T&sa%Q&sa!]&sa~P!)wOQ#ZiZ#Zi_#Zij#Ziv#Zi!R#Zi!a#Zi!b#Zi!d#Zi!j#Zi#[#Zi#]#Zi#^#Zi#_#Zi#`#Zi#a#Zi#b#Zi#c#Zi#e#Zi#g#Zi#i#Zi#j#Zi'W#Zi'f#Zi'p#Zi!O#Zi!c#Zin#Zi!T#Zi%Q#Zi!]#Zi~P!BpO_#ni!R#ni'W#ni!O#ni!c#nin#ni!T#ni%Q#ni!]#ni~P!)wO#z,jO~O#z,kO~O!]'lO!{,lO!T$OX#w$OX#z$OX$R$OX~O!Q,mO~O!T'oO#w,oO#z'nO$R,pO~O!R9pO!S'hX~P#*XO!S,qO~O$R,sO~OS'}O'U(OO'V,vO~O],yOk,yO!O,zO~O!RdX!]dX!cdX!c$eX'pdX~P!!rO!c-QO~P!BpO!R-RO!]!wO'p&oO!c'}X~O!c-WO~O!Q(`O']$bO!c'}P~O#W-YO~O!O$eX!R$eX!]$lX~P!!rO!R-ZO!O(OX~P!BpO!]-]O~O!O-_O~Oj-cO!]!wO!d$ZO'b$PO'p&oO~O!])aO~O_$^O!R-hO'W$^O~O!S-jO~P!&jO!X-kO!Y-kO'^$dO'g(jO~Ox-mO'g(jO~O!x-nO~O']${O!R&xX'a&xX~O!R(yO'a'ca~O'a-sO~Ou-tOv-tOx-uOPra'wra'xra!Rra!{ra~O'ara#mra~P#7pOu(SOx(TOP$^a'w$^a'x$^a!R$^a!{$^a~O'a$^a#m$^a~P#8fOu(SOx(TOP$`a'w$`a'x$`a!R$`a!{$`a~O'a$`a#m$`a~P#9XO]-vO~O#W-wO~O'a$na!R$na!{$na#m$na~P!#{O#W-zO~OP.TO!T&dO!o.SO%Q.RO~O]#qOj#rOk#qOl#qOq$ROs9tOx#yO!T#zO!_;eO!d#vO#V9}O#t$VO$_9wO$a9zO$d$WO'b$PO'f#sO~Oh.VO'].UO~P#:yO!])aO!T'`a_'`a!R'`a'W'`a~O#W.]O~OZ[X!RdX!SdX~O!R.^O!S(VX~O!S.`O~OZ.aO~O].cO'])iO~O!T$lO']$bO^'QX!R'QX~O!R)nO^(Ua~O!c.fO~P!)wO].hO~OZ.iO~O^.jO~OP.TO!T&dO!o.SO%Q.RO'b$PO~O!R)zO_(Ra'W(Ra~O!{.pO~OP.sO!T#zO~O'g'TO!S(SP~OP.}O!T.yO!o.|O%Q.{O'b$PO~OZ/XO!R/VO!S(TX~O!S/YO~O^/[O_$^O'W$^O~O]/]O~O]/^O'](|O~O#c/_O%r/`O~P0zO!{#eO#c/_O%r/`O~O_/aO~P){O_/cO~O%{/gOQ%yiR%yiX%yi]%yi_%yib%yic%yih%yij%yik%yil%yiq%yis%yix%yi{%yi|%yi}%yi!T%yi!_%yi!d%yi!g%yi!h%yi!i%yi!j%yi!k%yi!n%yi#d%yi#t%yi#x%yi%P%yi%R%yi%T%yi%U%yi%X%yi%Z%yi%^%yi%_%yi%a%yi%n%yi%t%yi%v%yi%x%yi%z%yi%}%yi&T%yi&Z%yi&]%yi&_%yi&a%yi&c%yi'S%yi']%yi'f%yi'o%yi'|%yi!S%yi`%yi&Q%yi~O`/mO!S/kO&Q/lO~P`O!TSO!d/oO~O&X*wOQ&SiR&SiX&Si]&Si_&Sib&Sic&Sih&Sij&Sik&Sil&Siq&Sis&Six&Si{&Si|&Si}&Si!T&Si!_&Si!d&Si!g&Si!h&Si!i&Si!j&Si!k&Si!n&Si#d&Si#t&Si#x&Si%P&Si%R&Si%T&Si%U&Si%X&Si%Z&Si%^&Si%_&Si%a&Si%n&Si%t&Si%v&Si%x&Si%z&Si%}&Si&T&Si&Z&Si&]&Si&_&Si&a&Si&c&Si'S&Si']&Si'f&Si'o&Si'|&Si!S&Si%{&Si`&Si&Q&Si~O!R#bOn$]a~O!O&ii!R&ii~P!)wO!R%zO!O'ji~O!R&`O!O'ti~O!O/uO~O!R!Va!S!Va~P#*XO]&ROk&RO!Q/{O'g(jO!R&jX!S&jX~P@dO!R+`O!S'ka~O]&ZOk&ZO!Q)yO'g'TO!R&oX!S&oX~O!R+cO!S'va~O!O'ui!R'ui~P!)wO_$^O!]!wO!d$ZO!j0VO!{0TO'W$^O'b$PO'p&oO~O!S0YO~P!?iO!X0ZO!Y0ZO'^$dO'g(jO'o+iO~O!W0[O~P#MSO!TSO!W0[O!u0^O!x0_O~P#MSO!W0[O!s0aO!t0aO!u0^O!x0_O~P#MSO!T&dO~O!T&dO~P!BpO!R'ri!c'ri_'ri'W'ri~P!)wO!{0jO!R'ri!c'ri_'ri'W'ri~O!R&tO!c'qi~Ox$uO!T$vO#V0lO']$bO~O#WraQraZra_rajra!ara!bra!dra!jra#[ra#]ra#^ra#_ra#`ra#ara#bra#cra#era#gra#ira#jra'Wra'fra'pra!cra!Ora!Tranra%Qra!]ra~P#7pO#W$^aQ$^aZ$^a_$^aj$^av$^a!a$^a!b$^a!d$^a!j$^a#[$^a#]$^a#^$^a#_$^a#`$^a#a$^a#b$^a#c$^a#e$^a#g$^a#i$^a#j$^a'W$^a'f$^a'p$^a!c$^a!O$^a!T$^an$^a%Q$^a!]$^a~P#8fO#W$`aQ$`aZ$`a_$`aj$`av$`a!a$`a!b$`a!d$`a!j$`a#[$`a#]$`a#^$`a#_$`a#`$`a#a$`a#b$`a#c$`a#e$`a#g$`a#i$`a#j$`a'W$`a'f$`a'p$`a!c$`a!O$`a!T$`an$`a%Q$`a!]$`a~P#9XO#W$naQ$naZ$na_$naj$nav$na!R$na!a$na!b$na!d$na!j$na#[$na#]$na#^$na#_$na#`$na#a$na#b$na#c$na#e$na#g$na#i$na#j$na'W$na'f$na'p$na!c$na!O$na!T$na!{$nan$na%Q$na!]$na~P!BpO_#Oq!R#Oq'W#Oq!O#Oq!c#Oqn#Oq!T#Oq%Q#Oq!]#Oq~P!)wO!R&kX'a&kX~PJjO!R,_O'a'ma~O!Q0tO!R&lX!c&lX~P){O!R,bO!c'na~O!R,bO!c'na~P!)wO#m!fa!S!fa~PCfO#m!^a!R!^a!S!^a~P#*XO!T1XO#x^O$P1YO~O!S1^O~On1_O~P!BpO_$Yq!R$Yq'W$Yq!O$Yq!c$Yqn$Yq!T$Yq%Q$Yq!]$Yq~P!)wO!O1`O~O],yOk,yO~Ou(SOx(TO'x(XOP$xi'w$xi!R$xi!{$xi~O'a$xi#m$xi~P$.POu(SOx(TOP$zi'w$zi'x$zi!R$zi!{$zi~O'a$zi#m$zi~P$.rO'p#[O~P!BpO!Q1cO']$bO!R&tX!c&tX~O!R-RO!c'}a~O!R-RO!]!wO!c'}a~O!R-RO!]!wO'p&oO!c'}a~O'a$gi!R$gi!{$gi#m$gi~P!#{O!Q1kO'](eO!O&vX!R&vX~P!$jO!R-ZO!O(Oa~O!R-ZO!O(Oa~P!BpO!]!wO~O!]!wO#c1sO~Oj1vO!]!wO'p&oO~O!R'di'a'di~P!#{O!{1yO!R'di'a'di~P!#{O!c1|O~O_$Zq!R$Zq'W$Zq!O$Zq!c$Zqn$Zq!T$Zq%Q$Zq!]$Zq~P!)wO!R2QO!T(PX~P!BpO!T&dO%Q2TO~O!T&dO%Q2TO~P!BpO!T$eX$u[X_$eX!R$eX'W$eX~P!!rO$u2XOPgXugXxgX!TgX'wgX'xgX_gX!RgX'WgX~O$u2XO~O]2_O%R2`O'])iO!R'PX!S'PX~O!R.^O!S(Va~OZ2dO~O^2eO~O]2hO~OP2jO!T&dO!o2iO%Q2TO~O_$^O'W$^O~P!BpO!T#zO~P!BpO!R2oO!{2qO!S(SX~O!S2rO~Ox;oO!W2{O!X2tO!Y2tO!r2zO!s2yO!t2yO!x2xO'^$dO'g(jO'o+iO~O!S2wO~P$7ZOP3SO!T.yO!o3RO%Q3QO~OP3SO!T.yO!o3RO%Q3QO'b$PO~O'](|O!R'OX!S'OX~O!R/VO!S(Ta~O]3^O'g3]O~O]3_O~O^3aO~O!c3dO~P){O_3fO~O_3fO~P){O#c3hO%r3iO~PFOO`/mO!S3mO&Q/lO~P`O!]3oO~O!R#Ti!S#Ti~P#*XO!{3qO!R#Ti!S#Ti~O!R!Vi!S!Vi~P#*XO_$^O!{3xO'W$^O~O_$^O!]!wO!{3xO'W$^O~O!X3|O!Y3|O'^$dO'g(jO'o+iO~O_$^O!]!wO!d$ZO!j3}O!{3xO'W$^O'b$PO'p&oO~O!W4OO~P$;xO!W4OO!u4RO!x4SO~P$;xO_$^O!]!wO!j3}O!{3xO'W$^O'p&oO~O!R'rq!c'rq_'rq'W'rq~P!)wO!R&tO!c'qq~O#W$xiQ$xiZ$xi_$xij$xiv$xi!a$xi!b$xi!d$xi!j$xi#[$xi#]$xi#^$xi#_$xi#`$xi#a$xi#b$xi#c$xi#e$xi#g$xi#i$xi#j$xi'W$xi'f$xi'p$xi!c$xi!O$xi!T$xin$xi%Q$xi!]$xi~P$.PO#W$ziQ$ziZ$zi_$zij$ziv$zi!a$zi!b$zi!d$zi!j$zi#[$zi#]$zi#^$zi#_$zi#`$zi#a$zi#b$zi#c$zi#e$zi#g$zi#i$zi#j$zi'W$zi'f$zi'p$zi!c$zi!O$zi!T$zin$zi%Q$zi!]$zi~P$.rO#W$giQ$giZ$gi_$gij$giv$gi!R$gi!a$gi!b$gi!d$gi!j$gi#[$gi#]$gi#^$gi#_$gi#`$gi#a$gi#b$gi#c$gi#e$gi#g$gi#i$gi#j$gi'W$gi'f$gi'p$gi!c$gi!O$gi!T$gi!{$gin$gi%Q$gi!]$gi~P!BpO!R&ka'a&ka~P!#{O!R&la!c&la~P!)wO!R,bO!c'ni~O#m#Oi!R#Oi!S#Oi~P#*XOQ#^Ou!{Ov!{Ox!|O!b!yO!d!zO!j#^O'fQOZ#Zij#Zi!a#Zi#]#Zi#^#Zi#_#Zi#`#Zi#a#Zi#b#Zi#c#Zi#e#Zi#g#Zi#i#Zi#j#Zi#m#Zi'p#Zi'w#Zi'x#Zi!R#Zi!S#Zi~O#[#Zi~P$EiO#[9eO~P$EiOQ#^Ou!{Ov!{Ox!|O!b!yO!d!zO!j#^O#[9eO#]9fO#^9fO#_9fO'fQOZ#Zi!a#Zi#`#Zi#a#Zi#b#Zi#c#Zi#e#Zi#g#Zi#i#Zi#j#Zi#m#Zi'p#Zi'w#Zi'x#Zi!R#Zi!S#Zi~Oj#Zi~P$GqOj9gO~P$GqOQ#^Oj9gOu!{Ov!{Ox!|O!b!yO!d!zO!j#^O#[9eO#]9fO#^9fO#_9fO#`9hO'fQO#e#Zi#g#Zi#i#Zi#j#Zi#m#Zi'p#Zi'w#Zi'x#Zi!R#Zi!S#Zi~OZ#Zi!a#Zi#a#Zi#b#Zi#c#Zi~P$IyOZ9rO!a9iO#a9iO#b9iO#c9iO~P$IyOQ#^OZ9rOj9gOu!{Ov!{Ox!|O!a9iO!b!yO!d!zO!j#^O#[9eO#]9fO#^9fO#_9fO#`9hO#a9iO#b9iO#c9iO#e9jO'fQO#g#Zi#i#Zi#j#Zi#m#Zi'p#Zi'x#Zi!R#Zi!S#Zi~O'w#Zi~P$L_O'w!}O~P$L_OQ#^OZ9rOj9gOu!{Ov!{Ox!|O!a9iO!b!yO!d!zO!j#^O#[9eO#]9fO#^9fO#_9fO#`9hO#a9iO#b9iO#c9iO#e9jO#g9lO'fQO'w!}O#i#Zi#j#Zi#m#Zi'p#Zi!R#Zi!S#Zi~O'x#Zi~P$NgO'x#OO~P$NgOQ#^OZ9rOj9gOu!{Ov!{Ox!|O!a9iO!b!yO!d!zO!j#^O#[9eO#]9fO#^9fO#_9fO#`9hO#a9iO#b9iO#c9iO#e9jO#g9lO#i9nO'fQO'w!}O'x#OO~O#j#Zi#m#Zi'p#Zi!R#Zi!S#Zi~P%!oO_#ky!R#ky'W#ky!O#ky!c#kyn#ky!T#ky%Q#ky!]#ky~P!)wOP;vOu(SOx(TO'w(VO'x(XO~OQ#ZiZ#Zij#Ziv#Zi!a#Zi!b#Zi!d#Zi!j#Zi#[#Zi#]#Zi#^#Zi#_#Zi#`#Zi#a#Zi#b#Zi#c#Zi#e#Zi#g#Zi#i#Zi#j#Zi#m#Zi'f#Zi'p#Zi!R#Zi!S#Zi~P%%aO!b!yOP'eXu'eXx'eX'w'eX'x'eX!S'eX~OQ'eXZ'eXj'eXv'eX!a'eX!d'eX!j'eX#['eX#]'eX#^'eX#_'eX#`'eX#a'eX#b'eX#c'eX#e'eX#g'eX#i'eX#j'eX#m'eX'f'eX'p'eX!R'eX~P%'eO#m#ni!R#ni!S#ni~P#*XO!S4eO~O!R&sa!S&sa~P#*XO!]!wO'p&oO!R&ta!c&ta~O!R-RO!c'}i~O!R-RO!]!wO!c'}i~O'a$gq!R$gq!{$gq#m$gq~P!#{O!O&va!R&va~P!BpO!]4lO~O!R-ZO!O(Oi~P!BpO!R-ZO!O(Oi~O!O4pO~O!]!wO#c4uO~Oj4vO!]!wO'p&oO~O!O4xO~O'a$iq!R$iq!{$iq#m$iq~P!#{O_$Zy!R$Zy'W$Zy!O$Zy!c$Zyn$Zy!T$Zy%Q$Zy!]$Zy~P!)wO!R2QO!T(Pa~O!T&dO%Q4}O~O!T&dO%Q4}O~P!BpO_#Oy!R#Oy'W#Oy!O#Oy!c#Oyn#Oy!T#Oy%Q#Oy!]#Oy~P!)wOZ5QO~O]5SO'])iO~O!R.^O!S(Vi~O]5VO~O^5WO~O'g'TO!R&{X!S&{X~O!R2oO!S(Sa~O!S5eO~P$7ZOx;sO'g(jO'o+iO~O!W5hO!X5gO!Y5gO!x0_O'^$dO'g(jO'o+iO~O!s5iO!t5iO~P%0^O!X5gO!Y5gO'^$dO'g(jO'o+iO~O!T.yO~O!T.yO%Q5kO~O!T.yO%Q5kO~P!BpOP5pO!T.yO!o5oO%Q5kO~OZ5uO!R'Oa!S'Oa~O!R/VO!S(Ti~O]5xO~O!c5yO~O!c5zO~O!c5{O~O!c5{O~P){O_5}O~O!]6QO~O!c6RO~O!R'ui!S'ui~P#*XO_$^O'W$^O~P!)wO_$^O!{6WO'W$^O~O_$^O!]!wO!{6WO'W$^O~O!X6]O!Y6]O'^$dO'g(jO'o+iO~O_$^O!]!wO!j6^O!{6WO'W$^O'p&oO~O!d$ZO'b$PO~P%4xO!W6_O~P%4gO!R'ry!c'ry_'ry'W'ry~P!)wO#W$gqQ$gqZ$gq_$gqj$gqv$gq!R$gq!a$gq!b$gq!d$gq!j$gq#[$gq#]$gq#^$gq#_$gq#`$gq#a$gq#b$gq#c$gq#e$gq#g$gq#i$gq#j$gq'W$gq'f$gq'p$gq!c$gq!O$gq!T$gq!{$gqn$gq%Q$gq!]$gq~P!BpO#W$iqQ$iqZ$iq_$iqj$iqv$iq!R$iq!a$iq!b$iq!d$iq!j$iq#[$iq#]$iq#^$iq#_$iq#`$iq#a$iq#b$iq#c$iq#e$iq#g$iq#i$iq#j$iq'W$iq'f$iq'p$iq!c$iq!O$iq!T$iq!{$iqn$iq%Q$iq!]$iq~P!BpO!R&li!c&li~P!)wO#m#Oq!R#Oq!S#Oq~P#*XOu-tOv-tOx-uOPra'wra'xra!Sra~OQraZrajra!ara!bra!dra!jra#[ra#]ra#^ra#_ra#`ra#ara#bra#cra#era#gra#ira#jra#mra'fra'pra!Rra~P%;OOu(SOx(TOP$^a'w$^a'x$^a!S$^a~OQ$^aZ$^aj$^av$^a!a$^a!b$^a!d$^a!j$^a#[$^a#]$^a#^$^a#_$^a#`$^a#a$^a#b$^a#c$^a#e$^a#g$^a#i$^a#j$^a#m$^a'f$^a'p$^a!R$^a~P%=SOu(SOx(TOP$`a'w$`a'x$`a!S$`a~OQ$`aZ$`aj$`av$`a!a$`a!b$`a!d$`a!j$`a#[$`a#]$`a#^$`a#_$`a#`$`a#a$`a#b$`a#c$`a#e$`a#g$`a#i$`a#j$`a#m$`a'f$`a'p$`a!R$`a~P%?WOQ$naZ$naj$nav$na!a$na!b$na!d$na!j$na#[$na#]$na#^$na#_$na#`$na#a$na#b$na#c$na#e$na#g$na#i$na#j$na#m$na'f$na'p$na!R$na!S$na~P%%aO#m$Yq!R$Yq!S$Yq~P#*XO#m$Zq!R$Zq!S$Zq~P#*XO!S6hO~O#m6iO~P!#{O!]!wO!R&ti!c&ti~O!]!wO'p&oO!R&ti!c&ti~O!R-RO!c'}q~O!O&vi!R&vi~P!BpO!R-ZO!O(Oq~O!O6oO~P!BpO!O6oO~O!R'dy'a'dy~P!#{O!R&ya!T&ya~P!BpO!T$tq_$tq!R$tq'W$tq~P!BpOZ6vO~O!R.^O!S(Vq~O]6yO~O!T&dO%Q6zO~O!T&dO%Q6zO~P!BpO!{6{O!R&{a!S&{a~O!R2oO!S(Si~P#*XO!X7RO!Y7RO'^$dO'g(jO'o+iO~O!W7TO!x4SO~P%GXO!T.yO%Q7WO~O!T.yO%Q7WO~P!BpO]7_O'g7^O~O!R/VO!S(Tq~O!c7aO~O!c7aO~P){O!c7cO~O!c7dO~O!R#Ty!S#Ty~P#*XO_$^O!{7jO'W$^O~O_$^O!]!wO!{7jO'W$^O~O!X7mO!Y7mO'^$dO'g(jO'o+iO~O_$^O!]!wO!j7nO!{7jO'W$^O'p&oO~O#m#ky!R#ky!S#ky~P#*XOQ$giZ$gij$giv$gi!a$gi!b$gi!d$gi!j$gi#[$gi#]$gi#^$gi#_$gi#`$gi#a$gi#b$gi#c$gi#e$gi#g$gi#i$gi#j$gi#m$gi'f$gi'p$gi!R$gi!S$gi~P%%aOu(SOx(TO'x(XOP$xi'w$xi!S$xi~OQ$xiZ$xij$xiv$xi!a$xi!b$xi!d$xi!j$xi#[$xi#]$xi#^$xi#_$xi#`$xi#a$xi#b$xi#c$xi#e$xi#g$xi#i$xi#j$xi#m$xi'f$xi'p$xi!R$xi~P%LjOu(SOx(TOP$zi'w$zi'x$zi!S$zi~OQ$ziZ$zij$ziv$zi!a$zi!b$zi!d$zi!j$zi#[$zi#]$zi#^$zi#_$zi#`$zi#a$zi#b$zi#c$zi#e$zi#g$zi#i$zi#j$zi#m$zi'f$zi'p$zi!R$zi~P%NnO#m$Zy!R$Zy!S$Zy~P#*XO#m#Oy!R#Oy!S#Oy~P#*XO!]!wO!R&tq!c&tq~O!R-RO!c'}y~O!O&vq!R&vq~P!BpO!O7tO~P!BpO!R.^O!S(Vy~O!R2oO!S(Sq~O!X8QO!Y8QO'^$dO'g(jO'o+iO~O!T.yO%Q8TO~O!T.yO%Q8TO~P!BpO!c8WO~O_$^O!{8]O'W$^O~O_$^O!]!wO!{8]O'W$^O~OQ$gqZ$gqj$gqv$gq!a$gq!b$gq!d$gq!j$gq#[$gq#]$gq#^$gq#_$gq#`$gq#a$gq#b$gq#c$gq#e$gq#g$gq#i$gq#j$gq#m$gq'f$gq'p$gq!R$gq!S$gq~P%%aOQ$iqZ$iqj$iqv$iq!a$iq!b$iq!d$iq!j$iq#[$iq#]$iq#^$iq#_$iq#`$iq#a$iq#b$iq#c$iq#e$iq#g$iq#i$iq#j$iq#m$iq'f$iq'p$iq!R$iq!S$iq~P%%aO'a$|!Z!R$|!Z!{$|!Z#m$|!Z~P!#{O!R&{q!S&{q~P#*XO_$^O!{8oO'W$^O~O#W$|!ZQ$|!ZZ$|!Z_$|!Zj$|!Zv$|!Z!R$|!Z!a$|!Z!b$|!Z!d$|!Z!j$|!Z#[$|!Z#]$|!Z#^$|!Z#_$|!Z#`$|!Z#a$|!Z#b$|!Z#c$|!Z#e$|!Z#g$|!Z#i$|!Z#j$|!Z'W$|!Z'f$|!Z'p$|!Z!c$|!Z!O$|!Z!T$|!Z!{$|!Zn$|!Z%Q$|!Z!]$|!Z~P!BpOP;uOu(SOx(TO'w(VO'x(XO~O!S!za!W!za!X!za!Y!za!r!za!s!za!t!za!x!za'^!za'g!za'o!za~P&,_O!W'eX!X'eX!Y'eX!r'eX!s'eX!t'eX!x'eX'^'eX'g'eX'o'eX~P%'eOQ$|!ZZ$|!Zj$|!Zv$|!Z!a$|!Z!b$|!Z!d$|!Z!j$|!Z#[$|!Z#]$|!Z#^$|!Z#_$|!Z#`$|!Z#a$|!Z#b$|!Z#c$|!Z#e$|!Z#g$|!Z#i$|!Z#j$|!Z#m$|!Z'f$|!Z'p$|!Z!R$|!Z!S$|!Z~P%%aO!Wra!Xra!Yra!rra!sra!tra!xra'^ra'gra'ora~P%;OO!W$^a!X$^a!Y$^a!r$^a!s$^a!t$^a!x$^a'^$^a'g$^a'o$^a~P%=SO!W$`a!X$`a!Y$`a!r$`a!s$`a!t$`a!x$`a'^$`a'g$`a'o$`a~P%?WO!S$na!W$na!X$na!Y$na!r$na!s$na!t$na!x$na'^$na'g$na'o$na~P&,_O!W$xi!X$xi!Y$xi!r$xi!s$xi!t$xi!x$xi'^$xi'g$xi'o$xi~P%LjO!W$zi!X$zi!Y$zi!r$zi!s$zi!t$zi!x$zi'^$zi'g$zi'o$zi~P%NnO!S$gi!W$gi!X$gi!Y$gi!r$gi!s$gi!t$gi!x$gi'^$gi'g$gi'o$gi~P&,_O!S$gq!W$gq!X$gq!Y$gq!r$gq!s$gq!t$gq!x$gq'^$gq'g$gq'o$gq~P&,_O!S$iq!W$iq!X$iq!Y$iq!r$iq!s$iq!t$iq!x$iq'^$iq'g$iq'o$iq~P&,_O!S$|!Z!W$|!Z!X$|!Z!Y$|!Z!r$|!Z!s$|!Z!t$|!Z!x$|!Z'^$|!Z'g$|!Z'o$|!Z~P&,_On'hX~P.jOn[X!O[X!c[X%r[X!T[X%Q[X!][X~P$zO!]dX!c[X!cdX'pdX~P;dOQ9^OR9^O]cOb;`Oc!jOhcOj9^OkcOlcOq9^Os9^OxRO{cO|cO}cO!TSO!_9`O!dUO!g9^O!h9^O!i9^O!j9^O!k9^O!n!iO#t!lO#x^O']'cO'fQO'oYO'|;^O~O]#qOh$QOj#rOk#qOl#qOq$ROs9uOx#yO!T#zO!_;fO!d#vO#V:OO#t$VO$_9xO$a9{O$d$WO']&{O'b$PO'f#sO~O!R9pO!S$]a~O]#qOh$QOj#rOk#qOl#qOq$ROs9vOx#yO!T#zO!_;gO!d#vO#V:PO#t$VO$_9yO$a9|O$d$WO']&{O'b$PO'f#sO~O#d'jO~P&<WO!S[X!SdX~P;dO!]9dO~O#W9cO~O!]!wO#W9cO~O!{9sO~O#c9iO~O!{:QO!R'uX!S'uX~O!{9sO!R'sX!S'sX~O#W:RO~O'a:TO~P!#{O#W:[O~O#W:]O~O#W:^O~O!]!wO#W:_O~O!]!wO#W:RO~O#m:`O~P#*XO#W:aO~O#W:bO~O#W:cO~O#W:dO~O#W:eO~O#W:fO~O#W:gO~O#W:hO~O!O:iO~O#m:jO~P!#{O#m:kO~P!#{O#m:lO~P!#{O!O:mO~P!BpO!O:mO~O!O:nO~P!BpO!]!wO#c;lO~O!]!wO#c;nO~O#x~!b!r!t!u#U#V'|$_$a$d$u%P%Q%R%X%Z%^%_%a%c~UT#x'|#]}'Y'Z#z'Y']'g~",
  goto: "#Kk(ZPPPPPPPP([P(lP*`PPPP-zPP.a3s7o8SP8SPPP8SP:U8SP8SP:YPP:`P:t?VPPPP?ZPPPP?ZA{PPPBRDdP?ZPFwPPPPHp?ZPPPPPJi?ZPPMjNgPPPPNk!!TP!!]!#^PNg?Z?Z!&n!)i!.[!.[!1kPPP!1r!4h?ZPPPPPPPPPP!7_P!8pPP?Z!9}P?ZP?Z?Z?Z?ZP?Z!;dPP!>]P!AQ!AY!A^!A^P!>YP!Ab!AbP!DVP!DZ?Z?Z!Da!GT8SP8SP8S8SP!HW8S8S!Jf8S!M_8S# g8S8S#!T#$c#$c#$g#$c#$oP#$cP8S#%k8S#'X8S8S-zPPP#(yPP#)c#)cP#)cP#)x#)cPP#*OP#)uP#)u#*b!!X#)u#+P#+V#+Y([#+]([P#+d#+d#+dP([P([P([P([PP([P#+j#+mP#+m([P#+qP#+tP([P([P([P([P([P([([#+z#,U#,[#,b#,p#,v#,|#-W#-^#-m#-s#.R#.X#._#.m#/S#0z#1Y#1`#1f#1l#1r#1|#2S#2Y#2d#2v#2|PPPPPPPP#3SPP#3v#7OPP#8f#8m#8uPP#>a#@t#Fp#Fs#Fv#GR#GUPP#GX#G]#Gz#Hq#Hu#IZPP#I_#Ie#IiP#Il#Ip#Is#Jc#Jy#KO#KR#KU#K[#K_#Kc#KgmhOSj}!n$]%c%f%g%i*o*t/g/jQ$imQ$ppQ%ZyS&V!b+`Q&k!jS(l#z(qQ)g$jQ)t$rQ*`%TQ+f&^S+k&d+mQ+}&lQ-k(sQ/U*aY0Z+o+p+q+r+sS2t.y2vU3|0[0^0aU5g2y2z2{S6]4O4RS7R5h5iQ7m6_R8Q7T$p[ORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#b#e$]$n%[%_%c%e%f%g%i%m%x%z&S&_&f&p&}'R(R)V)^*k*o*t+T+x,P,b,h-u-z.S.].|/_/`/a/c/g/j/l0T0j0t2i3R3f3h3i3x5o5}6W7j8]8o!j'e#]#k&W'w+X+[,m/{1X2q3q6{9^9`9c9e9f9g9h9i9j9k9l9m9n9o9p9s:Q:R:T:_:`:g:h;aQ(}$SQ)l$lQ*b%WQ*i%`Q,X9tQ.W)aQ.c)mQ/^*gQ2_.^Q3Z/VQ4^9vQ5S2`R8{9upeOSjy}!n$]%Y%c%f%g%i*o*t/g/jR*d%[&WVOSTjkn}!S!W!k!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#]#b#e#k$]$n%[%_%`%c%e%f%g%i%m%z&S&_&f&p&}'R'w(R)V)^*k*o*t+T+X+[+x,P,b,h,m-u-z.S.].|/_/`/a/c/g/j/l/{0T0j0t1X2i2q3R3f3h3i3q3x5o5}6W6{7j8]8o9^9`9c9e9f9g9h9i9j9k9l9m9n9o9p9s:Q:R:T:_:`:g:h;`;a[!cRU!]!`%x&WQ$clQ$hmS$mp$rv$wrs!r!u$Z$u&`&t&w)x)y)z*m+Y+h,S,U/o0lQ%PwQ&h!iQ&j!jS(_#v(cS)f$i$jQ)j$lQ)w$tQ*Z%RQ*_%TS+|&k&lQ-V(`Q.[)gQ.b)mQ.d)nQ.g)rQ/P*[S/T*`*aQ0h+}Q1b-RQ2^.^Q2b.aQ2g.iQ3Y/UQ4i1cQ5R2`Q5U2dQ6u5QR7w6vx#xa!y$T$U$Y(W(Y(b(w(x,_-Y-w1a1y6i;^;i;j;k!Y$fm!j$h$i$j&U&j&k&l(k)f)g+]+j+|+}-d.[0Q0W0]0h1u3{4Q6Z7k8^Q)`$cQ*P$|Q*S$}Q*^%TQ.k)wQ/O*ZU/S*_*`*aQ3T/PS3X/T/UQ5b2sQ5t3YS7P5c5fS8O7Q7SQ8f8PQ8u8g#[;b!w#d#v#y&g'}(Z(h)])_)a*O*R+y-Z-].R.T.p.s.{.}1k1s2Q2T2X2j3Q3S4l4u4}5k5p6z7W8T9w9z9}:U:X:[:a:d:j;l;n;t;u;vd;c9d9x9{:O:V:Y:]:b:e:ke;d9r9y9|:P:W:Z:^:c:f:lW#}a$P(y;^S$|t%YQ$}uQ%OvR)}$z%P#|a!w!y#d#v#y$T$U$Y&g'}(W(Y(Z(b(h(w(x)])_)a*O*R+y,_-Y-Z-]-w.R.T.p.s.{.}1a1k1s1y2Q2T2X2j3Q3S4l4u4}5k5p6i6z7W8T9d9r9w9x9y9z9{9|9}:O:P:U:V:W:X:Y:Z:[:]:^:a:b:c:d:e:f:j:k:l;^;i;j;k;l;n;t;u;vT(O#s(PX)O$S9t9u9vU&Z!b$v+cQ'U!{Q)q$oQ.t*TQ1z-tR5^2o&^cORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#]#b#e#k$]$n%[%_%`%c%e%f%g%i%m%x%z&S&W&_&f&p&}'R'w(R)V)^*k*o*t+T+X+[+x,P,b,h,m-u-z.S.].|/_/`/a/c/g/j/l/{0T0j0t1X2i2q3R3f3h3i3q3x5o5}6W6{7j8]8o9^9`9c9e9f9g9h9i9j9k9l9m9n9o9p9s:Q:R:T:_:`:g:h;a$]#aZ!_!o$a%w%}&y'Q'W'X'Y'Z'[']'^'_'`'a'b'd'g'k'u)p+R+^+g,O,^,d,g,i,w-x/v/y0i0s0w0x0y0z0{0|0}1O1P1Q1R1S1T1W1]2O2[3s3v4W4[4]4b4c5`6S6V6b6f6g7g7z8Z8m8y9_:|T!XQ!Y&_cORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#]#b#e#k$]$n%[%_%`%c%e%f%g%i%m%x%z&S&W&_&f&p&}'R'w(R)V)^*k*o*t+T+X+[+x,P,b,h,m-u-z.S.].|/_/`/a/c/g/j/l/{0T0j0t1X2i2q3R3f3h3i3q3x5o5}6W6{7j8]8o9^9`9c9e9f9g9h9i9j9k9l9m9n9o9p9s:Q:R:T:_:`:g:h;aQ&X!bR/|+`Y&R!b&V&^+`+fS(k#z(qS+j&d+mS-d(l(sQ-e(mQ-l(tQ.v*VU0W+k+o+pU0]+q+r+sS0b+t2xQ1u-kQ1w-mQ1x-nS2s.y2vU3{0Z0[0^Q4P0_Q4Q0aS5c2t2{S5f2y2zU6Z3|4O4RQ6`4SS7Q5g5hQ7S5iS7k6]6_S8P7R7TQ8^7mQ8g8QQ;h;oR;m;slhOSj}!n$]%c%f%g%i*o*t/g/jQ%k!QS&x!v9cQ)d$gQ*X%PQ*Y%QQ+z&iS,]&}:RS-y)V:_Q.Y)eQ.x*WQ/n*vQ/p*wQ/x+ZQ0`+qQ0f+{S2P-z:gQ2Y.ZS2].]:hQ3r/zQ3u0RQ4U0gQ5P2ZQ6T3tQ6X3zQ6a4VQ7e6RQ7h6YQ8Y7iQ8l8[R8x8n$W#`Z!_!o%w%}&y'Q'W'X'Y'Z'[']'^'_'`'a'b'd'g'k'u)p+R+^+g,O,^,d,g,w-x/v/y0i0s0w0x0y0z0{0|0}1O1P1Q1R1S1T1W1]2O2[3s3v4W4[4]4b4c5`6S6V6b6f6g7g7z8Z8m8y9_:|W(v#{&|1V8qT)Z$a,i$W#_Z!_!o%w%}&y'Q'W'X'Y'Z'[']'^'_'`'a'b'd'g'k'u)p+R+^+g,O,^,d,g,w-x/v/y0i0s0w0x0y0z0{0|0}1O1P1Q1R1S1T1W1]2O2[3s3v4W4[4]4b4c5`6S6V6b6f6g7g7z8Z8m8y9_:|Q'f#`S)Y$a,iR-{)Z&^cORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#]#b#e#k$]$n%[%_%`%c%e%f%g%i%m%x%z&S&W&_&f&p&}'R'w(R)V)^*k*o*t+T+X+[+x,P,b,h,m-u-z.S.].|/_/`/a/c/g/j/l/{0T0j0t1X2i2q3R3f3h3i3q3x5o5}6W6{7j8]8o9^9`9c9e9f9g9h9i9j9k9l9m9n9o9p9s:Q:R:T:_:`:g:h;aQ%f{Q%g|Q%i!OQ%j!PR/f*rQ&e!iQ)[$cQ+w&hS.Q)`)wS0c+u+vW2S-}.O.P.kS4T0d0eU4|2U2V2WU6s4{5Y5ZQ7v6tR8b7yT+l&d+mS+j&d+mU0W+k+o+pU0]+q+r+sS0b+t2xS2s.y2vU3{0Z0[0^Q4P0_Q4Q0aS5c2t2{S5f2y2zU6Z3|4O4RQ6`4SS7Q5g5hQ7S5iS7k6]6_S8P7R7TQ8^7mR8g8QS+l&d+mT2u.y2vS&r!q/dQ-U(_Q-b(kS0V+j2sQ1g-VS1p-c-lU3}0]0b5fQ4h1bS4s1v1xU6^4P4Q7SQ6k4iQ6r4vR7n6`Q!xXS&q!q/dQ)W$[Q)b$eQ)h$kQ,Q&rQ-T(_Q-a(kQ-f(nQ.X)cQ/Q*]S0U+j2sS1f-U-VS1o-b-lQ1r-eQ1t-gQ3V/RW3y0V0]0b5fQ4g1bQ4k1gS4o1p1xQ4t1wQ5r3WW6[3}4P4Q7SS6j4h4iS6n4p:iQ6p4sQ6}5aQ7[5sS7l6^6`Q7r6kS7s6o:mQ7u6rQ7|7OQ8V7]Q8_7nS8a7t:nQ8d7}Q8s8eQ9Q8tQ9X9RQ:u:pQ;T:zQ;U:{Q;V;hR;[;m$rWORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#b#e$]$n%[%_%`%c%e%f%g%i%m%x%z&S&_&f&p&}'R(R)V)^*k*o*t+T+x,P,b,h-u-z.S.].|/_/`/a/c/g/j/l0T0j0t2i3R3f3h3i3x5o5}6W7j8]8oS!xn!k!j:o#]#k&W'w+X+[,m/{1X2q3q6{9^9`9c9e9f9g9h9i9j9k9l9m9n9o9p9s:Q:R:T:_:`:g:h;aR:u;`$rXORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#b#e$]$n%[%_%`%c%e%f%g%i%m%x%z&S&_&f&p&}'R(R)V)^*k*o*t+T+x,P,b,h-u-z.S.].|/_/`/a/c/g/j/l0T0j0t2i3R3f3h3i3x5o5}6W7j8]8oQ$[b!Y$em!j$h$i$j&U&j&k&l(k)f)g+]+j+|+}-d.[0Q0W0]0h1u3{4Q6Z7k8^S$kn!kQ)c$fQ*]%TW/R*^*_*`*aU3W/S/T/UQ5a2sS5s3X3YU7O5b5c5fQ7]5tU7}7P7Q7SS8e8O8PS8t8f8gQ9R8u!j:p#]#k&W'w+X+[,m/{1X2q3q6{9^9`9c9e9f9g9h9i9j9k9l9m9n9o9p9s:Q:R:T:_:`:g:h;aQ:z;_R:{;`$f]OSTjk}!S!W!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#b#e$]$n%[%_%c%e%f%g%i%m%z&S&_&f&p&}'R(R)V)^*k*o*t+T+x,P,b,h-u-z.S.].|/_/`/a/c/g/j/l0T0j0t2i3R3f3h3i3x5o5}6W7j8]8oY!hRU!]!`%xv$wrs!r!u$Z$u&`&t&w)x)y)z*m+Y+h,S,U/o0lQ*j%`!h:q#]#k'w+X+[,m/{1X2q3q6{9^9`9c9e9f9g9h9i9j9k9l9m9n9o9p9s:Q:R:T:_:`:g:h;aR:t&WS&[!b$vR0O+c$p[ORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#b#e$]$n%[%_%c%e%f%g%i%m%x%z&S&_&f&p&}'R(R)V)^*k*o*t+T+x,P,b,h-u-z.S.].|/_/`/a/c/g/j/l0T0j0t2i3R3f3h3i3x5o5}6W7j8]8o!j'e#]#k&W'w+X+[,m/{1X2q3q6{9^9`9c9e9f9g9h9i9j9k9l9m9n9o9p9s:Q:R:T:_:`:g:h;aR*i%`$roORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#b#e$]$n%[%_%`%c%e%f%g%i%m%x%z&S&_&f&p&}'R(R)V)^*k*o*t+T+x,P,b,h-u-z.S.].|/_/`/a/c/g/j/l0T0j0t2i3R3f3h3i3x5o5}6W7j8]8oQ'U!{!k:r#]#k&W'w+X+[,m/{1X2q3q6{9^9`9c9e9f9g9h9i9j9k9l9m9n9o9p9s:Q:R:T:_:`:g:h;a!h#VZ!_$a%w%}&y'Q'_'`'a'b'g'k)p+R+g,O,^,d,w-x0i0s1T2O2[3v4W4[6V7g8Z8m8y9_!R9k'd'u+^,i/v/y0w1P1Q1R1S1W1]3s4]4b4c5`6S6b6f6g7z:|!d#XZ!_$a%w%}&y'Q'a'b'g'k)p+R+g,O,^,d,w-x0i0s1T2O2[3v4W4[6V7g8Z8m8y9_}9m'd'u+^,i/v/y0w1R1S1W1]3s4]4b4c5`6S6b6f6g7z:|!`#]Z!_$a%w%}&y'Q'g'k)p+R+g,O,^,d,w-x0i0s1T2O2[3v4W4[6V7g8Z8m8y9_Q1a-Px;a'd'u+^,i/v/y0w1W1]3s4]4b4c5`6S6b6f6g7z:|Q;i;pQ;j;qR;k;r&^cORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#]#b#e#k$]$n%[%_%`%c%e%f%g%i%m%x%z&S&W&_&f&p&}'R'w(R)V)^*k*o*t+T+X+[+x,P,b,h,m-u-z.S.].|/_/`/a/c/g/j/l/{0T0j0t1X2i2q3R3f3h3i3q3x5o5}6W6{7j8]8o9^9`9c9e9f9g9h9i9j9k9l9m9n9o9p9s:Q:R:T:_:`:g:h;aS#l`#mR1Y,l&e_ORSTU`jk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#]#b#e#k#m$]$n%[%_%`%c%e%f%g%i%m%x%z&S&W&_&f&p&}'R'w(R)V)^*k*o*t+T+X+[+x,P,b,h,l,m-u-z.S.].|/_/`/a/c/g/j/l/{0T0j0t1X2i2q3R3f3h3i3q3x5o5}6W6{7j8]8o9^9`9c9e9f9g9h9i9j9k9l9m9n9o9p9s:Q:R:T:_:`:g:h;aS#g^#nT'n#i'rT#h^#nT'p#i'r&e`ORSTU`jk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#]#b#e#k#m$]$n%[%_%`%c%e%f%g%i%m%x%z&S&W&_&f&p&}'R'w(R)V)^*k*o*t+T+X+[+x,P,b,h,l,m-u-z.S.].|/_/`/a/c/g/j/l/{0T0j0t1X2i2q3R3f3h3i3q3x5o5}6W6{7j8]8o9^9`9c9e9f9g9h9i9j9k9l9m9n9o9p9s:Q:R:T:_:`:g:h;aT#l`#mQ#o`R'y#m$rbORSTUjk}!S!W!]!`!n!v!z!|#P#Q#R#S#T#U#V#W#X#Y#Z#b#e$]$n%[%_%`%c%e%f%g%i%m%x%z&S&_&f&p&}'R(R)V)^*k*o*t+T+x,P,b,h-u-z.S.].|/_/`/a/c/g/j/l0T0j0t2i3R3f3h3i3x5o5}6W7j8]8o!k;_#]#k&W'w+X+[,m/{1X2q3q6{9^9`9c9e9f9g9h9i9j9k9l9m9n9o9p9s:Q:R:T:_:`:g:h;a#RdOSUj}!S!W!n!|#k$]%[%_%`%c%e%f%g%i%m&S&f'w)^*k*o*t+x,m-u.S.|/_/`/a/c/g/j/l1X2i3R3f3h3i5o5}x#{a!y$T$U$Y(W(Y(b(w(x,_-Y-w1a1y6i;^;i;j;k#[&|!w#d#v#y&g'}(Z(h)])_)a*O*R+y-Z-].R.T.p.s.{.}1k1s2Q2T2X2j3Q3S4l4u4}5k5p6z7W8T9w9z9}:U:X:[:a:d:j;l;n;t;u;vQ)S$WQ,x(Sd1V9r9y9|:P:W:Z:^:c:f:le8q9d9x9{:O:V:Y:]:b:e:kx#wa!y$T$U$Y(W(Y(b(w(x,_-Y-w1a1y6i;^;i;j;kQ(d#xS(n#z(qQ)T$XQ-g(o#[:w!w#d#v#y&g'}(Z(h)])_)a*O*R+y-Z-].R.T.p.s.{.}1k1s2Q2T2X2j3Q3S4l4u4}5k5p6z7W8T9w9z9}:U:X:[:a:d:j;l;n;t;u;vd:x9d9x9{:O:V:Y:]:b:e:kd:y9r9y9|:P:W:Z:^:c:f:lQ:};bQ;O;cQ;P;dQ;Q;eQ;R;fR;S;gx#{a!y$T$U$Y(W(Y(b(w(x,_-Y-w1a1y6i;^;i;j;k#[&|!w#d#v#y&g'}(Z(h)])_)a*O*R+y-Z-].R.T.p.s.{.}1k1s2Q2T2X2j3Q3S4l4u4}5k5p6z7W8T9w9z9}:U:X:[:a:d:j;l;n;t;u;vd1V9r9y9|:P:W:Z:^:c:f:le8q9d9x9{:O:V:Y:]:b:e:klfOSj}!n$]%c%f%g%i*o*t/g/jQ(g#yQ*}%pQ+O%rR1j-Z%O#|a!w!y#d#v#y$T$U$Y&g'}(W(Y(Z(b(h(w(x)])_)a*O*R+y,_-Y-Z-]-w.R.T.p.s.{.}1a1k1s1y2Q2T2X2j3Q3S4l4u4}5k5p6i6z7W8T9d9r9w9x9y9z9{9|9}:O:P:U:V:W:X:Y:Z:[:]:^:a:b:c:d:e:f:j:k:l;^;i;j;k;l;n;t;u;vQ*Q$}Q.r*SQ2m.qR5]2nT(p#z(qS(p#z(qT2u.y2vQ)b$eQ-f(nQ.X)cQ/Q*]Q3V/RQ5r3WQ6}5aQ7[5sQ7|7OQ8V7]Q8d7}Q8s8eQ9Q8tR9X9Rp(W#t'O)U-X-o-p0q1h1}4f4w7q:v;W;X;Y!n:U&z'i(^(f+v,[,t-P-^-|.P.o.q0e0p1i1m2W2l2n3O4Y4Z4m4q4y5O5Z5n6m6q7Y8`;Z;];p;q;r[:V8p9O9V9Y9Z9]]:W1U4a6c7o7p8zr(Y#t'O)U,}-X-o-p0q1h1}4f4w7q:v;W;X;Y!p:X&z'i(^(f+v,[,t-P-^-|.P.o.q0e0n0p1i1m2W2l2n3O4Y4Z4m4q4y5O5Z5n6m6q7Y8`;Z;];p;q;r^:Y8p9O9T9V9Y9Z9]_:Z1U4a6c6d7o7p8zpeOSjy}!n$]%Y%c%f%g%i*o*t/g/jQ%VxR*k%`peOSjy}!n$]%Y%c%f%g%i*o*t/g/jR%VxQ*U%OR.n)}qeOSjy}!n$]%Y%c%f%g%i*o*t/g/jQ.z*ZS3P/O/PW5j2|2}3O3TU7V5l5m5nU8R7U7X7YQ8h8SR8v8iQ%^yR*e%YR3^/XR7_5uS$mp$rR.d)nQ%czR*o%dR*u%jT/h*t/jR*y%kQ*x%kR/q*yQjOQ!nST$`j!nQ(P#sR,u(PQ!YQR%u!YQ!^RU%{!^%|+UQ%|!_R+U%}Q+a&XR/}+aQ,`'OR0r,`Q,c'QS0u,c0vR0v,dQ+m&dR0X+mS!eR$uU&a!e&b+VQ&b!fR+V&OQ+d&[R0P+dQ&u!sQ,R&sU,V&u,R0mR0m,WQ'r#iR,n'rQ#m`R'x#mQ#cZU'h#c+Q9qQ+Q9_R9q'uQ-S(_W1d-S1e4j6lU1e-T-U-VS4j1f1gR6l4k$k(U#t&z'O'i(^(f)P)Q)U+v,Y,Z,[,t,}-O-P-X-^-o-p-|.P.o.q0e0n0o0p0q1U1h1i1m1}2W2l2n3O4Y4Z4_4`4a4f4m4q4w4y5O5Z5n6c6d6e6m6q7Y7o7p7q8`8p8z8|8}9O9T9U9V9Y9Z9]:v;W;X;Y;Z;];p;q;rQ-[(fU1l-[1n4nQ1n-^R4n1mQ(q#zR-i(qQ(z$OR-r(zQ2R-|R4z2RQ){$xR.m){Q2p.tS5_2p6|R6|5`Q*W%PR.w*WQ2v.yR5d2vQ/W*bS3[/W5vR5v3^Q._)jW2a._2c5T6wQ2c.bQ5T2bR6w5UQ)o$mR.e)oQ/j*tR3l/jWiOSj!nQ%h}Q)X$]Q*n%cQ*p%fQ*q%gQ*s%iQ/e*oS/h*t/jR3k/gQ$_gQ%l!RQ%o!TQ%q!UQ%s!VQ)v$sQ)|$yQ*d%^Q*{%nQ-h(pS/Z*e*hQ/r*zQ/s*}Q/t+OS0S+j2sQ2f.hQ2k.oQ3U/QQ3`/]Q3j/fY3w0U0V0]0b5fQ5X2hQ5[2lQ5q3VQ5w3_[6U3v3y3}4P4Q7SQ6x5VQ7Z5rQ7`5xW7f6V6[6^6`Q7x6yQ7{6}Q8U7[U8X7g7l7nQ8c7|Q8j8VS8k8Z8_Q8r8dQ8w8mQ9P8sQ9S8yQ9W9QR9[9XQ$gmQ&i!jU)e$h$i$jQ+Z&UU+{&j&k&lQ-`(kS.Z)f)gQ/z+]Q0R+jS0g+|+}Q1q-dQ2Z.[Q3t0QS3z0W0]Q4V0hQ4r1uS6Y3{4QQ7i6ZQ8[7kR8n8^S#ua;^R({$PU$Oa$P;^R-q(yQ#taS&z!w)aQ'O!yQ'i#dQ(^#vQ(f#yQ)P$TQ)Q$UQ)U$YQ+v&gQ,Y9wQ,Z9zQ,[9}Q,t'}Q,}(WQ-O(YQ-P(ZQ-X(bQ-^(hQ-o(wQ-p(xd-|)].R.{2T3Q4}5k6z7W8TQ.P)_Q.o*OQ.q*RQ0e+yQ0n:UQ0o:XQ0p:[Q0q,_Q1U9rQ1h-YQ1i-ZQ1m-]Q1}-wQ2W.TQ2l.pQ2n.sQ3O.}Q4Y:aQ4Z:dQ4_9yQ4`9|Q4a:PQ4f1aQ4m1kQ4q1sQ4w1yQ4y2QQ5O2XQ5Z2jQ5n3SQ6c:^Q6d:WQ6e:ZQ6m4lQ6q4uQ7Y5pQ7o:cQ7p:fQ7q6iQ8`:jQ8p9dQ8z:lQ8|9xQ8}9{Q9O:OQ9T:VQ9U:YQ9V:]Q9Y:bQ9Z:eQ9]:kQ:v;^Q;W;iQ;X;jQ;Y;kQ;Z;lQ;];nQ;p;tQ;q;uR;r;vlgOSj}!n$]%c%f%g%i*o*t/g/jS!pU%eQ%n!SQ%t!WQ'V!|Q'v#kS*h%[%_Q*l%`Q*z%mQ+W&SQ+u&fQ,r'wQ.O)^Q/b*kQ0d+xQ1[,mQ1{-uQ2V.SQ2}.|Q3b/_Q3c/`Q3e/aQ3g/cQ3n/lQ4d1XQ5Y2iQ5m3RQ5|3fQ6O3hQ6P3iQ7X5oR7b5}!vZOSUj}!S!n!|$]%[%_%`%c%e%f%g%i%m&S&f)^*k*o*t+x-u.S.|/_/`/a/c/g/j/l2i3R3f3h3i5o5}Q!_RQ!oTQ$akS%w!]%zQ%}!`Q&y!vQ'Q!zQ'W#PQ'X#QQ'Y#RQ'Z#SQ'[#TQ']#UQ'^#VQ'_#WQ'`#XQ'a#YQ'b#ZQ'd#]Q'g#bQ'k#eW'u#k'w,m1XQ)p$nS+R%x+TS+^&W/{Q+g&_Q,O&pQ,^&}Q,d'RQ,g9^Q,i9`Q,w(RQ-x)VQ/v+XQ/y+[Q0i,PQ0s,bQ0w9cQ0x9eQ0y9fQ0z9gQ0{9hQ0|9iQ0}9jQ1O9kQ1P9lQ1Q9mQ1R9nQ1S9oQ1T,hQ1W9sQ1]9pQ2O-zQ2[.]Q3s:QQ3v0TQ4W0jQ4[0tQ4]:RQ4b:TQ4c:_Q5`2qQ6S3qQ6V3xQ6b:`Q6f:gQ6g:hQ7g6WQ7z6{Q8Z7jQ8m8]Q8y8oQ9_!WR:|;aR!aRR&Y!bS&U!b+`S+]&V&^R0Q+fR'P!yR'S!zT!tU$ZS!sU$ZU$xrs*mS&s!r!uQ,T&tQ,W&wQ.l)zS0k,S,UR4X0l`!dR!]!`$u%x&`)x+hh!qUrs!r!u$Z&t&w)z,S,U0lQ/d*mQ/w+YQ3p/oT:s&W)yT!gR$uS!fR$uS%y!]&`S&O!`)xS+S%x+hT+_&W)yT&]!b$vQ#i^R'{#nT'q#i'rR1Z,lT(a#v(cR(i#yQ-})]Q2U.RQ2|.{Q4{2TQ5l3QQ6t4}Q7U5kQ7y6zQ8S7WR8i8TlhOSj}!n$]%c%f%g%i*o*t/g/jQ%]yR*d%YV$yrs*mR.u*TR*c%WQ$qpR)u$rR)k$lT%az%dT%bz%dT/i*t/j",
  nodeNames: "\u26A0 extends ArithOp ArithOp InterpolationStart LineComment BlockComment Script ExportDeclaration export Star as VariableName String from ; default FunctionDeclaration async function VariableDefinition TypeParamList TypeDefinition ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Interpolation null super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression await yield delete LogicOp BitOp ParenthesizedExpression ClassExpression class extends ClassBody MethodDeclaration Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression PrivatePropertyName BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXStartTag JSXSelfClosingTag JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody MethodDeclaration AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement",
  maxTerm: 332,
  context: trackNewline,
  nodeProps: [
    ["closedBy", 4, "InterpolationEnd", 40, "]", 51, "}", 66, ")", 132, "JSXSelfCloseEndTag JSXEndTag", 146, "JSXEndTag"],
    ["group", -26, 8, 15, 17, 58, 184, 188, 191, 192, 194, 197, 200, 211, 213, 219, 221, 223, 225, 228, 234, 240, 242, 244, 246, 248, 250, 251, "Statement", -30, 12, 13, 24, 27, 28, 41, 43, 44, 45, 47, 52, 60, 68, 74, 75, 91, 92, 101, 103, 119, 122, 124, 125, 126, 127, 129, 130, 148, 149, 151, "Expression", -22, 23, 25, 29, 32, 34, 152, 154, 156, 157, 159, 160, 161, 163, 164, 165, 167, 168, 169, 178, 180, 182, 183, "Type", -3, 79, 85, 90, "ClassItem"],
    ["openedBy", 30, "InterpolationStart", 46, "[", 50, "{", 65, "(", 131, "JSXStartTag", 141, "JSXStartTag JSXStartCloseTag"]
  ],
  propSources: [jsHighlight],
  skippedNodes: [0, 5, 6],
  repeatNodeCount: 28,
  tokenData: "!C}~R!`OX%TXY%cYZ'RZ[%c[]%T]^'R^p%Tpq%cqr'crs(kst0htu2`uv4pvw5ewx6cxy<yyz=Zz{=k{|>k|}?O}!O>k!O!P?`!P!QCl!Q!R!0[!R![!1q![!]!7s!]!^!8V!^!_!8g!_!`!9d!`!a!:[!a!b!<R!b!c%T!c!}2`!}#O!=d#O#P%T#P#Q!=t#Q#R!>U#R#S2`#S#T!>i#T#o2`#o#p!>y#p#q!?O#q#r!?f#r#s!?x#s$f%T$f$g%c$g#BY2`#BY#BZ!@Y#BZ$IS2`$IS$I_!@Y$I_$I|2`$I|$I}!Bq$I}$JO!Bq$JO$JT2`$JT$JU!@Y$JU$KV2`$KV$KW!@Y$KW&FU2`&FU&FV!@Y&FV?HT2`?HT?HU!@Y?HU~2`W%YR$UWO!^%T!_#o%T#p~%T7Z%jg$UW'Y7ROX%TXY%cYZ%TZ[%c[p%Tpq%cq!^%T!_#o%T#p$f%T$f$g%c$g#BY%T#BY#BZ%c#BZ$IS%T$IS$I_%c$I_$JT%T$JT$JU%c$JU$KV%T$KV$KW%c$KW&FU%T&FU&FV%c&FV?HT%T?HT?HU%c?HU~%T7Z'YR$UW'Z7RO!^%T!_#o%T#p~%T$T'jS$UW!j#{O!^%T!_!`'v!`#o%T#p~%T$O'}S#e#v$UWO!^%T!_!`(Z!`#o%T#p~%T$O(bR#e#v$UWO!^%T!_#o%T#p~%T)X(rZ$UW]#eOY(kYZ)eZr(krs*rs!^(k!^!_+U!_#O(k#O#P-b#P#o(k#o#p+U#p~(k&r)jV$UWOr)ers*Ps!^)e!^!_*a!_#o)e#o#p*a#p~)e&r*WR$P&j$UWO!^%T!_#o%T#p~%T&j*dROr*ars*ms~*a&j*rO$P&j)X*{R$P&j$UW]#eO!^%T!_#o%T#p~%T)P+ZV]#eOY+UYZ*aZr+Urs+ps#O+U#O#P+w#P~+U)P+wO$P&j]#e)P+zROr+Urs,Ts~+U)P,[U$P&j]#eOY,nZr,nrs-Vs#O,n#O#P-[#P~,n#e,sU]#eOY,nZr,nrs-Vs#O,n#O#P-[#P~,n#e-[O]#e#e-_PO~,n)X-gV$UWOr(krs-|s!^(k!^!_+U!_#o(k#o#p+U#p~(k)X.VZ$P&j$UW]#eOY.xYZ%TZr.xrs/rs!^.x!^!_,n!_#O.x#O#P0S#P#o.x#o#p,n#p~.x#m/PZ$UW]#eOY.xYZ%TZr.xrs/rs!^.x!^!_,n!_#O.x#O#P0S#P#o.x#o#p,n#p~.x#m/yR$UW]#eO!^%T!_#o%T#p~%T#m0XT$UWO!^.x!^!_,n!_#o.x#o#p,n#p~.x3]0mZ$UWOt%Ttu1`u!^%T!_!c%T!c!}1`!}#R%T#R#S1`#S#T%T#T#o1`#p$g%T$g~1`3]1g]$UW'o3TOt%Ttu1`u!Q%T!Q![1`![!^%T!_!c%T!c!}1`!}#R%T#R#S1`#S#T%T#T#o1`#p$g%T$g~1`7Z2k_$UW#zS']$y'g3SOt%Ttu2`u}%T}!O3j!O!Q%T!Q![2`![!^%T!_!c%T!c!}2`!}#R%T#R#S2`#S#T%T#T#o2`#p$g%T$g~2`[3q_$UW#zSOt%Ttu3ju}%T}!O3j!O!Q%T!Q![3j![!^%T!_!c%T!c!}3j!}#R%T#R#S3j#S#T%T#T#o3j#p$g%T$g~3j$O4wS#^#v$UWO!^%T!_!`5T!`#o%T#p~%T$O5[R$UW#o#vO!^%T!_#o%T#p~%T5b5lU'x5Y$UWOv%Tvw6Ow!^%T!_!`5T!`#o%T#p~%T$O6VS$UW#i#vO!^%T!_!`5T!`#o%T#p~%T)X6jZ$UW]#eOY6cYZ7]Zw6cwx*rx!^6c!^!_8T!_#O6c#O#P:T#P#o6c#o#p8T#p~6c&r7bV$UWOw7]wx*Px!^7]!^!_7w!_#o7]#o#p7w#p~7]&j7zROw7wwx*mx~7w)P8YV]#eOY8TYZ7wZw8Twx+px#O8T#O#P8o#P~8T)P8rROw8Twx8{x~8T)P9SU$P&j]#eOY9fZw9fwx-Vx#O9f#O#P9}#P~9f#e9kU]#eOY9fZw9fwx-Vx#O9f#O#P9}#P~9f#e:QPO~9f)X:YV$UWOw6cwx:ox!^6c!^!_8T!_#o6c#o#p8T#p~6c)X:xZ$P&j$UW]#eOY;kYZ%TZw;kwx/rx!^;k!^!_9f!_#O;k#O#P<e#P#o;k#o#p9f#p~;k#m;rZ$UW]#eOY;kYZ%TZw;kwx/rx!^;k!^!_9f!_#O;k#O#P<e#P#o;k#o#p9f#p~;k#m<jT$UWO!^;k!^!_9f!_#o;k#o#p9f#p~;k&i=QR!d&a$UWO!^%T!_#o%T#p~%Tk=bR!cc$UWO!^%T!_#o%T#p~%T7V=tU'^4V#_#v$UWOz%Tz{>W{!^%T!_!`5T!`#o%T#p~%T$O>_S#[#v$UWO!^%T!_!`5T!`#o%T#p~%T%w>rSj%o$UWO!^%T!_!`5T!`#o%T#p~%T&i?VR!R&a$UWO!^%T!_#o%T#p~%T7Z?gVu5^$UWO!O%T!O!P?|!P!Q%T!Q![@r![!^%T!_#o%T#p~%T!{@RT$UWO!O%T!O!P@b!P!^%T!_#o%T#p~%T!{@iR!Q!s$UWO!^%T!_#o%T#p~%T!{@yZ$UWk!sO!Q%T!Q![@r![!^%T!_!g%T!g!hAl!h#R%T#R#S@r#S#X%T#X#YAl#Y#o%T#p~%T!{AqZ$UWO{%T{|Bd|}%T}!OBd!O!Q%T!Q![CO![!^%T!_#R%T#R#SCO#S#o%T#p~%T!{BiV$UWO!Q%T!Q![CO![!^%T!_#R%T#R#SCO#S#o%T#p~%T!{CVV$UWk!sO!Q%T!Q![CO![!^%T!_#R%T#R#SCO#S#o%T#p~%T7ZCs`$UW#]#vOYDuYZ%TZzDuz{Jl{!PDu!P!Q!-e!Q!^Du!^!_Fx!_!`!.^!`!a!/]!a!}Du!}#OHq#O#PJQ#P#oDu#o#pFx#p~DuXD|[$UW}POYDuYZ%TZ!PDu!P!QEr!Q!^Du!^!_Fx!_!}Du!}#OHq#O#PJQ#P#oDu#o#pFx#p~DuXEy_$UW}PO!^%T!_#Z%T#Z#[Er#[#]%T#]#^Er#^#a%T#a#bEr#b#g%T#g#hEr#h#i%T#i#jEr#j#m%T#m#nEr#n#o%T#p~%TPF}V}POYFxZ!PFx!P!QGd!Q!}Fx!}#OG{#O#PHh#P~FxPGiU}P#Z#[Gd#]#^Gd#a#bGd#g#hGd#i#jGd#m#nGdPHOTOYG{Z#OG{#O#PH_#P#QFx#Q~G{PHbQOYG{Z~G{PHkQOYFxZ~FxXHvY$UWOYHqYZ%TZ!^Hq!^!_G{!_#OHq#O#PIf#P#QDu#Q#oHq#o#pG{#p~HqXIkV$UWOYHqYZ%TZ!^Hq!^!_G{!_#oHq#o#pG{#p~HqXJVV$UWOYDuYZ%TZ!^Du!^!_Fx!_#oDu#o#pFx#p~Du7ZJs^$UW}POYJlYZKoZzJlz{NQ{!PJl!P!Q!,R!Q!^Jl!^!_!!]!_!}Jl!}#O!'|#O#P!+a#P#oJl#o#p!!]#p~Jl7ZKtV$UWOzKoz{LZ{!^Ko!^!_M]!_#oKo#o#pM]#p~Ko7ZL`X$UWOzKoz{LZ{!PKo!P!QL{!Q!^Ko!^!_M]!_#oKo#o#pM]#p~Ko7ZMSR$UWU7RO!^%T!_#o%T#p~%T7RM`ROzM]z{Mi{~M]7RMlTOzM]z{Mi{!PM]!P!QM{!Q~M]7RNQOU7R7ZNX^$UW}POYJlYZKoZzJlz{NQ{!PJl!P!Q! T!Q!^Jl!^!_!!]!_!}Jl!}#O!'|#O#P!+a#P#oJl#o#p!!]#p~Jl7Z! ^_$UWU7R}PO!^%T!_#Z%T#Z#[Er#[#]%T#]#^Er#^#a%T#a#bEr#b#g%T#g#hEr#h#i%T#i#jEr#j#m%T#m#nEr#n#o%T#p~%T7R!!bY}POY!!]YZM]Zz!!]z{!#Q{!P!!]!P!Q!&x!Q!}!!]!}#O!$`#O#P!&f#P~!!]7R!#VY}POY!!]YZM]Zz!!]z{!#Q{!P!!]!P!Q!#u!Q!}!!]!}#O!$`#O#P!&f#P~!!]7R!#|UU7R}P#Z#[Gd#]#^Gd#a#bGd#g#hGd#i#jGd#m#nGd7R!$cWOY!$`YZM]Zz!$`z{!${{#O!$`#O#P!&S#P#Q!!]#Q~!$`7R!%OYOY!$`YZM]Zz!$`z{!${{!P!$`!P!Q!%n!Q#O!$`#O#P!&S#P#Q!!]#Q~!$`7R!%sTU7ROYG{Z#OG{#O#PH_#P#QFx#Q~G{7R!&VTOY!$`YZM]Zz!$`z{!${{~!$`7R!&iTOY!!]YZM]Zz!!]z{!#Q{~!!]7R!&}_}POzM]z{Mi{#ZM]#Z#[!&x#[#]M]#]#^!&x#^#aM]#a#b!&x#b#gM]#g#h!&x#h#iM]#i#j!&x#j#mM]#m#n!&x#n~M]7Z!(R[$UWOY!'|YZKoZz!'|z{!(w{!^!'|!^!_!$`!_#O!'|#O#P!*o#P#QJl#Q#o!'|#o#p!$`#p~!'|7Z!(|^$UWOY!'|YZKoZz!'|z{!(w{!P!'|!P!Q!)x!Q!^!'|!^!_!$`!_#O!'|#O#P!*o#P#QJl#Q#o!'|#o#p!$`#p~!'|7Z!*PY$UWU7ROYHqYZ%TZ!^Hq!^!_G{!_#OHq#O#PIf#P#QDu#Q#oHq#o#pG{#p~Hq7Z!*tX$UWOY!'|YZKoZz!'|z{!(w{!^!'|!^!_!$`!_#o!'|#o#p!$`#p~!'|7Z!+fX$UWOYJlYZKoZzJlz{NQ{!^Jl!^!_!!]!_#oJl#o#p!!]#p~Jl7Z!,Yc$UW}POzKoz{LZ{!^Ko!^!_M]!_#ZKo#Z#[!,R#[#]Ko#]#^!,R#^#aKo#a#b!,R#b#gKo#g#h!,R#h#iKo#i#j!,R#j#mKo#m#n!,R#n#oKo#o#pM]#p~Ko7Z!-lV$UWT7ROY!-eYZ%TZ!^!-e!^!_!.R!_#o!-e#o#p!.R#p~!-e7R!.WQT7ROY!.RZ~!.R$P!.g[$UW#o#v}POYDuYZ%TZ!PDu!P!QEr!Q!^Du!^!_Fx!_!}Du!}#OHq#O#PJQ#P#oDu#o#pFx#p~Du]!/f[#wS$UW}POYDuYZ%TZ!PDu!P!QEr!Q!^Du!^!_Fx!_!}Du!}#OHq#O#PJQ#P#oDu#o#pFx#p~Du!{!0cd$UWk!sO!O%T!O!P@r!P!Q%T!Q![!1q![!^%T!_!g%T!g!hAl!h#R%T#R#S!1q#S#U%T#U#V!3X#V#X%T#X#YAl#Y#b%T#b#c!2w#c#d!4m#d#l%T#l#m!5{#m#o%T#p~%T!{!1x_$UWk!sO!O%T!O!P@r!P!Q%T!Q![!1q![!^%T!_!g%T!g!hAl!h#R%T#R#S!1q#S#X%T#X#YAl#Y#b%T#b#c!2w#c#o%T#p~%T!{!3OR$UWk!sO!^%T!_#o%T#p~%T!{!3^W$UWO!Q%T!Q!R!3v!R!S!3v!S!^%T!_#R%T#R#S!3v#S#o%T#p~%T!{!3}Y$UWk!sO!Q%T!Q!R!3v!R!S!3v!S!^%T!_#R%T#R#S!3v#S#b%T#b#c!2w#c#o%T#p~%T!{!4rV$UWO!Q%T!Q!Y!5X!Y!^%T!_#R%T#R#S!5X#S#o%T#p~%T!{!5`X$UWk!sO!Q%T!Q!Y!5X!Y!^%T!_#R%T#R#S!5X#S#b%T#b#c!2w#c#o%T#p~%T!{!6QZ$UWO!Q%T!Q![!6s![!^%T!_!c%T!c!i!6s!i#R%T#R#S!6s#S#T%T#T#Z!6s#Z#o%T#p~%T!{!6z]$UWk!sO!Q%T!Q![!6s![!^%T!_!c%T!c!i!6s!i#R%T#R#S!6s#S#T%T#T#Z!6s#Z#b%T#b#c!2w#c#o%T#p~%T$u!7|R!]V$UW#m$fO!^%T!_#o%T#p~%T!q!8^R_!i$UWO!^%T!_#o%T#p~%T5w!8rR'bd!a/n#x&s'|P!P!Q!8{!^!_!9Q!_!`!9_W!9QO$WW#v!9VP#`#v!_!`!9Y#v!9_O#o#v#v!9dO#a#v$u!9kT!{$m$UWO!^%T!_!`'v!`!a!9z!a#o%T#p~%T$P!:RR#W#w$UWO!^%T!_#o%T#p~%T%V!:gT'a!R#a#v$RS$UWO!^%T!_!`!:v!`!a!;W!a#o%T#p~%T$O!:}R#a#v$UWO!^%T!_#o%T#p~%T$O!;_T#`#v$UWO!^%T!_!`5T!`!a!;n!a#o%T#p~%T$O!;uS#`#v$UWO!^%T!_!`5T!`#o%T#p~%T*a!<YV'p#{$UWO!O%T!O!P!<o!P!^%T!_!a%T!a!b!=P!b#o%T#p~%T*[!<vRv*S$UWO!^%T!_#o%T#p~%T$O!=WS$UW#j#vO!^%T!_!`5T!`#o%T#p~%T7V!=kRx6}$UWO!^%T!_#o%T#p~%Tk!={R!Oc$UWO!^%T!_#o%T#p~%T$O!>]S#g#v$UWO!^%T!_!`5T!`#o%T#p~%T$a!>pR$UW'f$XO!^%T!_#o%T#p~%T~!?OO!T~5b!?VT'w5Y$UWO!^%T!_!`5T!`#o%T#p#q!=P#q~%T6X!?oR!S5}nQ$UWO!^%T!_#o%T#p~%TX!@PR!kP$UWO!^%T!_#o%T#p~%T7Z!@gr$UW'Y7R#zS']$y'g3SOX%TXY%cYZ%TZ[%c[p%Tpq%cqt%Ttu2`u}%T}!O3j!O!Q%T!Q![2`![!^%T!_!c%T!c!}2`!}#R%T#R#S2`#S#T%T#T#o2`#p$f%T$f$g%c$g#BY2`#BY#BZ!@Y#BZ$IS2`$IS$I_!@Y$I_$JT2`$JT$JU!@Y$JU$KV2`$KV$KW!@Y$KW&FU2`&FU&FV!@Y&FV?HT2`?HT?HU!@Y?HU~2`7Z!CO_$UW'Z7R#zS']$y'g3SOt%Ttu2`u}%T}!O3j!O!Q%T!Q![2`![!^%T!_!c%T!c!}2`!}#R%T#R#S2`#S#T%T#T#o2`#p$g%T$g~2`",
  tokenizers: [tsExtends, noSemicolon, incdecToken, template, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, insertSemicolon],
  topRules: { "Script": [0, 7] },
  dialects: { jsx: 12107, ts: 12109 },
  dynamicPrecedences: { "149": 1, "176": 1 },
  specialized: [{ term: 289, get: (value) => spec_identifier[value] || -1 }, { term: 299, get: (value) => spec_word[value] || -1 }, { term: 63, get: (value) => spec_LessThan[value] || -1 }],
  tokenPrec: 12130
});
class CompletionContext {
  constructor(state, pos, explicit) {
    this.state = state;
    this.pos = pos;
    this.explicit = explicit;
    this.abortListeners = [];
  }
  tokenBefore(types2) {
    let token2 = syntaxTree(this.state).resolveInner(this.pos, -1);
    while (token2 && types2.indexOf(token2.name) < 0)
      token2 = token2.parent;
    return token2 ? {
      from: token2.from,
      to: this.pos,
      text: this.state.sliceDoc(token2.from, this.pos),
      type: token2.type
    } : null;
  }
  matchBefore(expr) {
    let line2 = this.state.doc.lineAt(this.pos);
    let start2 = Math.max(line2.from, this.pos - 250);
    let str = line2.text.slice(start2 - line2.from, this.pos - line2.from);
    let found = str.search(ensureAnchor(expr, false));
    return found < 0 ? null : { from: start2 + found, to: this.pos, text: str.slice(found) };
  }
  get aborted() {
    return this.abortListeners == null;
  }
  addEventListener(type2, listener) {
    if (type2 == "abort" && this.abortListeners)
      this.abortListeners.push(listener);
  }
}
function toSet(chars) {
  let flat = Object.keys(chars).join("");
  let words = /\w/.test(flat);
  if (words)
    flat = flat.replace(/\w/g, "");
  return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
}
function prefixMatch(options2) {
  let first = /* @__PURE__ */ Object.create(null), rest = /* @__PURE__ */ Object.create(null);
  for (let { label } of options2) {
    first[label[0]] = true;
    for (let i = 1; i < label.length; i++)
      rest[label[i]] = true;
  }
  let source = toSet(first) + toSet(rest) + "*$";
  return [new RegExp("^" + source), new RegExp(source)];
}
function completeFromList(list2) {
  let options2 = list2.map((o) => typeof o == "string" ? { label: o } : o);
  let [validFor, match] = options2.every((o) => /^\w+$/.test(o.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options2);
  return (context) => {
    let token2 = context.matchBefore(match);
    return token2 || context.explicit ? { from: token2 ? token2.from : context.pos, options: options2, validFor } : null;
  };
}
function ifNotIn(nodes, source) {
  return (context) => {
    for (let pos = syntaxTree(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent)
      if (nodes.indexOf(pos.name) > -1)
        return null;
    return source(context);
  };
}
class Option {
  constructor(completion, source, match) {
    this.completion = completion;
    this.source = source;
    this.match = match;
  }
}
function cur(state) {
  return state.selection.main.head;
}
function ensureAnchor(expr, start2) {
  var _a2;
  let { source } = expr;
  let addStart = start2 && source[0] != "^", addEnd = source[source.length - 1] != "$";
  if (!addStart && !addEnd)
    return expr;
  return new RegExp(`${addStart ? "^" : ""}(?:${source})${addEnd ? "$" : ""}`, (_a2 = expr.flags) !== null && _a2 !== void 0 ? _a2 : expr.ignoreCase ? "i" : "");
}
function insertCompletionText(state, text2, from2, to2) {
  return Object.assign(Object.assign({}, state.changeByRange((range2) => {
    if (range2 == state.selection.main)
      return {
        changes: { from: from2, to: to2, insert: text2 },
        range: EditorSelection.cursor(from2 + text2.length)
      };
    let len = to2 - from2;
    if (!range2.empty || len && state.sliceDoc(range2.from - len, range2.from) != state.sliceDoc(from2, to2))
      return { range: range2 };
    return {
      changes: { from: range2.from - len, to: range2.from, insert: text2 },
      range: EditorSelection.cursor(range2.from - len + text2.length)
    };
  })), { userEvent: "input.complete" });
}
function applyCompletion(view, option) {
  const apply2 = option.completion.apply || option.completion.label;
  let result = option.source;
  if (typeof apply2 == "string")
    view.dispatch(insertCompletionText(view.state, apply2, result.from, result.to));
  else
    apply2(view, option.completion, result.from, result.to);
}
const SourceCache = /* @__PURE__ */ new WeakMap();
function asSource(source) {
  if (!Array.isArray(source))
    return source;
  let known = SourceCache.get(source);
  if (!known)
    SourceCache.set(source, known = completeFromList(source));
  return known;
}
class FuzzyMatcher {
  constructor(pattern) {
    this.pattern = pattern;
    this.chars = [];
    this.folded = [];
    this.any = [];
    this.precise = [];
    this.byWord = [];
    for (let p = 0; p < pattern.length; ) {
      let char2 = codePointAt(pattern, p), size = codePointSize(char2);
      this.chars.push(char2);
      let part = pattern.slice(p, p + size), upper = part.toUpperCase();
      this.folded.push(codePointAt(upper == part ? part.toLowerCase() : upper, 0));
      p += size;
    }
    this.astral = pattern.length != this.chars.length;
  }
  match(word) {
    if (this.pattern.length == 0)
      return [0];
    if (word.length < this.pattern.length)
      return null;
    let { chars, folded, any, precise, byWord } = this;
    if (chars.length == 1) {
      let first = codePointAt(word, 0);
      return first == chars[0] ? [0, 0, codePointSize(first)] : first == folded[0] ? [-200, 0, codePointSize(first)] : null;
    }
    let direct = word.indexOf(this.pattern);
    if (direct == 0)
      return [0, 0, this.pattern.length];
    let len = chars.length, anyTo = 0;
    if (direct < 0) {
      for (let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len; ) {
        let next2 = codePointAt(word, i);
        if (next2 == chars[anyTo] || next2 == folded[anyTo])
          any[anyTo++] = i;
        i += codePointSize(next2);
      }
      if (anyTo < len)
        return null;
    }
    let preciseTo = 0;
    let byWordTo = 0, byWordFolded = false;
    let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;
    let hasLower = /[a-z]/.test(word), wordAdjacent = true;
    for (let i = 0, e = Math.min(word.length, 200), prevType = 0; i < e && byWordTo < len; ) {
      let next2 = codePointAt(word, i);
      if (direct < 0) {
        if (preciseTo < len && next2 == chars[preciseTo])
          precise[preciseTo++] = i;
        if (adjacentTo < len) {
          if (next2 == chars[adjacentTo] || next2 == folded[adjacentTo]) {
            if (adjacentTo == 0)
              adjacentStart = i;
            adjacentEnd = i + 1;
            adjacentTo++;
          } else {
            adjacentTo = 0;
          }
        }
      }
      let ch, type2 = next2 < 255 ? next2 >= 48 && next2 <= 57 || next2 >= 97 && next2 <= 122 ? 2 : next2 >= 65 && next2 <= 90 ? 1 : 0 : (ch = fromCodePoint(next2)) != ch.toLowerCase() ? 1 : ch != ch.toUpperCase() ? 2 : 0;
      if (!i || type2 == 1 && hasLower || prevType == 0 && type2 != 0) {
        if (chars[byWordTo] == next2 || folded[byWordTo] == next2 && (byWordFolded = true))
          byWord[byWordTo++] = i;
        else if (byWord.length)
          wordAdjacent = false;
      }
      prevType = type2;
      i += codePointSize(next2);
    }
    if (byWordTo == len && byWord[0] == 0 && wordAdjacent)
      return this.result(-100 + (byWordFolded ? -200 : 0), byWord, word);
    if (adjacentTo == len && adjacentStart == 0)
      return [-200 - word.length, 0, adjacentEnd];
    if (direct > -1)
      return [-700 - word.length, direct, direct + this.pattern.length];
    if (adjacentTo == len)
      return [-200 + -700 - word.length, adjacentStart, adjacentEnd];
    if (byWordTo == len)
      return this.result(-100 + (byWordFolded ? -200 : 0) + -700 + (wordAdjacent ? 0 : -1100), byWord, word);
    return chars.length == 2 ? null : this.result((any[0] ? -700 : 0) + -200 + -1100, any, word);
  }
  result(score2, positions, word) {
    let result = [score2 - word.length], i = 1;
    for (let pos of positions) {
      let to2 = pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1);
      if (i > 1 && result[i - 1] == pos)
        result[i - 1] = to2;
      else {
        result[i++] = pos;
        result[i++] = to2;
      }
    }
    return result;
  }
}
const completionConfig = /* @__PURE__ */ Facet.define({
  combine(configs) {
    return combineConfig(configs, {
      activateOnTyping: true,
      selectOnOpen: true,
      override: null,
      closeOnBlur: true,
      maxRenderedOptions: 100,
      defaultKeymap: true,
      optionClass: () => "",
      aboveCursor: false,
      icons: true,
      addToOptions: [],
      compareCompletions: (a2, b) => a2.label.localeCompare(b.label),
      interactionDelay: 75
    }, {
      defaultKeymap: (a2, b) => a2 && b,
      closeOnBlur: (a2, b) => a2 && b,
      icons: (a2, b) => a2 && b,
      optionClass: (a2, b) => (c2) => joinClass(a2(c2), b(c2)),
      addToOptions: (a2, b) => a2.concat(b)
    });
  }
});
function joinClass(a2, b) {
  return a2 ? b ? a2 + " " + b : a2 : b;
}
function optionContent(config2) {
  let content2 = config2.addToOptions.slice();
  if (config2.icons)
    content2.push({
      render(completion) {
        let icon = document.createElement("div");
        icon.classList.add("cm-completionIcon");
        if (completion.type)
          icon.classList.add(...completion.type.split(/\s+/g).map((cls) => "cm-completionIcon-" + cls));
        icon.setAttribute("aria-hidden", "true");
        return icon;
      },
      position: 20
    });
  content2.push({
    render(completion, _s, match) {
      let labelElt = document.createElement("span");
      labelElt.className = "cm-completionLabel";
      let { label } = completion, off = 0;
      for (let j2 = 1; j2 < match.length; ) {
        let from2 = match[j2++], to2 = match[j2++];
        if (from2 > off)
          labelElt.appendChild(document.createTextNode(label.slice(off, from2)));
        let span = labelElt.appendChild(document.createElement("span"));
        span.appendChild(document.createTextNode(label.slice(from2, to2)));
        span.className = "cm-completionMatchedText";
        off = to2;
      }
      if (off < label.length)
        labelElt.appendChild(document.createTextNode(label.slice(off)));
      return labelElt;
    },
    position: 50
  }, {
    render(completion) {
      if (!completion.detail)
        return null;
      let detailElt = document.createElement("span");
      detailElt.className = "cm-completionDetail";
      detailElt.textContent = completion.detail;
      return detailElt;
    },
    position: 80
  });
  return content2.sort((a2, b) => a2.position - b.position).map((a2) => a2.render);
}
function rangeAroundSelected(total, selected, max2) {
  if (total <= max2)
    return { from: 0, to: total };
  if (selected < 0)
    selected = 0;
  if (selected <= total >> 1) {
    let off2 = Math.floor(selected / max2);
    return { from: off2 * max2, to: (off2 + 1) * max2 };
  }
  let off = Math.floor((total - selected) / max2);
  return { from: total - (off + 1) * max2, to: total - off * max2 };
}
class CompletionTooltip {
  constructor(view, stateField) {
    this.view = view;
    this.stateField = stateField;
    this.info = null;
    this.placeInfo = {
      read: () => this.measureInfo(),
      write: (pos) => this.positionInfo(pos),
      key: this
    };
    let cState = view.state.field(stateField);
    let { options: options2, selected } = cState.open;
    let config2 = view.state.facet(completionConfig);
    this.optionContent = optionContent(config2);
    this.optionClass = config2.optionClass;
    this.range = rangeAroundSelected(options2.length, selected, config2.maxRenderedOptions);
    this.dom = document.createElement("div");
    this.dom.className = "cm-tooltip-autocomplete";
    this.dom.addEventListener("mousedown", (e) => {
      for (let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode) {
        if (dom.nodeName == "LI" && (match = /-(\d+)$/.exec(dom.id)) && +match[1] < options2.length) {
          applyCompletion(view, options2[+match[1]]);
          e.preventDefault();
          return;
        }
      }
    });
    this.list = this.dom.appendChild(this.createListBox(options2, cState.id, this.range));
    this.list.addEventListener("scroll", () => {
      if (this.info)
        this.view.requestMeasure(this.placeInfo);
    });
  }
  mount() {
    this.updateSel();
  }
  update(update) {
    if (update.state.field(this.stateField) != update.startState.field(this.stateField))
      this.updateSel();
  }
  positioned() {
    if (this.info)
      this.view.requestMeasure(this.placeInfo);
  }
  updateSel() {
    let cState = this.view.state.field(this.stateField), open = cState.open;
    if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {
      this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
      this.list.remove();
      this.list = this.dom.appendChild(this.createListBox(open.options, cState.id, this.range));
      this.list.addEventListener("scroll", () => {
        if (this.info)
          this.view.requestMeasure(this.placeInfo);
      });
    }
    if (this.updateSelectedOption(open.selected)) {
      if (this.info) {
        this.info.remove();
        this.info = null;
      }
      let { completion } = open.options[open.selected];
      let { info: info2 } = completion;
      if (!info2)
        return;
      let infoResult = typeof info2 === "string" ? document.createTextNode(info2) : info2(completion);
      if (!infoResult)
        return;
      if ("then" in infoResult) {
        infoResult.then((node2) => {
          if (node2 && this.view.state.field(this.stateField, false) == cState)
            this.addInfoPane(node2);
        }).catch((e) => logException(this.view.state, e, "completion info"));
      } else {
        this.addInfoPane(infoResult);
      }
    }
  }
  addInfoPane(content2) {
    let dom = this.info = document.createElement("div");
    dom.className = "cm-tooltip cm-completionInfo";
    dom.appendChild(content2);
    this.dom.appendChild(dom);
    this.view.requestMeasure(this.placeInfo);
  }
  updateSelectedOption(selected) {
    let set2 = null;
    for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {
      if (i == selected) {
        if (!opt.hasAttribute("aria-selected")) {
          opt.setAttribute("aria-selected", "true");
          set2 = opt;
        }
      } else {
        if (opt.hasAttribute("aria-selected"))
          opt.removeAttribute("aria-selected");
      }
    }
    if (set2)
      scrollIntoView(this.list, set2);
    return set2;
  }
  measureInfo() {
    let sel = this.dom.querySelector("[aria-selected]");
    if (!sel || !this.info)
      return null;
    let win = this.dom.ownerDocument.defaultView || window;
    let listRect = this.dom.getBoundingClientRect();
    let infoRect = this.info.getBoundingClientRect();
    let selRect = sel.getBoundingClientRect();
    if (selRect.top > Math.min(win.innerHeight, listRect.bottom) - 10 || selRect.bottom < Math.max(0, listRect.top) + 10)
      return null;
    let rtl = this.view.textDirection == Direction.RTL, left2 = rtl, narrow = false, maxWidth;
    let top2 = "", bottom2 = "";
    let spaceLeft = listRect.left, spaceRight = win.innerWidth - listRect.right;
    if (left2 && spaceLeft < Math.min(infoRect.width, spaceRight))
      left2 = false;
    else if (!left2 && spaceRight < Math.min(infoRect.width, spaceLeft))
      left2 = true;
    if (infoRect.width <= (left2 ? spaceLeft : spaceRight)) {
      top2 = Math.max(0, Math.min(selRect.top, win.innerHeight - infoRect.height)) - listRect.top + "px";
      maxWidth = Math.min(400, left2 ? spaceLeft : spaceRight) + "px";
    } else {
      narrow = true;
      maxWidth = Math.min(400, (rtl ? listRect.right : win.innerWidth - listRect.left) - 30) + "px";
      let spaceBelow = win.innerHeight - listRect.bottom;
      if (spaceBelow >= infoRect.height || spaceBelow > listRect.top)
        top2 = selRect.bottom - listRect.top + "px";
      else
        bottom2 = listRect.bottom - selRect.top + "px";
    }
    return {
      top: top2,
      bottom: bottom2,
      maxWidth,
      class: narrow ? rtl ? "left-narrow" : "right-narrow" : left2 ? "left" : "right"
    };
  }
  positionInfo(pos) {
    if (this.info) {
      if (pos) {
        this.info.style.top = pos.top;
        this.info.style.bottom = pos.bottom;
        this.info.style.maxWidth = pos.maxWidth;
        this.info.className = "cm-tooltip cm-completionInfo cm-completionInfo-" + pos.class;
      } else {
        this.info.style.top = "-1e6px";
      }
    }
  }
  createListBox(options2, id2, range2) {
    const ul = document.createElement("ul");
    ul.id = id2;
    ul.setAttribute("role", "listbox");
    ul.setAttribute("aria-expanded", "true");
    ul.setAttribute("aria-label", this.view.state.phrase("Completions"));
    for (let i = range2.from; i < range2.to; i++) {
      let { completion, match } = options2[i];
      const li = ul.appendChild(document.createElement("li"));
      li.id = id2 + "-" + i;
      li.setAttribute("role", "option");
      let cls = this.optionClass(completion);
      if (cls)
        li.className = cls;
      for (let source of this.optionContent) {
        let node2 = source(completion, this.view.state, match);
        if (node2)
          li.appendChild(node2);
      }
    }
    if (range2.from)
      ul.classList.add("cm-completionListIncompleteTop");
    if (range2.to < options2.length)
      ul.classList.add("cm-completionListIncompleteBottom");
    return ul;
  }
}
function completionTooltip(stateField) {
  return (view) => new CompletionTooltip(view, stateField);
}
function scrollIntoView(container, element) {
  let parent = container.getBoundingClientRect();
  let self2 = element.getBoundingClientRect();
  if (self2.top < parent.top)
    container.scrollTop -= parent.top - self2.top;
  else if (self2.bottom > parent.bottom)
    container.scrollTop += self2.bottom - parent.bottom;
}
function score$1(option) {
  return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) + (option.type ? 1 : 0);
}
function sortOptions(active2, state) {
  let options2 = [], i = 0;
  for (let a2 of active2)
    if (a2.hasResult()) {
      if (a2.result.filter === false) {
        let getMatch = a2.result.getMatch;
        for (let option of a2.result.options) {
          let match = [1e9 - i++];
          if (getMatch)
            for (let n of getMatch(option))
              match.push(n);
          options2.push(new Option(option, a2, match));
        }
      } else {
        let matcher2 = new FuzzyMatcher(state.sliceDoc(a2.from, a2.to)), match;
        for (let option of a2.result.options)
          if (match = matcher2.match(option.label)) {
            if (option.boost != null)
              match[0] += option.boost;
            options2.push(new Option(option, a2, match));
          }
      }
    }
  let result = [], prev2 = null;
  let compare2 = state.facet(completionConfig).compareCompletions;
  for (let opt of options2.sort((a2, b) => b.match[0] - a2.match[0] || compare2(a2.completion, b.completion))) {
    if (!prev2 || prev2.label != opt.completion.label || prev2.detail != opt.completion.detail || prev2.type != null && opt.completion.type != null && prev2.type != opt.completion.type || prev2.apply != opt.completion.apply)
      result.push(opt);
    else if (score$1(opt.completion) > score$1(prev2))
      result[result.length - 1] = opt;
    prev2 = opt.completion;
  }
  return result;
}
class CompletionDialog {
  constructor(options2, attrs, tooltip, timestamp, selected) {
    this.options = options2;
    this.attrs = attrs;
    this.tooltip = tooltip;
    this.timestamp = timestamp;
    this.selected = selected;
  }
  setSelected(selected, id2) {
    return selected == this.selected || selected >= this.options.length ? this : new CompletionDialog(this.options, makeAttrs(id2, selected), this.tooltip, this.timestamp, selected);
  }
  static build(active2, state, id2, prev2, conf2) {
    let options2 = sortOptions(active2, state);
    if (!options2.length)
      return null;
    let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;
    if (prev2 && prev2.selected != selected && prev2.selected != -1) {
      let selectedValue = prev2.options[prev2.selected].completion;
      for (let i = 0; i < options2.length; i++)
        if (options2[i].completion == selectedValue) {
          selected = i;
          break;
        }
    }
    return new CompletionDialog(options2, makeAttrs(id2, selected), {
      pos: active2.reduce((a2, b) => b.hasResult() ? Math.min(a2, b.from) : a2, 1e8),
      create: completionTooltip(completionState),
      above: conf2.aboveCursor
    }, prev2 ? prev2.timestamp : Date.now(), selected);
  }
  map(changes) {
    return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: changes.mapPos(this.tooltip.pos) }), this.timestamp, this.selected);
  }
}
class CompletionState {
  constructor(active2, id2, open) {
    this.active = active2;
    this.id = id2;
    this.open = open;
  }
  static start() {
    return new CompletionState(none$3, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(tr) {
    let { state } = tr, conf2 = state.facet(completionConfig);
    let sources = conf2.override || state.languageDataAt("autocomplete", cur(state)).map(asSource);
    let active2 = sources.map((source) => {
      let value = this.active.find((s2) => s2.source == source) || new ActiveSource(source, this.active.some((a2) => a2.state != 0) ? 1 : 0);
      return value.update(tr, conf2);
    });
    if (active2.length == this.active.length && active2.every((a2, i) => a2 == this.active[i]))
      active2 = this.active;
    let open = tr.selection || active2.some((a2) => a2.hasResult() && tr.changes.touchesRange(a2.from, a2.to)) || !sameResults(active2, this.active) ? CompletionDialog.build(active2, state, this.id, this.open, conf2) : this.open && tr.docChanged ? this.open.map(tr.changes) : this.open;
    if (!open && active2.every((a2) => a2.state != 1) && active2.some((a2) => a2.hasResult()))
      active2 = active2.map((a2) => a2.hasResult() ? new ActiveSource(a2.source, 0) : a2);
    for (let effect of tr.effects)
      if (effect.is(setSelectedEffect))
        open = open && open.setSelected(effect.value, this.id);
    return active2 == this.active && open == this.open ? this : new CompletionState(active2, this.id, open);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : baseAttrs;
  }
}
function sameResults(a2, b) {
  if (a2 == b)
    return true;
  for (let iA = 0, iB = 0; ; ) {
    while (iA < a2.length && !a2[iA].hasResult)
      iA++;
    while (iB < b.length && !b[iB].hasResult)
      iB++;
    let endA = iA == a2.length, endB = iB == b.length;
    if (endA || endB)
      return endA == endB;
    if (a2[iA++].result != b[iB++].result)
      return false;
  }
}
const baseAttrs = {
  "aria-autocomplete": "list"
};
function makeAttrs(id2, selected) {
  let result = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": id2
  };
  if (selected > -1)
    result["aria-activedescendant"] = id2 + "-" + selected;
  return result;
}
const none$3 = [];
function getUserEvent(tr) {
  return tr.isUserEvent("input.type") ? "input" : tr.isUserEvent("delete.backward") ? "delete" : null;
}
class ActiveSource {
  constructor(source, state, explicitPos = -1) {
    this.source = source;
    this.state = state;
    this.explicitPos = explicitPos;
  }
  hasResult() {
    return false;
  }
  update(tr, conf2) {
    let event2 = getUserEvent(tr), value = this;
    if (event2)
      value = value.handleUserEvent(tr, event2, conf2);
    else if (tr.docChanged)
      value = value.handleChange(tr);
    else if (tr.selection && value.state != 0)
      value = new ActiveSource(value.source, 0);
    for (let effect of tr.effects) {
      if (effect.is(startCompletionEffect))
        value = new ActiveSource(value.source, 1, effect.value ? cur(tr.state) : -1);
      else if (effect.is(closeCompletionEffect))
        value = new ActiveSource(value.source, 0);
      else if (effect.is(setActiveEffect)) {
        for (let active2 of effect.value)
          if (active2.source == value.source)
            value = active2;
      }
    }
    return value;
  }
  handleUserEvent(tr, type2, conf2) {
    return type2 == "delete" || !conf2.activateOnTyping ? this.map(tr.changes) : new ActiveSource(this.source, 1);
  }
  handleChange(tr) {
    return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0) : this.map(tr.changes);
  }
  map(changes) {
    return changes.empty || this.explicitPos < 0 ? this : new ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));
  }
}
class ActiveResult extends ActiveSource {
  constructor(source, explicitPos, result, from2, to2) {
    super(source, 2, explicitPos);
    this.result = result;
    this.from = from2;
    this.to = to2;
  }
  hasResult() {
    return true;
  }
  handleUserEvent(tr, type2, conf2) {
    var _a2;
    let from2 = tr.changes.mapPos(this.from), to2 = tr.changes.mapPos(this.to, 1);
    let pos = cur(tr.state);
    if ((this.explicitPos < 0 ? pos <= from2 : pos < this.from) || pos > to2 || type2 == "delete" && cur(tr.startState) == this.from)
      return new ActiveSource(this.source, type2 == "input" && conf2.activateOnTyping ? 1 : 0);
    let explicitPos = this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos), updated;
    if (checkValid(this.result.validFor, tr.state, from2, to2))
      return new ActiveResult(this.source, explicitPos, this.result, from2, to2);
    if (this.result.update && (updated = this.result.update(this.result, from2, to2, new CompletionContext(tr.state, pos, explicitPos >= 0))))
      return new ActiveResult(this.source, explicitPos, updated, updated.from, (_a2 = updated.to) !== null && _a2 !== void 0 ? _a2 : cur(tr.state));
    return new ActiveSource(this.source, 1, explicitPos);
  }
  handleChange(tr) {
    return tr.changes.touchesRange(this.from, this.to) ? new ActiveSource(this.source, 0) : this.map(tr.changes);
  }
  map(mapping) {
    return mapping.empty ? this : new ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));
  }
}
function checkValid(validFor, state, from2, to2) {
  if (!validFor)
    return false;
  let text2 = state.sliceDoc(from2, to2);
  return typeof validFor == "function" ? validFor(text2, from2, to2, state) : ensureAnchor(validFor, true).test(text2);
}
const startCompletionEffect = /* @__PURE__ */ StateEffect.define();
const closeCompletionEffect = /* @__PURE__ */ StateEffect.define();
const setActiveEffect = /* @__PURE__ */ StateEffect.define({
  map(sources, mapping) {
    return sources.map((s2) => s2.map(mapping));
  }
});
const setSelectedEffect = /* @__PURE__ */ StateEffect.define();
const completionState = /* @__PURE__ */ StateField.define({
  create() {
    return CompletionState.start();
  },
  update(value, tr) {
    return value.update(tr);
  },
  provide: (f2) => [
    showTooltip.from(f2, (val) => val.tooltip),
    EditorView.contentAttributes.from(f2, (state) => state.attrs)
  ]
});
function moveCompletionSelection(forward, by = "option") {
  return (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState || !cState.open || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
      return false;
    let step2 = 1, tooltip;
    if (by == "page" && (tooltip = getTooltip$2(view, cState.open.tooltip)))
      step2 = Math.max(2, Math.floor(tooltip.dom.offsetHeight / tooltip.dom.querySelector("li").offsetHeight) - 1);
    let { length: length2 } = cState.open.options;
    let selected = cState.open.selected > -1 ? cState.open.selected + step2 * (forward ? 1 : -1) : forward ? 0 : length2 - 1;
    if (selected < 0)
      selected = by == "page" ? 0 : length2 - 1;
    else if (selected >= length2)
      selected = by == "page" ? length2 - 1 : 0;
    view.dispatch({ effects: setSelectedEffect.of(selected) });
    return true;
  };
}
const acceptCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
    return false;
  applyCompletion(view, cState.open.options[cState.open.selected]);
  return true;
};
const startCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (!cState)
    return false;
  view.dispatch({ effects: startCompletionEffect.of(true) });
  return true;
};
const closeCompletion = (view) => {
  let cState = view.state.field(completionState, false);
  if (!cState || !cState.active.some((a2) => a2.state != 0))
    return false;
  view.dispatch({ effects: closeCompletionEffect.of(null) });
  return true;
};
class RunningQuery {
  constructor(active2, context) {
    this.active = active2;
    this.context = context;
    this.time = Date.now();
    this.updates = [];
    this.done = void 0;
  }
}
const DebounceTime = 50, MaxUpdateCount = 50, MinAbortTime = 1e3;
const completionPlugin = /* @__PURE__ */ ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.debounceUpdate = -1;
    this.running = [];
    this.debounceAccept = -1;
    this.composing = 0;
    for (let active2 of view.state.field(completionState).active)
      if (active2.state == 1)
        this.startQuery(active2);
  }
  update(update) {
    let cState = update.state.field(completionState);
    if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState)
      return;
    let doesReset = update.transactions.some((tr) => {
      return (tr.selection || tr.docChanged) && !getUserEvent(tr);
    });
    for (let i = 0; i < this.running.length; i++) {
      let query = this.running[i];
      if (doesReset || query.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {
        for (let handler of query.context.abortListeners) {
          try {
            handler();
          } catch (e) {
            logException(this.view.state, e);
          }
        }
        query.context.abortListeners = null;
        this.running.splice(i--, 1);
      } else {
        query.updates.push(...update.transactions);
      }
    }
    if (this.debounceUpdate > -1)
      clearTimeout(this.debounceUpdate);
    this.debounceUpdate = cState.active.some((a2) => a2.state == 1 && !this.running.some((q) => q.active.source == a2.source)) ? setTimeout(() => this.startUpdate(), DebounceTime) : -1;
    if (this.composing != 0)
      for (let tr of update.transactions) {
        if (getUserEvent(tr) == "input")
          this.composing = 2;
        else if (this.composing == 2 && tr.selection)
          this.composing = 3;
      }
  }
  startUpdate() {
    this.debounceUpdate = -1;
    let { state } = this.view, cState = state.field(completionState);
    for (let active2 of cState.active) {
      if (active2.state == 1 && !this.running.some((r) => r.active.source == active2.source))
        this.startQuery(active2);
    }
  }
  startQuery(active2) {
    let { state } = this.view, pos = cur(state);
    let context = new CompletionContext(state, pos, active2.explicitPos == pos);
    let pending = new RunningQuery(active2, context);
    this.running.push(pending);
    Promise.resolve(active2.source(context)).then((result) => {
      if (!pending.context.aborted) {
        pending.done = result || null;
        this.scheduleAccept();
      }
    }, (err) => {
      this.view.dispatch({ effects: closeCompletionEffect.of(null) });
      logException(this.view.state, err);
    });
  }
  scheduleAccept() {
    if (this.running.every((q) => q.done !== void 0))
      this.accept();
    else if (this.debounceAccept < 0)
      this.debounceAccept = setTimeout(() => this.accept(), DebounceTime);
  }
  accept() {
    var _a2;
    if (this.debounceAccept > -1)
      clearTimeout(this.debounceAccept);
    this.debounceAccept = -1;
    let updated = [];
    let conf2 = this.view.state.facet(completionConfig);
    for (let i = 0; i < this.running.length; i++) {
      let query = this.running[i];
      if (query.done === void 0)
        continue;
      this.running.splice(i--, 1);
      if (query.done) {
        let active2 = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, (_a2 = query.done.to) !== null && _a2 !== void 0 ? _a2 : cur(query.updates.length ? query.updates[0].startState : this.view.state));
        for (let tr of query.updates)
          active2 = active2.update(tr, conf2);
        if (active2.hasResult()) {
          updated.push(active2);
          continue;
        }
      }
      let current = this.view.state.field(completionState).active.find((a2) => a2.source == query.active.source);
      if (current && current.state == 1) {
        if (query.done == null) {
          let active2 = new ActiveSource(query.active.source, 0);
          for (let tr of query.updates)
            active2 = active2.update(tr, conf2);
          if (active2.state != 1)
            updated.push(active2);
        } else {
          this.startQuery(current);
        }
      }
    }
    if (updated.length)
      this.view.dispatch({ effects: setActiveEffect.of(updated) });
  }
}, {
  eventHandlers: {
    blur() {
      let state = this.view.state.field(completionState, false);
      if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur)
        this.view.dispatch({ effects: closeCompletionEffect.of(null) });
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      if (this.composing == 3) {
        setTimeout(() => this.view.dispatch({ effects: startCompletionEffect.of(false) }), 20);
      }
      this.composing = 0;
    }
  }
});
const baseTheme = /* @__PURE__ */ EditorView.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer",
        padding: "1px 3px",
        lineHeight: 1.2
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"\xB7\xB7\xB7"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: `${400}px`,
    boxSizing: "border-box"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: `${30}px` },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: `${30}px` },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'\u0192'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'\u25CB'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'\u25CC'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'\u{1D465}'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'\u{1D436}'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'\u{1D461}'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'\u222A'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'\u25A1'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'\u{1F511}\uFE0E'" }
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'\u25A2'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class FieldPos {
  constructor(field, line2, from2, to2) {
    this.field = field;
    this.line = line2;
    this.from = from2;
    this.to = to2;
  }
}
class FieldRange {
  constructor(field, from2, to2) {
    this.field = field;
    this.from = from2;
    this.to = to2;
  }
  map(changes) {
    let from2 = changes.mapPos(this.from, -1, MapMode.TrackDel);
    let to2 = changes.mapPos(this.to, 1, MapMode.TrackDel);
    return from2 == null || to2 == null ? null : new FieldRange(this.field, from2, to2);
  }
}
class Snippet {
  constructor(lines, fieldPositions) {
    this.lines = lines;
    this.fieldPositions = fieldPositions;
  }
  instantiate(state, pos) {
    let text2 = [], lineStart = [pos];
    let lineObj = state.doc.lineAt(pos), baseIndent = /^\s*/.exec(lineObj.text)[0];
    for (let line2 of this.lines) {
      if (text2.length) {
        let indent = baseIndent, tabs = /^\t*/.exec(line2)[0].length;
        for (let i = 0; i < tabs; i++)
          indent += state.facet(indentUnit);
        lineStart.push(pos + indent.length - tabs);
        line2 = indent + line2.slice(tabs);
      }
      text2.push(line2);
      pos += line2.length + 1;
    }
    let ranges2 = this.fieldPositions.map((pos2) => new FieldRange(pos2.field, lineStart[pos2.line] + pos2.from, lineStart[pos2.line] + pos2.to));
    return { text: text2, ranges: ranges2 };
  }
  static parse(template2) {
    let fields = [];
    let lines = [], positions = [], m;
    for (let line2 of template2.split(/\r\n?|\n/)) {
      while (m = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(line2)) {
        let seq2 = m[1] ? +m[1] : null, name2 = m[2] || m[3] || "", found = -1;
        for (let i = 0; i < fields.length; i++) {
          if (seq2 != null ? fields[i].seq == seq2 : name2 ? fields[i].name == name2 : false)
            found = i;
        }
        if (found < 0) {
          let i = 0;
          while (i < fields.length && (seq2 == null || fields[i].seq != null && fields[i].seq < seq2))
            i++;
          fields.splice(i, 0, { seq: seq2, name: name2 });
          found = i;
          for (let pos of positions)
            if (pos.field >= found)
              pos.field++;
        }
        positions.push(new FieldPos(found, lines.length, m.index, m.index + name2.length));
        line2 = line2.slice(0, m.index) + name2 + line2.slice(m.index + m[0].length);
      }
      for (let esc; esc = /([$#])\\{/.exec(line2); ) {
        line2 = line2.slice(0, esc.index) + esc[1] + "{" + line2.slice(esc.index + esc[0].length);
        for (let pos of positions)
          if (pos.line == lines.length && pos.from > esc.index) {
            pos.from--;
            pos.to--;
          }
      }
      lines.push(line2);
    }
    return new Snippet(lines, positions);
  }
}
let fieldMarker = /* @__PURE__ */ Decoration.widget({ widget: /* @__PURE__ */ new class extends WidgetType {
  toDOM() {
    let span = document.createElement("span");
    span.className = "cm-snippetFieldPosition";
    return span;
  }
  ignoreEvent() {
    return false;
  }
}() });
let fieldRange = /* @__PURE__ */ Decoration.mark({ class: "cm-snippetField" });
class ActiveSnippet {
  constructor(ranges2, active2) {
    this.ranges = ranges2;
    this.active = active2;
    this.deco = Decoration.set(ranges2.map((r) => (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)));
  }
  map(changes) {
    let ranges2 = [];
    for (let r of this.ranges) {
      let mapped = r.map(changes);
      if (!mapped)
        return null;
      ranges2.push(mapped);
    }
    return new ActiveSnippet(ranges2, this.active);
  }
  selectionInsideField(sel) {
    return sel.ranges.every((range2) => this.ranges.some((r) => r.field == this.active && r.from <= range2.from && r.to >= range2.to));
  }
}
const setActive = /* @__PURE__ */ StateEffect.define({
  map(value, changes) {
    return value && value.map(changes);
  }
});
const moveToField = /* @__PURE__ */ StateEffect.define();
const snippetState = /* @__PURE__ */ StateField.define({
  create() {
    return null;
  },
  update(value, tr) {
    for (let effect of tr.effects) {
      if (effect.is(setActive))
        return effect.value;
      if (effect.is(moveToField) && value)
        return new ActiveSnippet(value.ranges, effect.value);
    }
    if (value && tr.docChanged)
      value = value.map(tr.changes);
    if (value && tr.selection && !value.selectionInsideField(tr.selection))
      value = null;
    return value;
  },
  provide: (f2) => EditorView.decorations.from(f2, (val) => val ? val.deco : Decoration.none)
});
function fieldSelection(ranges2, field) {
  return EditorSelection.create(ranges2.filter((r) => r.field == field).map((r) => EditorSelection.range(r.from, r.to)));
}
function snippet(template2) {
  let snippet2 = Snippet.parse(template2);
  return (editor, _completion, from2, to2) => {
    let { text: text2, ranges: ranges2 } = snippet2.instantiate(editor.state, from2);
    let spec = {
      changes: { from: from2, to: to2, insert: Text.of(text2) },
      scrollIntoView: true
    };
    if (ranges2.length)
      spec.selection = fieldSelection(ranges2, 0);
    if (ranges2.length > 1) {
      let active2 = new ActiveSnippet(ranges2, 0);
      let effects = spec.effects = [setActive.of(active2)];
      if (editor.state.field(snippetState, false) === void 0)
        effects.push(StateEffect.appendConfig.of([snippetState, addSnippetKeymap, snippetPointerHandler, baseTheme]));
    }
    editor.dispatch(editor.state.update(spec));
  };
}
function moveField(dir) {
  return ({ state, dispatch: dispatch2 }) => {
    let active2 = state.field(snippetState, false);
    if (!active2 || dir < 0 && active2.active == 0)
      return false;
    let next2 = active2.active + dir, last = dir > 0 && !active2.ranges.some((r) => r.field == next2 + dir);
    dispatch2(state.update({
      selection: fieldSelection(active2.ranges, next2),
      effects: setActive.of(last ? null : new ActiveSnippet(active2.ranges, next2))
    }));
    return true;
  };
}
const clearSnippet = ({ state, dispatch: dispatch2 }) => {
  let active2 = state.field(snippetState, false);
  if (!active2)
    return false;
  dispatch2(state.update({ effects: setActive.of(null) }));
  return true;
};
const nextSnippetField = /* @__PURE__ */ moveField(1);
const prevSnippetField = /* @__PURE__ */ moveField(-1);
const defaultSnippetKeymap = [
  { key: "Tab", run: nextSnippetField, shift: prevSnippetField },
  { key: "Escape", run: clearSnippet }
];
const snippetKeymap = /* @__PURE__ */ Facet.define({
  combine(maps) {
    return maps.length ? maps[0] : defaultSnippetKeymap;
  }
});
const addSnippetKeymap = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ keymap.compute([snippetKeymap], (state) => state.facet(snippetKeymap)));
function snippetCompletion(template2, completion) {
  return Object.assign(Object.assign({}, completion), { apply: snippet(template2) });
}
const snippetPointerHandler = /* @__PURE__ */ EditorView.domEventHandlers({
  mousedown(event2, view) {
    let active2 = view.state.field(snippetState, false), pos;
    if (!active2 || (pos = view.posAtCoords({ x: event2.clientX, y: event2.clientY })) == null)
      return false;
    let match = active2.ranges.find((r) => r.from <= pos && r.to >= pos);
    if (!match || match.field == active2.active)
      return false;
    view.dispatch({
      selection: fieldSelection(active2.ranges, match.field),
      effects: setActive.of(active2.ranges.some((r) => r.field > match.field) ? new ActiveSnippet(active2.ranges, match.field) : null)
    });
    return true;
  }
});
const defaults = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
};
const closeBracketEffect = /* @__PURE__ */ StateEffect.define({
  map(value, mapping) {
    let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);
    return mapped == null ? void 0 : mapped;
  }
});
const skipBracketEffect = /* @__PURE__ */ StateEffect.define({
  map(value, mapping) {
    return mapping.mapPos(value);
  }
});
const closedBracket = /* @__PURE__ */ new class extends RangeValue {
}();
closedBracket.startSide = 1;
closedBracket.endSide = -1;
const bracketState = /* @__PURE__ */ StateField.define({
  create() {
    return RangeSet.empty;
  },
  update(value, tr) {
    if (tr.selection) {
      let lineStart = tr.state.doc.lineAt(tr.selection.main.head).from;
      let prevLineStart = tr.startState.doc.lineAt(tr.startState.selection.main.head).from;
      if (lineStart != tr.changes.mapPos(prevLineStart, -1))
        value = RangeSet.empty;
    }
    value = value.map(tr.changes);
    for (let effect of tr.effects) {
      if (effect.is(closeBracketEffect))
        value = value.update({ add: [closedBracket.range(effect.value, effect.value + 1)] });
      else if (effect.is(skipBracketEffect))
        value = value.update({ filter: (from2) => from2 != effect.value });
    }
    return value;
  }
});
function closeBrackets() {
  return [inputHandler, bracketState];
}
const definedClosing = "()[]{}<>";
function closing(ch) {
  for (let i = 0; i < definedClosing.length; i += 2)
    if (definedClosing.charCodeAt(i) == ch)
      return definedClosing.charAt(i + 1);
  return fromCodePoint(ch < 128 ? ch : ch + 1);
}
function config$2(state, pos) {
  return state.languageDataAt("closeBrackets", pos)[0] || defaults;
}
const android$1 = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent);
const inputHandler = /* @__PURE__ */ EditorView.inputHandler.of((view, from2, to2, insert2) => {
  if ((android$1 ? view.composing : view.compositionStarted) || view.state.readOnly)
    return false;
  let sel = view.state.selection.main;
  if (insert2.length > 2 || insert2.length == 2 && codePointSize(codePointAt(insert2, 0)) == 1 || from2 != sel.from || to2 != sel.to)
    return false;
  let tr = insertBracket(view.state, insert2);
  if (!tr)
    return false;
  view.dispatch(tr);
  return true;
});
function insertBracket(state, bracket2) {
  let conf2 = config$2(state, state.selection.main.head);
  let tokens = conf2.brackets || defaults.brackets;
  for (let tok of tokens) {
    let closed = closing(codePointAt(tok, 0));
    if (bracket2 == tok)
      return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf2) : handleOpen(state, tok, closed, conf2.before || defaults.before);
    if (bracket2 == closed && closedBracketAt(state, state.selection.main.from))
      return handleClose(state, tok, closed);
  }
  return null;
}
function closedBracketAt(state, pos) {
  let found = false;
  state.field(bracketState).between(0, state.doc.length, (from2) => {
    if (from2 == pos)
      found = true;
  });
  return found;
}
function nextChar(doc2, pos) {
  let next2 = doc2.sliceString(pos, pos + 2);
  return next2.slice(0, codePointSize(codePointAt(next2, 0)));
}
function handleOpen(state, open, close, closeBefore) {
  let dont = null, changes = state.changeByRange((range2) => {
    if (!range2.empty)
      return {
        changes: [{ insert: open, from: range2.from }, { insert: close, from: range2.to }],
        effects: closeBracketEffect.of(range2.to + open.length),
        range: EditorSelection.range(range2.anchor + open.length, range2.head + open.length)
      };
    let next2 = nextChar(state.doc, range2.head);
    if (!next2 || /\s/.test(next2) || closeBefore.indexOf(next2) > -1)
      return {
        changes: { insert: open + close, from: range2.head },
        effects: closeBracketEffect.of(range2.head + open.length),
        range: EditorSelection.cursor(range2.head + open.length)
      };
    return { range: dont = range2 };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function handleClose(state, _open, close) {
  let dont = null, moved = state.selection.ranges.map((range2) => {
    if (range2.empty && nextChar(state.doc, range2.head) == close)
      return EditorSelection.cursor(range2.head + close.length);
    return dont = range2;
  });
  return dont ? null : state.update({
    selection: EditorSelection.create(moved, state.selection.mainIndex),
    scrollIntoView: true,
    effects: state.selection.ranges.map(({ from: from2 }) => skipBracketEffect.of(from2))
  });
}
function handleSame(state, token2, allowTriple, config2) {
  let stringPrefixes = config2.stringPrefixes || defaults.stringPrefixes;
  let dont = null, changes = state.changeByRange((range2) => {
    if (!range2.empty)
      return {
        changes: [{ insert: token2, from: range2.from }, { insert: token2, from: range2.to }],
        effects: closeBracketEffect.of(range2.to + token2.length),
        range: EditorSelection.range(range2.anchor + token2.length, range2.head + token2.length)
      };
    let pos = range2.head, next2 = nextChar(state.doc, pos), start2;
    if (next2 == token2) {
      if (nodeStart$1(state, pos)) {
        return {
          changes: { insert: token2 + token2, from: pos },
          effects: closeBracketEffect.of(pos + token2.length),
          range: EditorSelection.cursor(pos + token2.length)
        };
      } else if (closedBracketAt(state, pos)) {
        let isTriple = allowTriple && state.sliceDoc(pos, pos + token2.length * 3) == token2 + token2 + token2;
        return {
          range: EditorSelection.cursor(pos + token2.length * (isTriple ? 3 : 1)),
          effects: skipBracketEffect.of(pos)
        };
      }
    } else if (allowTriple && state.sliceDoc(pos - 2 * token2.length, pos) == token2 + token2 && (start2 = canStartStringAt(state, pos - 2 * token2.length, stringPrefixes)) > -1 && nodeStart$1(state, start2)) {
      return {
        changes: { insert: token2 + token2 + token2 + token2, from: pos },
        effects: closeBracketEffect.of(pos + token2.length),
        range: EditorSelection.cursor(pos + token2.length)
      };
    } else if (state.charCategorizer(pos)(next2) != CharCategory.Word) {
      if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token2, stringPrefixes))
        return {
          changes: { insert: token2 + token2, from: pos },
          effects: closeBracketEffect.of(pos + token2.length),
          range: EditorSelection.cursor(pos + token2.length)
        };
    }
    return { range: dont = range2 };
  });
  return dont ? null : state.update(changes, {
    scrollIntoView: true,
    userEvent: "input.type"
  });
}
function nodeStart$1(state, pos) {
  let tree2 = syntaxTree(state).resolveInner(pos + 1);
  return tree2.parent && tree2.from == pos;
}
function probablyInString(state, pos, quoteToken, prefixes2) {
  let node2 = syntaxTree(state).resolveInner(pos, -1);
  let maxPrefix = prefixes2.reduce((m, p) => Math.max(m, p.length), 0);
  for (let i = 0; i < 5; i++) {
    let start2 = state.sliceDoc(node2.from, Math.min(node2.to, node2.from + quoteToken.length + maxPrefix));
    let quotePos = start2.indexOf(quoteToken);
    if (!quotePos || quotePos > -1 && prefixes2.indexOf(start2.slice(0, quotePos)) > -1) {
      let first = node2.firstChild;
      while (first && first.from == node2.from && first.to - first.from > quoteToken.length + quotePos) {
        if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken)
          return false;
        first = first.firstChild;
      }
      return true;
    }
    let parent = node2.to == pos && node2.parent;
    if (!parent)
      break;
    node2 = parent;
  }
  return false;
}
function canStartStringAt(state, pos, prefixes2) {
  let charCat = state.charCategorizer(pos);
  if (charCat(state.sliceDoc(pos - 1, pos)) != CharCategory.Word)
    return pos;
  for (let prefix2 of prefixes2) {
    let start2 = pos - prefix2.length;
    if (state.sliceDoc(start2, pos) == prefix2 && charCat(state.sliceDoc(start2 - 1, start2)) != CharCategory.Word)
      return start2;
  }
  return -1;
}
function autocompletion(config2 = {}) {
  return [
    completionState,
    completionConfig.of(config2),
    completionPlugin,
    completionKeymapExt,
    baseTheme
  ];
}
const completionKeymap = [
  { key: "Ctrl-Space", run: startCompletion },
  { key: "Escape", run: closeCompletion },
  { key: "ArrowDown", run: /* @__PURE__ */ moveCompletionSelection(true) },
  { key: "ArrowUp", run: /* @__PURE__ */ moveCompletionSelection(false) },
  { key: "PageDown", run: /* @__PURE__ */ moveCompletionSelection(true, "page") },
  { key: "PageUp", run: /* @__PURE__ */ moveCompletionSelection(false, "page") },
  { key: "Enter", run: acceptCompletion }
];
const completionKeymapExt = /* @__PURE__ */ Prec.highest(/* @__PURE__ */ keymap.computeN([completionConfig], (state) => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));
const snippets = [
  /* @__PURE__ */ snippetCompletion("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("try {\n	${}\n} catch (${error}) {\n	${}\n}", {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("if (${}) {\n	${}\n} else {\n	${}\n}", {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion("class ${name} {\n	constructor(${params}) {\n		${}\n	}\n}", {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ snippetCompletion('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
];
const cache = /* @__PURE__ */ new NodeWeakMap();
const ScopeNodes = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function defID(type2) {
  return (node2, def) => {
    let id2 = node2.node.getChild("VariableDefinition");
    if (id2)
      def(id2, type2);
    return true;
  };
}
const functionContext = ["FunctionDeclaration"];
const gatherCompletions = {
  FunctionDeclaration: /* @__PURE__ */ defID("function"),
  ClassDeclaration: /* @__PURE__ */ defID("class"),
  ClassExpression: () => true,
  EnumDeclaration: /* @__PURE__ */ defID("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ defID("type"),
  NamespaceDeclaration: /* @__PURE__ */ defID("namespace"),
  VariableDefinition(node2, def) {
    if (!node2.matchContext(functionContext))
      def(node2, "variable");
  },
  TypeDefinition(node2, def) {
    def(node2, "type");
  },
  __proto__: null
};
function getScope(doc2, node2) {
  let cached = cache.get(node2);
  if (cached)
    return cached;
  let completions2 = [], top2 = true;
  function def(node3, type2) {
    let name2 = doc2.sliceString(node3.from, node3.to);
    completions2.push({ label: name2, type: type2 });
  }
  node2.cursor(IterMode.IncludeAnonymous).iterate((node3) => {
    if (top2) {
      top2 = false;
    } else if (node3.name) {
      let gather = gatherCompletions[node3.name];
      if (gather && gather(node3, def) || ScopeNodes.has(node3.name))
        return false;
    } else if (node3.to - node3.from > 8192) {
      for (let c2 of getScope(doc2, node3.node))
        completions2.push(c2);
      return false;
    }
  });
  cache.set(node2, completions2);
  return completions2;
}
const Identifier = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/;
const dontComplete = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName"
];
function localCompletionSource(context) {
  let inner = syntaxTree(context.state).resolveInner(context.pos, -1);
  if (dontComplete.indexOf(inner.name) > -1)
    return null;
  let isWord = inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));
  if (!isWord && !context.explicit)
    return null;
  let options2 = [];
  for (let pos = inner; pos; pos = pos.parent) {
    if (ScopeNodes.has(pos.name))
      options2 = options2.concat(getScope(context.state.doc, pos));
  }
  return {
    options: options2,
    from: isWord ? inner.from : context.pos,
    validFor: Identifier
  };
}
const javascriptLanguage = /* @__PURE__ */ LRLanguage.define({
  parser: /* @__PURE__ */ parser$d.configure({
    props: [
      /* @__PURE__ */ indentNodeProp.add({
        IfStatement: /* @__PURE__ */ continuedIndent({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ continuedIndent({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: flatIndent,
        SwitchBody: (context) => {
          let after = context.textAfter, closed = /^\s*\}/.test(after), isCase = /^\s*(case|default)\b/.test(after);
          return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;
        },
        Block: /* @__PURE__ */ delimitedIndent({ closing: "}" }),
        ArrowFunction: (cx) => cx.baseIndent + cx.unit,
        "TemplateString BlockComment": () => -1,
        "Statement Property": /* @__PURE__ */ continuedIndent({ except: /^{/ }),
        JSXElement(context) {
          let closed = /^\s*<\//.test(context.textAfter);
          return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);
        },
        JSXEscape(context) {
          let closed = /\s*\}/.test(context.textAfter);
          return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(context) {
          return context.column(context.node.from) + context.unit;
        }
      }),
      /* @__PURE__ */ foldNodeProp.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression": foldInside,
        BlockComment(tree2) {
          return { from: tree2.from + 2, to: tree2.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
});
const typescriptLanguage = /* @__PURE__ */ javascriptLanguage.configure({ dialect: "ts" });
const jsxLanguage = /* @__PURE__ */ javascriptLanguage.configure({ dialect: "jsx" });
const tsxLanguage = /* @__PURE__ */ javascriptLanguage.configure({ dialect: "jsx ts" });
const keywords$1 = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map((kw) => ({ label: kw, type: "keyword" }));
function javascript(config2 = {}) {
  let lang2 = config2.jsx ? config2.typescript ? tsxLanguage : jsxLanguage : config2.typescript ? typescriptLanguage : javascriptLanguage;
  return new LanguageSupport(lang2, [
    javascriptLanguage.data.of({
      autocomplete: ifNotIn(dontComplete, completeFromList(snippets.concat(keywords$1)))
    }),
    javascriptLanguage.data.of({
      autocomplete: localCompletionSource
    }),
    config2.jsx ? autoCloseTags$1 : []
  ]);
}
function elementName$1(doc2, tree2, max2 = doc2.length) {
  if (!tree2)
    return "";
  let name2 = tree2.getChild("JSXIdentifier");
  return name2 ? doc2.sliceString(name2.from, Math.min(name2.to, max2)) : "";
}
const android = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent);
const autoCloseTags$1 = /* @__PURE__ */ EditorView.inputHandler.of((view, from2, to2, text2) => {
  if ((android ? view.composing : view.compositionStarted) || view.state.readOnly || from2 != to2 || text2 != ">" && text2 != "/" || !javascriptLanguage.isActiveAt(view.state, from2, -1))
    return false;
  let { state } = view;
  let changes = state.changeByRange((range2) => {
    var _a2, _b, _c;
    let { head: head2 } = range2, around = syntaxTree(state).resolveInner(head2, -1), name2;
    if (around.name == "JSXStartTag")
      around = around.parent;
    if (text2 == ">" && around.name == "JSXFragmentTag") {
      return { range: EditorSelection.cursor(head2 + 1), changes: { from: head2, insert: `><>` } };
    } else if (text2 == ">" && around.name == "JSXIdentifier") {
      if (((_b = (_a2 = around.parent) === null || _a2 === void 0 ? void 0 : _a2.lastChild) === null || _b === void 0 ? void 0 : _b.name) != "JSXEndTag" && (name2 = elementName$1(state.doc, around.parent, head2)))
        return { range: EditorSelection.cursor(head2 + 1), changes: { from: head2, insert: `></${name2}>` } };
    } else if (text2 == "/" && around.name == "JSXFragmentTag") {
      let empty2 = around.parent, base2 = empty2 === null || empty2 === void 0 ? void 0 : empty2.parent;
      if (empty2.from == head2 - 1 && ((_c = base2.lastChild) === null || _c === void 0 ? void 0 : _c.name) != "JSXEndTag" && (name2 = elementName$1(state.doc, base2 === null || base2 === void 0 ? void 0 : base2.firstChild, head2))) {
        let insert2 = `/${name2}>`;
        return { range: EditorSelection.cursor(head2 + insert2.length), changes: { from: head2, insert: insert2 } };
      }
    }
    return { range: range2 };
  });
  if (changes.changes.empty)
    return false;
  view.dispatch(changes, { userEvent: "input.type", scrollIntoView: true });
  return true;
});
function esLint(eslint, config2) {
  if (!config2) {
    config2 = {
      parserOptions: { ecmaVersion: 2019, sourceType: "module" },
      env: { browser: true, node: true, es6: true, es2015: true, es2017: true, es2020: true },
      rules: {}
    };
    eslint.getRules().forEach((desc, name2) => {
      if (desc.meta.docs.recommended)
        config2.rules[name2] = 2;
    });
  }
  return (view) => {
    let { state } = view, found = [];
    for (let { from: from2, to: to2 } of javascriptLanguage.findRegions(state)) {
      let fromLine = state.doc.lineAt(from2), offset = { line: fromLine.number - 1, col: from2 - fromLine.from, pos: from2 };
      for (let d of eslint.verify(state.sliceDoc(from2, to2), config2))
        found.push(translateDiagnostic(d, state.doc, offset));
    }
    return found;
  };
}
function mapPos(line2, col, doc2, offset) {
  return doc2.line(line2 + offset.line).from + col + (line2 == 1 ? offset.col - 1 : -1);
}
function translateDiagnostic(input, doc2, offset) {
  let start2 = mapPos(input.line, input.column, doc2, offset);
  let result = {
    from: start2,
    to: input.endLine != null && input.endColumn != 1 ? mapPos(input.endLine, input.endColumn, doc2, offset) : start2,
    message: input.message,
    source: input.ruleId ? "jshint:" + input.ruleId : "jshint",
    severity: input.severity == 1 ? "warning" : "error"
  };
  if (input.fix) {
    let { range: range2, text: text2 } = input.fix, from2 = range2[0] + offset.pos - start2, to2 = range2[1] + offset.pos - start2;
    result.actions = [{
      name: "fix",
      apply(view, start3) {
        view.dispatch({ changes: { from: start3 + from2, to: start3 + to2, insert: text2 }, scrollIntoView: true });
      }
    }];
  }
  return result;
}
const index$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  autoCloseTags: autoCloseTags$1,
  esLint,
  javascript,
  javascriptLanguage,
  jsxLanguage,
  localCompletionSource,
  snippets,
  tsxLanguage,
  typescriptLanguage
}, Symbol.toStringTag, { value: "Module" }));
const Targets = ["_blank", "_self", "_top", "_parent"];
const Charsets = ["ascii", "utf-8", "utf-16", "latin1", "latin1"];
const Methods = ["get", "post", "put", "delete"];
const Encs = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"];
const Bool = ["true", "false"];
const S = {};
const Tags = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: Targets,
      hreflang: null
    }
  },
  abbr: S,
  acronym: S,
  address: S,
  applet: S,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: S,
  aside: S,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: S,
  base: { attrs: { href: null, target: Targets } },
  basefont: S,
  bdi: S,
  bdo: S,
  big: S,
  blockquote: { attrs: { cite: null } },
  body: S,
  br: S,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: Encs,
      formmethod: Methods,
      formnovalidate: ["novalidate"],
      formtarget: Targets,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: S,
  center: S,
  cite: S,
  code: S,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: S,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: S,
  dir: S,
  div: S,
  dl: S,
  dt: S,
  em: S,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: S,
  figure: S,
  font: S,
  footer: S,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": Charsets,
      autocomplete: ["on", "off"],
      enctype: Encs,
      method: Methods,
      novalidate: ["novalidate"],
      target: Targets
    }
  },
  frame: S,
  frameset: S,
  h1: S,
  h2: S,
  h3: S,
  h4: S,
  h5: S,
  h6: S,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: S,
  hgroup: S,
  hr: S,
  html: {
    attrs: { manifest: null }
  },
  i: S,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: Encs,
      formmethod: Methods,
      formnovalidate: ["novalidate"],
      formtarget: Targets,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: S,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: S,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: S,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: Charsets,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: S,
  noframes: S,
  noscript: S,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: S,
  param: { attrs: { name: null, value: null } },
  pre: S,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: S,
  rt: S,
  ruby: S,
  s: S,
  samp: S,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: Charsets
    }
  },
  section: S,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: S,
  source: { attrs: { src: null, type: null, media: null } },
  span: S,
  strike: S,
  strong: S,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: S,
  summary: S,
  sup: S,
  table: S,
  tbody: S,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: S,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: S,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: S,
  time: { attrs: { datetime: null } },
  title: S,
  tr: S,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  tt: S,
  u: S,
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: S,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: S
};
const GlobalAttrs = {
  accesskey: null,
  class: null,
  contenteditable: Bool,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: Bool,
  autocorrect: Bool,
  autocapitalize: Bool,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  onclick: null,
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": Bool,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": Bool,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": Bool,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": Bool,
  "aria-hidden": Bool,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": Bool,
  "aria-multiselectable": Bool,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": Bool,
  "aria-relevant": null,
  "aria-required": Bool,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
};
class Schema {
  constructor(extraTags, extraAttrs) {
    this.tags = Object.assign(Object.assign({}, Tags), extraTags);
    this.globalAttrs = Object.assign(Object.assign({}, GlobalAttrs), extraAttrs);
    this.allTags = Object.keys(this.tags);
    this.globalAttrNames = Object.keys(this.globalAttrs);
  }
}
Schema.default = /* @__PURE__ */ new Schema();
function elementName(doc2, tree2, max2 = doc2.length) {
  if (!tree2)
    return "";
  let tag = tree2.firstChild;
  let name2 = tag && tag.getChild("TagName");
  return name2 ? doc2.sliceString(name2.from, Math.min(name2.to, max2)) : "";
}
function findParentElement(tree2, skip = false) {
  for (let cur2 = tree2.parent; cur2; cur2 = cur2.parent)
    if (cur2.name == "Element") {
      if (skip)
        skip = false;
      else
        return cur2;
    }
  return null;
}
function allowedChildren(doc2, tree2, schema) {
  let parentInfo = schema.tags[elementName(doc2, findParentElement(tree2, true))];
  return (parentInfo === null || parentInfo === void 0 ? void 0 : parentInfo.children) || schema.allTags;
}
function openTags(doc2, tree2) {
  let open = [];
  for (let parent = tree2; parent = findParentElement(parent); ) {
    let tagName = elementName(doc2, parent);
    if (tagName && parent.lastChild.name == "CloseTag")
      break;
    if (tagName && open.indexOf(tagName) < 0 && (tree2.name == "EndTag" || tree2.from >= parent.firstChild.to))
      open.push(tagName);
  }
  return open;
}
const identifier$1 = /^[:\-\.\w\u00b7-\uffff]*$/;
function completeTag(state, schema, tree2, from2, to2) {
  let end2 = /\s*>/.test(state.sliceDoc(to2, to2 + 5)) ? "" : ">";
  return {
    from: from2,
    to: to2,
    options: allowedChildren(state.doc, tree2, schema).map((tagName) => ({ label: tagName, type: "type" })).concat(openTags(state.doc, tree2).map((tag, i) => ({
      label: "/" + tag,
      apply: "/" + tag + end2,
      type: "type",
      boost: 99 - i
    }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
function completeCloseTag(state, tree2, from2, to2) {
  let end2 = /\s*>/.test(state.sliceDoc(to2, to2 + 5)) ? "" : ">";
  return {
    from: from2,
    to: to2,
    options: openTags(state.doc, tree2).map((tag, i) => ({ label: tag, apply: tag + end2, type: "type", boost: 99 - i })),
    validFor: identifier$1
  };
}
function completeStartTag(state, schema, tree2, pos) {
  let options2 = [], level = 0;
  for (let tagName of allowedChildren(state.doc, tree2, schema))
    options2.push({ label: "<" + tagName, type: "type" });
  for (let open of openTags(state.doc, tree2))
    options2.push({ label: "</" + open + ">", type: "type", boost: 99 - level++ });
  return { from: pos, to: pos, options: options2, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function completeAttrName(state, schema, tree2, from2, to2) {
  let elt2 = findParentElement(tree2), info2 = elt2 ? schema.tags[elementName(state.doc, elt2)] : null;
  let names = info2 && info2.attrs ? Object.keys(info2.attrs).concat(schema.globalAttrNames) : schema.globalAttrNames;
  return {
    from: from2,
    to: to2,
    options: names.map((attrName) => ({ label: attrName, type: "property" })),
    validFor: identifier$1
  };
}
function completeAttrValue(state, schema, tree2, from2, to2) {
  var _a2;
  let nameNode = (_a2 = tree2.parent) === null || _a2 === void 0 ? void 0 : _a2.getChild("AttributeName");
  let options2 = [], token2 = void 0;
  if (nameNode) {
    let attrName = state.sliceDoc(nameNode.from, nameNode.to);
    let attrs = schema.globalAttrs[attrName];
    if (!attrs) {
      let elt2 = findParentElement(tree2), info2 = elt2 ? schema.tags[elementName(state.doc, elt2)] : null;
      attrs = (info2 === null || info2 === void 0 ? void 0 : info2.attrs) && info2.attrs[attrName];
    }
    if (attrs) {
      let base2 = state.sliceDoc(from2, to2).toLowerCase(), quoteStart = '"', quoteEnd = '"';
      if (/^['"]/.test(base2)) {
        token2 = base2[0] == '"' ? /^[^"]*$/ : /^[^']*$/;
        quoteStart = "";
        quoteEnd = state.sliceDoc(to2, to2 + 1) == base2[0] ? "" : base2[0];
        base2 = base2.slice(1);
        from2++;
      } else {
        token2 = /^[^\s<>='"]*$/;
      }
      for (let value of attrs)
        options2.push({ label: value, apply: quoteStart + value + quoteEnd, type: "constant" });
    }
  }
  return { from: from2, to: to2, options: options2, validFor: token2 };
}
function htmlCompletionFor(schema, context) {
  let { state, pos } = context, around = syntaxTree(state).resolveInner(pos), tree2 = around.resolve(pos, -1);
  for (let scan2 = pos, before; around == tree2 && (before = tree2.childBefore(scan2)); ) {
    let last = before.lastChild;
    if (!last || !last.type.isError || last.from < last.to)
      break;
    around = tree2 = before;
    scan2 = last.from;
  }
  if (tree2.name == "TagName") {
    return tree2.parent && /CloseTag$/.test(tree2.parent.name) ? completeCloseTag(state, tree2, tree2.from, pos) : completeTag(state, schema, tree2, tree2.from, pos);
  } else if (tree2.name == "StartTag") {
    return completeTag(state, schema, tree2, pos, pos);
  } else if (tree2.name == "StartCloseTag" || tree2.name == "IncompleteCloseTag") {
    return completeCloseTag(state, tree2, pos, pos);
  } else if (context.explicit && (tree2.name == "OpenTag" || tree2.name == "SelfClosingTag") || tree2.name == "AttributeName") {
    return completeAttrName(state, schema, tree2, tree2.name == "AttributeName" ? tree2.from : pos, pos);
  } else if (tree2.name == "Is" || tree2.name == "AttributeValue" || tree2.name == "UnquotedAttributeValue") {
    return completeAttrValue(state, schema, tree2, tree2.name == "Is" ? pos : tree2.from, pos);
  } else if (context.explicit && (around.name == "Element" || around.name == "Text" || around.name == "Document")) {
    return completeStartTag(state, schema, tree2, pos);
  } else {
    return null;
  }
}
function htmlCompletionSource(context) {
  return htmlCompletionFor(Schema.default, context);
}
function htmlCompletionSourceWith(config2) {
  let { extraTags, extraGlobalAttributes: extraAttrs } = config2;
  let schema = extraAttrs || extraTags ? new Schema(extraTags, extraAttrs) : Schema.default;
  return (context) => htmlCompletionFor(schema, context);
}
const htmlLanguage = /* @__PURE__ */ LRLanguage.define({
  parser: /* @__PURE__ */ parser$f.configure({
    props: [
      /* @__PURE__ */ indentNodeProp.add({
        Element(context) {
          let after = /^(\s*)(<\/)?/.exec(context.textAfter);
          if (context.node.to <= context.pos + after[0].length)
            return context.continue();
          return context.lineIndent(context.node.from) + (after[2] ? 0 : context.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(context) {
          return context.column(context.node.from) + context.unit;
        },
        Document(context) {
          if (context.pos + /\s*/.exec(context.textAfter)[0].length < context.node.to)
            return context.continue();
          let endElt = null, close;
          for (let cur2 = context.node; ; ) {
            let last = cur2.lastChild;
            if (!last || last.name != "Element" || last.to != cur2.to)
              break;
            endElt = cur2 = last;
          }
          if (endElt && !((close = endElt.lastChild) && (close.name == "CloseTag" || close.name == "SelfClosingTag")))
            return context.lineIndent(endElt.from) + context.unit;
          return null;
        }
      }),
      /* @__PURE__ */ foldNodeProp.add({
        Element(node2) {
          let first = node2.firstChild, last = node2.lastChild;
          if (!first || first.name != "OpenTag")
            return null;
          return { from: first.to, to: last.name == "CloseTag" ? last.from : node2.to };
        }
      })
    ],
    wrap: /* @__PURE__ */ configureNesting([
      {
        tag: "script",
        attrs(attrs) {
          return !attrs.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(attrs.type);
        },
        parser: javascriptLanguage.parser
      },
      {
        tag: "style",
        attrs(attrs) {
          return (!attrs.lang || attrs.lang == "css") && (!attrs.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(attrs.type));
        },
        parser: cssLanguage.parser
      }
    ])
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-._"
  }
});
function html$3(config2 = {}) {
  let lang2 = htmlLanguage;
  if (config2.matchClosingTags === false)
    lang2 = lang2.configure({ dialect: "noMatch" });
  return new LanguageSupport(lang2, [
    htmlLanguage.data.of({ autocomplete: htmlCompletionSourceWith(config2) }),
    config2.autoCloseTags !== false ? autoCloseTags : [],
    javascript().support,
    css().support
  ]);
}
const autoCloseTags = /* @__PURE__ */ EditorView.inputHandler.of((view, from2, to2, text2) => {
  if (view.composing || view.state.readOnly || from2 != to2 || text2 != ">" && text2 != "/" || !htmlLanguage.isActiveAt(view.state, from2, -1))
    return false;
  let { state } = view;
  let changes = state.changeByRange((range2) => {
    var _a2, _b, _c;
    let { head: head2 } = range2, around = syntaxTree(state).resolveInner(head2, -1), name2;
    if (around.name == "TagName" || around.name == "StartTag")
      around = around.parent;
    if (text2 == ">" && around.name == "OpenTag") {
      if (((_b = (_a2 = around.parent) === null || _a2 === void 0 ? void 0 : _a2.lastChild) === null || _b === void 0 ? void 0 : _b.name) != "CloseTag" && (name2 = elementName(state.doc, around.parent, head2)))
        return { range: EditorSelection.cursor(head2 + 1), changes: { from: head2, insert: `></${name2}>` } };
    } else if (text2 == "/" && around.name == "OpenTag") {
      let empty2 = around.parent, base2 = empty2 === null || empty2 === void 0 ? void 0 : empty2.parent;
      if (empty2.from == head2 - 1 && ((_c = base2.lastChild) === null || _c === void 0 ? void 0 : _c.name) != "CloseTag" && (name2 = elementName(state.doc, base2, head2))) {
        let insert2 = `/${name2}>`;
        return { range: EditorSelection.cursor(head2 + insert2.length), changes: { from: head2, insert: insert2 } };
      }
    }
    return { range: range2 };
  });
  if (changes.changes.empty)
    return false;
  view.dispatch(changes, { userEvent: "input.type", scrollIntoView: true });
  return true;
});
const index$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  autoCloseTags,
  html: html$3,
  htmlCompletionSource,
  htmlCompletionSourceWith,
  htmlLanguage
}, Symbol.toStringTag, { value: "Module" }));
const data = /* @__PURE__ */ defineLanguageFacet({ block: { open: "<!--", close: "-->" } });
const commonmark = /* @__PURE__ */ parser$g.configure({
  props: [
    /* @__PURE__ */ foldNodeProp.add((type2) => {
      if (!type2.is("Block") || type2.is("Document"))
        return void 0;
      return (tree2, state) => ({ from: state.doc.lineAt(tree2.from).to, to: tree2.to });
    }),
    /* @__PURE__ */ indentNodeProp.add({
      Document: () => null
    }),
    /* @__PURE__ */ languageDataProp.add({
      Document: data
    })
  ]
});
function mkLang(parser2) {
  return new Language(data, parser2, [], "markdown");
}
const commonmarkLanguage = /* @__PURE__ */ mkLang(commonmark);
const extended = /* @__PURE__ */ commonmark.configure([GFM, Subscript, Superscript, Emoji]);
const markdownLanguage = /* @__PURE__ */ mkLang(extended);
function getCodeParser(languages2, defaultLanguage) {
  return (info2) => {
    if (info2 && languages2) {
      let found = null;
      info2 = /\S*/.exec(info2)[0];
      if (typeof languages2 == "function")
        found = languages2(info2);
      else
        found = LanguageDescription.matchLanguageName(languages2, info2, true);
      if (found instanceof LanguageDescription)
        return found.support ? found.support.language.parser : ParseContext.getSkippingParser(found.load());
      else if (found)
        return found.parser;
    }
    return defaultLanguage ? defaultLanguage.parser : null;
  };
}
function nodeStart(node2, doc2) {
  return doc2.sliceString(node2.from, node2.from + 50);
}
class Context {
  constructor(node2, from2, to2, spaceBefore, spaceAfter, type2, item) {
    this.node = node2;
    this.from = from2;
    this.to = to2;
    this.spaceBefore = spaceBefore;
    this.spaceAfter = spaceAfter;
    this.type = type2;
    this.item = item;
  }
  blank(trailing = true) {
    let result = this.spaceBefore;
    if (this.node.name == "Blockquote")
      result += ">";
    else
      for (let i = this.to - this.from - result.length - this.spaceAfter.length; i > 0; i--)
        result += " ";
    return result + (trailing ? this.spaceAfter : "");
  }
  marker(doc2, add2) {
    let number3 = this.node.name == "OrderedList" ? String(+itemNumber(this.item, doc2)[2] + add2) : "";
    return this.spaceBefore + number3 + this.type + this.spaceAfter;
  }
}
function getContext(node2, line2, doc2) {
  let nodes = [];
  for (let cur2 = node2; cur2 && cur2.name != "Document"; cur2 = cur2.parent) {
    if (cur2.name == "ListItem" || cur2.name == "Blockquote" || cur2.name == "FencedCode")
      nodes.push(cur2);
  }
  let context = [], pos = 0;
  for (let i = nodes.length - 1; i >= 0; i--) {
    let node3 = nodes[i], match, start2 = pos;
    if (node3.name == "FencedCode") {
      context.push(new Context(node3, pos, pos, "", "", "", null));
    } else if (node3.name == "Blockquote" && (match = /^[ \t]*>( ?)/.exec(line2.slice(pos)))) {
      pos += match[0].length;
      context.push(new Context(node3, start2, pos, "", match[1], ">", null));
    } else if (node3.name == "ListItem" && node3.parent.name == "OrderedList" && (match = /^([ \t]*)\d+([.)])([ \t]*)/.exec(nodeStart(node3, doc2)))) {
      let after = match[3], len = match[0].length;
      if (after.length >= 4) {
        after = after.slice(0, after.length - 4);
        len -= 4;
      }
      pos += len;
      context.push(new Context(node3.parent, start2, pos, match[1], after, match[2], node3));
    } else if (node3.name == "ListItem" && node3.parent.name == "BulletList" && (match = /^([ \t]*)([-+*])([ \t]{1,4}\[[ xX]\])?([ \t]+)/.exec(nodeStart(node3, doc2)))) {
      let after = match[4], len = match[0].length;
      if (after.length > 4) {
        after = after.slice(0, after.length - 4);
        len -= 4;
      }
      let type2 = match[2];
      if (match[3])
        type2 += match[3].replace(/[xX]/, " ");
      pos += len;
      context.push(new Context(node3.parent, start2, pos, match[1], after, type2, node3));
    }
  }
  return context;
}
function itemNumber(item, doc2) {
  return /^(\s*)(\d+)(?=[.)])/.exec(doc2.sliceString(item.from, item.from + 10));
}
function renumberList(after, doc2, changes, offset = 0) {
  for (let prev2 = -1, node2 = after; ; ) {
    if (node2.name == "ListItem") {
      let m = itemNumber(node2, doc2);
      let number3 = +m[2];
      if (prev2 >= 0) {
        if (number3 != prev2 + 1)
          return;
        changes.push({ from: node2.from + m[1].length, to: node2.from + m[0].length, insert: String(prev2 + 2 + offset) });
      }
      prev2 = number3;
    }
    let next2 = node2.nextSibling;
    if (!next2)
      break;
    node2 = next2;
  }
}
const insertNewlineContinueMarkup = ({ state, dispatch: dispatch2 }) => {
  let tree2 = syntaxTree(state), { doc: doc2 } = state;
  let dont = null, changes = state.changeByRange((range2) => {
    if (!range2.empty || !markdownLanguage.isActiveAt(state, range2.from))
      return dont = { range: range2 };
    let pos = range2.from, line2 = doc2.lineAt(pos);
    let context = getContext(tree2.resolveInner(pos, -1), line2.text, doc2);
    while (context.length && context[context.length - 1].from > pos - line2.from)
      context.pop();
    if (!context.length)
      return dont = { range: range2 };
    let inner = context[context.length - 1];
    if (inner.to - inner.spaceAfter.length > pos - line2.from)
      return dont = { range: range2 };
    let emptyLine = pos >= inner.to - inner.spaceAfter.length && !/\S/.test(line2.text.slice(inner.to));
    if (inner.item && emptyLine) {
      if (inner.node.firstChild.to >= pos || line2.from > 0 && !/[^\s>]/.test(doc2.lineAt(line2.from - 1).text)) {
        let next2 = context.length > 1 ? context[context.length - 2] : null;
        let delTo, insert3 = "";
        if (next2 && next2.item) {
          delTo = line2.from + next2.from;
          insert3 = next2.marker(doc2, 1);
        } else {
          delTo = line2.from + (next2 ? next2.to : 0);
        }
        let changes3 = [{ from: delTo, to: pos, insert: insert3 }];
        if (inner.node.name == "OrderedList")
          renumberList(inner.item, doc2, changes3, -2);
        if (next2 && next2.node.name == "OrderedList")
          renumberList(next2.item, doc2, changes3);
        return { range: EditorSelection.cursor(delTo + insert3.length), changes: changes3 };
      } else {
        let insert3 = "";
        for (let i = 0, e = context.length - 2; i <= e; i++)
          insert3 += context[i].blank(i < e);
        insert3 += state.lineBreak;
        return { range: EditorSelection.cursor(pos + insert3.length), changes: { from: line2.from, insert: insert3 } };
      }
    }
    if (inner.node.name == "Blockquote" && emptyLine && line2.from) {
      let prevLine = doc2.lineAt(line2.from - 1), quoted = />\s*$/.exec(prevLine.text);
      if (quoted && quoted.index == inner.from) {
        let changes3 = state.changes([
          { from: prevLine.from + quoted.index, to: prevLine.to },
          { from: line2.from + inner.from, to: line2.to }
        ]);
        return { range: range2.map(changes3), changes: changes3 };
      }
    }
    let changes2 = [];
    if (inner.node.name == "OrderedList")
      renumberList(inner.item, doc2, changes2);
    let insert2 = state.lineBreak;
    let continued = inner.item && inner.item.from < line2.from;
    if (!continued || /^[\s\d.)\-+*>]*/.exec(line2.text)[0].length >= inner.to) {
      for (let i = 0, e = context.length - 1; i <= e; i++)
        insert2 += i == e && !continued ? context[i].marker(doc2, 1) : context[i].blank();
    }
    let from2 = pos;
    while (from2 > line2.from && /\s/.test(line2.text.charAt(from2 - line2.from - 1)))
      from2--;
    changes2.push({ from: from2, to: pos, insert: insert2 });
    return { range: EditorSelection.cursor(from2 + insert2.length), changes: changes2 };
  });
  if (dont)
    return false;
  dispatch2(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
  return true;
};
function isMark(node2) {
  return node2.name == "QuoteMark" || node2.name == "ListMark";
}
function contextNodeForDelete(tree2, pos) {
  let node2 = tree2.resolveInner(pos, -1), scan2 = pos;
  if (isMark(node2)) {
    scan2 = node2.from;
    node2 = node2.parent;
  }
  for (let prev2; prev2 = node2.childBefore(scan2); ) {
    if (isMark(prev2)) {
      scan2 = prev2.from;
    } else if (prev2.name == "OrderedList" || prev2.name == "BulletList") {
      node2 = prev2.lastChild;
      scan2 = node2.to;
    } else {
      break;
    }
  }
  return node2;
}
const deleteMarkupBackward = ({ state, dispatch: dispatch2 }) => {
  let tree2 = syntaxTree(state);
  let dont = null, changes = state.changeByRange((range2) => {
    let pos = range2.from, { doc: doc2 } = state;
    if (range2.empty && markdownLanguage.isActiveAt(state, range2.from)) {
      let line2 = doc2.lineAt(pos);
      let context = getContext(contextNodeForDelete(tree2, pos), line2.text, doc2);
      if (context.length) {
        let inner = context[context.length - 1];
        let spaceEnd = inner.to - inner.spaceAfter.length + (inner.spaceAfter ? 1 : 0);
        if (pos - line2.from > spaceEnd && !/\S/.test(line2.text.slice(spaceEnd, pos - line2.from)))
          return {
            range: EditorSelection.cursor(line2.from + spaceEnd),
            changes: { from: line2.from + spaceEnd, to: pos }
          };
        if (pos - line2.from == spaceEnd) {
          let start2 = line2.from + inner.from;
          if (inner.item && inner.node.from < inner.item.from && /\S/.test(line2.text.slice(inner.from, inner.to)))
            return { range: range2, changes: { from: start2, to: line2.from + inner.to, insert: inner.blank() } };
          if (start2 < pos)
            return { range: EditorSelection.cursor(start2), changes: { from: start2, to: pos } };
        }
      }
    }
    return dont = { range: range2 };
  });
  if (dont)
    return false;
  dispatch2(state.update(changes, { scrollIntoView: true, userEvent: "delete" }));
  return true;
};
const markdownKeymap = [
  { key: "Enter", run: insertNewlineContinueMarkup },
  { key: "Backspace", run: deleteMarkupBackward }
];
const htmlNoMatch = /* @__PURE__ */ html$3({ matchClosingTags: false });
function markdown(config2 = {}) {
  let { codeLanguages, defaultCodeLanguage, addKeymap = true, base: { parser: parser2 } = commonmarkLanguage } = config2;
  if (!(parser2 instanceof MarkdownParser))
    throw new RangeError("Base parser provided to `markdown` should be a Markdown parser");
  let extensions = config2.extensions ? [config2.extensions] : [];
  let support = [htmlNoMatch.support], defaultCode;
  if (defaultCodeLanguage instanceof LanguageSupport) {
    support.push(defaultCodeLanguage.support);
    defaultCode = defaultCodeLanguage.language;
  } else if (defaultCodeLanguage) {
    defaultCode = defaultCodeLanguage;
  }
  let codeParser = codeLanguages || defaultCode ? getCodeParser(codeLanguages, defaultCode) : void 0;
  extensions.push(parseCode({ codeParser, htmlParser: htmlNoMatch.language.parser }));
  if (addKeymap)
    support.push(Prec.high(keymap.of(markdownKeymap)));
  return new LanguageSupport(mkLang(parser2.configure(extensions)), support);
}
const index$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  commonmarkLanguage,
  deleteMarkupBackward,
  insertNewlineContinueMarkup,
  markdown,
  markdownKeymap,
  markdownLanguage
}, Symbol.toStringTag, { value: "Module" }));
function legacy(parser2) {
  return new LanguageSupport(StreamLanguage.define(parser2));
}
function sql(dialectName) {
  return __vitePreload(() => import("./index.3663a0f3.js"), true ? ["assets/index.3663a0f3.js","assets/index.99a5f7ec.js","assets/index.c5b01107.css","assets/account.81044ebe.js","assets/transform.606510e9.js"] : void 0).then((m) => m.sql({ dialect: m[dialectName] }));
}
const languages = [
  /* @__PURE__ */ LanguageDescription.of({
    name: "C",
    extensions: ["c", "h", "ino"],
    load() {
      return __vitePreload(() => import("./index.987be74e.js"), true ? ["assets/index.987be74e.js","assets/index.99a5f7ec.js","assets/index.c5b01107.css","assets/account.81044ebe.js","assets/transform.606510e9.js"] : void 0).then((m) => m.cpp());
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "C++",
    alias: ["cpp"],
    extensions: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"],
    load() {
      return __vitePreload(() => import("./index.987be74e.js"), true ? ["assets/index.987be74e.js","assets/index.99a5f7ec.js","assets/index.c5b01107.css","assets/account.81044ebe.js","assets/transform.606510e9.js"] : void 0).then((m) => m.cpp());
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "CQL",
    alias: ["cassandra"],
    extensions: ["cql"],
    load() {
      return sql("Cassandra");
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "CSS",
    extensions: ["css"],
    load() {
      return __vitePreload(() => Promise.resolve().then(() => index$7), true ? void 0 : void 0).then((m) => m.css());
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "HTML",
    alias: ["xhtml"],
    extensions: ["html", "htm", "handlebars", "hbs"],
    load() {
      return __vitePreload(() => Promise.resolve().then(() => index$5), true ? void 0 : void 0).then((m) => m.html());
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Java",
    extensions: ["java"],
    load() {
      return __vitePreload(() => import("./index.d4ef27e1.js"), true ? ["assets/index.d4ef27e1.js","assets/index.99a5f7ec.js","assets/index.c5b01107.css","assets/account.81044ebe.js","assets/transform.606510e9.js"] : void 0).then((m) => m.java());
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "JavaScript",
    alias: ["ecmascript", "js", "node"],
    extensions: ["js", "mjs", "cjs"],
    load() {
      return __vitePreload(() => Promise.resolve().then(() => index$6), true ? void 0 : void 0).then((m) => m.javascript());
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "JSON",
    alias: ["json5"],
    extensions: ["json", "map"],
    load() {
      return __vitePreload(() => import("./index.bc3a3dc5.js"), true ? ["assets/index.bc3a3dc5.js","assets/index.99a5f7ec.js","assets/index.c5b01107.css","assets/account.81044ebe.js","assets/transform.606510e9.js"] : void 0).then((m) => m.json());
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "JSX",
    extensions: ["jsx"],
    load() {
      return __vitePreload(() => Promise.resolve().then(() => index$6), true ? void 0 : void 0).then((m) => m.javascript({ jsx: true }));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "MariaDB SQL",
    load() {
      return sql("MariaSQL");
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Markdown",
    extensions: ["md", "markdown", "mkd"],
    load() {
      return __vitePreload(() => Promise.resolve().then(() => index$4), true ? void 0 : void 0).then((m) => m.markdown());
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "MS SQL",
    load() {
      return sql("MSSQL");
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "MySQL",
    load() {
      return sql("MySQL");
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "PHP",
    extensions: ["php", "php3", "php4", "php5", "php7", "phtml"],
    load() {
      return __vitePreload(() => import("./index.c63a5d15.js"), true ? ["assets/index.c63a5d15.js","assets/index.99a5f7ec.js","assets/index.c5b01107.css","assets/account.81044ebe.js","assets/transform.606510e9.js"] : void 0).then((m) => m.php());
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "PLSQL",
    extensions: ["pls"],
    load() {
      return sql("PLSQL");
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "PostgreSQL",
    load() {
      return sql("PostgreSQL");
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Python",
    extensions: ["BUILD", "bzl", "py", "pyw"],
    filename: /^(BUCK|BUILD)$/,
    load() {
      return __vitePreload(() => import("./index.4d88b1be.js"), true ? ["assets/index.4d88b1be.js","assets/index.99a5f7ec.js","assets/index.c5b01107.css","assets/account.81044ebe.js","assets/transform.606510e9.js"] : void 0).then((m) => m.python());
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Rust",
    extensions: ["rs"],
    load() {
      return __vitePreload(() => import("./index.a1ee58ed.js"), true ? ["assets/index.a1ee58ed.js","assets/index.99a5f7ec.js","assets/index.c5b01107.css","assets/account.81044ebe.js","assets/transform.606510e9.js"] : void 0).then((m) => m.rust());
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "SQL",
    extensions: ["sql"],
    load() {
      return sql("StandardSQL");
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "SQLite",
    load() {
      return sql("SQLite");
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "TSX",
    extensions: ["tsx"],
    load() {
      return __vitePreload(() => Promise.resolve().then(() => index$6), true ? void 0 : void 0).then((m) => m.javascript({ jsx: true, typescript: true }));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "TypeScript",
    alias: ["ts"],
    extensions: ["ts"],
    load() {
      return __vitePreload(() => Promise.resolve().then(() => index$6), true ? void 0 : void 0).then((m) => m.javascript({ typescript: true }));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "WebAssembly",
    extensions: ["wat", "wast"],
    load() {
      return __vitePreload(() => import("./index.e72fdeba.js"), true ? ["assets/index.e72fdeba.js","assets/index.99a5f7ec.js","assets/index.c5b01107.css","assets/account.81044ebe.js","assets/transform.606510e9.js"] : void 0).then((m) => m.wast());
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "XML",
    alias: ["rss", "wsdl", "xsd"],
    extensions: ["xml", "xsl", "xsd", "svg"],
    load() {
      return __vitePreload(() => import("./index.ecfe8d32.js"), true ? ["assets/index.ecfe8d32.js","assets/index.99a5f7ec.js","assets/index.c5b01107.css","assets/account.81044ebe.js","assets/transform.606510e9.js"] : void 0).then((m) => m.xml());
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "APL",
    extensions: ["dyalog", "apl"],
    load() {
      return __vitePreload(() => import("./apl.5279cdf3.js"), true ? [] : void 0).then((m) => legacy(m.apl));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "PGP",
    alias: ["asciiarmor"],
    extensions: ["asc", "pgp", "sig"],
    load() {
      return __vitePreload(() => import("./asciiarmor.36ede709.js"), true ? [] : void 0).then((m) => legacy(m.asciiArmor));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "ASN.1",
    extensions: ["asn", "asn1"],
    load() {
      return __vitePreload(() => import("./asn1.1d497af6.js"), true ? [] : void 0).then((m) => legacy(m.asn1({})));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Asterisk",
    filename: /^extensions\.conf$/i,
    load() {
      return __vitePreload(() => import("./asterisk.6b156c05.js"), true ? [] : void 0).then((m) => legacy(m.asterisk));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Brainfuck",
    extensions: ["b", "bf"],
    load() {
      return __vitePreload(() => import("./brainfuck.e6564070.js"), true ? [] : void 0).then((m) => legacy(m.brainfuck));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Cobol",
    extensions: ["cob", "cpy"],
    load() {
      return __vitePreload(() => import("./cobol.2dfd90e7.js"), true ? [] : void 0).then((m) => legacy(m.cobol));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "C#",
    alias: ["csharp", "cs"],
    extensions: ["cs"],
    load() {
      return __vitePreload(() => import("./clike.d50545e9.js"), true ? [] : void 0).then((m) => legacy(m.csharp));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Clojure",
    extensions: ["clj", "cljc", "cljx"],
    load() {
      return __vitePreload(() => import("./clojure.e832e3b3.js"), true ? [] : void 0).then((m) => legacy(m.clojure));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "ClojureScript",
    extensions: ["cljs"],
    load() {
      return __vitePreload(() => import("./clojure.e832e3b3.js"), true ? [] : void 0).then((m) => legacy(m.clojure));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Closure Stylesheets (GSS)",
    extensions: ["gss"],
    load() {
      return __vitePreload(() => import("./css.3c26eb64.js"), true ? [] : void 0).then((m) => legacy(m.gss));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "CMake",
    extensions: ["cmake", "cmake.in"],
    filename: /^CMakeLists\.txt$/,
    load() {
      return __vitePreload(() => import("./cmake.17de1bd4.js"), true ? [] : void 0).then((m) => legacy(m.cmake));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "CoffeeScript",
    alias: ["coffee", "coffee-script"],
    extensions: ["coffee"],
    load() {
      return __vitePreload(() => import("./coffeescript.c1964d4e.js"), true ? [] : void 0).then((m) => legacy(m.coffeeScript));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Common Lisp",
    alias: ["lisp"],
    extensions: ["cl", "lisp", "el"],
    load() {
      return __vitePreload(() => import("./commonlisp.6cb62ad0.js"), true ? [] : void 0).then((m) => legacy(m.commonLisp));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Cypher",
    extensions: ["cyp", "cypher"],
    load() {
      return __vitePreload(() => import("./cypher.3cfd7c2b.js"), true ? [] : void 0).then((m) => legacy(m.cypher));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Cython",
    extensions: ["pyx", "pxd", "pxi"],
    load() {
      return __vitePreload(() => import("./python.ac641beb.js"), true ? [] : void 0).then((m) => legacy(m.cython));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Crystal",
    extensions: ["cr"],
    load() {
      return __vitePreload(() => import("./crystal.8887b2b0.js"), true ? [] : void 0).then((m) => legacy(m.crystal));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "D",
    extensions: ["d"],
    load() {
      return __vitePreload(() => import("./d.62084003.js"), true ? [] : void 0).then((m) => legacy(m.d));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Dart",
    extensions: ["dart"],
    load() {
      return __vitePreload(() => import("./clike.d50545e9.js"), true ? [] : void 0).then((m) => legacy(m.dart));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "diff",
    extensions: ["diff", "patch"],
    load() {
      return __vitePreload(() => import("./diff.67d66c7a.js"), true ? [] : void 0).then((m) => legacy(m.diff));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Dockerfile",
    filename: /^Dockerfile$/,
    load() {
      return __vitePreload(() => import("./dockerfile.8e9483a8.js"), true ? ["assets/dockerfile.8e9483a8.js","assets/simple-mode.2be04451.js"] : void 0).then((m) => legacy(m.dockerFile));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "DTD",
    extensions: ["dtd"],
    load() {
      return __vitePreload(() => import("./dtd.7e711e8c.js"), true ? [] : void 0).then((m) => legacy(m.dtd));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Dylan",
    extensions: ["dylan", "dyl", "intr"],
    load() {
      return __vitePreload(() => import("./dylan.38e2f639.js"), true ? [] : void 0).then((m) => legacy(m.dylan));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "EBNF",
    load() {
      return __vitePreload(() => import("./ebnf.5c30a706.js"), true ? [] : void 0).then((m) => legacy(m.ebnf));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "ECL",
    extensions: ["ecl"],
    load() {
      return __vitePreload(() => import("./ecl.f505022f.js"), true ? [] : void 0).then((m) => legacy(m.ecl));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "edn",
    extensions: ["edn"],
    load() {
      return __vitePreload(() => import("./clojure.e832e3b3.js"), true ? [] : void 0).then((m) => legacy(m.clojure));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Eiffel",
    extensions: ["e"],
    load() {
      return __vitePreload(() => import("./eiffel.9cb8ca3a.js"), true ? [] : void 0).then((m) => legacy(m.eiffel));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Elm",
    extensions: ["elm"],
    load() {
      return __vitePreload(() => import("./elm.30e6255b.js"), true ? [] : void 0).then((m) => legacy(m.elm));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Erlang",
    extensions: ["erl"],
    load() {
      return __vitePreload(() => import("./erlang.1383a233.js"), true ? [] : void 0).then((m) => legacy(m.erlang));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Esper",
    load() {
      return __vitePreload(() => import("./sql.682a9ce0.js"), true ? [] : void 0).then((m) => legacy(m.esper));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Factor",
    extensions: ["factor"],
    load() {
      return __vitePreload(() => import("./factor.a71dabf8.js"), true ? ["assets/factor.a71dabf8.js","assets/simple-mode.2be04451.js"] : void 0).then((m) => legacy(m.factor));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "FCL",
    load() {
      return __vitePreload(() => import("./fcl.09e54a49.js"), true ? [] : void 0).then((m) => legacy(m.fcl));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Forth",
    extensions: ["forth", "fth", "4th"],
    load() {
      return __vitePreload(() => import("./forth.50aeb900.js"), true ? [] : void 0).then((m) => legacy(m.forth));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Fortran",
    extensions: ["f", "for", "f77", "f90", "f95"],
    load() {
      return __vitePreload(() => import("./fortran.712a8abc.js"), true ? [] : void 0).then((m) => legacy(m.fortran));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "F#",
    alias: ["fsharp"],
    extensions: ["fs"],
    load() {
      return __vitePreload(() => import("./mllike.1c6f2c0d.js"), true ? [] : void 0).then((m) => legacy(m.fSharp));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Gas",
    extensions: ["s"],
    load() {
      return __vitePreload(() => import("./gas.23b0e1a7.js"), true ? [] : void 0).then((m) => legacy(m.gas));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Gherkin",
    extensions: ["feature"],
    load() {
      return __vitePreload(() => import("./gherkin.3fb3e32b.js"), true ? [] : void 0).then((m) => legacy(m.gherkin));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Go",
    extensions: ["go"],
    load() {
      return __vitePreload(() => import("./go.ab4daeb2.js"), true ? [] : void 0).then((m) => legacy(m.go));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Groovy",
    extensions: ["groovy", "gradle"],
    filename: /^Jenkinsfile$/,
    load() {
      return __vitePreload(() => import("./groovy.14a6b1dc.js"), true ? [] : void 0).then((m) => legacy(m.groovy));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Haskell",
    extensions: ["hs"],
    load() {
      return __vitePreload(() => import("./haskell.69cc2adb.js"), true ? [] : void 0).then((m) => legacy(m.haskell));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Haxe",
    extensions: ["hx"],
    load() {
      return __vitePreload(() => import("./haxe.89b50351.js"), true ? [] : void 0).then((m) => legacy(m.haxe));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "HXML",
    extensions: ["hxml"],
    load() {
      return __vitePreload(() => import("./haxe.89b50351.js"), true ? [] : void 0).then((m) => legacy(m.hxml));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "HTTP",
    load() {
      return __vitePreload(() => import("./http.9bed8e47.js"), true ? [] : void 0).then((m) => legacy(m.http));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "IDL",
    extensions: ["pro"],
    load() {
      return __vitePreload(() => import("./idl.6d02433e.js"), true ? [] : void 0).then((m) => legacy(m.idl));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "JSON-LD",
    alias: ["jsonld"],
    extensions: ["jsonld"],
    load() {
      return __vitePreload(() => import("./javascript.14ff2075.js"), true ? [] : void 0).then((m) => legacy(m.jsonld));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Jinja2",
    extensions: ["j2", "jinja", "jinja2"],
    load() {
      return __vitePreload(() => import("./jinja2.a49c81a6.js"), true ? [] : void 0).then((m) => legacy(m.jinja2));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Julia",
    extensions: ["jl"],
    load() {
      return __vitePreload(() => import("./julia.6d6c5e44.js"), true ? [] : void 0).then((m) => legacy(m.julia));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Kotlin",
    extensions: ["kt"],
    load() {
      return __vitePreload(() => import("./clike.d50545e9.js"), true ? [] : void 0).then((m) => legacy(m.kotlin));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "LESS",
    extensions: ["less"],
    load() {
      return __vitePreload(() => import("./css.3c26eb64.js"), true ? [] : void 0).then((m) => legacy(m.less));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "LiveScript",
    alias: ["ls"],
    extensions: ["ls"],
    load() {
      return __vitePreload(() => import("./livescript.188868f2.js"), true ? [] : void 0).then((m) => legacy(m.liveScript));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Lua",
    extensions: ["lua"],
    load() {
      return __vitePreload(() => import("./lua.d506a169.js"), true ? [] : void 0).then((m) => legacy(m.lua));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "mIRC",
    extensions: ["mrc"],
    load() {
      return __vitePreload(() => import("./mirc.bbdf6a3e.js"), true ? [] : void 0).then((m) => legacy(m.mirc));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Mathematica",
    extensions: ["m", "nb", "wl", "wls"],
    load() {
      return __vitePreload(() => import("./mathematica.2e640b53.js"), true ? [] : void 0).then((m) => legacy(m.mathematica));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Modelica",
    extensions: ["mo"],
    load() {
      return __vitePreload(() => import("./modelica.3164296d.js"), true ? [] : void 0).then((m) => legacy(m.modelica));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "MUMPS",
    extensions: ["mps"],
    load() {
      return __vitePreload(() => import("./mumps.a8c3b61a.js"), true ? [] : void 0).then((m) => legacy(m.mumps));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Mbox",
    extensions: ["mbox"],
    load() {
      return __vitePreload(() => import("./mbox.987e1005.js"), true ? [] : void 0).then((m) => legacy(m.mbox));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Nginx",
    filename: /nginx.*\.conf$/i,
    load() {
      return __vitePreload(() => import("./nginx.ee3278f5.js"), true ? [] : void 0).then((m) => legacy(m.nginx));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "NSIS",
    extensions: ["nsh", "nsi"],
    load() {
      return __vitePreload(() => import("./nsis.e82e0142.js"), true ? ["assets/nsis.e82e0142.js","assets/simple-mode.2be04451.js"] : void 0).then((m) => legacy(m.nsis));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "NTriples",
    extensions: ["nt", "nq"],
    load() {
      return __vitePreload(() => import("./ntriples.d89c0dd5.js"), true ? [] : void 0).then((m) => legacy(m.ntriples));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Objective-C",
    alias: ["objective-c", "objc"],
    extensions: ["m"],
    load() {
      return __vitePreload(() => import("./clike.d50545e9.js"), true ? [] : void 0).then((m) => legacy(m.objectiveC));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Objective-C++",
    alias: ["objective-c++", "objc++"],
    extensions: ["mm"],
    load() {
      return __vitePreload(() => import("./clike.d50545e9.js"), true ? [] : void 0).then((m) => legacy(m.objectiveCpp));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "OCaml",
    extensions: ["ml", "mli", "mll", "mly"],
    load() {
      return __vitePreload(() => import("./mllike.1c6f2c0d.js"), true ? [] : void 0).then((m) => legacy(m.oCaml));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Octave",
    extensions: ["m"],
    load() {
      return __vitePreload(() => import("./octave.33274048.js"), true ? [] : void 0).then((m) => legacy(m.octave));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Oz",
    extensions: ["oz"],
    load() {
      return __vitePreload(() => import("./oz.a11dadbd.js"), true ? [] : void 0).then((m) => legacy(m.oz));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Pascal",
    extensions: ["p", "pas"],
    load() {
      return __vitePreload(() => import("./pascal.a4e9cf7d.js"), true ? [] : void 0).then((m) => legacy(m.pascal));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Perl",
    extensions: ["pl", "pm"],
    load() {
      return __vitePreload(() => import("./perl.cacf9f61.js"), true ? [] : void 0).then((m) => legacy(m.perl));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Pig",
    extensions: ["pig"],
    load() {
      return __vitePreload(() => import("./pig.5c4d0697.js"), true ? [] : void 0).then((m) => legacy(m.pig));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "PowerShell",
    extensions: ["ps1", "psd1", "psm1"],
    load() {
      return __vitePreload(() => import("./powershell.26361c4f.js"), true ? [] : void 0).then((m) => legacy(m.powerShell));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Properties files",
    alias: ["ini", "properties"],
    extensions: ["properties", "ini", "in"],
    load() {
      return __vitePreload(() => import("./properties.0156ad53.js"), true ? [] : void 0).then((m) => legacy(m.properties));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "ProtoBuf",
    extensions: ["proto"],
    load() {
      return __vitePreload(() => import("./protobuf.99e80c63.js"), true ? [] : void 0).then((m) => legacy(m.protobuf));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Puppet",
    extensions: ["pp"],
    load() {
      return __vitePreload(() => import("./puppet.1f7652d7.js"), true ? [] : void 0).then((m) => legacy(m.puppet));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Q",
    extensions: ["q"],
    load() {
      return __vitePreload(() => import("./q.ed284513.js"), true ? [] : void 0).then((m) => legacy(m.q));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "R",
    alias: ["rscript"],
    extensions: ["r", "R"],
    load() {
      return __vitePreload(() => import("./r.dbcdf3b1.js"), true ? [] : void 0).then((m) => legacy(m.r));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "RPM Changes",
    load() {
      return __vitePreload(() => import("./rpm.5d0d4165.js"), true ? [] : void 0).then((m) => legacy(m.rpmChanges));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "RPM Spec",
    extensions: ["spec"],
    load() {
      return __vitePreload(() => import("./rpm.5d0d4165.js"), true ? [] : void 0).then((m) => legacy(m.rpmSpec));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Ruby",
    alias: ["jruby", "macruby", "rake", "rb", "rbx"],
    extensions: ["rb"],
    load() {
      return __vitePreload(() => import("./ruby.c1f5c63b.js"), true ? [] : void 0).then((m) => legacy(m.ruby));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "SAS",
    extensions: ["sas"],
    load() {
      return __vitePreload(() => import("./sas.a9ccbcbf.js"), true ? [] : void 0).then((m) => legacy(m.sas));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Sass",
    extensions: ["sass"],
    load() {
      return __vitePreload(() => import("./sass.f0e19d3c.js"), true ? ["assets/sass.f0e19d3c.js","assets/css.3c26eb64.js"] : void 0).then((m) => legacy(m.sass));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Scala",
    extensions: ["scala"],
    load() {
      return __vitePreload(() => import("./clike.d50545e9.js"), true ? [] : void 0).then((m) => legacy(m.scala));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Scheme",
    extensions: ["scm", "ss"],
    load() {
      return __vitePreload(() => import("./scheme.3c5dc50d.js"), true ? [] : void 0).then((m) => legacy(m.scheme));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "SCSS",
    extensions: ["scss"],
    load() {
      return __vitePreload(() => import("./css.3c26eb64.js"), true ? [] : void 0).then((m) => legacy(m.sCSS));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Shell",
    alias: ["bash", "sh", "zsh"],
    extensions: ["sh", "ksh", "bash"],
    filename: /^PKGBUILD$/,
    load() {
      return __vitePreload(() => import("./shell.4fdc9c48.js"), true ? [] : void 0).then((m) => legacy(m.shell));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Sieve",
    extensions: ["siv", "sieve"],
    load() {
      return __vitePreload(() => import("./sieve.9cf0a95f.js"), true ? [] : void 0).then((m) => legacy(m.sieve));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Smalltalk",
    extensions: ["st"],
    load() {
      return __vitePreload(() => import("./smalltalk.1a1dc7f5.js"), true ? [] : void 0).then((m) => legacy(m.smalltalk));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Solr",
    load() {
      return __vitePreload(() => import("./solr.55928669.js"), true ? [] : void 0).then((m) => legacy(m.solr));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "SML",
    extensions: ["sml", "sig", "fun", "smackspec"],
    load() {
      return __vitePreload(() => import("./mllike.1c6f2c0d.js"), true ? [] : void 0).then((m) => legacy(m.sml));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "SPARQL",
    alias: ["sparul"],
    extensions: ["rq", "sparql"],
    load() {
      return __vitePreload(() => import("./sparql.e4634a0b.js"), true ? [] : void 0).then((m) => legacy(m.sparql));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Spreadsheet",
    alias: ["excel", "formula"],
    load() {
      return __vitePreload(() => import("./spreadsheet.ea708a5e.js"), true ? [] : void 0).then((m) => legacy(m.spreadsheet));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Squirrel",
    extensions: ["nut"],
    load() {
      return __vitePreload(() => import("./clike.d50545e9.js"), true ? [] : void 0).then((m) => legacy(m.squirrel));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Stylus",
    extensions: ["styl"],
    load() {
      return __vitePreload(() => import("./stylus.516bd8ed.js"), true ? [] : void 0).then((m) => legacy(m.stylus));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Swift",
    extensions: ["swift"],
    load() {
      return __vitePreload(() => import("./swift.8dc54098.js"), true ? [] : void 0).then((m) => legacy(m.swift));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "sTeX",
    load() {
      return __vitePreload(() => import("./stex.bb423439.js"), true ? [] : void 0).then((m) => legacy(m.stex));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "LaTeX",
    alias: ["tex"],
    extensions: ["text", "ltx", "tex"],
    load() {
      return __vitePreload(() => import("./stex.bb423439.js"), true ? [] : void 0).then((m) => legacy(m.stex));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "SystemVerilog",
    extensions: ["v", "sv", "svh"],
    load() {
      return __vitePreload(() => import("./verilog.ac1604ab.js"), true ? [] : void 0).then((m) => legacy(m.verilog));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Tcl",
    extensions: ["tcl"],
    load() {
      return __vitePreload(() => import("./tcl.63c0f4d9.js"), true ? [] : void 0).then((m) => legacy(m.tcl));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Textile",
    extensions: ["textile"],
    load() {
      return __vitePreload(() => import("./textile.790439e7.js"), true ? [] : void 0).then((m) => legacy(m.textile));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "TiddlyWiki",
    load() {
      return __vitePreload(() => import("./tiddlywiki.00e44342.js"), true ? [] : void 0).then((m) => legacy(m.tiddlyWiki));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Tiki wiki",
    load() {
      return __vitePreload(() => import("./tiki.db4b0342.js"), true ? [] : void 0).then((m) => legacy(m.tiki));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "TOML",
    extensions: ["toml"],
    load() {
      return __vitePreload(() => import("./toml.5f62c289.js"), true ? [] : void 0).then((m) => legacy(m.toml));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Troff",
    extensions: ["1", "2", "3", "4", "5", "6", "7", "8", "9"],
    load() {
      return __vitePreload(() => import("./troff.b7a41639.js"), true ? [] : void 0).then((m) => legacy(m.troff));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "TTCN",
    extensions: ["ttcn", "ttcn3", "ttcnpp"],
    load() {
      return __vitePreload(() => import("./ttcn.a77db865.js"), true ? [] : void 0).then((m) => legacy(m.ttcn));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "TTCN_CFG",
    extensions: ["cfg"],
    load() {
      return __vitePreload(() => import("./ttcn-cfg.6d4d0be1.js"), true ? [] : void 0).then((m) => legacy(m.ttcnCfg));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Turtle",
    extensions: ["ttl"],
    load() {
      return __vitePreload(() => import("./turtle.a34de549.js"), true ? [] : void 0).then((m) => legacy(m.turtle));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Web IDL",
    extensions: ["webidl"],
    load() {
      return __vitePreload(() => import("./webidl.51fb3de5.js"), true ? [] : void 0).then((m) => legacy(m.webIDL));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "VB.NET",
    extensions: ["vb"],
    load() {
      return __vitePreload(() => import("./vb.d4b2b4da.js"), true ? [] : void 0).then((m) => legacy(m.vb));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "VBScript",
    extensions: ["vbs"],
    load() {
      return __vitePreload(() => import("./vbscript.2ba221db.js"), true ? [] : void 0).then((m) => legacy(m.vbScript));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Velocity",
    extensions: ["vtl"],
    load() {
      return __vitePreload(() => import("./velocity.82ca13ca.js"), true ? [] : void 0).then((m) => legacy(m.velocity));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Verilog",
    extensions: ["v"],
    load() {
      return __vitePreload(() => import("./verilog.ac1604ab.js"), true ? [] : void 0).then((m) => legacy(m.verilog));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "VHDL",
    extensions: ["vhd", "vhdl"],
    load() {
      return __vitePreload(() => import("./vhdl.b163f95a.js"), true ? [] : void 0).then((m) => legacy(m.vhdl));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "XQuery",
    extensions: ["xy", "xquery"],
    load() {
      return __vitePreload(() => import("./xquery.4ff84527.js"), true ? [] : void 0).then((m) => legacy(m.xQuery));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Yacas",
    extensions: ["ys"],
    load() {
      return __vitePreload(() => import("./yacas.fedbc06b.js"), true ? [] : void 0).then((m) => legacy(m.yacas));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "YAML",
    alias: ["yml"],
    extensions: ["yaml", "yml"],
    load() {
      return __vitePreload(() => import("./yaml.67a204c5.js"), true ? [] : void 0).then((m) => legacy(m.yaml));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "Z80",
    extensions: ["z80"],
    load() {
      return __vitePreload(() => import("./z80.7d536384.js"), true ? [] : void 0).then((m) => legacy(m.z80));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "MscGen",
    extensions: ["mscgen", "mscin", "msc"],
    load() {
      return __vitePreload(() => import("./mscgen.88dc2281.js"), true ? [] : void 0).then((m) => legacy(m.mscgen));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "X\xF9",
    extensions: ["xu"],
    load() {
      return __vitePreload(() => import("./mscgen.88dc2281.js"), true ? [] : void 0).then((m) => legacy(m.xu));
    }
  }),
  /* @__PURE__ */ LanguageDescription.of({
    name: "MsGenny",
    extensions: ["msgenny"],
    load() {
      return __vitePreload(() => import("./mscgen.88dc2281.js"), true ? [] : void 0).then((m) => legacy(m.msgenny));
    }
  })
];
const xt = "data-ink-mde-ssr-hydration-marker", vt = `[${xt}]`, yt = () => ({}), H = {
  array: "[object Array]",
  object: "[object Object]",
  string: "[object String]",
  undefined: "[object Undefined]",
  window: "[object Window]"
}, $t = (e) => {
  if (Object.prototype.toString.call(e) === H.object)
    return `[object ${e.constructor.name}]`;
}, j = (e, t4) => $t(e) === t4, wt = (e, t4) => {
  const n = /* @__PURE__ */ new WeakMap(), o = (r, i) => n.get(r) || (j(r, H.object) && n.set(r, true), j(i, H.undefined)) ? r : j(r, H.array) && j(i, H.array) ? [...i] : j(r, H.object) && j(i, H.object) ? Object.keys(r).reduce((l2, a2) => (Object.hasOwnProperty.call(i, a2) ? l2[a2] = o(r[a2], i[a2]) : l2[a2] = r[a2], l2), {}) : i;
  return o(e, t4);
}, P = (e, t4) => wt(e, t4);
var V = /* @__PURE__ */ ((e) => (e.Auto = "auto", e.Dark = "dark", e.Light = "light", e))(V || {}), g = /* @__PURE__ */ ((e) => (e.Bold = "bold", e.Code = "code", e.CodeBlock = "code_block", e.Heading = "heading", e.Image = "image", e.Italic = "italic", e.Link = "link", e.List = "list", e.OrderedList = "ordered_list", e.Quote = "quote", e.TaskList = "task_list", e))(g || {}), re$2 = /* @__PURE__ */ ((e) => (e.Completion = "completion", e.Default = "default", e.Grammar = "grammar", e))(re$2 || {}), ie = /* @__PURE__ */ ((e) => (e.End = "end", e.Start = "start", e))(ie || {});
const xe = () => document.createElement("div"), Ce = () => window.matchMedia("(prefers-color-scheme: dark)").matches, Ct = (e) => e === V.Dark ? true : e === V.Light ? false : Ce(), ne = (e) => {
  const t4 = [
    { suffix: "border-radius", default: "0.25rem" },
    { suffix: "color", default: "currentColor" },
    { suffix: "flex-direction", default: "column" },
    { suffix: "font-family", default: "inherit" },
    { suffix: "block-background-color", default: "#121212", light: "#f5f5f5" },
    { suffix: "block-background-color-on-hover", default: "#0f0f0f", light: "#e0e0e0" },
    { suffix: "block-max-height", default: "20rem" },
    { suffix: "block-padding", default: "0.5rem" },
    { suffix: "code-background-color", default: "var(--ink-internal-block-background-color)" },
    { suffix: "code-color", default: "inherit" },
    { suffix: "code-font-family", default: "'Monaco', Courier, monospace" },
    { suffix: "editor-font-size", default: "1em" },
    { suffix: "editor-line-height", default: "2em" },
    { suffix: "editor-padding", default: "0.5rem" },
    { suffix: "inline-padding", default: "0.125rem" },
    { suffix: "modal-position", default: "fixed" },
    { suffix: "syntax-atom-color", default: "#d19a66" },
    { suffix: "syntax-comment-color", default: "#abb2bf" },
    { suffix: "syntax-comment-font-style", default: "italic" },
    { suffix: "syntax-emphasis-color", default: "inherit" },
    { suffix: "syntax-emphasis-font-style", default: "italic" },
    { suffix: "syntax-hashtag-background-color", default: "#222", light: "#eee" },
    { suffix: "syntax-hashtag-color", default: "inherit" },
    { suffix: "syntax-heading-color", default: "inherit" },
    { suffix: "syntax-heading-font-weight", default: "600" },
    { suffix: "syntax-heading1-color", default: "var(--ink-internal-syntax-heading-color, inherit)" },
    { suffix: "syntax-heading1-font-size", default: "1.6em" },
    { suffix: "syntax-heading1-font-weight", default: "600" },
    { suffix: "syntax-heading2-color", default: "var(--ink-internal-syntax-heading-color, inherit)" },
    { suffix: "syntax-heading2-font-size", default: "1.5em" },
    { suffix: "syntax-heading2-font-weight", default: "600" },
    { suffix: "syntax-heading3-color", default: "var(--ink-internal-syntax-heading-color, inherit)" },
    { suffix: "syntax-heading3-font-size", default: "1.4em" },
    { suffix: "syntax-heading3-font-weight", default: "600" },
    { suffix: "syntax-heading4-color", default: "var(--ink-internal-syntax-heading-color, inherit)" },
    { suffix: "syntax-heading4-font-size", default: "1.3em" },
    { suffix: "syntax-heading4-font-weight", default: "600" },
    { suffix: "syntax-heading5-color", default: "var(--ink-internal-syntax-heading-color, inherit)" },
    { suffix: "syntax-heading5-font-size", default: "1.2em" },
    { suffix: "syntax-heading5-font-weight", default: "600" },
    { suffix: "syntax-heading6-color", default: "var(--ink-internal-syntax-heading-color, inherit)" },
    { suffix: "syntax-heading6-font-size", default: "1.1em" },
    { suffix: "syntax-heading6-font-weight", default: "600" },
    { suffix: "syntax-highlight-background-color", default: "#555555" },
    { suffix: "syntax-keyword-color", default: "#c678dd" },
    { suffix: "syntax-link-color", default: "inherit" },
    { suffix: "syntax-meta-color", default: "#abb2bf" },
    { suffix: "syntax-monospace-color", default: "var(--ink-internal-code-color)" },
    { suffix: "syntax-monospace-font-family", default: "var(--ink-internal-code-font-family)" },
    { suffix: "syntax-name-color", default: "#d19a66" },
    { suffix: "syntax-name-label-color", default: "#abb2bf" },
    { suffix: "syntax-name-property-color", default: "#96c0d8" },
    { suffix: "syntax-name-property-definition-color", default: "#e06c75" },
    { suffix: "syntax-name-variable-color", default: "#e06c75" },
    { suffix: "syntax-name-variable-definition-color", default: "#e5c07b" },
    { suffix: "syntax-name-variable-local-color", default: "#d19a66" },
    { suffix: "syntax-name-variable-special-color", default: "inherit" },
    { suffix: "syntax-number-color", default: "#d19a66" },
    { suffix: "syntax-operator-color", default: "#96c0d8" },
    { suffix: "syntax-processing-instruction-color", default: "#444444", light: "#bbbbbb" },
    { suffix: "syntax-punctuation-color", default: "#abb2bf" },
    { suffix: "syntax-strikethrough-color", default: "inherit" },
    { suffix: "syntax-strikethrough-text-decoration", default: "line-through" },
    { suffix: "syntax-string-color", default: "#98c379" },
    { suffix: "syntax-string-special-color", default: "inherit" },
    { suffix: "syntax-strong-color", default: "inherit" },
    { suffix: "syntax-strong-font-weight", default: "600" },
    { suffix: "syntax-url-color", default: "#aaaaaa", light: "#666666" }
  ], n = !Ct(e.options.interface.appearance);
  return t4.map((o) => {
    const r = n && o.light ? o.light : o.default;
    return `--ink-internal-${o.suffix}: var(--ink-${o.suffix}, ${r});`;
  });
}, Lt = (e) => [
  EditorView.theme({}, { dark: e })
], St = (e) => e.extensions.map((t4) => t4.initialValue(e)), ue = (e) => Promise.all(
  e.extensions.map((t4) => t4.reconfigure(e.options))
), Mt = (e) => {
  const t4 = new Compartment();
  return {
    compartment: t4,
    initialValue: (n) => t4.of(e(n.options)),
    reconfigure: (n) => t4.reconfigure(e(n))
  };
}, At = (e) => {
  const t4 = new Compartment();
  return {
    compartment: t4,
    initialValue: (n) => t4.of([]),
    reconfigure: (n) => e(n, t4)
  };
}, Dt = () => [
  ...Ht.map((e) => Mt(e)),
  ...zt.map((e) => At(e))
], Ht = [
  (e) => {
    const t4 = e.interface.appearance === V.Dark, n = e.interface.appearance === V.Auto;
    return Lt(t4 || n && Ce());
  }
], zt = [
  async (e, t4) => {
    if (e.interface.autocomplete) {
      const { autocomplete: n } = await __vitePreload(() => import("./autocomplete.eef6ac6b.c318b0c9.js"), true ? ["assets/autocomplete.eef6ac6b.c318b0c9.js","assets/index.99a5f7ec.js","assets/index.c5b01107.css","assets/account.81044ebe.js","assets/transform.606510e9.js"] : void 0);
      return t4.reconfigure(n(e));
    }
    return t4.reconfigure([]);
  },
  async (e, t4) => {
    if (e.interface.images) {
      const { images: n } = await __vitePreload(() => import("./images.0bde9a43.7d03d17e.js"), true ? ["assets/images.0bde9a43.7d03d17e.js","assets/index.99a5f7ec.js","assets/index.c5b01107.css","assets/account.81044ebe.js","assets/transform.606510e9.js"] : void 0);
      return t4.reconfigure(n());
    }
    return t4.reconfigure([]);
  },
  async (e, t4) => {
    if (e.interface.lists) {
      const { lists: n } = await __vitePreload(() => import("./lists.b465ff74.550582cb.js"), true ? ["assets/lists.b465ff74.550582cb.js","assets/index.99a5f7ec.js","assets/index.c5b01107.css","assets/account.81044ebe.js","assets/transform.606510e9.js"] : void 0);
      return t4.reconfigure(n());
    }
    return t4.reconfigure([]);
  },
  async (e, t4) => {
    if (e.interface.readonly) {
      const { readonly: n } = await __vitePreload(() => import("./readonly.90b28a57.abc94b99.js"), true ? ["assets/readonly.90b28a57.abc94b99.js","assets/index.99a5f7ec.js","assets/index.c5b01107.css","assets/account.81044ebe.js","assets/transform.606510e9.js"] : void 0);
      return t4.reconfigure(n());
    }
    return t4.reconfigure([]);
  },
  async (e, t4) => {
    if (e.interface.spellcheck) {
      const { spellcheck: n } = await __vitePreload(() => import("./spellcheck.7e0765c7.03ead051.js"), true ? ["assets/spellcheck.7e0765c7.03ead051.js","assets/index.99a5f7ec.js","assets/index.c5b01107.css","assets/account.81044ebe.js","assets/transform.606510e9.js"] : void 0);
      return t4.reconfigure(n());
    }
    return t4.reconfigure([]);
  },
  async (e, t4) => {
    if (e.vim) {
      const { vim: n } = await __vitePreload(() => import("./vim.e0ec79d3.8d2f0656.js"), true ? ["assets/vim.e0ec79d3.8d2f0656.js","assets/index.99a5f7ec.js","assets/index.c5b01107.css","assets/account.81044ebe.js","assets/transform.606510e9.js"] : void 0);
      return t4.reconfigure(n());
    }
    return t4.reconfigure([]);
  }
], ae = () => {
  const e = {
    doc: "",
    files: {
      clipboard: false,
      dragAndDrop: false,
      handler: () => {
      },
      injectMarkup: true,
      types: ["image/*"]
    },
    hooks: {
      afterUpdate: () => {
      },
      beforeUpdate: () => {
      }
    },
    interface: {
      appearance: V.Auto,
      attribution: true,
      autocomplete: false,
      images: false,
      lists: false,
      readonly: false,
      spellcheck: true,
      toolbar: false
    },
    plugins: [],
    selections: [],
    toolbar: {
      bold: true,
      code: true,
      codeBlock: true,
      heading: true,
      image: true,
      italic: true,
      link: true,
      list: true,
      orderedList: true,
      quote: true,
      taskList: true,
      upload: false
    },
    vim: false
  };
  return {
    editor: {},
    extensions: Dt(),
    options: e,
    root: xe(),
    target: xe()
  };
}, Bt = (e) => P(ae(), e), fe = (e, t4 = {}) => {
  const [n, o] = createSignal(Bt({ ...t4, options: e }));
  return [n, o];
}, Et = ([e]) => {
  const { editor: t4 } = e();
  t4.destroy();
}, le = ([e]) => {
  const { editor: t4 } = e();
  t4.hasFocus || t4.focus();
}, _$F = (e) => ({ ...{
  block: false,
  line: false,
  multiline: false,
  nodes: [],
  prefix: "",
  prefixStates: [],
  suffix: ""
}, ...e }), jt = {
  [g.Bold]: _$F({
    nodes: ["StrongEmphasis"],
    prefix: "**",
    suffix: "**"
  }),
  [g.Code]: _$F({
    nodes: ["InlineCode"],
    prefix: "`",
    suffix: "`"
  }),
  [g.CodeBlock]: _$F({
    block: true,
    nodes: ["FencedCode"],
    prefix: "```\n",
    suffix: "\n```"
  }),
  [g.Heading]: _$F({
    multiline: true,
    nodes: ["ATXHeading1", "ATXHeading2", "ATXHeading3", "ATXHeading4", "ATXHeading5", "ATXHeading6"],
    prefix: "# ",
    prefixStates: ["# ", "## ", "### ", "#### ", "##### ", "###### ", ""]
  }),
  [g.Image]: _$F({
    nodes: ["Image"],
    prefix: "![](",
    suffix: ")"
  }),
  [g.Italic]: _$F({
    nodes: ["Emphasis"],
    prefix: "*",
    suffix: "*"
  }),
  [g.Link]: _$F({
    nodes: ["Link"],
    prefix: "[](",
    suffix: ")"
  }),
  [g.OrderedList]: _$F({
    line: true,
    multiline: true,
    nodes: ["OrderedList"],
    prefix: "1. "
  }),
  [g.Quote]: _$F({
    line: true,
    multiline: true,
    nodes: ["Blockquote"],
    prefix: "> "
  }),
  [g.TaskList]: _$F({
    line: true,
    multiline: true,
    nodes: ["BulletList"],
    prefix: "- [ ] "
  }),
  [g.List]: _$F({
    line: true,
    multiline: true,
    nodes: ["BulletList"],
    prefix: "- "
  })
}, Le = ([e, t4], n) => {
  const { editor: o } = e(), r = o.lineBlockAt(n.start), i = o.lineBlockAt(n.end);
  return { start: r.from, end: i.to };
}, Vt = ([e, t4], n) => {
  const { editor: o } = e();
  let r = n.start;
  const i = [];
  for (; r <= n.end; ) {
    const l2 = o.lineBlockAt(r), a2 = Math.max(r, l2.from), s2 = Math.min(r, l2.to);
    i.push({ start: a2, end: s2 }), r = l2.to + 1;
  }
  return i;
}, Ot = ([e, t4], n) => {
  var _a2, _b;
  const { editor: o } = e(), r = ((_a2 = o.state.wordAt(n.start)) == null ? void 0 : _a2.from) || n.start, i = ((_b = o.state.wordAt(n.end)) == null ? void 0 : _b.to) || n.end;
  return { start: r, end: i };
}, Nt = ([e, t4], n) => n || Z([e, t4]).pop() || { start: 0, end: 0 }, Se = ([e, t4], n) => {
  const { editor: o } = e();
  return o.state.sliceDoc(n.start, n.end);
}, ge = ([e, t4], n, o) => Tt(e(), o).find(({ type: i }) => n.nodes.includes(i.name)), Tt = ({ editor: { state: e } }, t4) => {
  const n = [];
  return syntaxTree(e).iterate({
    from: t4.start,
    to: t4.end,
    enter: ({ type: o, from: r, to: i }) => {
      n.push({ type: o, from: r, to: i });
    }
  }), n;
}, pe = ([e, t4], n, o) => {
  const r = Se([e, t4], o), i = n.prefix.length, l2 = n.suffix.length * -1 || r.length, a2 = r.slice(i, l2);
  O([e, t4], a2, o);
}, qt = ([e, t4], n, o) => {
  const r = Le([e, t4], o), i = ge([e, t4], n, r);
  if (i) {
    const l2 = i.from, a2 = i.to;
    pe([e, t4], n, { start: l2, end: a2 });
  } else {
    const l2 = n.prefix, a2 = n.suffix;
    G([e, t4], { before: l2, after: a2, selection: r });
  }
}, It = ([e, t4], n, o) => {
  Vt([e, t4], o).forEach((i) => {
    Me([e, t4], n, i);
  });
}, Me = ([e, t4], n, o) => {
  const r = Le([e, t4], o), i = ge([e, t4], n, r), l2 = n.prefixStates.length > 0;
  if (i && l2)
    n.prefixStates.find((a2, s2) => {
      const u = i.from, x2 = i.to, y2 = Se([e, t4], { start: u, end: x2 }), C2 = y2.startsWith(a2);
      return C2 && O([e, t4], y2.replace(new RegExp(`^${a2}`), n.prefixStates[s2 + 1]), { start: u, end: x2 }), C2;
    });
  else if (i) {
    const a2 = i.from, s2 = i.to;
    pe([e, t4], n, { start: a2, end: s2 });
  } else {
    const a2 = n.prefix, s2 = n.suffix;
    G([e, t4], { before: a2, after: s2, selection: r });
  }
}, Rt = ([e, t4], n, o) => {
  const r = ge([e, t4], n, o);
  if (r) {
    const i = r.from, l2 = r.to;
    pe([e, t4], n, { start: i, end: l2 });
  } else {
    const { start: i, end: l2 } = Ot([e, t4], o), a2 = Array.isArray(n.prefix) ? n.prefix[0] : n.prefix, s2 = n.suffix;
    G([e, t4], { before: a2, after: s2, selection: { start: i, end: l2 } });
  }
}, Ae = ([e, t4], n, { selection: o } = {}) => {
  const r = jt[n], i = Nt([e, t4], o);
  r.block ? qt([e, t4], r, i) : r.multiline ? It([e, t4], r, i) : r.line ? Me([e, t4], r, i) : Rt([e, t4], r, i);
}, Pt = ([e]) => {
  const { editor: t4 } = e();
  return t4.state.sliceDoc();
}, De = (e) => {
  const t4 = e.map((n) => SelectionRange.fromJSON({ anchor: n.start, head: n.end }));
  return EditorSelection.create(t4);
}, Wt = (e) => e.ranges.map((n) => ({
  end: n.anchor < n.head ? n.head : n.anchor,
  start: n.head < n.anchor ? n.head : n.anchor
})), Z = ([e]) => {
  const { editor: t4 } = e();
  return Wt(t4.state.selection);
}, O = ([e, t4], n, o, r = false) => {
  const { editor: i } = e();
  let l2 = o == null ? void 0 : o.start, a2 = (o == null ? void 0 : o.end) || (o == null ? void 0 : o.start);
  if (typeof l2 > "u") {
    const u = Z([e, t4]).pop();
    l2 = u.start, a2 = u.end;
  }
  const s2 = { changes: { from: l2, to: a2, insert: n } };
  if (r) {
    const u = l2 === a2 ? l2 + n.length : l2, x2 = l2 + n.length;
    Object.assign(s2, { selection: { anchor: u, head: x2 } });
  }
  i.dispatch(
    i.state.update(s2)
  );
}, Ft = [
  "Blockquote"
], Ut = Decoration.line({ attributes: { class: "cm-blockquote" } }), Xt = Decoration.line({ attributes: { class: "cm-blockquote-open" } }), Kt = Decoration.line({ attributes: { class: "cm-blockquote-close" } }), Qt = ViewPlugin.define((e) => ({
  update: () => Yt(e)
}), { decorations: (e) => e.update() }), Yt = (e) => {
  const t4 = new RangeSetBuilder(), n = syntaxTree(e.state);
  for (const o of e.visibleRanges)
    for (let r = o.from; r < o.to; ) {
      const i = e.state.doc.lineAt(r);
      n.iterate({
        enter({ type: l2, from: a2, to: s2 }) {
          if (l2.name !== "Document" && Ft.includes(l2.name)) {
            t4.add(i.from, i.from, Ut);
            const u = e.state.doc.lineAt(a2), x2 = e.state.doc.lineAt(s2);
            return u.number === i.number && t4.add(i.from, i.from, Xt), x2.number === i.number && t4.add(i.from, i.from, Kt), false;
          }
        },
        from: i.from,
        to: i.to
      }), r = i.to + 1;
    }
  return t4.finish();
}, Zt = () => [
  Qt
], Gt = [
  "CodeBlock",
  "FencedCode",
  "HTMLBlock",
  "CommentBlock"
], N = {
  "data-enable-grammarly": "false",
  "data-gramm": "false",
  "data-grammarly-skip": "true",
  spellcheck: "false"
}, Jt = Decoration.line({ attributes: { ...N, class: "cm-codeblock" } }), en = Decoration.line({ attributes: { ...N, class: "cm-codeblock-open" } }), tn = Decoration.line({ attributes: { ...N, class: "cm-codeblock-close" } }), nn = Decoration.mark({ attributes: { ...N, class: "cm-code" } }), on = Decoration.mark({ attributes: { ...N, class: "cm-code cm-code-open" } }), rn = Decoration.mark({ attributes: { ...N, class: "cm-code cm-code-close" } }), an = ViewPlugin.define((e) => ({
  update: () => ln(e)
}), { decorations: (e) => e.update() }), ln = (e) => {
  const t4 = new RangeSetBuilder(), n = syntaxTree(e.state);
  for (const o of e.visibleRanges)
    for (let r = o.from; r < o.to; ) {
      const i = e.state.doc.lineAt(r);
      let l2;
      n.iterate({
        enter({ type: a2, from: s2, to: u }) {
          if (a2.name !== "Document")
            if (Gt.includes(a2.name)) {
              t4.add(i.from, i.from, Jt);
              const x2 = e.state.doc.lineAt(s2), y2 = e.state.doc.lineAt(u);
              return x2.number === i.number && t4.add(i.from, i.from, en), y2.number === i.number && t4.add(i.from, i.from, tn), false;
            } else
              a2.name === "InlineCode" ? l2 = { from: s2, to: u, innerFrom: s2, innerTo: u } : a2.name === "CodeMark" && (s2 === l2.from ? (l2.innerFrom = u, t4.add(s2, u, on)) : u === l2.to && (l2.innerTo = s2, t4.add(l2.innerFrom, l2.innerTo, nn), t4.add(s2, u, rn)));
        },
        from: i.from,
        to: i.to
      }), r = i.to + 1;
    }
  return t4.finish();
}, sn = () => [
  an
], cn = () => [
  EditorView.editorAttributes.of({
    class: "ink-mde-editor"
  }),
  EditorView.contentAttributes.of({
    class: "ink-mde-editor-content"
  })
], dn = () => [
  ...cn()
], un = [
  {
    key: "Tab",
    run: ({ state: e, dispatch: t4 }) => e.selection.ranges.some((n) => !n.empty) ? indentMore({ state: e, dispatch: t4 }) : (t4(
      e.update(e.replaceSelection("  "), {
        scrollIntoView: true,
        annotations: Transaction.userEvent.of("input")
      })
    ), true),
    shift: indentLess
  }
], fn = () => keymap.of([
  ...un,
  ...defaultKeymap,
  ...historyKeymap
]), gn = () => EditorView.lineWrapping, pn = () => [
  syntaxHighlighting(
    HighlightStyle.define([
      {
        tag: tags$5.atom,
        color: "var(--ink-internal-syntax-atom-color)"
      },
      {
        tag: tags$5.meta,
        color: "var(--ink-internal-syntax-meta-color)"
      },
      {
        tag: tags$5.emphasis,
        color: "var(--ink-internal-syntax-emphasis-color)",
        fontStyle: "var(--ink-internal-syntax-emphasis-font-style)"
      },
      {
        tag: tags$5.strong,
        color: "var(--ink-internal-syntax-strong-color)",
        fontWeight: "var(--ink-internal-syntax-strong-font-weight)"
      },
      {
        tag: tags$5.strikethrough,
        color: "var(--ink-internal-syntax-strikethrough-color)",
        textDecoration: "var(--ink-internal-syntax-strikethrough-text-decoration)"
      },
      {
        tag: tags$5.comment,
        color: "var(--ink-internal-syntax-comment-color)",
        fontStyle: "var(--ink-internal-syntax-comment-font-style)"
      },
      {
        tag: tags$5.monospace,
        color: "var(--ink-internal-syntax-code-color)",
        fontFamily: "var(--ink-internal-syntax-code-font-family)"
      },
      {
        tag: tags$5.name,
        color: "var(--ink-internal-syntax-name-color)"
      },
      {
        tag: tags$5.labelName,
        color: "var(--ink-internal-syntax-name-label-color)"
      },
      {
        tag: tags$5.propertyName,
        color: "var(--ink-internal-syntax-name-property-color)"
      },
      {
        tag: tags$5.definition(tags$5.propertyName),
        color: "var(--ink-internal-syntax-name-property-definition-color)"
      },
      {
        tag: tags$5.variableName,
        color: "var(--ink-internal-syntax-name-variable-color)"
      },
      {
        tag: tags$5.definition(tags$5.variableName),
        color: "var(--ink-internal-syntax-name-variable-definition-color)"
      },
      {
        tag: tags$5.local(tags$5.variableName),
        color: "var(--ink-internal-syntax-name-variable-local-color)"
      },
      {
        tag: tags$5.special(tags$5.variableName),
        color: "var(--ink-internal-syntax-name-variable-special-color)"
      },
      {
        tag: tags$5.heading,
        color: "var(--ink-internal-syntax-heading-color)",
        fontWeight: "var(--ink-internal-syntax-heading-font-weight)"
      },
      {
        tag: tags$5.heading1,
        color: "var(--ink-internal-syntax-heading1-color)",
        fontSize: "var(--ink-internal-syntax-heading1-font-size)",
        fontWeight: "var(--ink-internal-syntax-heading1-font-weight)"
      },
      {
        tag: tags$5.heading2,
        color: "var(--ink-internal-syntax-heading2-color)",
        fontSize: "var(--ink-internal-syntax-heading2-font-size)",
        fontWeight: "var(--ink-internal-syntax-heading2-font-weight)"
      },
      {
        tag: tags$5.heading3,
        color: "var(--ink-internal-syntax-heading3-color)",
        fontSize: "var(--ink-internal-syntax-heading3-font-size)",
        fontWeight: "var(--ink-internal-syntax-heading3-font-weight)"
      },
      {
        tag: tags$5.heading4,
        color: "var(--ink-internal-syntax-heading4-color)",
        fontSize: "var(--ink-internal-syntax-heading4-font-size)",
        fontWeight: "var(--ink-internal-syntax-heading4-font-weight)"
      },
      {
        tag: tags$5.heading5,
        color: "var(--ink-internal-syntax-heading5-color)",
        fontSize: "var(--ink-internal-syntax-heading5-font-size)",
        fontWeight: "var(--ink-internal-syntax-heading5-font-weight)"
      },
      {
        tag: tags$5.heading6,
        color: "var(--ink-internal-syntax-heading6-color)",
        fontSize: "var(--ink-internal-syntax-heading6-font-size)",
        fontWeight: "var(--ink-internal-syntax-heading6-font-weight)"
      },
      {
        tag: tags$5.keyword,
        color: "var(--ink-internal-syntax-keyword-color)"
      },
      {
        tag: tags$5.number,
        color: "var(--ink-internal-syntax-number-color)"
      },
      {
        tag: tags$5.operator,
        color: "var(--ink-internal-syntax-operator-color)"
      },
      {
        tag: tags$5.punctuation,
        color: "var(--ink-internal-syntax-punctuation-color)"
      },
      {
        tag: tags$5.link,
        color: "var(--ink-internal-syntax-link-color)"
      },
      {
        tag: tags$5.url,
        color: "var(--ink-internal-syntax-url-color)"
      },
      {
        tag: tags$5.string,
        color: "var(--ink-internal-syntax-string-color)"
      },
      {
        tag: tags$5.special(tags$5.string),
        color: "var(--ink-internal-syntax-string-special-color)"
      },
      {
        tag: tags$5.processingInstruction,
        color: "var(--ink-internal-syntax-processing-instruction-color)"
      }
    ])
  )
], mn = (e) => {
  if (e.length > 0)
    return De(e);
}, He = (e) => {
  const t4 = e.options.plugins.flatMap((o) => o.type === re$2.Default ? o.value : []), n = e.options.plugins.flatMap((o) => o.type === re$2.Grammar ? o.value : []);
  return EditorState.create({
    doc: e.options.doc,
    selection: mn(e.options.selections),
    extensions: [
      ...St(e),
      Zt(),
      sn(),
      history(),
      dn(),
      fn(),
      gn(),
      markdown({
        base: markdownLanguage,
        codeLanguages: languages,
        extensions: n
      }),
      pn(),
      ...t4
    ]
  });
}, hn = ([e, t4], n) => {
  t4(P(e(), { options: { doc: n } })), e().editor.setState(He(e()));
}, kn = ([e]) => e().options, bn = async ([e, t4], n) => {
  const o = t4(P(e(), { options: n })), r = await ue(o);
  o.editor.dispatch({ effects: r });
}, ze = (e, t4 = {}) => {
  if (t4.selections)
    return Be(e, t4.selections);
  if (t4.selection)
    return se(e, t4.selection);
  if (t4.at)
    return xn(e, t4.at);
}, xn = (e, t4) => {
  const [n] = e;
  if (t4 === ie.Start)
    return se(e, { start: 0, end: 0 });
  if (t4 === ie.End) {
    const o = n().editor.state.doc.length;
    return se(e, { start: o, end: o });
  }
}, Be = ([e], t4) => {
  const { editor: n } = e();
  n.dispatch(
    n.state.update({
      selection: De(t4)
    })
  );
}, se = (e, t4) => Be(e, [t4]), vn = ([e], t4) => {
  const { editor: n } = e();
  n.dispatch(
    n.state.update({
      changes: {
        from: 0,
        to: n.state.doc.length,
        insert: t4
      }
    })
  );
}, G = ([e, t4], { after: n, before: o, selection: r }) => {
  const { editor: i } = e(), l2 = r || Z([e, t4]).pop() || { start: 0, end: 0 }, a2 = i.state.sliceDoc(l2.start, l2.end);
  O([e, t4], `${o}${a2}${n}`, l2), ze([e, t4], { selections: [{ start: l2.start + o.length, end: l2.end + o.length }] });
}, Ee = (e) => ({
  destroy: Et.bind(void 0, e),
  focus: le.bind(void 0, e),
  format: Ae.bind(void 0, e),
  getDoc: Pt.bind(void 0, e),
  insert: O.bind(void 0, e),
  load: hn.bind(void 0, e),
  options: kn.bind(void 0, e),
  reconfigure: bn.bind(void 0, e),
  select: ze.bind(void 0, e),
  selections: Z.bind(void 0, e),
  update: vn.bind(void 0, e),
  wrap: G.bind(void 0, e)
}), yn = `.ink-drop-zone{align-items:center;background-color:#00000080;color:var(--ink-internal-color);display:flex;inset:0;justify-content:center;position:var(--ink-internal-modal-position);z-index:100}.ink-drop-zone:not(.visible){display:none}.ink-drop-zone-modal{background-color:var(--ink-internal-block-background-color);border-radius:var(--ink-internal-border-radius);box-sizing:border-box;height:100%;max-height:20rem;max-width:40rem;padding:1rem;position:relative;width:100%}.ink-drop-zone-hide{cursor:pointer;height:1.75rem;position:absolute;right:.25rem;top:.25rem;width:1.75rem}.ink-drop-zone-hide svg{background-color:var(--ink-internal-block-background-color)}.ink-drop-zone-droppable-area{align-items:center;border:.2rem dashed var(--ink-internal-color);border-radius:.125rem;box-sizing:border-box;display:flex;flex-direction:column;font-size:1.25em;gap:1rem;height:100%;justify-content:center;padding:1rem;text-align:center}.ink-drop-zone-file-preview{align-items:center;display:flex;flex-wrap:wrap;gap:.5rem;max-width:25.5rem}.ink-drop-zone-file-preview-image{border:.125rem solid #222;border-radius:.125rem;box-sizing:border-box;height:6rem;object-fit:cover;padding:.5rem;width:6rem}
`, $n = /* @__PURE__ */ template$1("<span>uploading files...</span>"), wn = /* @__PURE__ */ template$1('<div class="ink-drop-zone"><style></style><div class="ink-drop-zone-modal"><div class="ink-drop-zone-droppable-area"><div class="ink-drop-zone-file-preview"></div><!#><!/></div><div class="ink-drop-zone-hide"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg></div></div></div>'), _n = /* @__PURE__ */ template$1('<img class="ink-drop-zone-file-preview-image">'), Cn = /* @__PURE__ */ template$1("<span>drop files here</span>"), Ln = () => {
  const [e, t4] = createSignal(0), [n, o] = createSignal([]), [r, i] = createSignal(false), [l2, a2] = createSignal(false), [s2, u] = W(), x2 = () => {
    a2(false);
  }, y2 = (f2) => {
    if (s2().options.files.dragAndDrop) {
      f2.preventDefault(), f2.stopPropagation();
      const p = f2.dataTransfer;
      (p == null ? void 0 : p.files) ? E2(p.files) : (t4(0), a2(false), o([]));
    }
  }, C2 = (f2) => {
    s2().options.files.dragAndDrop && (f2.preventDefault(), t4(e() + 1), a2(true));
  }, S2 = (f2) => {
    s2().options.files.dragAndDrop && (f2.preventDefault(), t4(e() - 1), e() === 0 && a2(false));
  }, M2 = (f2) => {
    s2().options.files.dragAndDrop && (f2.preventDefault(), a2(true));
  }, A5 = (f2) => {
    s2().options.files.dragAndDrop && (f2.preventDefault(), t4(0), a2(false));
  }, B2 = (f2) => {
    if (s2().options.files.clipboard) {
      f2.preventDefault();
      const p = f2.clipboardData;
      (p == null ? void 0 : p.files) && p.files.length > 0 && E2(p.files);
    }
  }, E2 = (f2) => {
    Array.from(f2).forEach((p) => {
      o([...n(), p]);
    }), i(true), a2(true), Promise.resolve(s2().options.files.handler(f2)).then((p) => {
      if (s2().options.files.injectMarkup && p) {
        const T = `![](${p})`;
        O([s2, u], T);
      }
    }).finally(() => {
      t4(0), i(false), a2(false), o([]);
    });
  };
  return onMount(() => {
    document.addEventListener("dragenter", C2), document.addEventListener("dragleave", S2), document.addEventListener("dragover", M2), document.addEventListener("drop", A5), s2().root.addEventListener("paste", B2);
  }), onCleanup(() => {
    document.removeEventListener("dragenter", C2), document.removeEventListener("dragleave", S2), document.removeEventListener("dragover", M2), document.removeEventListener("drop", A5), s2().root.removeEventListener("paste", B2);
  }), (() => {
    const f2 = getNextElement(wn), p = f2.firstChild, T = p.nextSibling, D2 = T.firstChild, F = D2.firstChild, J = F.nextSibling, [U, ee] = getNextMarker(J.nextSibling), te = D2.nextSibling;
    return p.textContent = yn, D2.addEventListener("drop", y2), insert$1(F, createComponent(For, {
      get each() {
        return n().slice(0, 8);
      },
      children: (X3) => (() => {
        const q = getNextElement(_n);
        return createRenderEffect((w2) => {
          const K2 = X3.name, I = URL.createObjectURL(X3);
          return K2 !== w2._v$ && setAttribute(q, "alt", w2._v$ = K2), I !== w2._v$2 && setAttribute(q, "src", w2._v$2 = I), w2;
        }, {
          _v$: void 0,
          _v$2: void 0
        }), q;
      })()
    })), insert$1(D2, createComponent(Show, {
      get when() {
        return r();
      },
      get fallback() {
        return getNextElement(Cn);
      },
      get children() {
        return getNextElement($n);
      }
    }), U, ee), te.$$click = x2, createRenderEffect(() => f2.classList.toggle("visible", !!l2())), runHydrationEvents(), f2;
  })();
};
delegateEvents(["click"]);
const Sn = (e) => {
  const t4 = new EditorView({
    dispatch: (n) => {
      const { options: o } = e;
      o.hooks.beforeUpdate(n.newDoc.toString()), t4.update([n]), n.docChanged && o.hooks.afterUpdate(n.newDoc.toString());
    },
    state: He(e)
  });
  return t4;
}, Mn = () => {
  const [e, t4] = W(), n = Sn(e());
  return t4(P(e(), {
    editor: n
  })), ue(e()).then((o) => {
    n.dispatch({
      effects: o
    });
  }), n.dom;
}, An = /* @__PURE__ */ template$1('<button class="ink-button" type="button"></button>'), $ = (e) => (() => {
  const t4 = getNextElement(An);
  return t4.$$click = (n) => e.onclick(n), insert$1(t4, () => e.children), runHydrationEvents(), t4;
})();
delegateEvents(["click"]);
const Dn = `.ink .ink-toolbar{background-color:var(--ink-internal-block-background-color);border-radius:var(--ink-internal-border-radius);bottom:.25rem;color:inherit;display:flex;flex-shrink:0;gap:2rem;overflow:auto;padding:.25rem;position:sticky;top:.25rem;z-index:10}.ink .ink-toolbar-group{display:flex}.ink .ink-toolbar .ink-button{align-items:center;background:none;border:none;border-radius:var(--ink-internal-border-radius);color:inherit;cursor:pointer;display:flex;height:2.25rem;justify-content:center;padding:.4rem;width:2.25rem}.ink .ink-toolbar .ink-button:hover{background-color:var(--ink-internal-block-background-color-on-hover)}.ink .ink-toolbar .ink-button>*{align-items:center;display:flex;height:100%}
`, Hn = /* @__PURE__ */ template$1('<svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-miterlimit="5" stroke-linecap="round" stroke-linejoin="round"><path d="M6 4V10M6 16V10M6 10H14M14 10V4M14 10V16"></path></svg>'), zn = /* @__PURE__ */ template$1('<svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-width="1.5" stroke-miterlimit="5" stroke-linecap="round" stroke-linejoin="round"><path d="M6.5 10H10.5C12.1569 10 13.5 11.3431 13.5 13C13.5 14.6569 12.1569 16 10.5 16H6.5V4H9.5C11.1569 4 12.5 5.34315 12.5 7C12.5 8.65686 11.1569 10 9.5 10"></path></svg>'), Bn = /* @__PURE__ */ template$1('<svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-miterlimit="5" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4L9 16M13 4H9M7 16H11"></path></svg>'), En = /* @__PURE__ */ template$1('<svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-miterlimit="5" stroke-linecap="round" stroke-linejoin="round"><path d="M2.00257 16H17.9955M2.00055 4H18M7 10H18.0659M2 8.5V11.4999C2.4 11.5 2.5 11.5 2.5 11.5V11V10.5M4 8.5V11.4999H4.5V11V10.5"></path></svg>'), jn = /* @__PURE__ */ template$1('<svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-miterlimit="5" stroke-linecap="round" stroke-linejoin="round"><path d="M13 4L7 16"></path><path d="M5 7L2 10L5 13"></path><path d="M15 7L18 10L15 13"></path></svg>'), Vn = /* @__PURE__ */ template$1('<svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-miterlimit="5" stroke-linecap="round" stroke-linejoin="round"><path d="M7 4L8 6"></path></svg>'), On = /* @__PURE__ */ template$1('<svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-miterlimit="5" stroke-linecap="round" stroke-linejoin="round"><path d="M7 16H17.8294"></path><path d="M2 16H4"></path><path d="M7 10H17.8294"></path><path d="M2 10H4"></path><path d="M7 4H17.8294"></path><path d="M2 4H4"></path></svg>'), Nn = /* @__PURE__ */ template$1('<svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-miterlimit="5" stroke-linecap="round" stroke-linejoin="round"><path d="M7 16H18"></path><path d="M2 17.0242C2.48314 17.7569 3.94052 17.6154 3.99486 16.7919C4.05315 15.9169 3.1975 16.0044 2.99496 16.0044M2.0023 14.9758C2.48544 14.2431 3.94282 14.3846 3.99716 15.2081C4.05545 16.0831 3.1998 16.0002 2.99726 16.0002"></path><path d="M7 10H18"></path><path d="M2.00501 11.5H4M2.00193 8.97562C2.48449 8.24319 3.9401 8.38467 3.99437 9.20777C4.05259 10.0825 2.04342 10.5788 2 11.4996"></path><path d="M7 4H18"></path><path d="M2 5.5H4M2.99713 5.49952V2.5L2.215 2.93501"></path></svg>'), Tn = /* @__PURE__ */ template$1('<svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-miterlimit="5" stroke-linecap="round" stroke-linejoin="round"><path d="M7 16H17.8294"></path><path d="M5 15L3 17L2 16"></path><path d="M7 10H17.8294"></path><path d="M5 9L3 11L2 10"></path><path d="M7 4H17.8294"></path><path d="M5 3L3 5L2 4"></path></svg>'), qn = /* @__PURE__ */ template$1('<svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-miterlimit="5" stroke-linecap="round" stroke-linejoin="round"><path d="M9.12127 10.881C10.02 11.78 11.5237 11.7349 12.4771 10.7813L15.2546 8.00302C16.2079 7.04937 16.253 5.54521 15.3542 4.6462C14.4555 3.74719 12.9512 3.79174 11.9979 4.74539L10.3437 6.40007M10.8787 9.11903C9.97997 8.22002 8.47626 8.26509 7.52288 9.21874L4.74545 11.997C3.79208 12.9506 3.74701 14.4548 4.64577 15.3538C5.54452 16.2528 7.04876 16.2083 8.00213 15.2546L9.65633 13.5999"></path></svg>'), In = /* @__PURE__ */ template$1('<svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-miterlimit="5" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="4" width="16" height="12" rx="1"></rect><path d="M7.42659 7.67597L13.7751 13.8831M2.00208 12.9778L7.42844 7.67175"></path><path d="M11.9119 12.0599L14.484 9.54443L17.9973 12.9785"></path><path d="M10.9989 7.95832C11.551 7.95832 11.9986 7.52072 11.9986 6.98092C11.9986 6.44113 11.551 6.00354 10.9989 6.00354C10.4468 6.00354 9.99921 6.44113 9.99921 6.98092C9.99921 7.52072 10.4468 7.95832 10.9989 7.95832Z"></path></svg>'), Rn = /* @__PURE__ */ template$1('<svg viewBox="0 0 20 20" fill="none" stroke="currentColor" stroke-miterlimit="5" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13V4M10 4L13 7M10 4L7 7"></path><path d="M2 13V15C2 15.5523 2.44772 16 3 16H17C17.5523 16 18 15.5523 18 15V13"></path></svg>'), Pn = /* @__PURE__ */ template$1('<input type="file">'), Wn = /* @__PURE__ */ template$1('<div class="ink-toolbar"><style></style><div class="ink-toolbar-group"><!#><!/><!#><!/><!#><!/></div><div class="ink-toolbar-group"><!#><!/><!#><!/><!#><!/></div><div class="ink-toolbar-group"><!#><!/><!#><!/><!#><!/></div><div class="ink-toolbar-group"><!#><!/><!#><!/><!#><!/></div></div>'), Fn = () => {
  const [e, t4] = W(), [n, o] = createSignal(), r = (a2) => {
    Ae([e, t4], a2), le([e, t4]);
  }, i = (a2) => {
    const s2 = a2.target;
    (s2 == null ? void 0 : s2.files) && Promise.resolve(e().options.files.handler(s2.files)).then((u) => {
      const x2 = `![](${u})`;
      O([e, t4], x2), le([e, t4]);
    });
  }, l2 = () => {
    var _a2;
    (_a2 = n()) == null ? void 0 : _a2.click();
  };
  return (() => {
    const a2 = getNextElement(Wn), s2 = a2.firstChild, u = s2.nextSibling, x2 = u.firstChild, [y2, C2] = getNextMarker(x2.nextSibling), S2 = y2.nextSibling, [M2, A5] = getNextMarker(S2.nextSibling), B2 = M2.nextSibling, [E2, f2] = getNextMarker(B2.nextSibling), p = u.nextSibling, T = p.firstChild, [D2, F] = getNextMarker(T.nextSibling), J = D2.nextSibling, [U, ee] = getNextMarker(J.nextSibling), te = U.nextSibling, [X3, q] = getNextMarker(te.nextSibling), w2 = p.nextSibling, K2 = w2.firstChild, [I, Oe] = getNextMarker(K2.nextSibling), Ne = I.nextSibling, [me, Te] = getNextMarker(Ne.nextSibling), qe = me.nextSibling, [Ie, Re] = getNextMarker(qe.nextSibling), Q = w2.nextSibling, Pe = Q.firstChild, [he, We] = getNextMarker(Pe.nextSibling), Fe = he.nextSibling, [ke, Ue] = getNextMarker(Fe.nextSibling), Xe = ke.nextSibling, [Ke, Qe] = getNextMarker(Xe.nextSibling);
    return s2.textContent = Dn, insert$1(u, createComponent(Show, {
      get when() {
        return e().options.toolbar.heading;
      },
      get children() {
        return createComponent($, {
          onclick: () => r(g.Heading),
          get children() {
            return getNextElement(Hn);
          }
        });
      }
    }), y2, C2), insert$1(u, createComponent(Show, {
      get when() {
        return e().options.toolbar.bold;
      },
      get children() {
        return createComponent($, {
          onclick: () => r(g.Bold),
          get children() {
            return getNextElement(zn);
          }
        });
      }
    }), M2, A5), insert$1(u, createComponent(Show, {
      get when() {
        return e().options.toolbar.italic;
      },
      get children() {
        return createComponent($, {
          onclick: () => r(g.Italic),
          get children() {
            return getNextElement(Bn);
          }
        });
      }
    }), E2, f2), insert$1(p, createComponent(Show, {
      get when() {
        return e().options.toolbar.quote;
      },
      get children() {
        return createComponent($, {
          onclick: () => r(g.Quote),
          get children() {
            return getNextElement(En);
          }
        });
      }
    }), D2, F), insert$1(p, createComponent(Show, {
      get when() {
        return e().options.toolbar.codeBlock;
      },
      get children() {
        return createComponent($, {
          onclick: () => r(g.CodeBlock),
          get children() {
            return getNextElement(jn);
          }
        });
      }
    }), U, ee), insert$1(p, createComponent(Show, {
      get when() {
        return e().options.toolbar.code;
      },
      get children() {
        return createComponent($, {
          onclick: () => r(g.Code),
          get children() {
            return getNextElement(Vn);
          }
        });
      }
    }), X3, q), insert$1(w2, createComponent(Show, {
      get when() {
        return e().options.toolbar.list;
      },
      get children() {
        return createComponent($, {
          onclick: () => r(g.List),
          get children() {
            return getNextElement(On);
          }
        });
      }
    }), I, Oe), insert$1(w2, createComponent(Show, {
      get when() {
        return e().options.toolbar.orderedList;
      },
      get children() {
        return createComponent($, {
          onclick: () => r(g.OrderedList),
          get children() {
            return getNextElement(Nn);
          }
        });
      }
    }), me, Te), insert$1(w2, createComponent(Show, {
      get when() {
        return e().options.toolbar.taskList;
      },
      get children() {
        return createComponent($, {
          onclick: () => r(g.TaskList),
          get children() {
            return getNextElement(Tn);
          }
        });
      }
    }), Ie, Re), insert$1(Q, createComponent(Show, {
      get when() {
        return e().options.toolbar.link;
      },
      get children() {
        return createComponent($, {
          onclick: () => r(g.Link),
          get children() {
            return getNextElement(qn);
          }
        });
      }
    }), he, We), insert$1(Q, createComponent(Show, {
      get when() {
        return e().options.toolbar.image;
      },
      get children() {
        return createComponent($, {
          onclick: () => r(g.Image),
          get children() {
            return getNextElement(In);
          }
        });
      }
    }), ke, Ue), insert$1(Q, createComponent(Show, {
      get when() {
        return e().options.toolbar.upload;
      },
      get children() {
        return createComponent($, {
          onclick: l2,
          get children() {
            return [getNextElement(Rn), (() => {
              const Y3 = getNextElement(Pn);
              return o(Y3), Y3.addEventListener("change", i), Y3.style.setProperty("display", "none"), Y3;
            })()];
          }
        });
      }
    }), Ke, Qe), a2;
  })();
}, Un = `.ink{color:var(--ink-internal-color, inherit);display:flex;flex-direction:var(--ink-internal-flex-direction, column);gap:1rem;padding:var(--ink-internal-editor-padding, 0)}.ink .cm-tooltip{background-color:var(--ink-internal-block-background-color);border-radius:var(--ink-internal-border-radius);font-family:inherit;padding:.25rem}.ink .cm-tooltip.cm-tooltip-autocomplete ul{font-family:inherit}.ink .cm-tooltip.cm-tooltip-autocomplete ul li.ink-tooltip-option{border-radius:var(--ink-internal-border-radius);padding:.25rem}.ink .cm-tooltip.cm-tooltip-autocomplete ul li.ink-tooltip-option[aria-selected]{background-color:#96969640}.ink .cm-completionLabel{font-family:inherit}.ink-mde,.ink-mde *{box-sizing:border-box}.ink-mde .ink-mde-editor-container{display:flex;flex-direction:column;flex-grow:1;gap:2em}.ink-mde .ink-mde-attribution{display:flex;font-size:.75em;justify-content:flex-end;opacity:.5}.ink-mde .ink-mde-attribution-link{color:currentColor;font-weight:600;text-decoration:none}.ink-mde .ink-mde-task-toggle{cursor:pointer;height:1rem;line-height:2em;margin:0 .25rem 0 0;position:relative;top:-1px;vertical-align:middle;width:1rem}.ink-mde .cm-editor{display:flex;flex-direction:column;position:relative}.ink-mde .cm-scroller{align-items:flex-start;display:flex;font-family:var(--ink-internal-font-family);font-size:var(--ink-internal-editor-font-size);line-height:var(--ink-internal-editor-line-height);overflow-x:auto;position:relative}.ink-mde .cm-content{display:block;flex-grow:2;flex-shrink:0;margin:0;outline:none;padding:0;white-space:pre;word-wrap:normal}.ink-mde .cm-lineWrapping{flex-shrink:1;overflow-wrap:anywhere;white-space:break-spaces;word-break:break-word}.ink-mde .cm-line{font-family:var(--ink-internal-font-family);padding:0}.ink-mde .cm-line.cm-blockquote{background-color:var(--ink-internal-block-background-color);border-left:.25rem solid currentColor;padding:0 var(--ink-internal-block-padding)}.ink-mde .cm-line.cm-blockquote.cm-blockquote-open{border-top-left-radius:var(--ink-internal-border-radius);border-top-right-radius:var(--ink-internal-border-radius);padding-top:var(--ink-internal-block-padding)}.ink-mde .cm-line.cm-blockquote.cm-blockquote-close{border-bottom-left-radius:var(--ink-internal-border-radius);border-bottom-right-radius:var(--ink-internal-border-radius);padding-bottom:var(--ink-internal-block-padding)}.ink-mde .cm-line.cm-codeblock{background-color:var(--ink-internal-block-background-color);font-family:var(--ink-internal-code-font-family);padding:0 var(--ink-internal-block-padding)}.ink-mde .cm-line.cm-codeblock.cm-codeblock-open{border-radius:var(--ink-internal-border-radius) var(--ink-internal-border-radius) 0 0;padding-top:var(--ink-internal-block-padding)}.ink-mde .cm-line.cm-codeblock.cm-codeblock-close{border-radius:0 0 var(--ink-internal-border-radius) var(--ink-internal-border-radius);padding-bottom:var(--ink-internal-block-padding)}.ink-mde .cm-line .cm-code{background-color:var(--ink-internal-block-background-color);font-family:var(--ink-internal-code-font-family);padding:var(--ink-internal-inline-padding) 0}.ink-mde .cm-line .cm-code.cm-code-open{border-radius:var(--ink-internal-border-radius) 0 0 var(--ink-internal-border-radius);padding-left:var(--ink-internal-inline-padding)}.ink-mde .cm-line .cm-code.cm-code-close{border-radius:0 var(--ink-internal-border-radius) var(--ink-internal-border-radius) 0;padding-right:var(--ink-internal-inline-padding)}.ink-mde .cm-image-backdrop{background-color:var(--ink-internal-block-background-color)}
`, Xn$2 = /* @__PURE__ */ template$1("<style> </style>"), Kn = () => {
  const [e] = W(), [t4, n] = createSignal(ne(e()));
  return createEffect(() => {
    n(ne(e()));
  }), onMount(() => {
    const o = window.matchMedia("(prefers-color-scheme: dark)"), r = (i) => {
      const {
        editor: l2,
        root: a2
      } = e();
      a2.isConnected ? ue(e()).then((s2) => {
        l2.dispatch({
          effects: s2
        }), n(ne(e()));
      }) : o.removeEventListener("change", r);
    };
    o.addEventListener("change", r);
  }), (() => {
    const o = getNextElement(Xn$2), r = o.firstChild;
    return createRenderEffect(() => r.data = `.ink {
  ${t4().join(`
  `)}
}
${Un}`), o;
  })();
}, Qn = /* @__PURE__ */ template$1('<div class="ink-mde-attribution"><span>powered by <a class="ink-mde-attribution-link" href="https://github.com/voracious/ink-mde" rel="noopener noreferrer" target="_blank">ink-mde</a></span></div>'), Yn$2 = /* @__PURE__ */ template$1('<div class="ink ink-mde"><!#><!/><!#><!/><!#><!/><div class="ink-mde-editor-container"><!#><!/><!#><!/></div></div>'), Zn$2 = () => {
  const [e, t4] = W(), n = (o) => {
    t4(P(e(), {
      root: o
    }));
  };
  return (() => {
    const o = getNextElement(Yn$2), r = o.firstChild, [i, l2] = getNextMarker(r.nextSibling), a2 = i.nextSibling, [s2, u] = getNextMarker(a2.nextSibling), x2 = s2.nextSibling, [y2, C2] = getNextMarker(x2.nextSibling), S2 = y2.nextSibling, M2 = S2.firstChild, [A5, B2] = getNextMarker(M2.nextSibling), E2 = A5.nextSibling, [f2, p] = getNextMarker(E2.nextSibling);
    return n(o), spread(o, yt, false, true), insert$1(o, createComponent(Kn, {}), i, l2), insert$1(o, createComponent(Show, {
      get when() {
        return e().options.files.clipboard || e().options.files.dragAndDrop;
      },
      get children() {
        return createComponent(Ln, {});
      }
    }), s2, u), insert$1(o, createComponent(Show, {
      get when() {
        return e().options.interface.toolbar;
      },
      get children() {
        return createComponent(Fn, {});
      }
    }), y2, C2), insert$1(S2, createComponent(Mn, {}), A5, B2), insert$1(S2, createComponent(Show, {
      get when() {
        return e().options.interface.attribution;
      },
      get children() {
        return getNextElement(Qn);
      }
    }), f2, p), runHydrationEvents(), o;
  })();
}, je = createContext([() => ae(), (e) => typeof e == "function" ? e(ae()) : e]), Gn = (e) => createComponent(je.Provider, {
  get value() {
    return e.store;
  },
  get children() {
    return e.children;
  }
}), W = () => useContext(je), Ve = (e) => createComponent(Gn, {
  get store() {
    return e.store;
  },
  get children() {
    return createComponent(Zn$2, {
      get store() {
        return e.store;
      }
    });
  }
}), Jn = (e, t4 = {}) => {
  const n = fe(t4);
  return to(), hydrate(() => createComponent(Ve, {
    store: n
  }), e), Ee(n);
}, go = (e, t4 = {}) => e.querySelector(vt) ? Jn(e, t4) : eo(e, t4), eo = (e, t4 = {}) => {
  const n = fe(t4);
  return render$3(() => createComponent(Ve, {
    store: n
  }), e), Ee(n);
}, po = (e = {}) => (fe(e), ""), to = () => {
  let e, t4;
  e = window._$HY || (window._$HY = {
    events: [],
    completed: /* @__PURE__ */ new WeakSet(),
    r: {}
  }), t4 = (n) => n && n.hasAttribute && (n.hasAttribute("data-hk") ? n : t4(n.host && n.host instanceof Node ? n.host : n.parentNode)), ["click", "input"].forEach((n) => document.addEventListener(n, (o) => {
    let r = o.composedPath && o.composedPath()[0] || o.target, i = t4(r);
    i && !e.completed.has(i) && e.events.push([i, o]);
  })), e.init = (n, o) => {
    e.r[n] = [new Promise((r, i) => o = r), o];
  }, e.set = (n, o, r) => {
    (r = e.r[n]) && r[1](o), e.r[n] = [o];
  }, e.unset = (n) => {
    delete e.r[n];
  }, e.load = (n, o) => {
    if (o = e.r[n])
      return o[0];
  };
};
const h = defineComponent({
  name: "InkMde",
  emits: ["update:modelValue"],
  props: {
    modelValue: {
      type: String
    },
    options: {
      type: Object
    }
  },
  data() {
    return {
      html: "",
      instance: void 0
    };
  },
  watch: {
    modelValue(t4) {
      var n, e;
      ((n = this.instance) == null ? void 0 : n.getDoc()) !== t4 && ((e = this.instance) == null || e.update(t4));
    },
    options: {
      deep: true,
      handler(t4, n) {
        var e;
        (e = this.instance) == null || e.reconfigure(t4);
      }
    }
  },
  methods: {
    tryInit() {
      var t4;
      this.$refs.ink && !this.instance && (this.instance = go(this.$refs.ink, {
        ...this.options,
        doc: this.modelValue,
        hooks: {
          ...(t4 = this.options) == null ? void 0 : t4.hooks,
          afterUpdate: (n) => {
            var e, i;
            this.$emit("update:modelValue", n), (i = (e = this.options) == null ? void 0 : e.hooks) != null && i.afterUpdate && this.options.hooks.afterUpdate(n);
          }
        }
      }), this.$refs.ink.addEventListener("input", (n) => {
        n.stopPropagation();
      }), this.instance.focus());
    }
  },
  created() {
    ({ BASE_URL: "/", MODE: "production", DEV: false, PROD: true }).VITE_SSR && (this.html = po(this.options));
  },
  mounted() {
    this.tryInit();
  },
  updated() {
    this.tryInit();
  }
}), c$4 = (t4, n) => {
  const e = t4.__vccOpts || t4;
  for (const [i, o] of n)
    e[i] = o;
  return e;
}, f = ["innerHTML"];
function l(t4, n, e, i, o, u) {
  return openBlock(), createElementBlock("div", {
    ref: "ink",
    innerHTML: t4.html
  }, null, 8, f);
}
const _$E = /* @__PURE__ */ c$4(h, [["render", l]]);
const readTime = (text2, wordsPerMinute = 225) => {
  return wordCount(text2) / wordsPerMinute;
};
const wordCount = (text2) => {
  const scrubbed = text2.replace(/[']/g, "").replace(/[^\w\d]+/g, " ").trim();
  return scrubbed === "" ? 0 : scrubbed.split(/\s+/).length;
};
var mimeTypes = {};
var mimeDb = { exports: {} };
const require$$0$1 = {
  "application/1d-interleaved-parityfec": {
    source: "iana"
  },
  "application/3gpdash-qoe-report+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/3gpp-ims+xml": {
    source: "iana",
    compressible: true
  },
  "application/3gpphal+json": {
    source: "iana",
    compressible: true
  },
  "application/3gpphalforms+json": {
    source: "iana",
    compressible: true
  },
  "application/a2l": {
    source: "iana"
  },
  "application/ace+cbor": {
    source: "iana"
  },
  "application/activemessage": {
    source: "iana"
  },
  "application/activity+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-costmap+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-costmapfilter+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-directory+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointcost+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointcostparams+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointprop+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointpropparams+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-error+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-networkmap+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-networkmapfilter+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-updatestreamcontrol+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-updatestreamparams+json": {
    source: "iana",
    compressible: true
  },
  "application/aml": {
    source: "iana"
  },
  "application/andrew-inset": {
    source: "iana",
    extensions: [
      "ez"
    ]
  },
  "application/applefile": {
    source: "iana"
  },
  "application/applixware": {
    source: "apache",
    extensions: [
      "aw"
    ]
  },
  "application/at+jwt": {
    source: "iana"
  },
  "application/atf": {
    source: "iana"
  },
  "application/atfx": {
    source: "iana"
  },
  "application/atom+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atom"
    ]
  },
  "application/atomcat+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atomcat"
    ]
  },
  "application/atomdeleted+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atomdeleted"
    ]
  },
  "application/atomicmail": {
    source: "iana"
  },
  "application/atomsvc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atomsvc"
    ]
  },
  "application/atsc-dwd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "dwd"
    ]
  },
  "application/atsc-dynamic-event-message": {
    source: "iana"
  },
  "application/atsc-held+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "held"
    ]
  },
  "application/atsc-rdt+json": {
    source: "iana",
    compressible: true
  },
  "application/atsc-rsat+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rsat"
    ]
  },
  "application/atxml": {
    source: "iana"
  },
  "application/auth-policy+xml": {
    source: "iana",
    compressible: true
  },
  "application/bacnet-xdd+zip": {
    source: "iana",
    compressible: false
  },
  "application/batch-smtp": {
    source: "iana"
  },
  "application/bdoc": {
    compressible: false,
    extensions: [
      "bdoc"
    ]
  },
  "application/beep+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/calendar+json": {
    source: "iana",
    compressible: true
  },
  "application/calendar+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xcs"
    ]
  },
  "application/call-completion": {
    source: "iana"
  },
  "application/cals-1840": {
    source: "iana"
  },
  "application/captive+json": {
    source: "iana",
    compressible: true
  },
  "application/cbor": {
    source: "iana"
  },
  "application/cbor-seq": {
    source: "iana"
  },
  "application/cccex": {
    source: "iana"
  },
  "application/ccmp+xml": {
    source: "iana",
    compressible: true
  },
  "application/ccxml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ccxml"
    ]
  },
  "application/cdfx+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "cdfx"
    ]
  },
  "application/cdmi-capability": {
    source: "iana",
    extensions: [
      "cdmia"
    ]
  },
  "application/cdmi-container": {
    source: "iana",
    extensions: [
      "cdmic"
    ]
  },
  "application/cdmi-domain": {
    source: "iana",
    extensions: [
      "cdmid"
    ]
  },
  "application/cdmi-object": {
    source: "iana",
    extensions: [
      "cdmio"
    ]
  },
  "application/cdmi-queue": {
    source: "iana",
    extensions: [
      "cdmiq"
    ]
  },
  "application/cdni": {
    source: "iana"
  },
  "application/cea": {
    source: "iana"
  },
  "application/cea-2018+xml": {
    source: "iana",
    compressible: true
  },
  "application/cellml+xml": {
    source: "iana",
    compressible: true
  },
  "application/cfw": {
    source: "iana"
  },
  "application/city+json": {
    source: "iana",
    compressible: true
  },
  "application/clr": {
    source: "iana"
  },
  "application/clue+xml": {
    source: "iana",
    compressible: true
  },
  "application/clue_info+xml": {
    source: "iana",
    compressible: true
  },
  "application/cms": {
    source: "iana"
  },
  "application/cnrp+xml": {
    source: "iana",
    compressible: true
  },
  "application/coap-group+json": {
    source: "iana",
    compressible: true
  },
  "application/coap-payload": {
    source: "iana"
  },
  "application/commonground": {
    source: "iana"
  },
  "application/conference-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/cose": {
    source: "iana"
  },
  "application/cose-key": {
    source: "iana"
  },
  "application/cose-key-set": {
    source: "iana"
  },
  "application/cpl+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "cpl"
    ]
  },
  "application/csrattrs": {
    source: "iana"
  },
  "application/csta+xml": {
    source: "iana",
    compressible: true
  },
  "application/cstadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/csvm+json": {
    source: "iana",
    compressible: true
  },
  "application/cu-seeme": {
    source: "apache",
    extensions: [
      "cu"
    ]
  },
  "application/cwt": {
    source: "iana"
  },
  "application/cybercash": {
    source: "iana"
  },
  "application/dart": {
    compressible: true
  },
  "application/dash+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpd"
    ]
  },
  "application/dash-patch+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpp"
    ]
  },
  "application/dashdelta": {
    source: "iana"
  },
  "application/davmount+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "davmount"
    ]
  },
  "application/dca-rft": {
    source: "iana"
  },
  "application/dcd": {
    source: "iana"
  },
  "application/dec-dx": {
    source: "iana"
  },
  "application/dialog-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/dicom": {
    source: "iana"
  },
  "application/dicom+json": {
    source: "iana",
    compressible: true
  },
  "application/dicom+xml": {
    source: "iana",
    compressible: true
  },
  "application/dii": {
    source: "iana"
  },
  "application/dit": {
    source: "iana"
  },
  "application/dns": {
    source: "iana"
  },
  "application/dns+json": {
    source: "iana",
    compressible: true
  },
  "application/dns-message": {
    source: "iana"
  },
  "application/docbook+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "dbk"
    ]
  },
  "application/dots+cbor": {
    source: "iana"
  },
  "application/dskpp+xml": {
    source: "iana",
    compressible: true
  },
  "application/dssc+der": {
    source: "iana",
    extensions: [
      "dssc"
    ]
  },
  "application/dssc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xdssc"
    ]
  },
  "application/dvcs": {
    source: "iana"
  },
  "application/ecmascript": {
    source: "iana",
    compressible: true,
    extensions: [
      "es",
      "ecma"
    ]
  },
  "application/edi-consent": {
    source: "iana"
  },
  "application/edi-x12": {
    source: "iana",
    compressible: false
  },
  "application/edifact": {
    source: "iana",
    compressible: false
  },
  "application/efi": {
    source: "iana"
  },
  "application/elm+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/elm+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.cap+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/emergencycalldata.comment+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.control+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.deviceinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.ecall.msd": {
    source: "iana"
  },
  "application/emergencycalldata.providerinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.serviceinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.subscriberinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.veds+xml": {
    source: "iana",
    compressible: true
  },
  "application/emma+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "emma"
    ]
  },
  "application/emotionml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "emotionml"
    ]
  },
  "application/encaprtp": {
    source: "iana"
  },
  "application/epp+xml": {
    source: "iana",
    compressible: true
  },
  "application/epub+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "epub"
    ]
  },
  "application/eshop": {
    source: "iana"
  },
  "application/exi": {
    source: "iana",
    extensions: [
      "exi"
    ]
  },
  "application/expect-ct-report+json": {
    source: "iana",
    compressible: true
  },
  "application/express": {
    source: "iana",
    extensions: [
      "exp"
    ]
  },
  "application/fastinfoset": {
    source: "iana"
  },
  "application/fastsoap": {
    source: "iana"
  },
  "application/fdt+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "fdt"
    ]
  },
  "application/fhir+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/fhir+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/fido.trusted-apps+json": {
    compressible: true
  },
  "application/fits": {
    source: "iana"
  },
  "application/flexfec": {
    source: "iana"
  },
  "application/font-sfnt": {
    source: "iana"
  },
  "application/font-tdpfr": {
    source: "iana",
    extensions: [
      "pfr"
    ]
  },
  "application/font-woff": {
    source: "iana",
    compressible: false
  },
  "application/framework-attributes+xml": {
    source: "iana",
    compressible: true
  },
  "application/geo+json": {
    source: "iana",
    compressible: true,
    extensions: [
      "geojson"
    ]
  },
  "application/geo+json-seq": {
    source: "iana"
  },
  "application/geopackage+sqlite3": {
    source: "iana"
  },
  "application/geoxacml+xml": {
    source: "iana",
    compressible: true
  },
  "application/gltf-buffer": {
    source: "iana"
  },
  "application/gml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "gml"
    ]
  },
  "application/gpx+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "gpx"
    ]
  },
  "application/gxf": {
    source: "apache",
    extensions: [
      "gxf"
    ]
  },
  "application/gzip": {
    source: "iana",
    compressible: false,
    extensions: [
      "gz"
    ]
  },
  "application/h224": {
    source: "iana"
  },
  "application/held+xml": {
    source: "iana",
    compressible: true
  },
  "application/hjson": {
    extensions: [
      "hjson"
    ]
  },
  "application/http": {
    source: "iana"
  },
  "application/hyperstudio": {
    source: "iana",
    extensions: [
      "stk"
    ]
  },
  "application/ibe-key-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/ibe-pkg-reply+xml": {
    source: "iana",
    compressible: true
  },
  "application/ibe-pp-data": {
    source: "iana"
  },
  "application/iges": {
    source: "iana"
  },
  "application/im-iscomposing+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/index": {
    source: "iana"
  },
  "application/index.cmd": {
    source: "iana"
  },
  "application/index.obj": {
    source: "iana"
  },
  "application/index.response": {
    source: "iana"
  },
  "application/index.vnd": {
    source: "iana"
  },
  "application/inkml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ink",
      "inkml"
    ]
  },
  "application/iotp": {
    source: "iana"
  },
  "application/ipfix": {
    source: "iana",
    extensions: [
      "ipfix"
    ]
  },
  "application/ipp": {
    source: "iana"
  },
  "application/isup": {
    source: "iana"
  },
  "application/its+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "its"
    ]
  },
  "application/java-archive": {
    source: "apache",
    compressible: false,
    extensions: [
      "jar",
      "war",
      "ear"
    ]
  },
  "application/java-serialized-object": {
    source: "apache",
    compressible: false,
    extensions: [
      "ser"
    ]
  },
  "application/java-vm": {
    source: "apache",
    compressible: false,
    extensions: [
      "class"
    ]
  },
  "application/javascript": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "js",
      "mjs"
    ]
  },
  "application/jf2feed+json": {
    source: "iana",
    compressible: true
  },
  "application/jose": {
    source: "iana"
  },
  "application/jose+json": {
    source: "iana",
    compressible: true
  },
  "application/jrd+json": {
    source: "iana",
    compressible: true
  },
  "application/jscalendar+json": {
    source: "iana",
    compressible: true
  },
  "application/json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "json",
      "map"
    ]
  },
  "application/json-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/json-seq": {
    source: "iana"
  },
  "application/json5": {
    extensions: [
      "json5"
    ]
  },
  "application/jsonml+json": {
    source: "apache",
    compressible: true,
    extensions: [
      "jsonml"
    ]
  },
  "application/jwk+json": {
    source: "iana",
    compressible: true
  },
  "application/jwk-set+json": {
    source: "iana",
    compressible: true
  },
  "application/jwt": {
    source: "iana"
  },
  "application/kpml-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/kpml-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/ld+json": {
    source: "iana",
    compressible: true,
    extensions: [
      "jsonld"
    ]
  },
  "application/lgr+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lgr"
    ]
  },
  "application/link-format": {
    source: "iana"
  },
  "application/load-control+xml": {
    source: "iana",
    compressible: true
  },
  "application/lost+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lostxml"
    ]
  },
  "application/lostsync+xml": {
    source: "iana",
    compressible: true
  },
  "application/lpf+zip": {
    source: "iana",
    compressible: false
  },
  "application/lxf": {
    source: "iana"
  },
  "application/mac-binhex40": {
    source: "iana",
    extensions: [
      "hqx"
    ]
  },
  "application/mac-compactpro": {
    source: "apache",
    extensions: [
      "cpt"
    ]
  },
  "application/macwriteii": {
    source: "iana"
  },
  "application/mads+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mads"
    ]
  },
  "application/manifest+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "webmanifest"
    ]
  },
  "application/marc": {
    source: "iana",
    extensions: [
      "mrc"
    ]
  },
  "application/marcxml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mrcx"
    ]
  },
  "application/mathematica": {
    source: "iana",
    extensions: [
      "ma",
      "nb",
      "mb"
    ]
  },
  "application/mathml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mathml"
    ]
  },
  "application/mathml-content+xml": {
    source: "iana",
    compressible: true
  },
  "application/mathml-presentation+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-associated-procedure-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-deregister+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-envelope+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-msk+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-msk-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-protection-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-reception-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-register+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-register-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-schedule+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-user-service-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbox": {
    source: "iana",
    extensions: [
      "mbox"
    ]
  },
  "application/media-policy-dataset+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpf"
    ]
  },
  "application/media_control+xml": {
    source: "iana",
    compressible: true
  },
  "application/mediaservercontrol+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mscml"
    ]
  },
  "application/merge-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/metalink+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "metalink"
    ]
  },
  "application/metalink4+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "meta4"
    ]
  },
  "application/mets+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mets"
    ]
  },
  "application/mf4": {
    source: "iana"
  },
  "application/mikey": {
    source: "iana"
  },
  "application/mipc": {
    source: "iana"
  },
  "application/missing-blocks+cbor-seq": {
    source: "iana"
  },
  "application/mmt-aei+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "maei"
    ]
  },
  "application/mmt-usd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "musd"
    ]
  },
  "application/mods+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mods"
    ]
  },
  "application/moss-keys": {
    source: "iana"
  },
  "application/moss-signature": {
    source: "iana"
  },
  "application/mosskey-data": {
    source: "iana"
  },
  "application/mosskey-request": {
    source: "iana"
  },
  "application/mp21": {
    source: "iana",
    extensions: [
      "m21",
      "mp21"
    ]
  },
  "application/mp4": {
    source: "iana",
    extensions: [
      "mp4s",
      "m4p"
    ]
  },
  "application/mpeg4-generic": {
    source: "iana"
  },
  "application/mpeg4-iod": {
    source: "iana"
  },
  "application/mpeg4-iod-xmt": {
    source: "iana"
  },
  "application/mrb-consumer+xml": {
    source: "iana",
    compressible: true
  },
  "application/mrb-publish+xml": {
    source: "iana",
    compressible: true
  },
  "application/msc-ivr+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/msc-mixer+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/msword": {
    source: "iana",
    compressible: false,
    extensions: [
      "doc",
      "dot"
    ]
  },
  "application/mud+json": {
    source: "iana",
    compressible: true
  },
  "application/multipart-core": {
    source: "iana"
  },
  "application/mxf": {
    source: "iana",
    extensions: [
      "mxf"
    ]
  },
  "application/n-quads": {
    source: "iana",
    extensions: [
      "nq"
    ]
  },
  "application/n-triples": {
    source: "iana",
    extensions: [
      "nt"
    ]
  },
  "application/nasdata": {
    source: "iana"
  },
  "application/news-checkgroups": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-groupinfo": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-transmission": {
    source: "iana"
  },
  "application/nlsml+xml": {
    source: "iana",
    compressible: true
  },
  "application/node": {
    source: "iana",
    extensions: [
      "cjs"
    ]
  },
  "application/nss": {
    source: "iana"
  },
  "application/oauth-authz-req+jwt": {
    source: "iana"
  },
  "application/oblivious-dns-message": {
    source: "iana"
  },
  "application/ocsp-request": {
    source: "iana"
  },
  "application/ocsp-response": {
    source: "iana"
  },
  "application/octet-stream": {
    source: "iana",
    compressible: false,
    extensions: [
      "bin",
      "dms",
      "lrf",
      "mar",
      "so",
      "dist",
      "distz",
      "pkg",
      "bpk",
      "dump",
      "elc",
      "deploy",
      "exe",
      "dll",
      "deb",
      "dmg",
      "iso",
      "img",
      "msi",
      "msp",
      "msm",
      "buffer"
    ]
  },
  "application/oda": {
    source: "iana",
    extensions: [
      "oda"
    ]
  },
  "application/odm+xml": {
    source: "iana",
    compressible: true
  },
  "application/odx": {
    source: "iana"
  },
  "application/oebps-package+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "opf"
    ]
  },
  "application/ogg": {
    source: "iana",
    compressible: false,
    extensions: [
      "ogx"
    ]
  },
  "application/omdoc+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "omdoc"
    ]
  },
  "application/onenote": {
    source: "apache",
    extensions: [
      "onetoc",
      "onetoc2",
      "onetmp",
      "onepkg"
    ]
  },
  "application/opc-nodeset+xml": {
    source: "iana",
    compressible: true
  },
  "application/oscore": {
    source: "iana"
  },
  "application/oxps": {
    source: "iana",
    extensions: [
      "oxps"
    ]
  },
  "application/p21": {
    source: "iana"
  },
  "application/p21+zip": {
    source: "iana",
    compressible: false
  },
  "application/p2p-overlay+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "relo"
    ]
  },
  "application/parityfec": {
    source: "iana"
  },
  "application/passport": {
    source: "iana"
  },
  "application/patch-ops-error+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xer"
    ]
  },
  "application/pdf": {
    source: "iana",
    compressible: false,
    extensions: [
      "pdf"
    ]
  },
  "application/pdx": {
    source: "iana"
  },
  "application/pem-certificate-chain": {
    source: "iana"
  },
  "application/pgp-encrypted": {
    source: "iana",
    compressible: false,
    extensions: [
      "pgp"
    ]
  },
  "application/pgp-keys": {
    source: "iana",
    extensions: [
      "asc"
    ]
  },
  "application/pgp-signature": {
    source: "iana",
    extensions: [
      "asc",
      "sig"
    ]
  },
  "application/pics-rules": {
    source: "apache",
    extensions: [
      "prf"
    ]
  },
  "application/pidf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/pidf-diff+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/pkcs10": {
    source: "iana",
    extensions: [
      "p10"
    ]
  },
  "application/pkcs12": {
    source: "iana"
  },
  "application/pkcs7-mime": {
    source: "iana",
    extensions: [
      "p7m",
      "p7c"
    ]
  },
  "application/pkcs7-signature": {
    source: "iana",
    extensions: [
      "p7s"
    ]
  },
  "application/pkcs8": {
    source: "iana",
    extensions: [
      "p8"
    ]
  },
  "application/pkcs8-encrypted": {
    source: "iana"
  },
  "application/pkix-attr-cert": {
    source: "iana",
    extensions: [
      "ac"
    ]
  },
  "application/pkix-cert": {
    source: "iana",
    extensions: [
      "cer"
    ]
  },
  "application/pkix-crl": {
    source: "iana",
    extensions: [
      "crl"
    ]
  },
  "application/pkix-pkipath": {
    source: "iana",
    extensions: [
      "pkipath"
    ]
  },
  "application/pkixcmp": {
    source: "iana",
    extensions: [
      "pki"
    ]
  },
  "application/pls+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "pls"
    ]
  },
  "application/poc-settings+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/postscript": {
    source: "iana",
    compressible: true,
    extensions: [
      "ai",
      "eps",
      "ps"
    ]
  },
  "application/ppsp-tracker+json": {
    source: "iana",
    compressible: true
  },
  "application/problem+json": {
    source: "iana",
    compressible: true
  },
  "application/problem+xml": {
    source: "iana",
    compressible: true
  },
  "application/provenance+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "provx"
    ]
  },
  "application/prs.alvestrand.titrax-sheet": {
    source: "iana"
  },
  "application/prs.cww": {
    source: "iana",
    extensions: [
      "cww"
    ]
  },
  "application/prs.cyn": {
    source: "iana",
    charset: "7-BIT"
  },
  "application/prs.hpub+zip": {
    source: "iana",
    compressible: false
  },
  "application/prs.nprend": {
    source: "iana"
  },
  "application/prs.plucker": {
    source: "iana"
  },
  "application/prs.rdf-xml-crypt": {
    source: "iana"
  },
  "application/prs.xsf+xml": {
    source: "iana",
    compressible: true
  },
  "application/pskc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "pskcxml"
    ]
  },
  "application/pvd+json": {
    source: "iana",
    compressible: true
  },
  "application/qsig": {
    source: "iana"
  },
  "application/raml+yaml": {
    compressible: true,
    extensions: [
      "raml"
    ]
  },
  "application/raptorfec": {
    source: "iana"
  },
  "application/rdap+json": {
    source: "iana",
    compressible: true
  },
  "application/rdf+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rdf",
      "owl"
    ]
  },
  "application/reginfo+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rif"
    ]
  },
  "application/relax-ng-compact-syntax": {
    source: "iana",
    extensions: [
      "rnc"
    ]
  },
  "application/remote-printing": {
    source: "iana"
  },
  "application/reputon+json": {
    source: "iana",
    compressible: true
  },
  "application/resource-lists+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rl"
    ]
  },
  "application/resource-lists-diff+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rld"
    ]
  },
  "application/rfc+xml": {
    source: "iana",
    compressible: true
  },
  "application/riscos": {
    source: "iana"
  },
  "application/rlmi+xml": {
    source: "iana",
    compressible: true
  },
  "application/rls-services+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rs"
    ]
  },
  "application/route-apd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rapd"
    ]
  },
  "application/route-s-tsid+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sls"
    ]
  },
  "application/route-usd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rusd"
    ]
  },
  "application/rpki-ghostbusters": {
    source: "iana",
    extensions: [
      "gbr"
    ]
  },
  "application/rpki-manifest": {
    source: "iana",
    extensions: [
      "mft"
    ]
  },
  "application/rpki-publication": {
    source: "iana"
  },
  "application/rpki-roa": {
    source: "iana",
    extensions: [
      "roa"
    ]
  },
  "application/rpki-updown": {
    source: "iana"
  },
  "application/rsd+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "rsd"
    ]
  },
  "application/rss+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "rss"
    ]
  },
  "application/rtf": {
    source: "iana",
    compressible: true,
    extensions: [
      "rtf"
    ]
  },
  "application/rtploopback": {
    source: "iana"
  },
  "application/rtx": {
    source: "iana"
  },
  "application/samlassertion+xml": {
    source: "iana",
    compressible: true
  },
  "application/samlmetadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/sarif+json": {
    source: "iana",
    compressible: true
  },
  "application/sarif-external-properties+json": {
    source: "iana",
    compressible: true
  },
  "application/sbe": {
    source: "iana"
  },
  "application/sbml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sbml"
    ]
  },
  "application/scaip+xml": {
    source: "iana",
    compressible: true
  },
  "application/scim+json": {
    source: "iana",
    compressible: true
  },
  "application/scvp-cv-request": {
    source: "iana",
    extensions: [
      "scq"
    ]
  },
  "application/scvp-cv-response": {
    source: "iana",
    extensions: [
      "scs"
    ]
  },
  "application/scvp-vp-request": {
    source: "iana",
    extensions: [
      "spq"
    ]
  },
  "application/scvp-vp-response": {
    source: "iana",
    extensions: [
      "spp"
    ]
  },
  "application/sdp": {
    source: "iana",
    extensions: [
      "sdp"
    ]
  },
  "application/secevent+jwt": {
    source: "iana"
  },
  "application/senml+cbor": {
    source: "iana"
  },
  "application/senml+json": {
    source: "iana",
    compressible: true
  },
  "application/senml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "senmlx"
    ]
  },
  "application/senml-etch+cbor": {
    source: "iana"
  },
  "application/senml-etch+json": {
    source: "iana",
    compressible: true
  },
  "application/senml-exi": {
    source: "iana"
  },
  "application/sensml+cbor": {
    source: "iana"
  },
  "application/sensml+json": {
    source: "iana",
    compressible: true
  },
  "application/sensml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sensmlx"
    ]
  },
  "application/sensml-exi": {
    source: "iana"
  },
  "application/sep+xml": {
    source: "iana",
    compressible: true
  },
  "application/sep-exi": {
    source: "iana"
  },
  "application/session-info": {
    source: "iana"
  },
  "application/set-payment": {
    source: "iana"
  },
  "application/set-payment-initiation": {
    source: "iana",
    extensions: [
      "setpay"
    ]
  },
  "application/set-registration": {
    source: "iana"
  },
  "application/set-registration-initiation": {
    source: "iana",
    extensions: [
      "setreg"
    ]
  },
  "application/sgml": {
    source: "iana"
  },
  "application/sgml-open-catalog": {
    source: "iana"
  },
  "application/shf+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "shf"
    ]
  },
  "application/sieve": {
    source: "iana",
    extensions: [
      "siv",
      "sieve"
    ]
  },
  "application/simple-filter+xml": {
    source: "iana",
    compressible: true
  },
  "application/simple-message-summary": {
    source: "iana"
  },
  "application/simplesymbolcontainer": {
    source: "iana"
  },
  "application/sipc": {
    source: "iana"
  },
  "application/slate": {
    source: "iana"
  },
  "application/smil": {
    source: "iana"
  },
  "application/smil+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "smi",
      "smil"
    ]
  },
  "application/smpte336m": {
    source: "iana"
  },
  "application/soap+fastinfoset": {
    source: "iana"
  },
  "application/soap+xml": {
    source: "iana",
    compressible: true
  },
  "application/sparql-query": {
    source: "iana",
    extensions: [
      "rq"
    ]
  },
  "application/sparql-results+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "srx"
    ]
  },
  "application/spdx+json": {
    source: "iana",
    compressible: true
  },
  "application/spirits-event+xml": {
    source: "iana",
    compressible: true
  },
  "application/sql": {
    source: "iana"
  },
  "application/srgs": {
    source: "iana",
    extensions: [
      "gram"
    ]
  },
  "application/srgs+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "grxml"
    ]
  },
  "application/sru+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sru"
    ]
  },
  "application/ssdl+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "ssdl"
    ]
  },
  "application/ssml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ssml"
    ]
  },
  "application/stix+json": {
    source: "iana",
    compressible: true
  },
  "application/swid+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "swidtag"
    ]
  },
  "application/tamp-apex-update": {
    source: "iana"
  },
  "application/tamp-apex-update-confirm": {
    source: "iana"
  },
  "application/tamp-community-update": {
    source: "iana"
  },
  "application/tamp-community-update-confirm": {
    source: "iana"
  },
  "application/tamp-error": {
    source: "iana"
  },
  "application/tamp-sequence-adjust": {
    source: "iana"
  },
  "application/tamp-sequence-adjust-confirm": {
    source: "iana"
  },
  "application/tamp-status-query": {
    source: "iana"
  },
  "application/tamp-status-response": {
    source: "iana"
  },
  "application/tamp-update": {
    source: "iana"
  },
  "application/tamp-update-confirm": {
    source: "iana"
  },
  "application/tar": {
    compressible: true
  },
  "application/taxii+json": {
    source: "iana",
    compressible: true
  },
  "application/td+json": {
    source: "iana",
    compressible: true
  },
  "application/tei+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "tei",
      "teicorpus"
    ]
  },
  "application/tetra_isi": {
    source: "iana"
  },
  "application/thraud+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "tfi"
    ]
  },
  "application/timestamp-query": {
    source: "iana"
  },
  "application/timestamp-reply": {
    source: "iana"
  },
  "application/timestamped-data": {
    source: "iana",
    extensions: [
      "tsd"
    ]
  },
  "application/tlsrpt+gzip": {
    source: "iana"
  },
  "application/tlsrpt+json": {
    source: "iana",
    compressible: true
  },
  "application/tnauthlist": {
    source: "iana"
  },
  "application/token-introspection+jwt": {
    source: "iana"
  },
  "application/toml": {
    compressible: true,
    extensions: [
      "toml"
    ]
  },
  "application/trickle-ice-sdpfrag": {
    source: "iana"
  },
  "application/trig": {
    source: "iana",
    extensions: [
      "trig"
    ]
  },
  "application/ttml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ttml"
    ]
  },
  "application/tve-trigger": {
    source: "iana"
  },
  "application/tzif": {
    source: "iana"
  },
  "application/tzif-leap": {
    source: "iana"
  },
  "application/ubjson": {
    compressible: false,
    extensions: [
      "ubj"
    ]
  },
  "application/ulpfec": {
    source: "iana"
  },
  "application/urc-grpsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/urc-ressheet+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rsheet"
    ]
  },
  "application/urc-targetdesc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "td"
    ]
  },
  "application/urc-uisocketdesc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vcard+json": {
    source: "iana",
    compressible: true
  },
  "application/vcard+xml": {
    source: "iana",
    compressible: true
  },
  "application/vemmi": {
    source: "iana"
  },
  "application/vividence.scriptfile": {
    source: "apache"
  },
  "application/vnd.1000minds.decision-model+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "1km"
    ]
  },
  "application/vnd.3gpp-prose+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp-prose-pc3ch+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp-v2x-local-service-information": {
    source: "iana"
  },
  "application/vnd.3gpp.5gnas": {
    source: "iana"
  },
  "application/vnd.3gpp.access-transfer-events+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.bsf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.gmop+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.gtpc": {
    source: "iana"
  },
  "application/vnd.3gpp.interworking-data": {
    source: "iana"
  },
  "application/vnd.3gpp.lpp": {
    source: "iana"
  },
  "application/vnd.3gpp.mc-signalling-ear": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-payload": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-signalling": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-floor-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-location-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-signed+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-location-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mid-call+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.ngap": {
    source: "iana"
  },
  "application/vnd.3gpp.pfcp": {
    source: "iana"
  },
  "application/vnd.3gpp.pic-bw-large": {
    source: "iana",
    extensions: [
      "plb"
    ]
  },
  "application/vnd.3gpp.pic-bw-small": {
    source: "iana",
    extensions: [
      "psb"
    ]
  },
  "application/vnd.3gpp.pic-bw-var": {
    source: "iana",
    extensions: [
      "pvb"
    ]
  },
  "application/vnd.3gpp.s1ap": {
    source: "iana"
  },
  "application/vnd.3gpp.sms": {
    source: "iana"
  },
  "application/vnd.3gpp.sms+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.srvcc-ext+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.srvcc-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.state-and-event-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.ussd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp2.bcmcsinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp2.sms": {
    source: "iana"
  },
  "application/vnd.3gpp2.tcap": {
    source: "iana",
    extensions: [
      "tcap"
    ]
  },
  "application/vnd.3lightssoftware.imagescal": {
    source: "iana"
  },
  "application/vnd.3m.post-it-notes": {
    source: "iana",
    extensions: [
      "pwn"
    ]
  },
  "application/vnd.accpac.simply.aso": {
    source: "iana",
    extensions: [
      "aso"
    ]
  },
  "application/vnd.accpac.simply.imp": {
    source: "iana",
    extensions: [
      "imp"
    ]
  },
  "application/vnd.acucobol": {
    source: "iana",
    extensions: [
      "acu"
    ]
  },
  "application/vnd.acucorp": {
    source: "iana",
    extensions: [
      "atc",
      "acutc"
    ]
  },
  "application/vnd.adobe.air-application-installer-package+zip": {
    source: "apache",
    compressible: false,
    extensions: [
      "air"
    ]
  },
  "application/vnd.adobe.flash.movie": {
    source: "iana"
  },
  "application/vnd.adobe.formscentral.fcdt": {
    source: "iana",
    extensions: [
      "fcdt"
    ]
  },
  "application/vnd.adobe.fxp": {
    source: "iana",
    extensions: [
      "fxp",
      "fxpl"
    ]
  },
  "application/vnd.adobe.partial-upload": {
    source: "iana"
  },
  "application/vnd.adobe.xdp+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xdp"
    ]
  },
  "application/vnd.adobe.xfdf": {
    source: "iana",
    extensions: [
      "xfdf"
    ]
  },
  "application/vnd.aether.imp": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata-pagedef": {
    source: "iana"
  },
  "application/vnd.afpc.cmoca-cmresource": {
    source: "iana"
  },
  "application/vnd.afpc.foca-charset": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codedfont": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codepage": {
    source: "iana"
  },
  "application/vnd.afpc.modca": {
    source: "iana"
  },
  "application/vnd.afpc.modca-cmtable": {
    source: "iana"
  },
  "application/vnd.afpc.modca-formdef": {
    source: "iana"
  },
  "application/vnd.afpc.modca-mediummap": {
    source: "iana"
  },
  "application/vnd.afpc.modca-objectcontainer": {
    source: "iana"
  },
  "application/vnd.afpc.modca-overlay": {
    source: "iana"
  },
  "application/vnd.afpc.modca-pagesegment": {
    source: "iana"
  },
  "application/vnd.age": {
    source: "iana",
    extensions: [
      "age"
    ]
  },
  "application/vnd.ah-barcode": {
    source: "iana"
  },
  "application/vnd.ahead.space": {
    source: "iana",
    extensions: [
      "ahead"
    ]
  },
  "application/vnd.airzip.filesecure.azf": {
    source: "iana",
    extensions: [
      "azf"
    ]
  },
  "application/vnd.airzip.filesecure.azs": {
    source: "iana",
    extensions: [
      "azs"
    ]
  },
  "application/vnd.amadeus+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.amazon.ebook": {
    source: "apache",
    extensions: [
      "azw"
    ]
  },
  "application/vnd.amazon.mobi8-ebook": {
    source: "iana"
  },
  "application/vnd.americandynamics.acc": {
    source: "iana",
    extensions: [
      "acc"
    ]
  },
  "application/vnd.amiga.ami": {
    source: "iana",
    extensions: [
      "ami"
    ]
  },
  "application/vnd.amundsen.maze+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.android.ota": {
    source: "iana"
  },
  "application/vnd.android.package-archive": {
    source: "apache",
    compressible: false,
    extensions: [
      "apk"
    ]
  },
  "application/vnd.anki": {
    source: "iana"
  },
  "application/vnd.anser-web-certificate-issue-initiation": {
    source: "iana",
    extensions: [
      "cii"
    ]
  },
  "application/vnd.anser-web-funds-transfer-initiation": {
    source: "apache",
    extensions: [
      "fti"
    ]
  },
  "application/vnd.antix.game-component": {
    source: "iana",
    extensions: [
      "atx"
    ]
  },
  "application/vnd.apache.arrow.file": {
    source: "iana"
  },
  "application/vnd.apache.arrow.stream": {
    source: "iana"
  },
  "application/vnd.apache.thrift.binary": {
    source: "iana"
  },
  "application/vnd.apache.thrift.compact": {
    source: "iana"
  },
  "application/vnd.apache.thrift.json": {
    source: "iana"
  },
  "application/vnd.api+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.aplextor.warrp+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.apothekende.reservation+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.apple.installer+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpkg"
    ]
  },
  "application/vnd.apple.keynote": {
    source: "iana",
    extensions: [
      "key"
    ]
  },
  "application/vnd.apple.mpegurl": {
    source: "iana",
    extensions: [
      "m3u8"
    ]
  },
  "application/vnd.apple.numbers": {
    source: "iana",
    extensions: [
      "numbers"
    ]
  },
  "application/vnd.apple.pages": {
    source: "iana",
    extensions: [
      "pages"
    ]
  },
  "application/vnd.apple.pkpass": {
    compressible: false,
    extensions: [
      "pkpass"
    ]
  },
  "application/vnd.arastra.swi": {
    source: "iana"
  },
  "application/vnd.aristanetworks.swi": {
    source: "iana",
    extensions: [
      "swi"
    ]
  },
  "application/vnd.artisan+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.artsquare": {
    source: "iana"
  },
  "application/vnd.astraea-software.iota": {
    source: "iana",
    extensions: [
      "iota"
    ]
  },
  "application/vnd.audiograph": {
    source: "iana",
    extensions: [
      "aep"
    ]
  },
  "application/vnd.autopackage": {
    source: "iana"
  },
  "application/vnd.avalon+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.avistar+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.balsamiq.bmml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "bmml"
    ]
  },
  "application/vnd.balsamiq.bmpr": {
    source: "iana"
  },
  "application/vnd.banana-accounting": {
    source: "iana"
  },
  "application/vnd.bbf.usp.error": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.bekitzur-stech+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.bint.med-content": {
    source: "iana"
  },
  "application/vnd.biopax.rdf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.blink-idb-value-wrapper": {
    source: "iana"
  },
  "application/vnd.blueice.multipass": {
    source: "iana",
    extensions: [
      "mpm"
    ]
  },
  "application/vnd.bluetooth.ep.oob": {
    source: "iana"
  },
  "application/vnd.bluetooth.le.oob": {
    source: "iana"
  },
  "application/vnd.bmi": {
    source: "iana",
    extensions: [
      "bmi"
    ]
  },
  "application/vnd.bpf": {
    source: "iana"
  },
  "application/vnd.bpf3": {
    source: "iana"
  },
  "application/vnd.businessobjects": {
    source: "iana",
    extensions: [
      "rep"
    ]
  },
  "application/vnd.byu.uapi+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cab-jscript": {
    source: "iana"
  },
  "application/vnd.canon-cpdl": {
    source: "iana"
  },
  "application/vnd.canon-lips": {
    source: "iana"
  },
  "application/vnd.capasystems-pg+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cendio.thinlinc.clientconf": {
    source: "iana"
  },
  "application/vnd.century-systems.tcp_stream": {
    source: "iana"
  },
  "application/vnd.chemdraw+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "cdxml"
    ]
  },
  "application/vnd.chess-pgn": {
    source: "iana"
  },
  "application/vnd.chipnuts.karaoke-mmd": {
    source: "iana",
    extensions: [
      "mmd"
    ]
  },
  "application/vnd.ciedi": {
    source: "iana"
  },
  "application/vnd.cinderella": {
    source: "iana",
    extensions: [
      "cdy"
    ]
  },
  "application/vnd.cirpack.isdn-ext": {
    source: "iana"
  },
  "application/vnd.citationstyles.style+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "csl"
    ]
  },
  "application/vnd.claymore": {
    source: "iana",
    extensions: [
      "cla"
    ]
  },
  "application/vnd.cloanto.rp9": {
    source: "iana",
    extensions: [
      "rp9"
    ]
  },
  "application/vnd.clonk.c4group": {
    source: "iana",
    extensions: [
      "c4g",
      "c4d",
      "c4f",
      "c4p",
      "c4u"
    ]
  },
  "application/vnd.cluetrust.cartomobile-config": {
    source: "iana",
    extensions: [
      "c11amc"
    ]
  },
  "application/vnd.cluetrust.cartomobile-config-pkg": {
    source: "iana",
    extensions: [
      "c11amz"
    ]
  },
  "application/vnd.coffeescript": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet-template": {
    source: "iana"
  },
  "application/vnd.collection+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.collection.doc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.collection.next+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.comicbook+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.comicbook-rar": {
    source: "iana"
  },
  "application/vnd.commerce-battelle": {
    source: "iana"
  },
  "application/vnd.commonspace": {
    source: "iana",
    extensions: [
      "csp"
    ]
  },
  "application/vnd.contact.cmsg": {
    source: "iana",
    extensions: [
      "cdbcmsg"
    ]
  },
  "application/vnd.coreos.ignition+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cosmocaller": {
    source: "iana",
    extensions: [
      "cmc"
    ]
  },
  "application/vnd.crick.clicker": {
    source: "iana",
    extensions: [
      "clkx"
    ]
  },
  "application/vnd.crick.clicker.keyboard": {
    source: "iana",
    extensions: [
      "clkk"
    ]
  },
  "application/vnd.crick.clicker.palette": {
    source: "iana",
    extensions: [
      "clkp"
    ]
  },
  "application/vnd.crick.clicker.template": {
    source: "iana",
    extensions: [
      "clkt"
    ]
  },
  "application/vnd.crick.clicker.wordbank": {
    source: "iana",
    extensions: [
      "clkw"
    ]
  },
  "application/vnd.criticaltools.wbs+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wbs"
    ]
  },
  "application/vnd.cryptii.pipe+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.crypto-shade-file": {
    source: "iana"
  },
  "application/vnd.cryptomator.encrypted": {
    source: "iana"
  },
  "application/vnd.cryptomator.vault": {
    source: "iana"
  },
  "application/vnd.ctc-posml": {
    source: "iana",
    extensions: [
      "pml"
    ]
  },
  "application/vnd.ctct.ws+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cups-pdf": {
    source: "iana"
  },
  "application/vnd.cups-postscript": {
    source: "iana"
  },
  "application/vnd.cups-ppd": {
    source: "iana",
    extensions: [
      "ppd"
    ]
  },
  "application/vnd.cups-raster": {
    source: "iana"
  },
  "application/vnd.cups-raw": {
    source: "iana"
  },
  "application/vnd.curl": {
    source: "iana"
  },
  "application/vnd.curl.car": {
    source: "apache",
    extensions: [
      "car"
    ]
  },
  "application/vnd.curl.pcurl": {
    source: "apache",
    extensions: [
      "pcurl"
    ]
  },
  "application/vnd.cyan.dean.root+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cybank": {
    source: "iana"
  },
  "application/vnd.cyclonedx+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cyclonedx+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.d2l.coursepackage1p0+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.d3m-dataset": {
    source: "iana"
  },
  "application/vnd.d3m-problem": {
    source: "iana"
  },
  "application/vnd.dart": {
    source: "iana",
    compressible: true,
    extensions: [
      "dart"
    ]
  },
  "application/vnd.data-vision.rdz": {
    source: "iana",
    extensions: [
      "rdz"
    ]
  },
  "application/vnd.datapackage+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dataresource+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dbf": {
    source: "iana",
    extensions: [
      "dbf"
    ]
  },
  "application/vnd.debian.binary-package": {
    source: "iana"
  },
  "application/vnd.dece.data": {
    source: "iana",
    extensions: [
      "uvf",
      "uvvf",
      "uvd",
      "uvvd"
    ]
  },
  "application/vnd.dece.ttml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "uvt",
      "uvvt"
    ]
  },
  "application/vnd.dece.unspecified": {
    source: "iana",
    extensions: [
      "uvx",
      "uvvx"
    ]
  },
  "application/vnd.dece.zip": {
    source: "iana",
    extensions: [
      "uvz",
      "uvvz"
    ]
  },
  "application/vnd.denovo.fcselayout-link": {
    source: "iana",
    extensions: [
      "fe_launch"
    ]
  },
  "application/vnd.desmume.movie": {
    source: "iana"
  },
  "application/vnd.dir-bi.plate-dl-nosuffix": {
    source: "iana"
  },
  "application/vnd.dm.delegation+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dna": {
    source: "iana",
    extensions: [
      "dna"
    ]
  },
  "application/vnd.document+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dolby.mlp": {
    source: "apache",
    extensions: [
      "mlp"
    ]
  },
  "application/vnd.dolby.mobile.1": {
    source: "iana"
  },
  "application/vnd.dolby.mobile.2": {
    source: "iana"
  },
  "application/vnd.doremir.scorecloud-binary-document": {
    source: "iana"
  },
  "application/vnd.dpgraph": {
    source: "iana",
    extensions: [
      "dpg"
    ]
  },
  "application/vnd.dreamfactory": {
    source: "iana",
    extensions: [
      "dfac"
    ]
  },
  "application/vnd.drive+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ds-keypoint": {
    source: "apache",
    extensions: [
      "kpxx"
    ]
  },
  "application/vnd.dtg.local": {
    source: "iana"
  },
  "application/vnd.dtg.local.flash": {
    source: "iana"
  },
  "application/vnd.dtg.local.html": {
    source: "iana"
  },
  "application/vnd.dvb.ait": {
    source: "iana",
    extensions: [
      "ait"
    ]
  },
  "application/vnd.dvb.dvbisl+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.dvbj": {
    source: "iana"
  },
  "application/vnd.dvb.esgcontainer": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcdftnotifaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess2": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgpdd": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcroaming": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-base": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-enhancement": {
    source: "iana"
  },
  "application/vnd.dvb.notif-aggregate-root+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-container+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-generic+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-msglist+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-registration-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-registration-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-init+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.pfr": {
    source: "iana"
  },
  "application/vnd.dvb.service": {
    source: "iana",
    extensions: [
      "svc"
    ]
  },
  "application/vnd.dxr": {
    source: "iana"
  },
  "application/vnd.dynageo": {
    source: "iana",
    extensions: [
      "geo"
    ]
  },
  "application/vnd.dzr": {
    source: "iana"
  },
  "application/vnd.easykaraoke.cdgdownload": {
    source: "iana"
  },
  "application/vnd.ecdis-update": {
    source: "iana"
  },
  "application/vnd.ecip.rlp": {
    source: "iana"
  },
  "application/vnd.eclipse.ditto+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ecowin.chart": {
    source: "iana",
    extensions: [
      "mag"
    ]
  },
  "application/vnd.ecowin.filerequest": {
    source: "iana"
  },
  "application/vnd.ecowin.fileupdate": {
    source: "iana"
  },
  "application/vnd.ecowin.series": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesrequest": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesupdate": {
    source: "iana"
  },
  "application/vnd.efi.img": {
    source: "iana"
  },
  "application/vnd.efi.iso": {
    source: "iana"
  },
  "application/vnd.emclient.accessrequest+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.enliven": {
    source: "iana",
    extensions: [
      "nml"
    ]
  },
  "application/vnd.enphase.envoy": {
    source: "iana"
  },
  "application/vnd.eprints.data+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.epson.esf": {
    source: "iana",
    extensions: [
      "esf"
    ]
  },
  "application/vnd.epson.msf": {
    source: "iana",
    extensions: [
      "msf"
    ]
  },
  "application/vnd.epson.quickanime": {
    source: "iana",
    extensions: [
      "qam"
    ]
  },
  "application/vnd.epson.salt": {
    source: "iana",
    extensions: [
      "slt"
    ]
  },
  "application/vnd.epson.ssf": {
    source: "iana",
    extensions: [
      "ssf"
    ]
  },
  "application/vnd.ericsson.quickcall": {
    source: "iana"
  },
  "application/vnd.espass-espass+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.eszigno3+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "es3",
      "et3"
    ]
  },
  "application/vnd.etsi.aoc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.asic-e+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.etsi.asic-s+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.etsi.cug+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvcommand+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvdiscovery+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-bc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-cod+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-npvr+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvservice+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsync+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvueprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.mcid+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.mheg5": {
    source: "iana"
  },
  "application/vnd.etsi.overload-control-policy-dataset+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.pstn+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.sci+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.simservs+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.timestamp-token": {
    source: "iana"
  },
  "application/vnd.etsi.tsl+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.tsl.der": {
    source: "iana"
  },
  "application/vnd.eu.kasparian.car+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.eudora.data": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.profile": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.settings": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.theme": {
    source: "iana"
  },
  "application/vnd.exstream-empower+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.exstream-package": {
    source: "iana"
  },
  "application/vnd.ezpix-album": {
    source: "iana",
    extensions: [
      "ez2"
    ]
  },
  "application/vnd.ezpix-package": {
    source: "iana",
    extensions: [
      "ez3"
    ]
  },
  "application/vnd.f-secure.mobile": {
    source: "iana"
  },
  "application/vnd.familysearch.gedcom+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.fastcopy-disk-image": {
    source: "iana"
  },
  "application/vnd.fdf": {
    source: "iana",
    extensions: [
      "fdf"
    ]
  },
  "application/vnd.fdsn.mseed": {
    source: "iana",
    extensions: [
      "mseed"
    ]
  },
  "application/vnd.fdsn.seed": {
    source: "iana",
    extensions: [
      "seed",
      "dataless"
    ]
  },
  "application/vnd.ffsns": {
    source: "iana"
  },
  "application/vnd.ficlab.flb+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.filmit.zfc": {
    source: "iana"
  },
  "application/vnd.fints": {
    source: "iana"
  },
  "application/vnd.firemonkeys.cloudcell": {
    source: "iana"
  },
  "application/vnd.flographit": {
    source: "iana",
    extensions: [
      "gph"
    ]
  },
  "application/vnd.fluxtime.clip": {
    source: "iana",
    extensions: [
      "ftc"
    ]
  },
  "application/vnd.font-fontforge-sfd": {
    source: "iana"
  },
  "application/vnd.framemaker": {
    source: "iana",
    extensions: [
      "fm",
      "frame",
      "maker",
      "book"
    ]
  },
  "application/vnd.frogans.fnc": {
    source: "iana",
    extensions: [
      "fnc"
    ]
  },
  "application/vnd.frogans.ltf": {
    source: "iana",
    extensions: [
      "ltf"
    ]
  },
  "application/vnd.fsc.weblaunch": {
    source: "iana",
    extensions: [
      "fsc"
    ]
  },
  "application/vnd.fujifilm.fb.docuworks": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.binder": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.container": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.jfi+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.fujitsu.oasys": {
    source: "iana",
    extensions: [
      "oas"
    ]
  },
  "application/vnd.fujitsu.oasys2": {
    source: "iana",
    extensions: [
      "oa2"
    ]
  },
  "application/vnd.fujitsu.oasys3": {
    source: "iana",
    extensions: [
      "oa3"
    ]
  },
  "application/vnd.fujitsu.oasysgp": {
    source: "iana",
    extensions: [
      "fg5"
    ]
  },
  "application/vnd.fujitsu.oasysprs": {
    source: "iana",
    extensions: [
      "bh2"
    ]
  },
  "application/vnd.fujixerox.art-ex": {
    source: "iana"
  },
  "application/vnd.fujixerox.art4": {
    source: "iana"
  },
  "application/vnd.fujixerox.ddd": {
    source: "iana",
    extensions: [
      "ddd"
    ]
  },
  "application/vnd.fujixerox.docuworks": {
    source: "iana",
    extensions: [
      "xdw"
    ]
  },
  "application/vnd.fujixerox.docuworks.binder": {
    source: "iana",
    extensions: [
      "xbd"
    ]
  },
  "application/vnd.fujixerox.docuworks.container": {
    source: "iana"
  },
  "application/vnd.fujixerox.hbpl": {
    source: "iana"
  },
  "application/vnd.fut-misnet": {
    source: "iana"
  },
  "application/vnd.futoin+cbor": {
    source: "iana"
  },
  "application/vnd.futoin+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.fuzzysheet": {
    source: "iana",
    extensions: [
      "fzs"
    ]
  },
  "application/vnd.genomatix.tuxedo": {
    source: "iana",
    extensions: [
      "txd"
    ]
  },
  "application/vnd.gentics.grd+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geo+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geocube+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geogebra.file": {
    source: "iana",
    extensions: [
      "ggb"
    ]
  },
  "application/vnd.geogebra.slides": {
    source: "iana"
  },
  "application/vnd.geogebra.tool": {
    source: "iana",
    extensions: [
      "ggt"
    ]
  },
  "application/vnd.geometry-explorer": {
    source: "iana",
    extensions: [
      "gex",
      "gre"
    ]
  },
  "application/vnd.geonext": {
    source: "iana",
    extensions: [
      "gxt"
    ]
  },
  "application/vnd.geoplan": {
    source: "iana",
    extensions: [
      "g2w"
    ]
  },
  "application/vnd.geospace": {
    source: "iana",
    extensions: [
      "g3w"
    ]
  },
  "application/vnd.gerber": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt-response": {
    source: "iana"
  },
  "application/vnd.gmx": {
    source: "iana",
    extensions: [
      "gmx"
    ]
  },
  "application/vnd.google-apps.document": {
    compressible: false,
    extensions: [
      "gdoc"
    ]
  },
  "application/vnd.google-apps.presentation": {
    compressible: false,
    extensions: [
      "gslides"
    ]
  },
  "application/vnd.google-apps.spreadsheet": {
    compressible: false,
    extensions: [
      "gsheet"
    ]
  },
  "application/vnd.google-earth.kml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "kml"
    ]
  },
  "application/vnd.google-earth.kmz": {
    source: "iana",
    compressible: false,
    extensions: [
      "kmz"
    ]
  },
  "application/vnd.gov.sk.e-form+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.gov.sk.e-form+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.gov.sk.xmldatacontainer+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.grafeq": {
    source: "iana",
    extensions: [
      "gqf",
      "gqs"
    ]
  },
  "application/vnd.gridmp": {
    source: "iana"
  },
  "application/vnd.groove-account": {
    source: "iana",
    extensions: [
      "gac"
    ]
  },
  "application/vnd.groove-help": {
    source: "iana",
    extensions: [
      "ghf"
    ]
  },
  "application/vnd.groove-identity-message": {
    source: "iana",
    extensions: [
      "gim"
    ]
  },
  "application/vnd.groove-injector": {
    source: "iana",
    extensions: [
      "grv"
    ]
  },
  "application/vnd.groove-tool-message": {
    source: "iana",
    extensions: [
      "gtm"
    ]
  },
  "application/vnd.groove-tool-template": {
    source: "iana",
    extensions: [
      "tpl"
    ]
  },
  "application/vnd.groove-vcard": {
    source: "iana",
    extensions: [
      "vcg"
    ]
  },
  "application/vnd.hal+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hal+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "hal"
    ]
  },
  "application/vnd.handheld-entertainment+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "zmm"
    ]
  },
  "application/vnd.hbci": {
    source: "iana",
    extensions: [
      "hbci"
    ]
  },
  "application/vnd.hc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hcl-bireports": {
    source: "iana"
  },
  "application/vnd.hdt": {
    source: "iana"
  },
  "application/vnd.heroku+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hhe.lesson-player": {
    source: "iana",
    extensions: [
      "les"
    ]
  },
  "application/vnd.hl7cda+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.hl7v2+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.hp-hpgl": {
    source: "iana",
    extensions: [
      "hpgl"
    ]
  },
  "application/vnd.hp-hpid": {
    source: "iana",
    extensions: [
      "hpid"
    ]
  },
  "application/vnd.hp-hps": {
    source: "iana",
    extensions: [
      "hps"
    ]
  },
  "application/vnd.hp-jlyt": {
    source: "iana",
    extensions: [
      "jlt"
    ]
  },
  "application/vnd.hp-pcl": {
    source: "iana",
    extensions: [
      "pcl"
    ]
  },
  "application/vnd.hp-pclxl": {
    source: "iana",
    extensions: [
      "pclxl"
    ]
  },
  "application/vnd.httphone": {
    source: "iana"
  },
  "application/vnd.hydrostatix.sof-data": {
    source: "iana",
    extensions: [
      "sfd-hdstx"
    ]
  },
  "application/vnd.hyper+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hyper-item+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hyperdrive+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hzn-3d-crossword": {
    source: "iana"
  },
  "application/vnd.ibm.afplinedata": {
    source: "iana"
  },
  "application/vnd.ibm.electronic-media": {
    source: "iana"
  },
  "application/vnd.ibm.minipay": {
    source: "iana",
    extensions: [
      "mpy"
    ]
  },
  "application/vnd.ibm.modcap": {
    source: "iana",
    extensions: [
      "afp",
      "listafp",
      "list3820"
    ]
  },
  "application/vnd.ibm.rights-management": {
    source: "iana",
    extensions: [
      "irm"
    ]
  },
  "application/vnd.ibm.secure-container": {
    source: "iana",
    extensions: [
      "sc"
    ]
  },
  "application/vnd.iccprofile": {
    source: "iana",
    extensions: [
      "icc",
      "icm"
    ]
  },
  "application/vnd.ieee.1905": {
    source: "iana"
  },
  "application/vnd.igloader": {
    source: "iana",
    extensions: [
      "igl"
    ]
  },
  "application/vnd.imagemeter.folder+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.imagemeter.image+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.immervision-ivp": {
    source: "iana",
    extensions: [
      "ivp"
    ]
  },
  "application/vnd.immervision-ivu": {
    source: "iana",
    extensions: [
      "ivu"
    ]
  },
  "application/vnd.ims.imsccv1p1": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p2": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p3": {
    source: "iana"
  },
  "application/vnd.ims.lis.v2.result+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolproxy+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolproxy.id+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolsettings+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.informedcontrol.rms+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.informix-visionary": {
    source: "iana"
  },
  "application/vnd.infotech.project": {
    source: "iana"
  },
  "application/vnd.infotech.project+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.innopath.wamp.notification": {
    source: "iana"
  },
  "application/vnd.insors.igm": {
    source: "iana",
    extensions: [
      "igm"
    ]
  },
  "application/vnd.intercon.formnet": {
    source: "iana",
    extensions: [
      "xpw",
      "xpx"
    ]
  },
  "application/vnd.intergeo": {
    source: "iana",
    extensions: [
      "i2g"
    ]
  },
  "application/vnd.intertrust.digibox": {
    source: "iana"
  },
  "application/vnd.intertrust.nncp": {
    source: "iana"
  },
  "application/vnd.intu.qbo": {
    source: "iana",
    extensions: [
      "qbo"
    ]
  },
  "application/vnd.intu.qfx": {
    source: "iana",
    extensions: [
      "qfx"
    ]
  },
  "application/vnd.iptc.g2.catalogitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.conceptitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.knowledgeitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.newsitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.newsmessage+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.packageitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.planningitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ipunplugged.rcprofile": {
    source: "iana",
    extensions: [
      "rcprofile"
    ]
  },
  "application/vnd.irepository.package+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "irp"
    ]
  },
  "application/vnd.is-xpr": {
    source: "iana",
    extensions: [
      "xpr"
    ]
  },
  "application/vnd.isac.fcs": {
    source: "iana",
    extensions: [
      "fcs"
    ]
  },
  "application/vnd.iso11783-10+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.jam": {
    source: "iana",
    extensions: [
      "jam"
    ]
  },
  "application/vnd.japannet-directory-service": {
    source: "iana"
  },
  "application/vnd.japannet-jpnstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-payment-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-registration": {
    source: "iana"
  },
  "application/vnd.japannet-registration-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-setstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-verification": {
    source: "iana"
  },
  "application/vnd.japannet-verification-wakeup": {
    source: "iana"
  },
  "application/vnd.jcp.javame.midlet-rms": {
    source: "iana",
    extensions: [
      "rms"
    ]
  },
  "application/vnd.jisp": {
    source: "iana",
    extensions: [
      "jisp"
    ]
  },
  "application/vnd.joost.joda-archive": {
    source: "iana",
    extensions: [
      "joda"
    ]
  },
  "application/vnd.jsk.isdn-ngn": {
    source: "iana"
  },
  "application/vnd.kahootz": {
    source: "iana",
    extensions: [
      "ktz",
      "ktr"
    ]
  },
  "application/vnd.kde.karbon": {
    source: "iana",
    extensions: [
      "karbon"
    ]
  },
  "application/vnd.kde.kchart": {
    source: "iana",
    extensions: [
      "chrt"
    ]
  },
  "application/vnd.kde.kformula": {
    source: "iana",
    extensions: [
      "kfo"
    ]
  },
  "application/vnd.kde.kivio": {
    source: "iana",
    extensions: [
      "flw"
    ]
  },
  "application/vnd.kde.kontour": {
    source: "iana",
    extensions: [
      "kon"
    ]
  },
  "application/vnd.kde.kpresenter": {
    source: "iana",
    extensions: [
      "kpr",
      "kpt"
    ]
  },
  "application/vnd.kde.kspread": {
    source: "iana",
    extensions: [
      "ksp"
    ]
  },
  "application/vnd.kde.kword": {
    source: "iana",
    extensions: [
      "kwd",
      "kwt"
    ]
  },
  "application/vnd.kenameaapp": {
    source: "iana",
    extensions: [
      "htke"
    ]
  },
  "application/vnd.kidspiration": {
    source: "iana",
    extensions: [
      "kia"
    ]
  },
  "application/vnd.kinar": {
    source: "iana",
    extensions: [
      "kne",
      "knp"
    ]
  },
  "application/vnd.koan": {
    source: "iana",
    extensions: [
      "skp",
      "skd",
      "skt",
      "skm"
    ]
  },
  "application/vnd.kodak-descriptor": {
    source: "iana",
    extensions: [
      "sse"
    ]
  },
  "application/vnd.las": {
    source: "iana"
  },
  "application/vnd.las.las+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.las.las+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lasxml"
    ]
  },
  "application/vnd.laszip": {
    source: "iana"
  },
  "application/vnd.leap+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.liberty-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.llamagraphics.life-balance.desktop": {
    source: "iana",
    extensions: [
      "lbd"
    ]
  },
  "application/vnd.llamagraphics.life-balance.exchange+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lbe"
    ]
  },
  "application/vnd.logipipe.circuit+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.loom": {
    source: "iana"
  },
  "application/vnd.lotus-1-2-3": {
    source: "iana",
    extensions: [
      "123"
    ]
  },
  "application/vnd.lotus-approach": {
    source: "iana",
    extensions: [
      "apr"
    ]
  },
  "application/vnd.lotus-freelance": {
    source: "iana",
    extensions: [
      "pre"
    ]
  },
  "application/vnd.lotus-notes": {
    source: "iana",
    extensions: [
      "nsf"
    ]
  },
  "application/vnd.lotus-organizer": {
    source: "iana",
    extensions: [
      "org"
    ]
  },
  "application/vnd.lotus-screencam": {
    source: "iana",
    extensions: [
      "scm"
    ]
  },
  "application/vnd.lotus-wordpro": {
    source: "iana",
    extensions: [
      "lwp"
    ]
  },
  "application/vnd.macports.portpkg": {
    source: "iana",
    extensions: [
      "portpkg"
    ]
  },
  "application/vnd.mapbox-vector-tile": {
    source: "iana",
    extensions: [
      "mvt"
    ]
  },
  "application/vnd.marlin.drm.actiontoken+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.conftoken+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.license+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.mdcf": {
    source: "iana"
  },
  "application/vnd.mason+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.maxar.archive.3tz+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.maxmind.maxmind-db": {
    source: "iana"
  },
  "application/vnd.mcd": {
    source: "iana",
    extensions: [
      "mcd"
    ]
  },
  "application/vnd.medcalcdata": {
    source: "iana",
    extensions: [
      "mc1"
    ]
  },
  "application/vnd.mediastation.cdkey": {
    source: "iana",
    extensions: [
      "cdkey"
    ]
  },
  "application/vnd.meridian-slingshot": {
    source: "iana"
  },
  "application/vnd.mfer": {
    source: "iana",
    extensions: [
      "mwf"
    ]
  },
  "application/vnd.mfmp": {
    source: "iana",
    extensions: [
      "mfm"
    ]
  },
  "application/vnd.micro+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.micrografx.flo": {
    source: "iana",
    extensions: [
      "flo"
    ]
  },
  "application/vnd.micrografx.igx": {
    source: "iana",
    extensions: [
      "igx"
    ]
  },
  "application/vnd.microsoft.portable-executable": {
    source: "iana"
  },
  "application/vnd.microsoft.windows.thumbnail-cache": {
    source: "iana"
  },
  "application/vnd.miele+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.mif": {
    source: "iana",
    extensions: [
      "mif"
    ]
  },
  "application/vnd.minisoft-hp3000-save": {
    source: "iana"
  },
  "application/vnd.mitsubishi.misty-guard.trustweb": {
    source: "iana"
  },
  "application/vnd.mobius.daf": {
    source: "iana",
    extensions: [
      "daf"
    ]
  },
  "application/vnd.mobius.dis": {
    source: "iana",
    extensions: [
      "dis"
    ]
  },
  "application/vnd.mobius.mbk": {
    source: "iana",
    extensions: [
      "mbk"
    ]
  },
  "application/vnd.mobius.mqy": {
    source: "iana",
    extensions: [
      "mqy"
    ]
  },
  "application/vnd.mobius.msl": {
    source: "iana",
    extensions: [
      "msl"
    ]
  },
  "application/vnd.mobius.plc": {
    source: "iana",
    extensions: [
      "plc"
    ]
  },
  "application/vnd.mobius.txf": {
    source: "iana",
    extensions: [
      "txf"
    ]
  },
  "application/vnd.mophun.application": {
    source: "iana",
    extensions: [
      "mpn"
    ]
  },
  "application/vnd.mophun.certificate": {
    source: "iana",
    extensions: [
      "mpc"
    ]
  },
  "application/vnd.motorola.flexsuite": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.adsi": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.fis": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.gotap": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.kmr": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.ttc": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.wem": {
    source: "iana"
  },
  "application/vnd.motorola.iprm": {
    source: "iana"
  },
  "application/vnd.mozilla.xul+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xul"
    ]
  },
  "application/vnd.ms-3mfdocument": {
    source: "iana"
  },
  "application/vnd.ms-artgalry": {
    source: "iana",
    extensions: [
      "cil"
    ]
  },
  "application/vnd.ms-asf": {
    source: "iana"
  },
  "application/vnd.ms-cab-compressed": {
    source: "iana",
    extensions: [
      "cab"
    ]
  },
  "application/vnd.ms-color.iccprofile": {
    source: "apache"
  },
  "application/vnd.ms-excel": {
    source: "iana",
    compressible: false,
    extensions: [
      "xls",
      "xlm",
      "xla",
      "xlc",
      "xlt",
      "xlw"
    ]
  },
  "application/vnd.ms-excel.addin.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlam"
    ]
  },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlsb"
    ]
  },
  "application/vnd.ms-excel.sheet.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlsm"
    ]
  },
  "application/vnd.ms-excel.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "xltm"
    ]
  },
  "application/vnd.ms-fontobject": {
    source: "iana",
    compressible: true,
    extensions: [
      "eot"
    ]
  },
  "application/vnd.ms-htmlhelp": {
    source: "iana",
    extensions: [
      "chm"
    ]
  },
  "application/vnd.ms-ims": {
    source: "iana",
    extensions: [
      "ims"
    ]
  },
  "application/vnd.ms-lrm": {
    source: "iana",
    extensions: [
      "lrm"
    ]
  },
  "application/vnd.ms-office.activex+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-officetheme": {
    source: "iana",
    extensions: [
      "thmx"
    ]
  },
  "application/vnd.ms-opentype": {
    source: "apache",
    compressible: true
  },
  "application/vnd.ms-outlook": {
    compressible: false,
    extensions: [
      "msg"
    ]
  },
  "application/vnd.ms-package.obfuscated-opentype": {
    source: "apache"
  },
  "application/vnd.ms-pki.seccat": {
    source: "apache",
    extensions: [
      "cat"
    ]
  },
  "application/vnd.ms-pki.stl": {
    source: "apache",
    extensions: [
      "stl"
    ]
  },
  "application/vnd.ms-playready.initiator+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-powerpoint": {
    source: "iana",
    compressible: false,
    extensions: [
      "ppt",
      "pps",
      "pot"
    ]
  },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": {
    source: "iana",
    extensions: [
      "ppam"
    ]
  },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
    source: "iana",
    extensions: [
      "pptm"
    ]
  },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": {
    source: "iana",
    extensions: [
      "sldm"
    ]
  },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
    source: "iana",
    extensions: [
      "ppsm"
    ]
  },
  "application/vnd.ms-powerpoint.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "potm"
    ]
  },
  "application/vnd.ms-printdevicecapabilities+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-printing.printticket+xml": {
    source: "apache",
    compressible: true
  },
  "application/vnd.ms-printschematicket+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-project": {
    source: "iana",
    extensions: [
      "mpp",
      "mpt"
    ]
  },
  "application/vnd.ms-tnef": {
    source: "iana"
  },
  "application/vnd.ms-windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.nwprinting.oob": {
    source: "iana"
  },
  "application/vnd.ms-windows.printerpairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.wsd.oob": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-resp": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-resp": {
    source: "iana"
  },
  "application/vnd.ms-word.document.macroenabled.12": {
    source: "iana",
    extensions: [
      "docm"
    ]
  },
  "application/vnd.ms-word.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "dotm"
    ]
  },
  "application/vnd.ms-works": {
    source: "iana",
    extensions: [
      "wps",
      "wks",
      "wcm",
      "wdb"
    ]
  },
  "application/vnd.ms-wpl": {
    source: "iana",
    extensions: [
      "wpl"
    ]
  },
  "application/vnd.ms-xpsdocument": {
    source: "iana",
    compressible: false,
    extensions: [
      "xps"
    ]
  },
  "application/vnd.msa-disk-image": {
    source: "iana"
  },
  "application/vnd.mseq": {
    source: "iana",
    extensions: [
      "mseq"
    ]
  },
  "application/vnd.msign": {
    source: "iana"
  },
  "application/vnd.multiad.creator": {
    source: "iana"
  },
  "application/vnd.multiad.creator.cif": {
    source: "iana"
  },
  "application/vnd.music-niff": {
    source: "iana"
  },
  "application/vnd.musician": {
    source: "iana",
    extensions: [
      "mus"
    ]
  },
  "application/vnd.muvee.style": {
    source: "iana",
    extensions: [
      "msty"
    ]
  },
  "application/vnd.mynfc": {
    source: "iana",
    extensions: [
      "taglet"
    ]
  },
  "application/vnd.nacamar.ybrid+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ncd.control": {
    source: "iana"
  },
  "application/vnd.ncd.reference": {
    source: "iana"
  },
  "application/vnd.nearst.inv+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nebumind.line": {
    source: "iana"
  },
  "application/vnd.nervana": {
    source: "iana"
  },
  "application/vnd.netfpx": {
    source: "iana"
  },
  "application/vnd.neurolanguage.nlu": {
    source: "iana",
    extensions: [
      "nlu"
    ]
  },
  "application/vnd.nimn": {
    source: "iana"
  },
  "application/vnd.nintendo.nitro.rom": {
    source: "iana"
  },
  "application/vnd.nintendo.snes.rom": {
    source: "iana"
  },
  "application/vnd.nitf": {
    source: "iana",
    extensions: [
      "ntf",
      "nitf"
    ]
  },
  "application/vnd.noblenet-directory": {
    source: "iana",
    extensions: [
      "nnd"
    ]
  },
  "application/vnd.noblenet-sealer": {
    source: "iana",
    extensions: [
      "nns"
    ]
  },
  "application/vnd.noblenet-web": {
    source: "iana",
    extensions: [
      "nnw"
    ]
  },
  "application/vnd.nokia.catalogs": {
    source: "iana"
  },
  "application/vnd.nokia.conml+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.conml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.iptv.config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.isds-radio-presets": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.landmarkcollection+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.n-gage.ac+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ac"
    ]
  },
  "application/vnd.nokia.n-gage.data": {
    source: "iana",
    extensions: [
      "ngdat"
    ]
  },
  "application/vnd.nokia.n-gage.symbian.install": {
    source: "iana",
    extensions: [
      "n-gage"
    ]
  },
  "application/vnd.nokia.ncd": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.radio-preset": {
    source: "iana",
    extensions: [
      "rpst"
    ]
  },
  "application/vnd.nokia.radio-presets": {
    source: "iana",
    extensions: [
      "rpss"
    ]
  },
  "application/vnd.novadigm.edm": {
    source: "iana",
    extensions: [
      "edm"
    ]
  },
  "application/vnd.novadigm.edx": {
    source: "iana",
    extensions: [
      "edx"
    ]
  },
  "application/vnd.novadigm.ext": {
    source: "iana",
    extensions: [
      "ext"
    ]
  },
  "application/vnd.ntt-local.content-share": {
    source: "iana"
  },
  "application/vnd.ntt-local.file-transfer": {
    source: "iana"
  },
  "application/vnd.ntt-local.ogw_remote-access": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_remote": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_tcp_stream": {
    source: "iana"
  },
  "application/vnd.oasis.opendocument.chart": {
    source: "iana",
    extensions: [
      "odc"
    ]
  },
  "application/vnd.oasis.opendocument.chart-template": {
    source: "iana",
    extensions: [
      "otc"
    ]
  },
  "application/vnd.oasis.opendocument.database": {
    source: "iana",
    extensions: [
      "odb"
    ]
  },
  "application/vnd.oasis.opendocument.formula": {
    source: "iana",
    extensions: [
      "odf"
    ]
  },
  "application/vnd.oasis.opendocument.formula-template": {
    source: "iana",
    extensions: [
      "odft"
    ]
  },
  "application/vnd.oasis.opendocument.graphics": {
    source: "iana",
    compressible: false,
    extensions: [
      "odg"
    ]
  },
  "application/vnd.oasis.opendocument.graphics-template": {
    source: "iana",
    extensions: [
      "otg"
    ]
  },
  "application/vnd.oasis.opendocument.image": {
    source: "iana",
    extensions: [
      "odi"
    ]
  },
  "application/vnd.oasis.opendocument.image-template": {
    source: "iana",
    extensions: [
      "oti"
    ]
  },
  "application/vnd.oasis.opendocument.presentation": {
    source: "iana",
    compressible: false,
    extensions: [
      "odp"
    ]
  },
  "application/vnd.oasis.opendocument.presentation-template": {
    source: "iana",
    extensions: [
      "otp"
    ]
  },
  "application/vnd.oasis.opendocument.spreadsheet": {
    source: "iana",
    compressible: false,
    extensions: [
      "ods"
    ]
  },
  "application/vnd.oasis.opendocument.spreadsheet-template": {
    source: "iana",
    extensions: [
      "ots"
    ]
  },
  "application/vnd.oasis.opendocument.text": {
    source: "iana",
    compressible: false,
    extensions: [
      "odt"
    ]
  },
  "application/vnd.oasis.opendocument.text-master": {
    source: "iana",
    extensions: [
      "odm"
    ]
  },
  "application/vnd.oasis.opendocument.text-template": {
    source: "iana",
    extensions: [
      "ott"
    ]
  },
  "application/vnd.oasis.opendocument.text-web": {
    source: "iana",
    extensions: [
      "oth"
    ]
  },
  "application/vnd.obn": {
    source: "iana"
  },
  "application/vnd.ocf+cbor": {
    source: "iana"
  },
  "application/vnd.oci.image.manifest.v1+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oftn.l10n+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.contentaccessdownload+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.contentaccessstreaming+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.cspg-hexbinary": {
    source: "iana"
  },
  "application/vnd.oipf.dae.svg+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.dae.xhtml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.mippvcontrolmessage+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.pae.gem": {
    source: "iana"
  },
  "application/vnd.oipf.spdiscovery+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.spdlist+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.ueprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.userprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.olpc-sugar": {
    source: "iana",
    extensions: [
      "xo"
    ]
  },
  "application/vnd.oma-scws-config": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-request": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-response": {
    source: "iana"
  },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.drm-trigger+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.imd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.ltkm": {
    source: "iana"
  },
  "application/vnd.oma.bcast.notification+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.provisioningtrigger": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgboot": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgdd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.sgdu": {
    source: "iana"
  },
  "application/vnd.oma.bcast.simple-symbol-container": {
    source: "iana"
  },
  "application/vnd.oma.bcast.smartcard-trigger+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.sprov+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.stkm": {
    source: "iana"
  },
  "application/vnd.oma.cab-address-book+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-feature-handler+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-pcc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-subs-invite+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-user-prefs+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.dcd": {
    source: "iana"
  },
  "application/vnd.oma.dcdc": {
    source: "iana"
  },
  "application/vnd.oma.dd2+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "dd2"
    ]
  },
  "application/vnd.oma.drm.risd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.group-usage-list+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.lwm2m+cbor": {
    source: "iana"
  },
  "application/vnd.oma.lwm2m+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.lwm2m+tlv": {
    source: "iana"
  },
  "application/vnd.oma.pal+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.detailed-progress-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.final-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.groups+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.invocation-descriptor+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.optimized-progress-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.push": {
    source: "iana"
  },
  "application/vnd.oma.scidm.messages+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.xcap-directory+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.omads-email+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omads-file+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omads-folder+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omaloc-supl-init": {
    source: "iana"
  },
  "application/vnd.onepager": {
    source: "iana"
  },
  "application/vnd.onepagertamp": {
    source: "iana"
  },
  "application/vnd.onepagertamx": {
    source: "iana"
  },
  "application/vnd.onepagertat": {
    source: "iana"
  },
  "application/vnd.onepagertatp": {
    source: "iana"
  },
  "application/vnd.onepagertatx": {
    source: "iana"
  },
  "application/vnd.openblox.game+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "obgx"
    ]
  },
  "application/vnd.openblox.game-binary": {
    source: "iana"
  },
  "application/vnd.openeye.oeb": {
    source: "iana"
  },
  "application/vnd.openofficeorg.extension": {
    source: "apache",
    extensions: [
      "oxt"
    ]
  },
  "application/vnd.openstreetmap.data+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "osm"
    ]
  },
  "application/vnd.opentimestamps.ots": {
    source: "iana"
  },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawing+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
    source: "iana",
    compressible: false,
    extensions: [
      "pptx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": {
    source: "iana",
    extensions: [
      "sldx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
    source: "iana",
    extensions: [
      "ppsx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template": {
    source: "iana",
    extensions: [
      "potx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
    source: "iana",
    compressible: false,
    extensions: [
      "xlsx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
    source: "iana",
    extensions: [
      "xltx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.theme+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.vmldrawing": {
    source: "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
    source: "iana",
    compressible: false,
    extensions: [
      "docx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
    source: "iana",
    extensions: [
      "dotx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.core-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.relationships+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oracle.resource+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.orange.indata": {
    source: "iana"
  },
  "application/vnd.osa.netdeploy": {
    source: "iana"
  },
  "application/vnd.osgeo.mapguide.package": {
    source: "iana",
    extensions: [
      "mgp"
    ]
  },
  "application/vnd.osgi.bundle": {
    source: "iana"
  },
  "application/vnd.osgi.dp": {
    source: "iana",
    extensions: [
      "dp"
    ]
  },
  "application/vnd.osgi.subsystem": {
    source: "iana",
    extensions: [
      "esa"
    ]
  },
  "application/vnd.otps.ct-kip+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oxli.countgraph": {
    source: "iana"
  },
  "application/vnd.pagerduty+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.palm": {
    source: "iana",
    extensions: [
      "pdb",
      "pqa",
      "oprc"
    ]
  },
  "application/vnd.panoply": {
    source: "iana"
  },
  "application/vnd.paos.xml": {
    source: "iana"
  },
  "application/vnd.patentdive": {
    source: "iana"
  },
  "application/vnd.patientecommsdoc": {
    source: "iana"
  },
  "application/vnd.pawaafile": {
    source: "iana",
    extensions: [
      "paw"
    ]
  },
  "application/vnd.pcos": {
    source: "iana"
  },
  "application/vnd.pg.format": {
    source: "iana",
    extensions: [
      "str"
    ]
  },
  "application/vnd.pg.osasli": {
    source: "iana",
    extensions: [
      "ei6"
    ]
  },
  "application/vnd.piaccess.application-licence": {
    source: "iana"
  },
  "application/vnd.picsel": {
    source: "iana",
    extensions: [
      "efif"
    ]
  },
  "application/vnd.pmi.widget": {
    source: "iana",
    extensions: [
      "wg"
    ]
  },
  "application/vnd.poc.group-advertisement+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.pocketlearn": {
    source: "iana",
    extensions: [
      "plf"
    ]
  },
  "application/vnd.powerbuilder6": {
    source: "iana",
    extensions: [
      "pbd"
    ]
  },
  "application/vnd.powerbuilder6-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder7": {
    source: "iana"
  },
  "application/vnd.powerbuilder7-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder75": {
    source: "iana"
  },
  "application/vnd.powerbuilder75-s": {
    source: "iana"
  },
  "application/vnd.preminet": {
    source: "iana"
  },
  "application/vnd.previewsystems.box": {
    source: "iana",
    extensions: [
      "box"
    ]
  },
  "application/vnd.proteus.magazine": {
    source: "iana",
    extensions: [
      "mgz"
    ]
  },
  "application/vnd.psfs": {
    source: "iana"
  },
  "application/vnd.publishare-delta-tree": {
    source: "iana",
    extensions: [
      "qps"
    ]
  },
  "application/vnd.pvi.ptid1": {
    source: "iana",
    extensions: [
      "ptid"
    ]
  },
  "application/vnd.pwg-multiplexed": {
    source: "iana"
  },
  "application/vnd.pwg-xhtml-print+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.qualcomm.brew-app-res": {
    source: "iana"
  },
  "application/vnd.quarantainenet": {
    source: "iana"
  },
  "application/vnd.quark.quarkxpress": {
    source: "iana",
    extensions: [
      "qxd",
      "qxt",
      "qwd",
      "qwt",
      "qxl",
      "qxb"
    ]
  },
  "application/vnd.quobject-quoxdocument": {
    source: "iana"
  },
  "application/vnd.radisys.moml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-conf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-conn+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-dialog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-stream+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-conf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-base+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-group+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-speech+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-transform+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.rainstor.data": {
    source: "iana"
  },
  "application/vnd.rapid": {
    source: "iana"
  },
  "application/vnd.rar": {
    source: "iana",
    extensions: [
      "rar"
    ]
  },
  "application/vnd.realvnc.bed": {
    source: "iana",
    extensions: [
      "bed"
    ]
  },
  "application/vnd.recordare.musicxml": {
    source: "iana",
    extensions: [
      "mxl"
    ]
  },
  "application/vnd.recordare.musicxml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "musicxml"
    ]
  },
  "application/vnd.renlearn.rlprint": {
    source: "iana"
  },
  "application/vnd.resilient.logic": {
    source: "iana"
  },
  "application/vnd.restful+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.rig.cryptonote": {
    source: "iana",
    extensions: [
      "cryptonote"
    ]
  },
  "application/vnd.rim.cod": {
    source: "apache",
    extensions: [
      "cod"
    ]
  },
  "application/vnd.rn-realmedia": {
    source: "apache",
    extensions: [
      "rm"
    ]
  },
  "application/vnd.rn-realmedia-vbr": {
    source: "apache",
    extensions: [
      "rmvb"
    ]
  },
  "application/vnd.route66.link66+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "link66"
    ]
  },
  "application/vnd.rs-274x": {
    source: "iana"
  },
  "application/vnd.ruckus.download": {
    source: "iana"
  },
  "application/vnd.s3sms": {
    source: "iana"
  },
  "application/vnd.sailingtracker.track": {
    source: "iana",
    extensions: [
      "st"
    ]
  },
  "application/vnd.sar": {
    source: "iana"
  },
  "application/vnd.sbm.cid": {
    source: "iana"
  },
  "application/vnd.sbm.mid2": {
    source: "iana"
  },
  "application/vnd.scribus": {
    source: "iana"
  },
  "application/vnd.sealed.3df": {
    source: "iana"
  },
  "application/vnd.sealed.csf": {
    source: "iana"
  },
  "application/vnd.sealed.doc": {
    source: "iana"
  },
  "application/vnd.sealed.eml": {
    source: "iana"
  },
  "application/vnd.sealed.mht": {
    source: "iana"
  },
  "application/vnd.sealed.net": {
    source: "iana"
  },
  "application/vnd.sealed.ppt": {
    source: "iana"
  },
  "application/vnd.sealed.tiff": {
    source: "iana"
  },
  "application/vnd.sealed.xls": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.html": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.pdf": {
    source: "iana"
  },
  "application/vnd.seemail": {
    source: "iana",
    extensions: [
      "see"
    ]
  },
  "application/vnd.seis+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.sema": {
    source: "iana",
    extensions: [
      "sema"
    ]
  },
  "application/vnd.semd": {
    source: "iana",
    extensions: [
      "semd"
    ]
  },
  "application/vnd.semf": {
    source: "iana",
    extensions: [
      "semf"
    ]
  },
  "application/vnd.shade-save-file": {
    source: "iana"
  },
  "application/vnd.shana.informed.formdata": {
    source: "iana",
    extensions: [
      "ifm"
    ]
  },
  "application/vnd.shana.informed.formtemplate": {
    source: "iana",
    extensions: [
      "itp"
    ]
  },
  "application/vnd.shana.informed.interchange": {
    source: "iana",
    extensions: [
      "iif"
    ]
  },
  "application/vnd.shana.informed.package": {
    source: "iana",
    extensions: [
      "ipk"
    ]
  },
  "application/vnd.shootproof+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.shopkick+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.shp": {
    source: "iana"
  },
  "application/vnd.shx": {
    source: "iana"
  },
  "application/vnd.sigrok.session": {
    source: "iana"
  },
  "application/vnd.simtech-mindmapper": {
    source: "iana",
    extensions: [
      "twd",
      "twds"
    ]
  },
  "application/vnd.siren+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.smaf": {
    source: "iana",
    extensions: [
      "mmf"
    ]
  },
  "application/vnd.smart.notebook": {
    source: "iana"
  },
  "application/vnd.smart.teacher": {
    source: "iana",
    extensions: [
      "teacher"
    ]
  },
  "application/vnd.snesdev-page-table": {
    source: "iana"
  },
  "application/vnd.software602.filler.form+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "fo"
    ]
  },
  "application/vnd.software602.filler.form-xml-zip": {
    source: "iana"
  },
  "application/vnd.solent.sdkm+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sdkm",
      "sdkd"
    ]
  },
  "application/vnd.spotfire.dxp": {
    source: "iana",
    extensions: [
      "dxp"
    ]
  },
  "application/vnd.spotfire.sfs": {
    source: "iana",
    extensions: [
      "sfs"
    ]
  },
  "application/vnd.sqlite3": {
    source: "iana"
  },
  "application/vnd.sss-cod": {
    source: "iana"
  },
  "application/vnd.sss-dtf": {
    source: "iana"
  },
  "application/vnd.sss-ntf": {
    source: "iana"
  },
  "application/vnd.stardivision.calc": {
    source: "apache",
    extensions: [
      "sdc"
    ]
  },
  "application/vnd.stardivision.draw": {
    source: "apache",
    extensions: [
      "sda"
    ]
  },
  "application/vnd.stardivision.impress": {
    source: "apache",
    extensions: [
      "sdd"
    ]
  },
  "application/vnd.stardivision.math": {
    source: "apache",
    extensions: [
      "smf"
    ]
  },
  "application/vnd.stardivision.writer": {
    source: "apache",
    extensions: [
      "sdw",
      "vor"
    ]
  },
  "application/vnd.stardivision.writer-global": {
    source: "apache",
    extensions: [
      "sgl"
    ]
  },
  "application/vnd.stepmania.package": {
    source: "iana",
    extensions: [
      "smzip"
    ]
  },
  "application/vnd.stepmania.stepchart": {
    source: "iana",
    extensions: [
      "sm"
    ]
  },
  "application/vnd.street-stream": {
    source: "iana"
  },
  "application/vnd.sun.wadl+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wadl"
    ]
  },
  "application/vnd.sun.xml.calc": {
    source: "apache",
    extensions: [
      "sxc"
    ]
  },
  "application/vnd.sun.xml.calc.template": {
    source: "apache",
    extensions: [
      "stc"
    ]
  },
  "application/vnd.sun.xml.draw": {
    source: "apache",
    extensions: [
      "sxd"
    ]
  },
  "application/vnd.sun.xml.draw.template": {
    source: "apache",
    extensions: [
      "std"
    ]
  },
  "application/vnd.sun.xml.impress": {
    source: "apache",
    extensions: [
      "sxi"
    ]
  },
  "application/vnd.sun.xml.impress.template": {
    source: "apache",
    extensions: [
      "sti"
    ]
  },
  "application/vnd.sun.xml.math": {
    source: "apache",
    extensions: [
      "sxm"
    ]
  },
  "application/vnd.sun.xml.writer": {
    source: "apache",
    extensions: [
      "sxw"
    ]
  },
  "application/vnd.sun.xml.writer.global": {
    source: "apache",
    extensions: [
      "sxg"
    ]
  },
  "application/vnd.sun.xml.writer.template": {
    source: "apache",
    extensions: [
      "stw"
    ]
  },
  "application/vnd.sus-calendar": {
    source: "iana",
    extensions: [
      "sus",
      "susp"
    ]
  },
  "application/vnd.svd": {
    source: "iana",
    extensions: [
      "svd"
    ]
  },
  "application/vnd.swiftview-ics": {
    source: "iana"
  },
  "application/vnd.sycle+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.syft+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.symbian.install": {
    source: "apache",
    extensions: [
      "sis",
      "sisx"
    ]
  },
  "application/vnd.syncml+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "xsm"
    ]
  },
  "application/vnd.syncml.dm+wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "bdm"
    ]
  },
  "application/vnd.syncml.dm+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "xdm"
    ]
  },
  "application/vnd.syncml.dm.notification": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "ddf"
    ]
  },
  "application/vnd.syncml.dmtnds+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmtnds+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.syncml.ds.notification": {
    source: "iana"
  },
  "application/vnd.tableschema+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tao.intent-module-archive": {
    source: "iana",
    extensions: [
      "tao"
    ]
  },
  "application/vnd.tcpdump.pcap": {
    source: "iana",
    extensions: [
      "pcap",
      "cap",
      "dmp"
    ]
  },
  "application/vnd.think-cell.ppttc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tmd.mediaflex.api+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tml": {
    source: "iana"
  },
  "application/vnd.tmobile-livetv": {
    source: "iana",
    extensions: [
      "tmo"
    ]
  },
  "application/vnd.tri.onesource": {
    source: "iana"
  },
  "application/vnd.trid.tpt": {
    source: "iana",
    extensions: [
      "tpt"
    ]
  },
  "application/vnd.triscape.mxs": {
    source: "iana",
    extensions: [
      "mxs"
    ]
  },
  "application/vnd.trueapp": {
    source: "iana",
    extensions: [
      "tra"
    ]
  },
  "application/vnd.truedoc": {
    source: "iana"
  },
  "application/vnd.ubisoft.webplayer": {
    source: "iana"
  },
  "application/vnd.ufdl": {
    source: "iana",
    extensions: [
      "ufd",
      "ufdl"
    ]
  },
  "application/vnd.uiq.theme": {
    source: "iana",
    extensions: [
      "utz"
    ]
  },
  "application/vnd.umajin": {
    source: "iana",
    extensions: [
      "umj"
    ]
  },
  "application/vnd.unity": {
    source: "iana",
    extensions: [
      "unityweb"
    ]
  },
  "application/vnd.uoml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "uoml"
    ]
  },
  "application/vnd.uplanet.alert": {
    source: "iana"
  },
  "application/vnd.uplanet.alert-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.channel": {
    source: "iana"
  },
  "application/vnd.uplanet.channel-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.list": {
    source: "iana"
  },
  "application/vnd.uplanet.list-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.signal": {
    source: "iana"
  },
  "application/vnd.uri-map": {
    source: "iana"
  },
  "application/vnd.valve.source.material": {
    source: "iana"
  },
  "application/vnd.vcx": {
    source: "iana",
    extensions: [
      "vcx"
    ]
  },
  "application/vnd.vd-study": {
    source: "iana"
  },
  "application/vnd.vectorworks": {
    source: "iana"
  },
  "application/vnd.vel+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.verimatrix.vcas": {
    source: "iana"
  },
  "application/vnd.veritone.aion+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.veryant.thin": {
    source: "iana"
  },
  "application/vnd.ves.encrypted": {
    source: "iana"
  },
  "application/vnd.vidsoft.vidconference": {
    source: "iana"
  },
  "application/vnd.visio": {
    source: "iana",
    extensions: [
      "vsd",
      "vst",
      "vss",
      "vsw"
    ]
  },
  "application/vnd.visionary": {
    source: "iana",
    extensions: [
      "vis"
    ]
  },
  "application/vnd.vividence.scriptfile": {
    source: "iana"
  },
  "application/vnd.vsf": {
    source: "iana",
    extensions: [
      "vsf"
    ]
  },
  "application/vnd.wap.sic": {
    source: "iana"
  },
  "application/vnd.wap.slc": {
    source: "iana"
  },
  "application/vnd.wap.wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "wbxml"
    ]
  },
  "application/vnd.wap.wmlc": {
    source: "iana",
    extensions: [
      "wmlc"
    ]
  },
  "application/vnd.wap.wmlscriptc": {
    source: "iana",
    extensions: [
      "wmlsc"
    ]
  },
  "application/vnd.webturbo": {
    source: "iana",
    extensions: [
      "wtb"
    ]
  },
  "application/vnd.wfa.dpp": {
    source: "iana"
  },
  "application/vnd.wfa.p2p": {
    source: "iana"
  },
  "application/vnd.wfa.wsc": {
    source: "iana"
  },
  "application/vnd.windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.wmc": {
    source: "iana"
  },
  "application/vnd.wmf.bootstrap": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica.package": {
    source: "iana"
  },
  "application/vnd.wolfram.player": {
    source: "iana",
    extensions: [
      "nbp"
    ]
  },
  "application/vnd.wordperfect": {
    source: "iana",
    extensions: [
      "wpd"
    ]
  },
  "application/vnd.wqd": {
    source: "iana",
    extensions: [
      "wqd"
    ]
  },
  "application/vnd.wrq-hp3000-labelled": {
    source: "iana"
  },
  "application/vnd.wt.stf": {
    source: "iana",
    extensions: [
      "stf"
    ]
  },
  "application/vnd.wv.csp+wbxml": {
    source: "iana"
  },
  "application/vnd.wv.csp+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.wv.ssp+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xacml+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xara": {
    source: "iana",
    extensions: [
      "xar"
    ]
  },
  "application/vnd.xfdl": {
    source: "iana",
    extensions: [
      "xfdl"
    ]
  },
  "application/vnd.xfdl.webform": {
    source: "iana"
  },
  "application/vnd.xmi+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xmpie.cpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.dpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.plan": {
    source: "iana"
  },
  "application/vnd.xmpie.ppkg": {
    source: "iana"
  },
  "application/vnd.xmpie.xlim": {
    source: "iana"
  },
  "application/vnd.yamaha.hv-dic": {
    source: "iana",
    extensions: [
      "hvd"
    ]
  },
  "application/vnd.yamaha.hv-script": {
    source: "iana",
    extensions: [
      "hvs"
    ]
  },
  "application/vnd.yamaha.hv-voice": {
    source: "iana",
    extensions: [
      "hvp"
    ]
  },
  "application/vnd.yamaha.openscoreformat": {
    source: "iana",
    extensions: [
      "osf"
    ]
  },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "osfpvg"
    ]
  },
  "application/vnd.yamaha.remote-setup": {
    source: "iana"
  },
  "application/vnd.yamaha.smaf-audio": {
    source: "iana",
    extensions: [
      "saf"
    ]
  },
  "application/vnd.yamaha.smaf-phrase": {
    source: "iana",
    extensions: [
      "spf"
    ]
  },
  "application/vnd.yamaha.through-ngn": {
    source: "iana"
  },
  "application/vnd.yamaha.tunnel-udpencap": {
    source: "iana"
  },
  "application/vnd.yaoweme": {
    source: "iana"
  },
  "application/vnd.yellowriver-custom-menu": {
    source: "iana",
    extensions: [
      "cmp"
    ]
  },
  "application/vnd.youtube.yt": {
    source: "iana"
  },
  "application/vnd.zul": {
    source: "iana",
    extensions: [
      "zir",
      "zirz"
    ]
  },
  "application/vnd.zzazz.deck+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "zaz"
    ]
  },
  "application/voicexml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "vxml"
    ]
  },
  "application/voucher-cms+json": {
    source: "iana",
    compressible: true
  },
  "application/vq-rtcpxr": {
    source: "iana"
  },
  "application/wasm": {
    source: "iana",
    compressible: true,
    extensions: [
      "wasm"
    ]
  },
  "application/watcherinfo+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wif"
    ]
  },
  "application/webpush-options+json": {
    source: "iana",
    compressible: true
  },
  "application/whoispp-query": {
    source: "iana"
  },
  "application/whoispp-response": {
    source: "iana"
  },
  "application/widget": {
    source: "iana",
    extensions: [
      "wgt"
    ]
  },
  "application/winhlp": {
    source: "apache",
    extensions: [
      "hlp"
    ]
  },
  "application/wita": {
    source: "iana"
  },
  "application/wordperfect5.1": {
    source: "iana"
  },
  "application/wsdl+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wsdl"
    ]
  },
  "application/wspolicy+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wspolicy"
    ]
  },
  "application/x-7z-compressed": {
    source: "apache",
    compressible: false,
    extensions: [
      "7z"
    ]
  },
  "application/x-abiword": {
    source: "apache",
    extensions: [
      "abw"
    ]
  },
  "application/x-ace-compressed": {
    source: "apache",
    extensions: [
      "ace"
    ]
  },
  "application/x-amf": {
    source: "apache"
  },
  "application/x-apple-diskimage": {
    source: "apache",
    extensions: [
      "dmg"
    ]
  },
  "application/x-arj": {
    compressible: false,
    extensions: [
      "arj"
    ]
  },
  "application/x-authorware-bin": {
    source: "apache",
    extensions: [
      "aab",
      "x32",
      "u32",
      "vox"
    ]
  },
  "application/x-authorware-map": {
    source: "apache",
    extensions: [
      "aam"
    ]
  },
  "application/x-authorware-seg": {
    source: "apache",
    extensions: [
      "aas"
    ]
  },
  "application/x-bcpio": {
    source: "apache",
    extensions: [
      "bcpio"
    ]
  },
  "application/x-bdoc": {
    compressible: false,
    extensions: [
      "bdoc"
    ]
  },
  "application/x-bittorrent": {
    source: "apache",
    extensions: [
      "torrent"
    ]
  },
  "application/x-blorb": {
    source: "apache",
    extensions: [
      "blb",
      "blorb"
    ]
  },
  "application/x-bzip": {
    source: "apache",
    compressible: false,
    extensions: [
      "bz"
    ]
  },
  "application/x-bzip2": {
    source: "apache",
    compressible: false,
    extensions: [
      "bz2",
      "boz"
    ]
  },
  "application/x-cbr": {
    source: "apache",
    extensions: [
      "cbr",
      "cba",
      "cbt",
      "cbz",
      "cb7"
    ]
  },
  "application/x-cdlink": {
    source: "apache",
    extensions: [
      "vcd"
    ]
  },
  "application/x-cfs-compressed": {
    source: "apache",
    extensions: [
      "cfs"
    ]
  },
  "application/x-chat": {
    source: "apache",
    extensions: [
      "chat"
    ]
  },
  "application/x-chess-pgn": {
    source: "apache",
    extensions: [
      "pgn"
    ]
  },
  "application/x-chrome-extension": {
    extensions: [
      "crx"
    ]
  },
  "application/x-cocoa": {
    source: "nginx",
    extensions: [
      "cco"
    ]
  },
  "application/x-compress": {
    source: "apache"
  },
  "application/x-conference": {
    source: "apache",
    extensions: [
      "nsc"
    ]
  },
  "application/x-cpio": {
    source: "apache",
    extensions: [
      "cpio"
    ]
  },
  "application/x-csh": {
    source: "apache",
    extensions: [
      "csh"
    ]
  },
  "application/x-deb": {
    compressible: false
  },
  "application/x-debian-package": {
    source: "apache",
    extensions: [
      "deb",
      "udeb"
    ]
  },
  "application/x-dgc-compressed": {
    source: "apache",
    extensions: [
      "dgc"
    ]
  },
  "application/x-director": {
    source: "apache",
    extensions: [
      "dir",
      "dcr",
      "dxr",
      "cst",
      "cct",
      "cxt",
      "w3d",
      "fgd",
      "swa"
    ]
  },
  "application/x-doom": {
    source: "apache",
    extensions: [
      "wad"
    ]
  },
  "application/x-dtbncx+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "ncx"
    ]
  },
  "application/x-dtbook+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "dtb"
    ]
  },
  "application/x-dtbresource+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "res"
    ]
  },
  "application/x-dvi": {
    source: "apache",
    compressible: false,
    extensions: [
      "dvi"
    ]
  },
  "application/x-envoy": {
    source: "apache",
    extensions: [
      "evy"
    ]
  },
  "application/x-eva": {
    source: "apache",
    extensions: [
      "eva"
    ]
  },
  "application/x-font-bdf": {
    source: "apache",
    extensions: [
      "bdf"
    ]
  },
  "application/x-font-dos": {
    source: "apache"
  },
  "application/x-font-framemaker": {
    source: "apache"
  },
  "application/x-font-ghostscript": {
    source: "apache",
    extensions: [
      "gsf"
    ]
  },
  "application/x-font-libgrx": {
    source: "apache"
  },
  "application/x-font-linux-psf": {
    source: "apache",
    extensions: [
      "psf"
    ]
  },
  "application/x-font-pcf": {
    source: "apache",
    extensions: [
      "pcf"
    ]
  },
  "application/x-font-snf": {
    source: "apache",
    extensions: [
      "snf"
    ]
  },
  "application/x-font-speedo": {
    source: "apache"
  },
  "application/x-font-sunos-news": {
    source: "apache"
  },
  "application/x-font-type1": {
    source: "apache",
    extensions: [
      "pfa",
      "pfb",
      "pfm",
      "afm"
    ]
  },
  "application/x-font-vfont": {
    source: "apache"
  },
  "application/x-freearc": {
    source: "apache",
    extensions: [
      "arc"
    ]
  },
  "application/x-futuresplash": {
    source: "apache",
    extensions: [
      "spl"
    ]
  },
  "application/x-gca-compressed": {
    source: "apache",
    extensions: [
      "gca"
    ]
  },
  "application/x-glulx": {
    source: "apache",
    extensions: [
      "ulx"
    ]
  },
  "application/x-gnumeric": {
    source: "apache",
    extensions: [
      "gnumeric"
    ]
  },
  "application/x-gramps-xml": {
    source: "apache",
    extensions: [
      "gramps"
    ]
  },
  "application/x-gtar": {
    source: "apache",
    extensions: [
      "gtar"
    ]
  },
  "application/x-gzip": {
    source: "apache"
  },
  "application/x-hdf": {
    source: "apache",
    extensions: [
      "hdf"
    ]
  },
  "application/x-httpd-php": {
    compressible: true,
    extensions: [
      "php"
    ]
  },
  "application/x-install-instructions": {
    source: "apache",
    extensions: [
      "install"
    ]
  },
  "application/x-iso9660-image": {
    source: "apache",
    extensions: [
      "iso"
    ]
  },
  "application/x-iwork-keynote-sffkey": {
    extensions: [
      "key"
    ]
  },
  "application/x-iwork-numbers-sffnumbers": {
    extensions: [
      "numbers"
    ]
  },
  "application/x-iwork-pages-sffpages": {
    extensions: [
      "pages"
    ]
  },
  "application/x-java-archive-diff": {
    source: "nginx",
    extensions: [
      "jardiff"
    ]
  },
  "application/x-java-jnlp-file": {
    source: "apache",
    compressible: false,
    extensions: [
      "jnlp"
    ]
  },
  "application/x-javascript": {
    compressible: true
  },
  "application/x-keepass2": {
    extensions: [
      "kdbx"
    ]
  },
  "application/x-latex": {
    source: "apache",
    compressible: false,
    extensions: [
      "latex"
    ]
  },
  "application/x-lua-bytecode": {
    extensions: [
      "luac"
    ]
  },
  "application/x-lzh-compressed": {
    source: "apache",
    extensions: [
      "lzh",
      "lha"
    ]
  },
  "application/x-makeself": {
    source: "nginx",
    extensions: [
      "run"
    ]
  },
  "application/x-mie": {
    source: "apache",
    extensions: [
      "mie"
    ]
  },
  "application/x-mobipocket-ebook": {
    source: "apache",
    extensions: [
      "prc",
      "mobi"
    ]
  },
  "application/x-mpegurl": {
    compressible: false
  },
  "application/x-ms-application": {
    source: "apache",
    extensions: [
      "application"
    ]
  },
  "application/x-ms-shortcut": {
    source: "apache",
    extensions: [
      "lnk"
    ]
  },
  "application/x-ms-wmd": {
    source: "apache",
    extensions: [
      "wmd"
    ]
  },
  "application/x-ms-wmz": {
    source: "apache",
    extensions: [
      "wmz"
    ]
  },
  "application/x-ms-xbap": {
    source: "apache",
    extensions: [
      "xbap"
    ]
  },
  "application/x-msaccess": {
    source: "apache",
    extensions: [
      "mdb"
    ]
  },
  "application/x-msbinder": {
    source: "apache",
    extensions: [
      "obd"
    ]
  },
  "application/x-mscardfile": {
    source: "apache",
    extensions: [
      "crd"
    ]
  },
  "application/x-msclip": {
    source: "apache",
    extensions: [
      "clp"
    ]
  },
  "application/x-msdos-program": {
    extensions: [
      "exe"
    ]
  },
  "application/x-msdownload": {
    source: "apache",
    extensions: [
      "exe",
      "dll",
      "com",
      "bat",
      "msi"
    ]
  },
  "application/x-msmediaview": {
    source: "apache",
    extensions: [
      "mvb",
      "m13",
      "m14"
    ]
  },
  "application/x-msmetafile": {
    source: "apache",
    extensions: [
      "wmf",
      "wmz",
      "emf",
      "emz"
    ]
  },
  "application/x-msmoney": {
    source: "apache",
    extensions: [
      "mny"
    ]
  },
  "application/x-mspublisher": {
    source: "apache",
    extensions: [
      "pub"
    ]
  },
  "application/x-msschedule": {
    source: "apache",
    extensions: [
      "scd"
    ]
  },
  "application/x-msterminal": {
    source: "apache",
    extensions: [
      "trm"
    ]
  },
  "application/x-mswrite": {
    source: "apache",
    extensions: [
      "wri"
    ]
  },
  "application/x-netcdf": {
    source: "apache",
    extensions: [
      "nc",
      "cdf"
    ]
  },
  "application/x-ns-proxy-autoconfig": {
    compressible: true,
    extensions: [
      "pac"
    ]
  },
  "application/x-nzb": {
    source: "apache",
    extensions: [
      "nzb"
    ]
  },
  "application/x-perl": {
    source: "nginx",
    extensions: [
      "pl",
      "pm"
    ]
  },
  "application/x-pilot": {
    source: "nginx",
    extensions: [
      "prc",
      "pdb"
    ]
  },
  "application/x-pkcs12": {
    source: "apache",
    compressible: false,
    extensions: [
      "p12",
      "pfx"
    ]
  },
  "application/x-pkcs7-certificates": {
    source: "apache",
    extensions: [
      "p7b",
      "spc"
    ]
  },
  "application/x-pkcs7-certreqresp": {
    source: "apache",
    extensions: [
      "p7r"
    ]
  },
  "application/x-pki-message": {
    source: "iana"
  },
  "application/x-rar-compressed": {
    source: "apache",
    compressible: false,
    extensions: [
      "rar"
    ]
  },
  "application/x-redhat-package-manager": {
    source: "nginx",
    extensions: [
      "rpm"
    ]
  },
  "application/x-research-info-systems": {
    source: "apache",
    extensions: [
      "ris"
    ]
  },
  "application/x-sea": {
    source: "nginx",
    extensions: [
      "sea"
    ]
  },
  "application/x-sh": {
    source: "apache",
    compressible: true,
    extensions: [
      "sh"
    ]
  },
  "application/x-shar": {
    source: "apache",
    extensions: [
      "shar"
    ]
  },
  "application/x-shockwave-flash": {
    source: "apache",
    compressible: false,
    extensions: [
      "swf"
    ]
  },
  "application/x-silverlight-app": {
    source: "apache",
    extensions: [
      "xap"
    ]
  },
  "application/x-sql": {
    source: "apache",
    extensions: [
      "sql"
    ]
  },
  "application/x-stuffit": {
    source: "apache",
    compressible: false,
    extensions: [
      "sit"
    ]
  },
  "application/x-stuffitx": {
    source: "apache",
    extensions: [
      "sitx"
    ]
  },
  "application/x-subrip": {
    source: "apache",
    extensions: [
      "srt"
    ]
  },
  "application/x-sv4cpio": {
    source: "apache",
    extensions: [
      "sv4cpio"
    ]
  },
  "application/x-sv4crc": {
    source: "apache",
    extensions: [
      "sv4crc"
    ]
  },
  "application/x-t3vm-image": {
    source: "apache",
    extensions: [
      "t3"
    ]
  },
  "application/x-tads": {
    source: "apache",
    extensions: [
      "gam"
    ]
  },
  "application/x-tar": {
    source: "apache",
    compressible: true,
    extensions: [
      "tar"
    ]
  },
  "application/x-tcl": {
    source: "apache",
    extensions: [
      "tcl",
      "tk"
    ]
  },
  "application/x-tex": {
    source: "apache",
    extensions: [
      "tex"
    ]
  },
  "application/x-tex-tfm": {
    source: "apache",
    extensions: [
      "tfm"
    ]
  },
  "application/x-texinfo": {
    source: "apache",
    extensions: [
      "texinfo",
      "texi"
    ]
  },
  "application/x-tgif": {
    source: "apache",
    extensions: [
      "obj"
    ]
  },
  "application/x-ustar": {
    source: "apache",
    extensions: [
      "ustar"
    ]
  },
  "application/x-virtualbox-hdd": {
    compressible: true,
    extensions: [
      "hdd"
    ]
  },
  "application/x-virtualbox-ova": {
    compressible: true,
    extensions: [
      "ova"
    ]
  },
  "application/x-virtualbox-ovf": {
    compressible: true,
    extensions: [
      "ovf"
    ]
  },
  "application/x-virtualbox-vbox": {
    compressible: true,
    extensions: [
      "vbox"
    ]
  },
  "application/x-virtualbox-vbox-extpack": {
    compressible: false,
    extensions: [
      "vbox-extpack"
    ]
  },
  "application/x-virtualbox-vdi": {
    compressible: true,
    extensions: [
      "vdi"
    ]
  },
  "application/x-virtualbox-vhd": {
    compressible: true,
    extensions: [
      "vhd"
    ]
  },
  "application/x-virtualbox-vmdk": {
    compressible: true,
    extensions: [
      "vmdk"
    ]
  },
  "application/x-wais-source": {
    source: "apache",
    extensions: [
      "src"
    ]
  },
  "application/x-web-app-manifest+json": {
    compressible: true,
    extensions: [
      "webapp"
    ]
  },
  "application/x-www-form-urlencoded": {
    source: "iana",
    compressible: true
  },
  "application/x-x509-ca-cert": {
    source: "iana",
    extensions: [
      "der",
      "crt",
      "pem"
    ]
  },
  "application/x-x509-ca-ra-cert": {
    source: "iana"
  },
  "application/x-x509-next-ca-cert": {
    source: "iana"
  },
  "application/x-xfig": {
    source: "apache",
    extensions: [
      "fig"
    ]
  },
  "application/x-xliff+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xlf"
    ]
  },
  "application/x-xpinstall": {
    source: "apache",
    compressible: false,
    extensions: [
      "xpi"
    ]
  },
  "application/x-xz": {
    source: "apache",
    extensions: [
      "xz"
    ]
  },
  "application/x-zmachine": {
    source: "apache",
    extensions: [
      "z1",
      "z2",
      "z3",
      "z4",
      "z5",
      "z6",
      "z7",
      "z8"
    ]
  },
  "application/x400-bp": {
    source: "iana"
  },
  "application/xacml+xml": {
    source: "iana",
    compressible: true
  },
  "application/xaml+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xaml"
    ]
  },
  "application/xcap-att+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xav"
    ]
  },
  "application/xcap-caps+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xca"
    ]
  },
  "application/xcap-diff+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xdf"
    ]
  },
  "application/xcap-el+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xel"
    ]
  },
  "application/xcap-error+xml": {
    source: "iana",
    compressible: true
  },
  "application/xcap-ns+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xns"
    ]
  },
  "application/xcon-conference-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/xcon-conference-info-diff+xml": {
    source: "iana",
    compressible: true
  },
  "application/xenc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xenc"
    ]
  },
  "application/xhtml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xhtml",
      "xht"
    ]
  },
  "application/xhtml-voice+xml": {
    source: "apache",
    compressible: true
  },
  "application/xliff+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xlf"
    ]
  },
  "application/xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xml",
      "xsl",
      "xsd",
      "rng"
    ]
  },
  "application/xml-dtd": {
    source: "iana",
    compressible: true,
    extensions: [
      "dtd"
    ]
  },
  "application/xml-external-parsed-entity": {
    source: "iana"
  },
  "application/xml-patch+xml": {
    source: "iana",
    compressible: true
  },
  "application/xmpp+xml": {
    source: "iana",
    compressible: true
  },
  "application/xop+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xop"
    ]
  },
  "application/xproc+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xpl"
    ]
  },
  "application/xslt+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xsl",
      "xslt"
    ]
  },
  "application/xspf+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xspf"
    ]
  },
  "application/xv+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mxml",
      "xhvml",
      "xvml",
      "xvm"
    ]
  },
  "application/yang": {
    source: "iana",
    extensions: [
      "yang"
    ]
  },
  "application/yang-data+json": {
    source: "iana",
    compressible: true
  },
  "application/yang-data+xml": {
    source: "iana",
    compressible: true
  },
  "application/yang-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/yang-patch+xml": {
    source: "iana",
    compressible: true
  },
  "application/yin+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "yin"
    ]
  },
  "application/zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "zip"
    ]
  },
  "application/zlib": {
    source: "iana"
  },
  "application/zstd": {
    source: "iana"
  },
  "audio/1d-interleaved-parityfec": {
    source: "iana"
  },
  "audio/32kadpcm": {
    source: "iana"
  },
  "audio/3gpp": {
    source: "iana",
    compressible: false,
    extensions: [
      "3gpp"
    ]
  },
  "audio/3gpp2": {
    source: "iana"
  },
  "audio/aac": {
    source: "iana"
  },
  "audio/ac3": {
    source: "iana"
  },
  "audio/adpcm": {
    source: "apache",
    extensions: [
      "adp"
    ]
  },
  "audio/amr": {
    source: "iana",
    extensions: [
      "amr"
    ]
  },
  "audio/amr-wb": {
    source: "iana"
  },
  "audio/amr-wb+": {
    source: "iana"
  },
  "audio/aptx": {
    source: "iana"
  },
  "audio/asc": {
    source: "iana"
  },
  "audio/atrac-advanced-lossless": {
    source: "iana"
  },
  "audio/atrac-x": {
    source: "iana"
  },
  "audio/atrac3": {
    source: "iana"
  },
  "audio/basic": {
    source: "iana",
    compressible: false,
    extensions: [
      "au",
      "snd"
    ]
  },
  "audio/bv16": {
    source: "iana"
  },
  "audio/bv32": {
    source: "iana"
  },
  "audio/clearmode": {
    source: "iana"
  },
  "audio/cn": {
    source: "iana"
  },
  "audio/dat12": {
    source: "iana"
  },
  "audio/dls": {
    source: "iana"
  },
  "audio/dsr-es201108": {
    source: "iana"
  },
  "audio/dsr-es202050": {
    source: "iana"
  },
  "audio/dsr-es202211": {
    source: "iana"
  },
  "audio/dsr-es202212": {
    source: "iana"
  },
  "audio/dv": {
    source: "iana"
  },
  "audio/dvi4": {
    source: "iana"
  },
  "audio/eac3": {
    source: "iana"
  },
  "audio/encaprtp": {
    source: "iana"
  },
  "audio/evrc": {
    source: "iana"
  },
  "audio/evrc-qcp": {
    source: "iana"
  },
  "audio/evrc0": {
    source: "iana"
  },
  "audio/evrc1": {
    source: "iana"
  },
  "audio/evrcb": {
    source: "iana"
  },
  "audio/evrcb0": {
    source: "iana"
  },
  "audio/evrcb1": {
    source: "iana"
  },
  "audio/evrcnw": {
    source: "iana"
  },
  "audio/evrcnw0": {
    source: "iana"
  },
  "audio/evrcnw1": {
    source: "iana"
  },
  "audio/evrcwb": {
    source: "iana"
  },
  "audio/evrcwb0": {
    source: "iana"
  },
  "audio/evrcwb1": {
    source: "iana"
  },
  "audio/evs": {
    source: "iana"
  },
  "audio/flexfec": {
    source: "iana"
  },
  "audio/fwdred": {
    source: "iana"
  },
  "audio/g711-0": {
    source: "iana"
  },
  "audio/g719": {
    source: "iana"
  },
  "audio/g722": {
    source: "iana"
  },
  "audio/g7221": {
    source: "iana"
  },
  "audio/g723": {
    source: "iana"
  },
  "audio/g726-16": {
    source: "iana"
  },
  "audio/g726-24": {
    source: "iana"
  },
  "audio/g726-32": {
    source: "iana"
  },
  "audio/g726-40": {
    source: "iana"
  },
  "audio/g728": {
    source: "iana"
  },
  "audio/g729": {
    source: "iana"
  },
  "audio/g7291": {
    source: "iana"
  },
  "audio/g729d": {
    source: "iana"
  },
  "audio/g729e": {
    source: "iana"
  },
  "audio/gsm": {
    source: "iana"
  },
  "audio/gsm-efr": {
    source: "iana"
  },
  "audio/gsm-hr-08": {
    source: "iana"
  },
  "audio/ilbc": {
    source: "iana"
  },
  "audio/ip-mr_v2.5": {
    source: "iana"
  },
  "audio/isac": {
    source: "apache"
  },
  "audio/l16": {
    source: "iana"
  },
  "audio/l20": {
    source: "iana"
  },
  "audio/l24": {
    source: "iana",
    compressible: false
  },
  "audio/l8": {
    source: "iana"
  },
  "audio/lpc": {
    source: "iana"
  },
  "audio/melp": {
    source: "iana"
  },
  "audio/melp1200": {
    source: "iana"
  },
  "audio/melp2400": {
    source: "iana"
  },
  "audio/melp600": {
    source: "iana"
  },
  "audio/mhas": {
    source: "iana"
  },
  "audio/midi": {
    source: "apache",
    extensions: [
      "mid",
      "midi",
      "kar",
      "rmi"
    ]
  },
  "audio/mobile-xmf": {
    source: "iana",
    extensions: [
      "mxmf"
    ]
  },
  "audio/mp3": {
    compressible: false,
    extensions: [
      "mp3"
    ]
  },
  "audio/mp4": {
    source: "iana",
    compressible: false,
    extensions: [
      "m4a",
      "mp4a"
    ]
  },
  "audio/mp4a-latm": {
    source: "iana"
  },
  "audio/mpa": {
    source: "iana"
  },
  "audio/mpa-robust": {
    source: "iana"
  },
  "audio/mpeg": {
    source: "iana",
    compressible: false,
    extensions: [
      "mpga",
      "mp2",
      "mp2a",
      "mp3",
      "m2a",
      "m3a"
    ]
  },
  "audio/mpeg4-generic": {
    source: "iana"
  },
  "audio/musepack": {
    source: "apache"
  },
  "audio/ogg": {
    source: "iana",
    compressible: false,
    extensions: [
      "oga",
      "ogg",
      "spx",
      "opus"
    ]
  },
  "audio/opus": {
    source: "iana"
  },
  "audio/parityfec": {
    source: "iana"
  },
  "audio/pcma": {
    source: "iana"
  },
  "audio/pcma-wb": {
    source: "iana"
  },
  "audio/pcmu": {
    source: "iana"
  },
  "audio/pcmu-wb": {
    source: "iana"
  },
  "audio/prs.sid": {
    source: "iana"
  },
  "audio/qcelp": {
    source: "iana"
  },
  "audio/raptorfec": {
    source: "iana"
  },
  "audio/red": {
    source: "iana"
  },
  "audio/rtp-enc-aescm128": {
    source: "iana"
  },
  "audio/rtp-midi": {
    source: "iana"
  },
  "audio/rtploopback": {
    source: "iana"
  },
  "audio/rtx": {
    source: "iana"
  },
  "audio/s3m": {
    source: "apache",
    extensions: [
      "s3m"
    ]
  },
  "audio/scip": {
    source: "iana"
  },
  "audio/silk": {
    source: "apache",
    extensions: [
      "sil"
    ]
  },
  "audio/smv": {
    source: "iana"
  },
  "audio/smv-qcp": {
    source: "iana"
  },
  "audio/smv0": {
    source: "iana"
  },
  "audio/sofa": {
    source: "iana"
  },
  "audio/sp-midi": {
    source: "iana"
  },
  "audio/speex": {
    source: "iana"
  },
  "audio/t140c": {
    source: "iana"
  },
  "audio/t38": {
    source: "iana"
  },
  "audio/telephone-event": {
    source: "iana"
  },
  "audio/tetra_acelp": {
    source: "iana"
  },
  "audio/tetra_acelp_bb": {
    source: "iana"
  },
  "audio/tone": {
    source: "iana"
  },
  "audio/tsvcis": {
    source: "iana"
  },
  "audio/uemclip": {
    source: "iana"
  },
  "audio/ulpfec": {
    source: "iana"
  },
  "audio/usac": {
    source: "iana"
  },
  "audio/vdvi": {
    source: "iana"
  },
  "audio/vmr-wb": {
    source: "iana"
  },
  "audio/vnd.3gpp.iufp": {
    source: "iana"
  },
  "audio/vnd.4sb": {
    source: "iana"
  },
  "audio/vnd.audiokoz": {
    source: "iana"
  },
  "audio/vnd.celp": {
    source: "iana"
  },
  "audio/vnd.cisco.nse": {
    source: "iana"
  },
  "audio/vnd.cmles.radio-events": {
    source: "iana"
  },
  "audio/vnd.cns.anp1": {
    source: "iana"
  },
  "audio/vnd.cns.inf1": {
    source: "iana"
  },
  "audio/vnd.dece.audio": {
    source: "iana",
    extensions: [
      "uva",
      "uvva"
    ]
  },
  "audio/vnd.digital-winds": {
    source: "iana",
    extensions: [
      "eol"
    ]
  },
  "audio/vnd.dlna.adts": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.1": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.2": {
    source: "iana"
  },
  "audio/vnd.dolby.mlp": {
    source: "iana"
  },
  "audio/vnd.dolby.mps": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2x": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2z": {
    source: "iana"
  },
  "audio/vnd.dolby.pulse.1": {
    source: "iana"
  },
  "audio/vnd.dra": {
    source: "iana",
    extensions: [
      "dra"
    ]
  },
  "audio/vnd.dts": {
    source: "iana",
    extensions: [
      "dts"
    ]
  },
  "audio/vnd.dts.hd": {
    source: "iana",
    extensions: [
      "dtshd"
    ]
  },
  "audio/vnd.dts.uhd": {
    source: "iana"
  },
  "audio/vnd.dvb.file": {
    source: "iana"
  },
  "audio/vnd.everad.plj": {
    source: "iana"
  },
  "audio/vnd.hns.audio": {
    source: "iana"
  },
  "audio/vnd.lucent.voice": {
    source: "iana",
    extensions: [
      "lvp"
    ]
  },
  "audio/vnd.ms-playready.media.pya": {
    source: "iana",
    extensions: [
      "pya"
    ]
  },
  "audio/vnd.nokia.mobile-xmf": {
    source: "iana"
  },
  "audio/vnd.nortel.vbk": {
    source: "iana"
  },
  "audio/vnd.nuera.ecelp4800": {
    source: "iana",
    extensions: [
      "ecelp4800"
    ]
  },
  "audio/vnd.nuera.ecelp7470": {
    source: "iana",
    extensions: [
      "ecelp7470"
    ]
  },
  "audio/vnd.nuera.ecelp9600": {
    source: "iana",
    extensions: [
      "ecelp9600"
    ]
  },
  "audio/vnd.octel.sbc": {
    source: "iana"
  },
  "audio/vnd.presonus.multitrack": {
    source: "iana"
  },
  "audio/vnd.qcelp": {
    source: "iana"
  },
  "audio/vnd.rhetorex.32kadpcm": {
    source: "iana"
  },
  "audio/vnd.rip": {
    source: "iana",
    extensions: [
      "rip"
    ]
  },
  "audio/vnd.rn-realaudio": {
    compressible: false
  },
  "audio/vnd.sealedmedia.softseal.mpeg": {
    source: "iana"
  },
  "audio/vnd.vmx.cvsd": {
    source: "iana"
  },
  "audio/vnd.wave": {
    compressible: false
  },
  "audio/vorbis": {
    source: "iana",
    compressible: false
  },
  "audio/vorbis-config": {
    source: "iana"
  },
  "audio/wav": {
    compressible: false,
    extensions: [
      "wav"
    ]
  },
  "audio/wave": {
    compressible: false,
    extensions: [
      "wav"
    ]
  },
  "audio/webm": {
    source: "apache",
    compressible: false,
    extensions: [
      "weba"
    ]
  },
  "audio/x-aac": {
    source: "apache",
    compressible: false,
    extensions: [
      "aac"
    ]
  },
  "audio/x-aiff": {
    source: "apache",
    extensions: [
      "aif",
      "aiff",
      "aifc"
    ]
  },
  "audio/x-caf": {
    source: "apache",
    compressible: false,
    extensions: [
      "caf"
    ]
  },
  "audio/x-flac": {
    source: "apache",
    extensions: [
      "flac"
    ]
  },
  "audio/x-m4a": {
    source: "nginx",
    extensions: [
      "m4a"
    ]
  },
  "audio/x-matroska": {
    source: "apache",
    extensions: [
      "mka"
    ]
  },
  "audio/x-mpegurl": {
    source: "apache",
    extensions: [
      "m3u"
    ]
  },
  "audio/x-ms-wax": {
    source: "apache",
    extensions: [
      "wax"
    ]
  },
  "audio/x-ms-wma": {
    source: "apache",
    extensions: [
      "wma"
    ]
  },
  "audio/x-pn-realaudio": {
    source: "apache",
    extensions: [
      "ram",
      "ra"
    ]
  },
  "audio/x-pn-realaudio-plugin": {
    source: "apache",
    extensions: [
      "rmp"
    ]
  },
  "audio/x-realaudio": {
    source: "nginx",
    extensions: [
      "ra"
    ]
  },
  "audio/x-tta": {
    source: "apache"
  },
  "audio/x-wav": {
    source: "apache",
    extensions: [
      "wav"
    ]
  },
  "audio/xm": {
    source: "apache",
    extensions: [
      "xm"
    ]
  },
  "chemical/x-cdx": {
    source: "apache",
    extensions: [
      "cdx"
    ]
  },
  "chemical/x-cif": {
    source: "apache",
    extensions: [
      "cif"
    ]
  },
  "chemical/x-cmdf": {
    source: "apache",
    extensions: [
      "cmdf"
    ]
  },
  "chemical/x-cml": {
    source: "apache",
    extensions: [
      "cml"
    ]
  },
  "chemical/x-csml": {
    source: "apache",
    extensions: [
      "csml"
    ]
  },
  "chemical/x-pdb": {
    source: "apache"
  },
  "chemical/x-xyz": {
    source: "apache",
    extensions: [
      "xyz"
    ]
  },
  "font/collection": {
    source: "iana",
    extensions: [
      "ttc"
    ]
  },
  "font/otf": {
    source: "iana",
    compressible: true,
    extensions: [
      "otf"
    ]
  },
  "font/sfnt": {
    source: "iana"
  },
  "font/ttf": {
    source: "iana",
    compressible: true,
    extensions: [
      "ttf"
    ]
  },
  "font/woff": {
    source: "iana",
    extensions: [
      "woff"
    ]
  },
  "font/woff2": {
    source: "iana",
    extensions: [
      "woff2"
    ]
  },
  "image/aces": {
    source: "iana",
    extensions: [
      "exr"
    ]
  },
  "image/apng": {
    compressible: false,
    extensions: [
      "apng"
    ]
  },
  "image/avci": {
    source: "iana",
    extensions: [
      "avci"
    ]
  },
  "image/avcs": {
    source: "iana",
    extensions: [
      "avcs"
    ]
  },
  "image/avif": {
    source: "iana",
    compressible: false,
    extensions: [
      "avif"
    ]
  },
  "image/bmp": {
    source: "iana",
    compressible: true,
    extensions: [
      "bmp"
    ]
  },
  "image/cgm": {
    source: "iana",
    extensions: [
      "cgm"
    ]
  },
  "image/dicom-rle": {
    source: "iana",
    extensions: [
      "drle"
    ]
  },
  "image/emf": {
    source: "iana",
    extensions: [
      "emf"
    ]
  },
  "image/fits": {
    source: "iana",
    extensions: [
      "fits"
    ]
  },
  "image/g3fax": {
    source: "iana",
    extensions: [
      "g3"
    ]
  },
  "image/gif": {
    source: "iana",
    compressible: false,
    extensions: [
      "gif"
    ]
  },
  "image/heic": {
    source: "iana",
    extensions: [
      "heic"
    ]
  },
  "image/heic-sequence": {
    source: "iana",
    extensions: [
      "heics"
    ]
  },
  "image/heif": {
    source: "iana",
    extensions: [
      "heif"
    ]
  },
  "image/heif-sequence": {
    source: "iana",
    extensions: [
      "heifs"
    ]
  },
  "image/hej2k": {
    source: "iana",
    extensions: [
      "hej2"
    ]
  },
  "image/hsj2": {
    source: "iana",
    extensions: [
      "hsj2"
    ]
  },
  "image/ief": {
    source: "iana",
    extensions: [
      "ief"
    ]
  },
  "image/jls": {
    source: "iana",
    extensions: [
      "jls"
    ]
  },
  "image/jp2": {
    source: "iana",
    compressible: false,
    extensions: [
      "jp2",
      "jpg2"
    ]
  },
  "image/jpeg": {
    source: "iana",
    compressible: false,
    extensions: [
      "jpeg",
      "jpg",
      "jpe"
    ]
  },
  "image/jph": {
    source: "iana",
    extensions: [
      "jph"
    ]
  },
  "image/jphc": {
    source: "iana",
    extensions: [
      "jhc"
    ]
  },
  "image/jpm": {
    source: "iana",
    compressible: false,
    extensions: [
      "jpm"
    ]
  },
  "image/jpx": {
    source: "iana",
    compressible: false,
    extensions: [
      "jpx",
      "jpf"
    ]
  },
  "image/jxr": {
    source: "iana",
    extensions: [
      "jxr"
    ]
  },
  "image/jxra": {
    source: "iana",
    extensions: [
      "jxra"
    ]
  },
  "image/jxrs": {
    source: "iana",
    extensions: [
      "jxrs"
    ]
  },
  "image/jxs": {
    source: "iana",
    extensions: [
      "jxs"
    ]
  },
  "image/jxsc": {
    source: "iana",
    extensions: [
      "jxsc"
    ]
  },
  "image/jxsi": {
    source: "iana",
    extensions: [
      "jxsi"
    ]
  },
  "image/jxss": {
    source: "iana",
    extensions: [
      "jxss"
    ]
  },
  "image/ktx": {
    source: "iana",
    extensions: [
      "ktx"
    ]
  },
  "image/ktx2": {
    source: "iana",
    extensions: [
      "ktx2"
    ]
  },
  "image/naplps": {
    source: "iana"
  },
  "image/pjpeg": {
    compressible: false
  },
  "image/png": {
    source: "iana",
    compressible: false,
    extensions: [
      "png"
    ]
  },
  "image/prs.btif": {
    source: "iana",
    extensions: [
      "btif"
    ]
  },
  "image/prs.pti": {
    source: "iana",
    extensions: [
      "pti"
    ]
  },
  "image/pwg-raster": {
    source: "iana"
  },
  "image/sgi": {
    source: "apache",
    extensions: [
      "sgi"
    ]
  },
  "image/svg+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "svg",
      "svgz"
    ]
  },
  "image/t38": {
    source: "iana",
    extensions: [
      "t38"
    ]
  },
  "image/tiff": {
    source: "iana",
    compressible: false,
    extensions: [
      "tif",
      "tiff"
    ]
  },
  "image/tiff-fx": {
    source: "iana",
    extensions: [
      "tfx"
    ]
  },
  "image/vnd.adobe.photoshop": {
    source: "iana",
    compressible: true,
    extensions: [
      "psd"
    ]
  },
  "image/vnd.airzip.accelerator.azv": {
    source: "iana",
    extensions: [
      "azv"
    ]
  },
  "image/vnd.cns.inf2": {
    source: "iana"
  },
  "image/vnd.dece.graphic": {
    source: "iana",
    extensions: [
      "uvi",
      "uvvi",
      "uvg",
      "uvvg"
    ]
  },
  "image/vnd.djvu": {
    source: "iana",
    extensions: [
      "djvu",
      "djv"
    ]
  },
  "image/vnd.dvb.subtitle": {
    source: "iana",
    extensions: [
      "sub"
    ]
  },
  "image/vnd.dwg": {
    source: "iana",
    extensions: [
      "dwg"
    ]
  },
  "image/vnd.dxf": {
    source: "iana",
    extensions: [
      "dxf"
    ]
  },
  "image/vnd.fastbidsheet": {
    source: "iana",
    extensions: [
      "fbs"
    ]
  },
  "image/vnd.fpx": {
    source: "iana",
    extensions: [
      "fpx"
    ]
  },
  "image/vnd.fst": {
    source: "iana",
    extensions: [
      "fst"
    ]
  },
  "image/vnd.fujixerox.edmics-mmr": {
    source: "iana",
    extensions: [
      "mmr"
    ]
  },
  "image/vnd.fujixerox.edmics-rlc": {
    source: "iana",
    extensions: [
      "rlc"
    ]
  },
  "image/vnd.globalgraphics.pgb": {
    source: "iana"
  },
  "image/vnd.microsoft.icon": {
    source: "iana",
    compressible: true,
    extensions: [
      "ico"
    ]
  },
  "image/vnd.mix": {
    source: "iana"
  },
  "image/vnd.mozilla.apng": {
    source: "iana"
  },
  "image/vnd.ms-dds": {
    compressible: true,
    extensions: [
      "dds"
    ]
  },
  "image/vnd.ms-modi": {
    source: "iana",
    extensions: [
      "mdi"
    ]
  },
  "image/vnd.ms-photo": {
    source: "apache",
    extensions: [
      "wdp"
    ]
  },
  "image/vnd.net-fpx": {
    source: "iana",
    extensions: [
      "npx"
    ]
  },
  "image/vnd.pco.b16": {
    source: "iana",
    extensions: [
      "b16"
    ]
  },
  "image/vnd.radiance": {
    source: "iana"
  },
  "image/vnd.sealed.png": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.gif": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.jpg": {
    source: "iana"
  },
  "image/vnd.svf": {
    source: "iana"
  },
  "image/vnd.tencent.tap": {
    source: "iana",
    extensions: [
      "tap"
    ]
  },
  "image/vnd.valve.source.texture": {
    source: "iana",
    extensions: [
      "vtf"
    ]
  },
  "image/vnd.wap.wbmp": {
    source: "iana",
    extensions: [
      "wbmp"
    ]
  },
  "image/vnd.xiff": {
    source: "iana",
    extensions: [
      "xif"
    ]
  },
  "image/vnd.zbrush.pcx": {
    source: "iana",
    extensions: [
      "pcx"
    ]
  },
  "image/webp": {
    source: "apache",
    extensions: [
      "webp"
    ]
  },
  "image/wmf": {
    source: "iana",
    extensions: [
      "wmf"
    ]
  },
  "image/x-3ds": {
    source: "apache",
    extensions: [
      "3ds"
    ]
  },
  "image/x-cmu-raster": {
    source: "apache",
    extensions: [
      "ras"
    ]
  },
  "image/x-cmx": {
    source: "apache",
    extensions: [
      "cmx"
    ]
  },
  "image/x-freehand": {
    source: "apache",
    extensions: [
      "fh",
      "fhc",
      "fh4",
      "fh5",
      "fh7"
    ]
  },
  "image/x-icon": {
    source: "apache",
    compressible: true,
    extensions: [
      "ico"
    ]
  },
  "image/x-jng": {
    source: "nginx",
    extensions: [
      "jng"
    ]
  },
  "image/x-mrsid-image": {
    source: "apache",
    extensions: [
      "sid"
    ]
  },
  "image/x-ms-bmp": {
    source: "nginx",
    compressible: true,
    extensions: [
      "bmp"
    ]
  },
  "image/x-pcx": {
    source: "apache",
    extensions: [
      "pcx"
    ]
  },
  "image/x-pict": {
    source: "apache",
    extensions: [
      "pic",
      "pct"
    ]
  },
  "image/x-portable-anymap": {
    source: "apache",
    extensions: [
      "pnm"
    ]
  },
  "image/x-portable-bitmap": {
    source: "apache",
    extensions: [
      "pbm"
    ]
  },
  "image/x-portable-graymap": {
    source: "apache",
    extensions: [
      "pgm"
    ]
  },
  "image/x-portable-pixmap": {
    source: "apache",
    extensions: [
      "ppm"
    ]
  },
  "image/x-rgb": {
    source: "apache",
    extensions: [
      "rgb"
    ]
  },
  "image/x-tga": {
    source: "apache",
    extensions: [
      "tga"
    ]
  },
  "image/x-xbitmap": {
    source: "apache",
    extensions: [
      "xbm"
    ]
  },
  "image/x-xcf": {
    compressible: false
  },
  "image/x-xpixmap": {
    source: "apache",
    extensions: [
      "xpm"
    ]
  },
  "image/x-xwindowdump": {
    source: "apache",
    extensions: [
      "xwd"
    ]
  },
  "message/cpim": {
    source: "iana"
  },
  "message/delivery-status": {
    source: "iana"
  },
  "message/disposition-notification": {
    source: "iana",
    extensions: [
      "disposition-notification"
    ]
  },
  "message/external-body": {
    source: "iana"
  },
  "message/feedback-report": {
    source: "iana"
  },
  "message/global": {
    source: "iana",
    extensions: [
      "u8msg"
    ]
  },
  "message/global-delivery-status": {
    source: "iana",
    extensions: [
      "u8dsn"
    ]
  },
  "message/global-disposition-notification": {
    source: "iana",
    extensions: [
      "u8mdn"
    ]
  },
  "message/global-headers": {
    source: "iana",
    extensions: [
      "u8hdr"
    ]
  },
  "message/http": {
    source: "iana",
    compressible: false
  },
  "message/imdn+xml": {
    source: "iana",
    compressible: true
  },
  "message/news": {
    source: "iana"
  },
  "message/partial": {
    source: "iana",
    compressible: false
  },
  "message/rfc822": {
    source: "iana",
    compressible: true,
    extensions: [
      "eml",
      "mime"
    ]
  },
  "message/s-http": {
    source: "iana"
  },
  "message/sip": {
    source: "iana"
  },
  "message/sipfrag": {
    source: "iana"
  },
  "message/tracking-status": {
    source: "iana"
  },
  "message/vnd.si.simp": {
    source: "iana"
  },
  "message/vnd.wfa.wsc": {
    source: "iana",
    extensions: [
      "wsc"
    ]
  },
  "model/3mf": {
    source: "iana",
    extensions: [
      "3mf"
    ]
  },
  "model/e57": {
    source: "iana"
  },
  "model/gltf+json": {
    source: "iana",
    compressible: true,
    extensions: [
      "gltf"
    ]
  },
  "model/gltf-binary": {
    source: "iana",
    compressible: true,
    extensions: [
      "glb"
    ]
  },
  "model/iges": {
    source: "iana",
    compressible: false,
    extensions: [
      "igs",
      "iges"
    ]
  },
  "model/mesh": {
    source: "iana",
    compressible: false,
    extensions: [
      "msh",
      "mesh",
      "silo"
    ]
  },
  "model/mtl": {
    source: "iana",
    extensions: [
      "mtl"
    ]
  },
  "model/obj": {
    source: "iana",
    extensions: [
      "obj"
    ]
  },
  "model/step": {
    source: "iana"
  },
  "model/step+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "stpx"
    ]
  },
  "model/step+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "stpz"
    ]
  },
  "model/step-xml+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "stpxz"
    ]
  },
  "model/stl": {
    source: "iana",
    extensions: [
      "stl"
    ]
  },
  "model/vnd.collada+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "dae"
    ]
  },
  "model/vnd.dwf": {
    source: "iana",
    extensions: [
      "dwf"
    ]
  },
  "model/vnd.flatland.3dml": {
    source: "iana"
  },
  "model/vnd.gdl": {
    source: "iana",
    extensions: [
      "gdl"
    ]
  },
  "model/vnd.gs-gdl": {
    source: "apache"
  },
  "model/vnd.gs.gdl": {
    source: "iana"
  },
  "model/vnd.gtw": {
    source: "iana",
    extensions: [
      "gtw"
    ]
  },
  "model/vnd.moml+xml": {
    source: "iana",
    compressible: true
  },
  "model/vnd.mts": {
    source: "iana",
    extensions: [
      "mts"
    ]
  },
  "model/vnd.opengex": {
    source: "iana",
    extensions: [
      "ogex"
    ]
  },
  "model/vnd.parasolid.transmit.binary": {
    source: "iana",
    extensions: [
      "x_b"
    ]
  },
  "model/vnd.parasolid.transmit.text": {
    source: "iana",
    extensions: [
      "x_t"
    ]
  },
  "model/vnd.pytha.pyox": {
    source: "iana"
  },
  "model/vnd.rosette.annotated-data-model": {
    source: "iana"
  },
  "model/vnd.sap.vds": {
    source: "iana",
    extensions: [
      "vds"
    ]
  },
  "model/vnd.usdz+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "usdz"
    ]
  },
  "model/vnd.valve.source.compiled-map": {
    source: "iana",
    extensions: [
      "bsp"
    ]
  },
  "model/vnd.vtu": {
    source: "iana",
    extensions: [
      "vtu"
    ]
  },
  "model/vrml": {
    source: "iana",
    compressible: false,
    extensions: [
      "wrl",
      "vrml"
    ]
  },
  "model/x3d+binary": {
    source: "apache",
    compressible: false,
    extensions: [
      "x3db",
      "x3dbz"
    ]
  },
  "model/x3d+fastinfoset": {
    source: "iana",
    extensions: [
      "x3db"
    ]
  },
  "model/x3d+vrml": {
    source: "apache",
    compressible: false,
    extensions: [
      "x3dv",
      "x3dvz"
    ]
  },
  "model/x3d+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "x3d",
      "x3dz"
    ]
  },
  "model/x3d-vrml": {
    source: "iana",
    extensions: [
      "x3dv"
    ]
  },
  "multipart/alternative": {
    source: "iana",
    compressible: false
  },
  "multipart/appledouble": {
    source: "iana"
  },
  "multipart/byteranges": {
    source: "iana"
  },
  "multipart/digest": {
    source: "iana"
  },
  "multipart/encrypted": {
    source: "iana",
    compressible: false
  },
  "multipart/form-data": {
    source: "iana",
    compressible: false
  },
  "multipart/header-set": {
    source: "iana"
  },
  "multipart/mixed": {
    source: "iana"
  },
  "multipart/multilingual": {
    source: "iana"
  },
  "multipart/parallel": {
    source: "iana"
  },
  "multipart/related": {
    source: "iana",
    compressible: false
  },
  "multipart/report": {
    source: "iana"
  },
  "multipart/signed": {
    source: "iana",
    compressible: false
  },
  "multipart/vnd.bint.med-plus": {
    source: "iana"
  },
  "multipart/voice-message": {
    source: "iana"
  },
  "multipart/x-mixed-replace": {
    source: "iana"
  },
  "text/1d-interleaved-parityfec": {
    source: "iana"
  },
  "text/cache-manifest": {
    source: "iana",
    compressible: true,
    extensions: [
      "appcache",
      "manifest"
    ]
  },
  "text/calendar": {
    source: "iana",
    extensions: [
      "ics",
      "ifb"
    ]
  },
  "text/calender": {
    compressible: true
  },
  "text/cmd": {
    compressible: true
  },
  "text/coffeescript": {
    extensions: [
      "coffee",
      "litcoffee"
    ]
  },
  "text/cql": {
    source: "iana"
  },
  "text/cql-expression": {
    source: "iana"
  },
  "text/cql-identifier": {
    source: "iana"
  },
  "text/css": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "css"
    ]
  },
  "text/csv": {
    source: "iana",
    compressible: true,
    extensions: [
      "csv"
    ]
  },
  "text/csv-schema": {
    source: "iana"
  },
  "text/directory": {
    source: "iana"
  },
  "text/dns": {
    source: "iana"
  },
  "text/ecmascript": {
    source: "iana"
  },
  "text/encaprtp": {
    source: "iana"
  },
  "text/enriched": {
    source: "iana"
  },
  "text/fhirpath": {
    source: "iana"
  },
  "text/flexfec": {
    source: "iana"
  },
  "text/fwdred": {
    source: "iana"
  },
  "text/gff3": {
    source: "iana"
  },
  "text/grammar-ref-list": {
    source: "iana"
  },
  "text/html": {
    source: "iana",
    compressible: true,
    extensions: [
      "html",
      "htm",
      "shtml"
    ]
  },
  "text/jade": {
    extensions: [
      "jade"
    ]
  },
  "text/javascript": {
    source: "iana",
    compressible: true
  },
  "text/jcr-cnd": {
    source: "iana"
  },
  "text/jsx": {
    compressible: true,
    extensions: [
      "jsx"
    ]
  },
  "text/less": {
    compressible: true,
    extensions: [
      "less"
    ]
  },
  "text/markdown": {
    source: "iana",
    compressible: true,
    extensions: [
      "markdown",
      "md"
    ]
  },
  "text/mathml": {
    source: "nginx",
    extensions: [
      "mml"
    ]
  },
  "text/mdx": {
    compressible: true,
    extensions: [
      "mdx"
    ]
  },
  "text/mizar": {
    source: "iana"
  },
  "text/n3": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "n3"
    ]
  },
  "text/parameters": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/parityfec": {
    source: "iana"
  },
  "text/plain": {
    source: "iana",
    compressible: true,
    extensions: [
      "txt",
      "text",
      "conf",
      "def",
      "list",
      "log",
      "in",
      "ini"
    ]
  },
  "text/provenance-notation": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/prs.fallenstein.rst": {
    source: "iana"
  },
  "text/prs.lines.tag": {
    source: "iana",
    extensions: [
      "dsc"
    ]
  },
  "text/prs.prop.logic": {
    source: "iana"
  },
  "text/raptorfec": {
    source: "iana"
  },
  "text/red": {
    source: "iana"
  },
  "text/rfc822-headers": {
    source: "iana"
  },
  "text/richtext": {
    source: "iana",
    compressible: true,
    extensions: [
      "rtx"
    ]
  },
  "text/rtf": {
    source: "iana",
    compressible: true,
    extensions: [
      "rtf"
    ]
  },
  "text/rtp-enc-aescm128": {
    source: "iana"
  },
  "text/rtploopback": {
    source: "iana"
  },
  "text/rtx": {
    source: "iana"
  },
  "text/sgml": {
    source: "iana",
    extensions: [
      "sgml",
      "sgm"
    ]
  },
  "text/shaclc": {
    source: "iana"
  },
  "text/shex": {
    source: "iana",
    extensions: [
      "shex"
    ]
  },
  "text/slim": {
    extensions: [
      "slim",
      "slm"
    ]
  },
  "text/spdx": {
    source: "iana",
    extensions: [
      "spdx"
    ]
  },
  "text/strings": {
    source: "iana"
  },
  "text/stylus": {
    extensions: [
      "stylus",
      "styl"
    ]
  },
  "text/t140": {
    source: "iana"
  },
  "text/tab-separated-values": {
    source: "iana",
    compressible: true,
    extensions: [
      "tsv"
    ]
  },
  "text/troff": {
    source: "iana",
    extensions: [
      "t",
      "tr",
      "roff",
      "man",
      "me",
      "ms"
    ]
  },
  "text/turtle": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "ttl"
    ]
  },
  "text/ulpfec": {
    source: "iana"
  },
  "text/uri-list": {
    source: "iana",
    compressible: true,
    extensions: [
      "uri",
      "uris",
      "urls"
    ]
  },
  "text/vcard": {
    source: "iana",
    compressible: true,
    extensions: [
      "vcard"
    ]
  },
  "text/vnd.a": {
    source: "iana"
  },
  "text/vnd.abc": {
    source: "iana"
  },
  "text/vnd.ascii-art": {
    source: "iana"
  },
  "text/vnd.curl": {
    source: "iana",
    extensions: [
      "curl"
    ]
  },
  "text/vnd.curl.dcurl": {
    source: "apache",
    extensions: [
      "dcurl"
    ]
  },
  "text/vnd.curl.mcurl": {
    source: "apache",
    extensions: [
      "mcurl"
    ]
  },
  "text/vnd.curl.scurl": {
    source: "apache",
    extensions: [
      "scurl"
    ]
  },
  "text/vnd.debian.copyright": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.dmclientscript": {
    source: "iana"
  },
  "text/vnd.dvb.subtitle": {
    source: "iana",
    extensions: [
      "sub"
    ]
  },
  "text/vnd.esmertec.theme-descriptor": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.familysearch.gedcom": {
    source: "iana",
    extensions: [
      "ged"
    ]
  },
  "text/vnd.ficlab.flt": {
    source: "iana"
  },
  "text/vnd.fly": {
    source: "iana",
    extensions: [
      "fly"
    ]
  },
  "text/vnd.fmi.flexstor": {
    source: "iana",
    extensions: [
      "flx"
    ]
  },
  "text/vnd.gml": {
    source: "iana"
  },
  "text/vnd.graphviz": {
    source: "iana",
    extensions: [
      "gv"
    ]
  },
  "text/vnd.hans": {
    source: "iana"
  },
  "text/vnd.hgl": {
    source: "iana"
  },
  "text/vnd.in3d.3dml": {
    source: "iana",
    extensions: [
      "3dml"
    ]
  },
  "text/vnd.in3d.spot": {
    source: "iana",
    extensions: [
      "spot"
    ]
  },
  "text/vnd.iptc.newsml": {
    source: "iana"
  },
  "text/vnd.iptc.nitf": {
    source: "iana"
  },
  "text/vnd.latex-z": {
    source: "iana"
  },
  "text/vnd.motorola.reflex": {
    source: "iana"
  },
  "text/vnd.ms-mediapackage": {
    source: "iana"
  },
  "text/vnd.net2phone.commcenter.command": {
    source: "iana"
  },
  "text/vnd.radisys.msml-basic-layout": {
    source: "iana"
  },
  "text/vnd.senx.warpscript": {
    source: "iana"
  },
  "text/vnd.si.uricatalogue": {
    source: "iana"
  },
  "text/vnd.sosi": {
    source: "iana"
  },
  "text/vnd.sun.j2me.app-descriptor": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "jad"
    ]
  },
  "text/vnd.trolltech.linguist": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.wap.si": {
    source: "iana"
  },
  "text/vnd.wap.sl": {
    source: "iana"
  },
  "text/vnd.wap.wml": {
    source: "iana",
    extensions: [
      "wml"
    ]
  },
  "text/vnd.wap.wmlscript": {
    source: "iana",
    extensions: [
      "wmls"
    ]
  },
  "text/vtt": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "vtt"
    ]
  },
  "text/x-asm": {
    source: "apache",
    extensions: [
      "s",
      "asm"
    ]
  },
  "text/x-c": {
    source: "apache",
    extensions: [
      "c",
      "cc",
      "cxx",
      "cpp",
      "h",
      "hh",
      "dic"
    ]
  },
  "text/x-component": {
    source: "nginx",
    extensions: [
      "htc"
    ]
  },
  "text/x-fortran": {
    source: "apache",
    extensions: [
      "f",
      "for",
      "f77",
      "f90"
    ]
  },
  "text/x-gwt-rpc": {
    compressible: true
  },
  "text/x-handlebars-template": {
    extensions: [
      "hbs"
    ]
  },
  "text/x-java-source": {
    source: "apache",
    extensions: [
      "java"
    ]
  },
  "text/x-jquery-tmpl": {
    compressible: true
  },
  "text/x-lua": {
    extensions: [
      "lua"
    ]
  },
  "text/x-markdown": {
    compressible: true,
    extensions: [
      "mkd"
    ]
  },
  "text/x-nfo": {
    source: "apache",
    extensions: [
      "nfo"
    ]
  },
  "text/x-opml": {
    source: "apache",
    extensions: [
      "opml"
    ]
  },
  "text/x-org": {
    compressible: true,
    extensions: [
      "org"
    ]
  },
  "text/x-pascal": {
    source: "apache",
    extensions: [
      "p",
      "pas"
    ]
  },
  "text/x-processing": {
    compressible: true,
    extensions: [
      "pde"
    ]
  },
  "text/x-sass": {
    extensions: [
      "sass"
    ]
  },
  "text/x-scss": {
    extensions: [
      "scss"
    ]
  },
  "text/x-setext": {
    source: "apache",
    extensions: [
      "etx"
    ]
  },
  "text/x-sfv": {
    source: "apache",
    extensions: [
      "sfv"
    ]
  },
  "text/x-suse-ymp": {
    compressible: true,
    extensions: [
      "ymp"
    ]
  },
  "text/x-uuencode": {
    source: "apache",
    extensions: [
      "uu"
    ]
  },
  "text/x-vcalendar": {
    source: "apache",
    extensions: [
      "vcs"
    ]
  },
  "text/x-vcard": {
    source: "apache",
    extensions: [
      "vcf"
    ]
  },
  "text/xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xml"
    ]
  },
  "text/xml-external-parsed-entity": {
    source: "iana"
  },
  "text/yaml": {
    compressible: true,
    extensions: [
      "yaml",
      "yml"
    ]
  },
  "video/1d-interleaved-parityfec": {
    source: "iana"
  },
  "video/3gpp": {
    source: "iana",
    extensions: [
      "3gp",
      "3gpp"
    ]
  },
  "video/3gpp-tt": {
    source: "iana"
  },
  "video/3gpp2": {
    source: "iana",
    extensions: [
      "3g2"
    ]
  },
  "video/av1": {
    source: "iana"
  },
  "video/bmpeg": {
    source: "iana"
  },
  "video/bt656": {
    source: "iana"
  },
  "video/celb": {
    source: "iana"
  },
  "video/dv": {
    source: "iana"
  },
  "video/encaprtp": {
    source: "iana"
  },
  "video/ffv1": {
    source: "iana"
  },
  "video/flexfec": {
    source: "iana"
  },
  "video/h261": {
    source: "iana",
    extensions: [
      "h261"
    ]
  },
  "video/h263": {
    source: "iana",
    extensions: [
      "h263"
    ]
  },
  "video/h263-1998": {
    source: "iana"
  },
  "video/h263-2000": {
    source: "iana"
  },
  "video/h264": {
    source: "iana",
    extensions: [
      "h264"
    ]
  },
  "video/h264-rcdo": {
    source: "iana"
  },
  "video/h264-svc": {
    source: "iana"
  },
  "video/h265": {
    source: "iana"
  },
  "video/iso.segment": {
    source: "iana",
    extensions: [
      "m4s"
    ]
  },
  "video/jpeg": {
    source: "iana",
    extensions: [
      "jpgv"
    ]
  },
  "video/jpeg2000": {
    source: "iana"
  },
  "video/jpm": {
    source: "apache",
    extensions: [
      "jpm",
      "jpgm"
    ]
  },
  "video/jxsv": {
    source: "iana"
  },
  "video/mj2": {
    source: "iana",
    extensions: [
      "mj2",
      "mjp2"
    ]
  },
  "video/mp1s": {
    source: "iana"
  },
  "video/mp2p": {
    source: "iana"
  },
  "video/mp2t": {
    source: "iana",
    extensions: [
      "ts"
    ]
  },
  "video/mp4": {
    source: "iana",
    compressible: false,
    extensions: [
      "mp4",
      "mp4v",
      "mpg4"
    ]
  },
  "video/mp4v-es": {
    source: "iana"
  },
  "video/mpeg": {
    source: "iana",
    compressible: false,
    extensions: [
      "mpeg",
      "mpg",
      "mpe",
      "m1v",
      "m2v"
    ]
  },
  "video/mpeg4-generic": {
    source: "iana"
  },
  "video/mpv": {
    source: "iana"
  },
  "video/nv": {
    source: "iana"
  },
  "video/ogg": {
    source: "iana",
    compressible: false,
    extensions: [
      "ogv"
    ]
  },
  "video/parityfec": {
    source: "iana"
  },
  "video/pointer": {
    source: "iana"
  },
  "video/quicktime": {
    source: "iana",
    compressible: false,
    extensions: [
      "qt",
      "mov"
    ]
  },
  "video/raptorfec": {
    source: "iana"
  },
  "video/raw": {
    source: "iana"
  },
  "video/rtp-enc-aescm128": {
    source: "iana"
  },
  "video/rtploopback": {
    source: "iana"
  },
  "video/rtx": {
    source: "iana"
  },
  "video/scip": {
    source: "iana"
  },
  "video/smpte291": {
    source: "iana"
  },
  "video/smpte292m": {
    source: "iana"
  },
  "video/ulpfec": {
    source: "iana"
  },
  "video/vc1": {
    source: "iana"
  },
  "video/vc2": {
    source: "iana"
  },
  "video/vnd.cctv": {
    source: "iana"
  },
  "video/vnd.dece.hd": {
    source: "iana",
    extensions: [
      "uvh",
      "uvvh"
    ]
  },
  "video/vnd.dece.mobile": {
    source: "iana",
    extensions: [
      "uvm",
      "uvvm"
    ]
  },
  "video/vnd.dece.mp4": {
    source: "iana"
  },
  "video/vnd.dece.pd": {
    source: "iana",
    extensions: [
      "uvp",
      "uvvp"
    ]
  },
  "video/vnd.dece.sd": {
    source: "iana",
    extensions: [
      "uvs",
      "uvvs"
    ]
  },
  "video/vnd.dece.video": {
    source: "iana",
    extensions: [
      "uvv",
      "uvvv"
    ]
  },
  "video/vnd.directv.mpeg": {
    source: "iana"
  },
  "video/vnd.directv.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dlna.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dvb.file": {
    source: "iana",
    extensions: [
      "dvb"
    ]
  },
  "video/vnd.fvt": {
    source: "iana",
    extensions: [
      "fvt"
    ]
  },
  "video/vnd.hns.video": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsavc": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsmpeg2": {
    source: "iana"
  },
  "video/vnd.motorola.video": {
    source: "iana"
  },
  "video/vnd.motorola.videop": {
    source: "iana"
  },
  "video/vnd.mpegurl": {
    source: "iana",
    extensions: [
      "mxu",
      "m4u"
    ]
  },
  "video/vnd.ms-playready.media.pyv": {
    source: "iana",
    extensions: [
      "pyv"
    ]
  },
  "video/vnd.nokia.interleaved-multimedia": {
    source: "iana"
  },
  "video/vnd.nokia.mp4vr": {
    source: "iana"
  },
  "video/vnd.nokia.videovoip": {
    source: "iana"
  },
  "video/vnd.objectvideo": {
    source: "iana"
  },
  "video/vnd.radgamettools.bink": {
    source: "iana"
  },
  "video/vnd.radgamettools.smacker": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg1": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg4": {
    source: "iana"
  },
  "video/vnd.sealed.swf": {
    source: "iana"
  },
  "video/vnd.sealedmedia.softseal.mov": {
    source: "iana"
  },
  "video/vnd.uvvu.mp4": {
    source: "iana",
    extensions: [
      "uvu",
      "uvvu"
    ]
  },
  "video/vnd.vivo": {
    source: "iana",
    extensions: [
      "viv"
    ]
  },
  "video/vnd.youtube.yt": {
    source: "iana"
  },
  "video/vp8": {
    source: "iana"
  },
  "video/vp9": {
    source: "iana"
  },
  "video/webm": {
    source: "apache",
    compressible: false,
    extensions: [
      "webm"
    ]
  },
  "video/x-f4v": {
    source: "apache",
    extensions: [
      "f4v"
    ]
  },
  "video/x-fli": {
    source: "apache",
    extensions: [
      "fli"
    ]
  },
  "video/x-flv": {
    source: "apache",
    compressible: false,
    extensions: [
      "flv"
    ]
  },
  "video/x-m4v": {
    source: "apache",
    extensions: [
      "m4v"
    ]
  },
  "video/x-matroska": {
    source: "apache",
    compressible: false,
    extensions: [
      "mkv",
      "mk3d",
      "mks"
    ]
  },
  "video/x-mng": {
    source: "apache",
    extensions: [
      "mng"
    ]
  },
  "video/x-ms-asf": {
    source: "apache",
    extensions: [
      "asf",
      "asx"
    ]
  },
  "video/x-ms-vob": {
    source: "apache",
    extensions: [
      "vob"
    ]
  },
  "video/x-ms-wm": {
    source: "apache",
    extensions: [
      "wm"
    ]
  },
  "video/x-ms-wmv": {
    source: "apache",
    compressible: false,
    extensions: [
      "wmv"
    ]
  },
  "video/x-ms-wmx": {
    source: "apache",
    extensions: [
      "wmx"
    ]
  },
  "video/x-ms-wvx": {
    source: "apache",
    extensions: [
      "wvx"
    ]
  },
  "video/x-msvideo": {
    source: "apache",
    extensions: [
      "avi"
    ]
  },
  "video/x-sgi-movie": {
    source: "apache",
    extensions: [
      "movie"
    ]
  },
  "video/x-smv": {
    source: "apache",
    extensions: [
      "smv"
    ]
  },
  "x-conference/x-cooltalk": {
    source: "apache",
    extensions: [
      "ice"
    ]
  },
  "x-shader/x-fragment": {
    compressible: true
  },
  "x-shader/x-vertex": {
    compressible: true
  }
};
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(module2) {
  module2.exports = require$$0$1;
})(mimeDb);
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(exports2) {
  var db = mimeDb.exports;
  var extname = require$$1.extname;
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports2.charset = charset;
  exports2.charsets = { lookup: charset };
  exports2.contentType = contentType;
  exports2.extension = extension2;
  exports2.extensions = /* @__PURE__ */ Object.create(null);
  exports2.lookup = lookup2;
  exports2.types = /* @__PURE__ */ Object.create(null);
  populateMaps(exports2.extensions, exports2.types);
  function charset(type2) {
    if (!type2 || typeof type2 !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type2);
    var mime = match && db[match[1].toLowerCase()];
    if (mime && mime.charset) {
      return mime.charset;
    }
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
      return "UTF-8";
    }
    return false;
  }
  function contentType(str) {
    if (!str || typeof str !== "string") {
      return false;
    }
    var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
    if (!mime) {
      return false;
    }
    if (mime.indexOf("charset") === -1) {
      var charset2 = exports2.charset(mime);
      if (charset2)
        mime += "; charset=" + charset2.toLowerCase();
    }
    return mime;
  }
  function extension2(type2) {
    if (!type2 || typeof type2 !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type2);
    var exts = match && exports2.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  }
  function lookup2(path2) {
    if (!path2 || typeof path2 !== "string") {
      return false;
    }
    var extension3 = extname("x." + path2).toLowerCase().substr(1);
    if (!extension3) {
      return false;
    }
    return exports2.types[extension3] || false;
  }
  function populateMaps(extensions, types2) {
    var preference = ["nginx", "apache", void 0, "iana"];
    Object.keys(db).forEach(function forEachMimeType(type2) {
      var mime = db[type2];
      var exts = mime.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions[type2] = exts;
      for (var i = 0; i < exts.length; i++) {
        var extension3 = exts[i];
        if (types2[extension3]) {
          var from2 = preference.indexOf(db[types2[extension3]].source);
          var to2 = preference.indexOf(mime.source);
          if (types2[extension3] !== "application/octet-stream" && (from2 > to2 || from2 === to2 && types2[extension3].substr(0, 12) === "application/")) {
            continue;
          }
        }
        types2[extension3] = type2;
      }
    });
  }
})(mimeTypes);
const addFile = async (file) => {
  const user = getAuth().currentUser;
  if (user) {
    const fileExtension = resolveExtension(file);
    const fileName = [nanoid(10), fileExtension].join(".");
    const storageRef = ref(getStorage());
    const fileRef = ref(storageRef, fileName);
    const metadata = {
      contentType: file.type,
      customMetadata: {
        ownerId: user.uid
      }
    };
    return uploadBytes(fileRef, file, metadata).then((_snapshot) => {
      return {
        extension: fileExtension,
        mimeType: file.type,
        url: `${"https://cdn.octo.app"}/${fileName}`
      };
    });
  }
};
const resolveExtension = (file) => {
  return mimeTypes.extension(file.type);
};
const completions$1 = (config2) => {
  return (context) => {
    const line2 = context.state.doc.lineAt(context.pos);
    const text2 = line2.text.slice(0, context.pos - line2.from);
    const match = matchStarts(text2).pop();
    if (!match) {
      return null;
    }
    const offset = match.index + match.length;
    return {
      from: line2.from + offset,
      options: config2.tags.map((tag) => {
        return {
          apply: tag,
          label: tag,
          type: "text"
        };
      })
    };
  };
};
const tags$3 = {
  hashtag: Tag.define()
};
const Hashtag = {
  defineNodes: [
    {
      name: "Hashtag",
      style: tags$3.hashtag
    }
  ],
  parseInline: [
    {
      name: "Hashtag",
      parse: (inline, charCode, index2) => {
        if (!HASHTAG_CODES.includes(charCode) || HASHTAG_CODES.includes(inline.char(index2 + 1)))
          return -1;
        const text2 = inline.slice(inline.offset, index2 + 1);
        const prefixMatch2 = matchHashtagPrefix(text2);
        if (prefixMatch2) {
          const start2 = index2 - prefixMatch2.boundary.length;
          const fullMatch = matchHashtag(inline.slice(start2, inline.end));
          if (fullMatch) {
            return inline.addElement(
              inline.elt(
                "Hashtag",
                index2,
                index2 + fullMatch.length - fullMatch.boundary.length
              )
            );
          }
        }
        return -1;
      },
      after: "Emphasis"
    }
  ]
};
const theme$4 = syntaxHighlighting(
  HighlightStyle.define([
    {
      tag: tags$3.hashtag,
      backgroundColor: "var(--ink-internal-syntax-hashtag-background-color)",
      borderRadius: "0.25rem",
      color: "var(--ink-internal-syntax-hashtag-color)",
      padding: "0.125rem 0.25rem"
    }
  ])
);
const hashtags = (config2) => {
  return [
    { type: "completion", value: completions$1(config2) },
    { type: "default", value: theme$4 },
    { type: "grammar", value: Hashtag }
  ];
};
var moment_min = { exports: {} };
(function(module2, exports2) {
  !function(e, t4) {
    module2.exports = t4();
  }(commonjsGlobal$1, function() {
    var H2;
    function f2() {
      return H2.apply(null, arguments);
    }
    function a2(e3) {
      return e3 instanceof Array || "[object Array]" === Object.prototype.toString.call(e3);
    }
    function F(e3) {
      return null != e3 && "[object Object]" === Object.prototype.toString.call(e3);
    }
    function c2(e3, t5) {
      return Object.prototype.hasOwnProperty.call(e3, t5);
    }
    function L(e3) {
      if (Object.getOwnPropertyNames)
        return 0 === Object.getOwnPropertyNames(e3).length;
      for (var t5 in e3)
        if (c2(e3, t5))
          return;
      return 1;
    }
    function o(e3) {
      return void 0 === e3;
    }
    function u(e3) {
      return "number" == typeof e3 || "[object Number]" === Object.prototype.toString.call(e3);
    }
    function V2(e3) {
      return e3 instanceof Date || "[object Date]" === Object.prototype.toString.call(e3);
    }
    function G2(e3, t5) {
      for (var n2 = [], s3 = e3.length, i2 = 0; i2 < s3; ++i2)
        n2.push(t5(e3[i2], i2));
      return n2;
    }
    function E2(e3, t5) {
      for (var n2 in t5)
        c2(t5, n2) && (e3[n2] = t5[n2]);
      return c2(t5, "toString") && (e3.toString = t5.toString), c2(t5, "valueOf") && (e3.valueOf = t5.valueOf), e3;
    }
    function l2(e3, t5, n2, s3) {
      return Pt2(e3, t5, n2, s3, true).utc();
    }
    function m(e3) {
      return null == e3._pf && (e3._pf = { empty: false, unusedTokens: [], unusedInput: [], overflow: -2, charsLeftOver: 0, nullInput: false, invalidEra: null, invalidMonth: null, invalidFormat: false, userInvalidated: false, iso: false, parsedDateParts: [], era: null, meridiem: null, rfc2822: false, weekdayMismatch: false }), e3._pf;
    }
    function A5(e3) {
      if (null == e3._isValid) {
        var t5 = m(e3), n2 = j2.call(t5.parsedDateParts, function(e4) {
          return null != e4;
        }), n2 = !isNaN(e3._d.getTime()) && t5.overflow < 0 && !t5.empty && !t5.invalidEra && !t5.invalidMonth && !t5.invalidWeekday && !t5.weekdayMismatch && !t5.nullInput && !t5.invalidFormat && !t5.userInvalidated && (!t5.meridiem || t5.meridiem && n2);
        if (e3._strict && (n2 = n2 && 0 === t5.charsLeftOver && 0 === t5.unusedTokens.length && void 0 === t5.bigHour), null != Object.isFrozen && Object.isFrozen(e3))
          return n2;
        e3._isValid = n2;
      }
      return e3._isValid;
    }
    function I(e3) {
      var t5 = l2(NaN);
      return null != e3 ? E2(m(t5), e3) : m(t5).userInvalidated = true, t5;
    }
    var j2 = Array.prototype.some || function(e3) {
      for (var t5 = Object(this), n2 = t5.length >>> 0, s3 = 0; s3 < n2; s3++)
        if (s3 in t5 && e3.call(this, t5[s3], s3, t5))
          return true;
      return false;
    }, Z3 = f2.momentProperties = [], z = false;
    function $2(e3, t5) {
      var n2, s3, i2, r2 = Z3.length;
      if (o(t5._isAMomentObject) || (e3._isAMomentObject = t5._isAMomentObject), o(t5._i) || (e3._i = t5._i), o(t5._f) || (e3._f = t5._f), o(t5._l) || (e3._l = t5._l), o(t5._strict) || (e3._strict = t5._strict), o(t5._tzm) || (e3._tzm = t5._tzm), o(t5._isUTC) || (e3._isUTC = t5._isUTC), o(t5._offset) || (e3._offset = t5._offset), o(t5._pf) || (e3._pf = m(t5)), o(t5._locale) || (e3._locale = t5._locale), 0 < r2)
        for (n2 = 0; n2 < r2; n2++)
          o(i2 = t5[s3 = Z3[n2]]) || (e3[s3] = i2);
      return e3;
    }
    function q(e3) {
      $2(this, e3), this._d = new Date(null != e3._d ? e3._d.getTime() : NaN), this.isValid() || (this._d = new Date(NaN)), false === z && (z = true, f2.updateOffset(this), z = false);
    }
    function h2(e3) {
      return e3 instanceof q || null != e3 && null != e3._isAMomentObject;
    }
    function B2(e3) {
      false === f2.suppressDeprecationWarnings && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + e3);
    }
    function e(r2, a3) {
      var o2 = true;
      return E2(function() {
        if (null != f2.deprecationHandler && f2.deprecationHandler(null, r2), o2) {
          for (var e3, t5, n2 = [], s3 = arguments.length, i2 = 0; i2 < s3; i2++) {
            if (e3 = "", "object" == typeof arguments[i2]) {
              for (t5 in e3 += "\n[" + i2 + "] ", arguments[0])
                c2(arguments[0], t5) && (e3 += t5 + ": " + arguments[0][t5] + ", ");
              e3 = e3.slice(0, -2);
            } else
              e3 = arguments[i2];
            n2.push(e3);
          }
          B2(r2 + "\nArguments: " + Array.prototype.slice.call(n2).join("") + "\n" + new Error().stack), o2 = false;
        }
        return a3.apply(this, arguments);
      }, a3);
    }
    var J = {};
    function Q(e3, t5) {
      null != f2.deprecationHandler && f2.deprecationHandler(e3, t5), J[e3] || (B2(t5), J[e3] = true);
    }
    function d(e3) {
      return "undefined" != typeof Function && e3 instanceof Function || "[object Function]" === Object.prototype.toString.call(e3);
    }
    function X3(e3, t5) {
      var n2, s3 = E2({}, e3);
      for (n2 in t5)
        c2(t5, n2) && (F(e3[n2]) && F(t5[n2]) ? (s3[n2] = {}, E2(s3[n2], e3[n2]), E2(s3[n2], t5[n2])) : null != t5[n2] ? s3[n2] = t5[n2] : delete s3[n2]);
      for (n2 in e3)
        c2(e3, n2) && !c2(t5, n2) && F(e3[n2]) && (s3[n2] = E2({}, s3[n2]));
      return s3;
    }
    function K2(e3) {
      null != e3 && this.set(e3);
    }
    f2.suppressDeprecationWarnings = false, f2.deprecationHandler = null;
    var ee = Object.keys || function(e3) {
      var t5, n2 = [];
      for (t5 in e3)
        c2(e3, t5) && n2.push(t5);
      return n2;
    };
    function r(e3, t5, n2) {
      var s3 = "" + Math.abs(e3);
      return (0 <= e3 ? n2 ? "+" : "" : "-") + Math.pow(10, Math.max(0, t5 - s3.length)).toString().substr(1) + s3;
    }
    var te = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, ne2 = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, se2 = {}, ie2 = {};
    function s2(e3, t5, n2, s3) {
      var i2 = "string" == typeof s3 ? function() {
        return this[s3]();
      } : s3;
      e3 && (ie2[e3] = i2), t5 && (ie2[t5[0]] = function() {
        return r(i2.apply(this, arguments), t5[1], t5[2]);
      }), n2 && (ie2[n2] = function() {
        return this.localeData().ordinal(i2.apply(this, arguments), e3);
      });
    }
    function re2(e3, t5) {
      return e3.isValid() ? (t5 = ae2(t5, e3.localeData()), se2[t5] = se2[t5] || function(s3) {
        for (var e4, i2 = s3.match(te), t6 = 0, r2 = i2.length; t6 < r2; t6++)
          ie2[i2[t6]] ? i2[t6] = ie2[i2[t6]] : i2[t6] = (e4 = i2[t6]).match(/\[[\s\S]/) ? e4.replace(/^\[|\]$/g, "") : e4.replace(/\\/g, "");
        return function(e6) {
          for (var t7 = "", n2 = 0; n2 < r2; n2++)
            t7 += d(i2[n2]) ? i2[n2].call(e6, s3) : i2[n2];
          return t7;
        };
      }(t5), se2[t5](e3)) : e3.localeData().invalidDate();
    }
    function ae2(e3, t5) {
      var n2 = 5;
      function s3(e4) {
        return t5.longDateFormat(e4) || e4;
      }
      for (ne2.lastIndex = 0; 0 <= n2 && ne2.test(e3); )
        e3 = e3.replace(ne2, s3), ne2.lastIndex = 0, --n2;
      return e3;
    }
    var oe = {};
    function t4(e3, t5) {
      var n2 = e3.toLowerCase();
      oe[n2] = oe[n2 + "s"] = oe[t5] = e3;
    }
    function _2(e3) {
      return "string" == typeof e3 ? oe[e3] || oe[e3.toLowerCase()] : void 0;
    }
    function ue2(e3) {
      var t5, n2, s3 = {};
      for (n2 in e3)
        c2(e3, n2) && (t5 = _2(n2)) && (s3[t5] = e3[n2]);
      return s3;
    }
    var le2 = {};
    function n(e3, t5) {
      le2[e3] = t5;
    }
    function he(e3) {
      return e3 % 4 == 0 && e3 % 100 != 0 || e3 % 400 == 0;
    }
    function y2(e3) {
      return e3 < 0 ? Math.ceil(e3) || 0 : Math.floor(e3);
    }
    function g2(e3) {
      var e3 = +e3, t5 = 0;
      return t5 = 0 != e3 && isFinite(e3) ? y2(e3) : t5;
    }
    function de(t5, n2) {
      return function(e3) {
        return null != e3 ? (fe2(this, t5, e3), f2.updateOffset(this, n2), this) : ce(this, t5);
      };
    }
    function ce(e3, t5) {
      return e3.isValid() ? e3._d["get" + (e3._isUTC ? "UTC" : "") + t5]() : NaN;
    }
    function fe2(e3, t5, n2) {
      e3.isValid() && !isNaN(n2) && ("FullYear" === t5 && he(e3.year()) && 1 === e3.month() && 29 === e3.date() ? (n2 = g2(n2), e3._d["set" + (e3._isUTC ? "UTC" : "") + t5](n2, e3.month(), We(n2, e3.month()))) : e3._d["set" + (e3._isUTC ? "UTC" : "") + t5](n2));
    }
    var i = /\d/, w2 = /\d\d/, me = /\d{3}/, _e = /\d{4}/, ye = /[+-]?\d{6}/, p = /\d\d?/, ge2 = /\d\d\d\d?/, we = /\d\d\d\d\d\d?/, pe2 = /\d{1,3}/, ke = /\d{1,4}/, ve = /[+-]?\d{1,6}/, Me2 = /\d+/, De2 = /[+-]?\d+/, Se2 = /Z|[+-]\d\d:?\d\d/gi, Ye = /Z|[+-]\d\d(?::?\d\d)?/gi, k2 = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
    function v(e3, n2, s3) {
      be[e3] = d(n2) ? n2 : function(e4, t5) {
        return e4 && s3 ? s3 : n2;
      };
    }
    function Oe(e3, t5) {
      return c2(be, e3) ? be[e3](t5._strict, t5._locale) : new RegExp(M2(e3.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(e4, t6, n2, s3, i2) {
        return t6 || n2 || s3 || i2;
      })));
    }
    function M2(e3) {
      return e3.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    var be = {}, xe2 = {};
    function D2(e3, n2) {
      var t5, s3, i2 = n2;
      for ("string" == typeof e3 && (e3 = [e3]), u(n2) && (i2 = function(e4, t6) {
        t6[n2] = g2(e4);
      }), s3 = e3.length, t5 = 0; t5 < s3; t5++)
        xe2[e3[t5]] = i2;
    }
    function Te(e3, i2) {
      D2(e3, function(e4, t5, n2, s3) {
        n2._w = n2._w || {}, i2(e4, n2._w, n2, s3);
      });
    }
    var S2, Y3 = 0, O2 = 1, b = 2, x2 = 3, T = 4, N2 = 5, Ne = 6, Pe = 7, Re = 8;
    function We(e3, t5) {
      if (isNaN(e3) || isNaN(t5))
        return NaN;
      var n2 = (t5 % (n2 = 12) + n2) % n2;
      return e3 += (t5 - n2) / 12, 1 == n2 ? he(e3) ? 29 : 28 : 31 - n2 % 7 % 2;
    }
    S2 = Array.prototype.indexOf || function(e3) {
      for (var t5 = 0; t5 < this.length; ++t5)
        if (this[t5] === e3)
          return t5;
      return -1;
    }, s2("M", ["MM", 2], "Mo", function() {
      return this.month() + 1;
    }), s2("MMM", 0, 0, function(e3) {
      return this.localeData().monthsShort(this, e3);
    }), s2("MMMM", 0, 0, function(e3) {
      return this.localeData().months(this, e3);
    }), t4("month", "M"), n("month", 8), v("M", p), v("MM", p, w2), v("MMM", function(e3, t5) {
      return t5.monthsShortRegex(e3);
    }), v("MMMM", function(e3, t5) {
      return t5.monthsRegex(e3);
    }), D2(["M", "MM"], function(e3, t5) {
      t5[O2] = g2(e3) - 1;
    }), D2(["MMM", "MMMM"], function(e3, t5, n2, s3) {
      s3 = n2._locale.monthsParse(e3, s3, n2._strict);
      null != s3 ? t5[O2] = s3 : m(n2).invalidMonth = e3;
    });
    var Ce2 = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), Ue = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), He2 = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, Fe = k2, Le2 = k2;
    function Ve2(e3, t5) {
      var n2;
      if (e3.isValid()) {
        if ("string" == typeof t5) {
          if (/^\d+$/.test(t5))
            t5 = g2(t5);
          else if (!u(t5 = e3.localeData().monthsParse(t5)))
            return;
        }
        n2 = Math.min(e3.date(), We(e3.year(), t5)), e3._d["set" + (e3._isUTC ? "UTC" : "") + "Month"](t5, n2);
      }
    }
    function Ge(e3) {
      return null != e3 ? (Ve2(this, e3), f2.updateOffset(this, true), this) : ce(this, "Month");
    }
    function Ee2() {
      function e3(e4, t6) {
        return t6.length - e4.length;
      }
      for (var t5, n2 = [], s3 = [], i2 = [], r2 = 0; r2 < 12; r2++)
        t5 = l2([2e3, r2]), n2.push(this.monthsShort(t5, "")), s3.push(this.months(t5, "")), i2.push(this.months(t5, "")), i2.push(this.monthsShort(t5, ""));
      for (n2.sort(e3), s3.sort(e3), i2.sort(e3), r2 = 0; r2 < 12; r2++)
        n2[r2] = M2(n2[r2]), s3[r2] = M2(s3[r2]);
      for (r2 = 0; r2 < 24; r2++)
        i2[r2] = M2(i2[r2]);
      this._monthsRegex = new RegExp("^(" + i2.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp("^(" + s3.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + n2.join("|") + ")", "i");
    }
    function Ae2(e3) {
      return he(e3) ? 366 : 365;
    }
    s2("Y", 0, 0, function() {
      var e3 = this.year();
      return e3 <= 9999 ? r(e3, 4) : "+" + e3;
    }), s2(0, ["YY", 2], 0, function() {
      return this.year() % 100;
    }), s2(0, ["YYYY", 4], 0, "year"), s2(0, ["YYYYY", 5], 0, "year"), s2(0, ["YYYYYY", 6, true], 0, "year"), t4("year", "y"), n("year", 1), v("Y", De2), v("YY", p, w2), v("YYYY", ke, _e), v("YYYYY", ve, ye), v("YYYYYY", ve, ye), D2(["YYYYY", "YYYYYY"], Y3), D2("YYYY", function(e3, t5) {
      t5[Y3] = 2 === e3.length ? f2.parseTwoDigitYear(e3) : g2(e3);
    }), D2("YY", function(e3, t5) {
      t5[Y3] = f2.parseTwoDigitYear(e3);
    }), D2("Y", function(e3, t5) {
      t5[Y3] = parseInt(e3, 10);
    }), f2.parseTwoDigitYear = function(e3) {
      return g2(e3) + (68 < g2(e3) ? 1900 : 2e3);
    };
    var Ie = de("FullYear", true);
    function je2(e3, t5, n2, s3, i2, r2, a3) {
      var o2;
      return e3 < 100 && 0 <= e3 ? (o2 = new Date(e3 + 400, t5, n2, s3, i2, r2, a3), isFinite(o2.getFullYear()) && o2.setFullYear(e3)) : o2 = new Date(e3, t5, n2, s3, i2, r2, a3), o2;
    }
    function Ze(e3) {
      var t5;
      return e3 < 100 && 0 <= e3 ? ((t5 = Array.prototype.slice.call(arguments))[0] = e3 + 400, t5 = new Date(Date.UTC.apply(null, t5)), isFinite(t5.getUTCFullYear()) && t5.setUTCFullYear(e3)) : t5 = new Date(Date.UTC.apply(null, arguments)), t5;
    }
    function ze2(e3, t5, n2) {
      n2 = 7 + t5 - n2;
      return n2 - (7 + Ze(e3, 0, n2).getUTCDay() - t5) % 7 - 1;
    }
    function $e(e3, t5, n2, s3, i2) {
      var r2, t5 = 1 + 7 * (t5 - 1) + (7 + n2 - s3) % 7 + ze2(e3, s3, i2), n2 = t5 <= 0 ? Ae2(r2 = e3 - 1) + t5 : t5 > Ae2(e3) ? (r2 = e3 + 1, t5 - Ae2(e3)) : (r2 = e3, t5);
      return { year: r2, dayOfYear: n2 };
    }
    function qe(e3, t5, n2) {
      var s3, i2, r2 = ze2(e3.year(), t5, n2), r2 = Math.floor((e3.dayOfYear() - r2 - 1) / 7) + 1;
      return r2 < 1 ? s3 = r2 + P2(i2 = e3.year() - 1, t5, n2) : r2 > P2(e3.year(), t5, n2) ? (s3 = r2 - P2(e3.year(), t5, n2), i2 = e3.year() + 1) : (i2 = e3.year(), s3 = r2), { week: s3, year: i2 };
    }
    function P2(e3, t5, n2) {
      var s3 = ze2(e3, t5, n2), t5 = ze2(e3 + 1, t5, n2);
      return (Ae2(e3) - s3 + t5) / 7;
    }
    s2("w", ["ww", 2], "wo", "week"), s2("W", ["WW", 2], "Wo", "isoWeek"), t4("week", "w"), t4("isoWeek", "W"), n("week", 5), n("isoWeek", 5), v("w", p), v("ww", p, w2), v("W", p), v("WW", p, w2), Te(["w", "ww", "W", "WW"], function(e3, t5, n2, s3) {
      t5[s3.substr(0, 1)] = g2(e3);
    });
    function Be2(e3, t5) {
      return e3.slice(t5, 7).concat(e3.slice(0, t5));
    }
    s2("d", 0, "do", "day"), s2("dd", 0, 0, function(e3) {
      return this.localeData().weekdaysMin(this, e3);
    }), s2("ddd", 0, 0, function(e3) {
      return this.localeData().weekdaysShort(this, e3);
    }), s2("dddd", 0, 0, function(e3) {
      return this.localeData().weekdays(this, e3);
    }), s2("e", 0, 0, "weekday"), s2("E", 0, 0, "isoWeekday"), t4("day", "d"), t4("weekday", "e"), t4("isoWeekday", "E"), n("day", 11), n("weekday", 11), n("isoWeekday", 11), v("d", p), v("e", p), v("E", p), v("dd", function(e3, t5) {
      return t5.weekdaysMinRegex(e3);
    }), v("ddd", function(e3, t5) {
      return t5.weekdaysShortRegex(e3);
    }), v("dddd", function(e3, t5) {
      return t5.weekdaysRegex(e3);
    }), Te(["dd", "ddd", "dddd"], function(e3, t5, n2, s3) {
      s3 = n2._locale.weekdaysParse(e3, s3, n2._strict);
      null != s3 ? t5.d = s3 : m(n2).invalidWeekday = e3;
    }), Te(["d", "e", "E"], function(e3, t5, n2, s3) {
      t5[s3] = g2(e3);
    });
    var Je = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), Qe = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), Xe = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), Ke = k2, et = k2, tt = k2;
    function nt() {
      function e3(e4, t6) {
        return t6.length - e4.length;
      }
      for (var t5, n2, s3, i2 = [], r2 = [], a3 = [], o2 = [], u2 = 0; u2 < 7; u2++)
        s3 = l2([2e3, 1]).day(u2), t5 = M2(this.weekdaysMin(s3, "")), n2 = M2(this.weekdaysShort(s3, "")), s3 = M2(this.weekdays(s3, "")), i2.push(t5), r2.push(n2), a3.push(s3), o2.push(t5), o2.push(n2), o2.push(s3);
      i2.sort(e3), r2.sort(e3), a3.sort(e3), o2.sort(e3), this._weekdaysRegex = new RegExp("^(" + o2.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + a3.join("|") + ")", "i"), this._weekdaysShortStrictRegex = new RegExp("^(" + r2.join("|") + ")", "i"), this._weekdaysMinStrictRegex = new RegExp("^(" + i2.join("|") + ")", "i");
    }
    function st() {
      return this.hours() % 12 || 12;
    }
    function it(e3, t5) {
      s2(e3, 0, 0, function() {
        return this.localeData().meridiem(this.hours(), this.minutes(), t5);
      });
    }
    function rt(e3, t5) {
      return t5._meridiemParse;
    }
    s2("H", ["HH", 2], 0, "hour"), s2("h", ["hh", 2], 0, st), s2("k", ["kk", 2], 0, function() {
      return this.hours() || 24;
    }), s2("hmm", 0, 0, function() {
      return "" + st.apply(this) + r(this.minutes(), 2);
    }), s2("hmmss", 0, 0, function() {
      return "" + st.apply(this) + r(this.minutes(), 2) + r(this.seconds(), 2);
    }), s2("Hmm", 0, 0, function() {
      return "" + this.hours() + r(this.minutes(), 2);
    }), s2("Hmmss", 0, 0, function() {
      return "" + this.hours() + r(this.minutes(), 2) + r(this.seconds(), 2);
    }), it("a", true), it("A", false), t4("hour", "h"), n("hour", 13), v("a", rt), v("A", rt), v("H", p), v("h", p), v("k", p), v("HH", p, w2), v("hh", p, w2), v("kk", p, w2), v("hmm", ge2), v("hmmss", we), v("Hmm", ge2), v("Hmmss", we), D2(["H", "HH"], x2), D2(["k", "kk"], function(e3, t5, n2) {
      e3 = g2(e3);
      t5[x2] = 24 === e3 ? 0 : e3;
    }), D2(["a", "A"], function(e3, t5, n2) {
      n2._isPm = n2._locale.isPM(e3), n2._meridiem = e3;
    }), D2(["h", "hh"], function(e3, t5, n2) {
      t5[x2] = g2(e3), m(n2).bigHour = true;
    }), D2("hmm", function(e3, t5, n2) {
      var s3 = e3.length - 2;
      t5[x2] = g2(e3.substr(0, s3)), t5[T] = g2(e3.substr(s3)), m(n2).bigHour = true;
    }), D2("hmmss", function(e3, t5, n2) {
      var s3 = e3.length - 4, i2 = e3.length - 2;
      t5[x2] = g2(e3.substr(0, s3)), t5[T] = g2(e3.substr(s3, 2)), t5[N2] = g2(e3.substr(i2)), m(n2).bigHour = true;
    }), D2("Hmm", function(e3, t5, n2) {
      var s3 = e3.length - 2;
      t5[x2] = g2(e3.substr(0, s3)), t5[T] = g2(e3.substr(s3));
    }), D2("Hmmss", function(e3, t5, n2) {
      var s3 = e3.length - 4, i2 = e3.length - 2;
      t5[x2] = g2(e3.substr(0, s3)), t5[T] = g2(e3.substr(s3, 2)), t5[N2] = g2(e3.substr(i2));
    });
    k2 = de("Hours", true);
    var at, ot = { calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, longDateFormat: { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, invalidDate: "Invalid date", ordinal: "%d", dayOfMonthOrdinalParse: /\d{1,2}/, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", w: "a week", ww: "%d weeks", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, months: Ce2, monthsShort: Ue, week: { dow: 0, doy: 6 }, weekdays: Je, weekdaysMin: Xe, weekdaysShort: Qe, meridiemParse: /[ap]\.?m?\.?/i }, R = {}, ut = {};
    function lt(e3) {
      return e3 && e3.toLowerCase().replace("_", "-");
    }
    function ht(e3) {
      for (var t5, n2, s3, i2, r2 = 0; r2 < e3.length; ) {
        for (t5 = (i2 = lt(e3[r2]).split("-")).length, n2 = (n2 = lt(e3[r2 + 1])) ? n2.split("-") : null; 0 < t5; ) {
          if (s3 = dt(i2.slice(0, t5).join("-")))
            return s3;
          if (n2 && n2.length >= t5 && function(e4, t6) {
            for (var n3 = Math.min(e4.length, t6.length), s4 = 0; s4 < n3; s4 += 1)
              if (e4[s4] !== t6[s4])
                return s4;
            return n3;
          }(i2, n2) >= t5 - 1)
            break;
          t5--;
        }
        r2++;
      }
      return at;
    }
    function dt(t5) {
      var e3;
      if (void 0 === R[t5] && true && module2 && module2.exports && null != t5.match("^[^/\\\\]*$"))
        try {
          e3 = at._abbr, commonjsRequire$1("./locale/" + t5), ct(e3);
        } catch (e4) {
          R[t5] = null;
        }
      return R[t5];
    }
    function ct(e3, t5) {
      return e3 && ((t5 = o(t5) ? mt(e3) : ft(e3, t5)) ? at = t5 : "undefined" != typeof console && console.warn && console.warn("Locale " + e3 + " not found. Did you forget to load it?")), at._abbr;
    }
    function ft(e3, t5) {
      if (null === t5)
        return delete R[e3], null;
      var n2, s3 = ot;
      if (t5.abbr = e3, null != R[e3])
        Q("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), s3 = R[e3]._config;
      else if (null != t5.parentLocale)
        if (null != R[t5.parentLocale])
          s3 = R[t5.parentLocale]._config;
        else {
          if (null == (n2 = dt(t5.parentLocale)))
            return ut[t5.parentLocale] || (ut[t5.parentLocale] = []), ut[t5.parentLocale].push({ name: e3, config: t5 }), null;
          s3 = n2._config;
        }
      return R[e3] = new K2(X3(s3, t5)), ut[e3] && ut[e3].forEach(function(e4) {
        ft(e4.name, e4.config);
      }), ct(e3), R[e3];
    }
    function mt(e3) {
      var t5;
      if (!(e3 = e3 && e3._locale && e3._locale._abbr ? e3._locale._abbr : e3))
        return at;
      if (!a2(e3)) {
        if (t5 = dt(e3))
          return t5;
        e3 = [e3];
      }
      return ht(e3);
    }
    function _t(e3) {
      var t5 = e3._a;
      return t5 && -2 === m(e3).overflow && (t5 = t5[O2] < 0 || 11 < t5[O2] ? O2 : t5[b] < 1 || t5[b] > We(t5[Y3], t5[O2]) ? b : t5[x2] < 0 || 24 < t5[x2] || 24 === t5[x2] && (0 !== t5[T] || 0 !== t5[N2] || 0 !== t5[Ne]) ? x2 : t5[T] < 0 || 59 < t5[T] ? T : t5[N2] < 0 || 59 < t5[N2] ? N2 : t5[Ne] < 0 || 999 < t5[Ne] ? Ne : -1, m(e3)._overflowDayOfYear && (t5 < Y3 || b < t5) && (t5 = b), m(e3)._overflowWeeks && -1 === t5 && (t5 = Pe), m(e3)._overflowWeekday && -1 === t5 && (t5 = Re), m(e3).overflow = t5), e3;
    }
    var yt2 = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, gt = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, wt2 = /Z|[+-]\d\d(?::?\d\d)?/, pt = [["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/], ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/], ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/], ["GGGG-[W]WW", /\d{4}-W\d\d/, false], ["YYYY-DDD", /\d{4}-\d{3}/], ["YYYY-MM", /\d{4}-\d\d/, false], ["YYYYYYMMDD", /[+-]\d{10}/], ["YYYYMMDD", /\d{8}/], ["GGGG[W]WWE", /\d{4}W\d{3}/], ["GGGG[W]WW", /\d{4}W\d{2}/, false], ["YYYYDDD", /\d{7}/], ["YYYYMM", /\d{6}/, false], ["YYYY", /\d{4}/, false]], kt = [["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/], ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/], ["HH:mm:ss", /\d\d:\d\d:\d\d/], ["HH:mm", /\d\d:\d\d/], ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/], ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/], ["HHmmss", /\d\d\d\d\d\d/], ["HHmm", /\d\d\d\d/], ["HH", /\d\d/]], vt2 = /^\/?Date\((-?\d+)/i, Mt2 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, Dt2 = { UT: 0, GMT: 0, EDT: -240, EST: -300, CDT: -300, CST: -360, MDT: -360, MST: -420, PDT: -420, PST: -480 };
    function St2(e3) {
      var t5, n2, s3, i2, r2, a3, o2 = e3._i, u2 = yt2.exec(o2) || gt.exec(o2), o2 = pt.length, l3 = kt.length;
      if (u2) {
        for (m(e3).iso = true, t5 = 0, n2 = o2; t5 < n2; t5++)
          if (pt[t5][1].exec(u2[1])) {
            i2 = pt[t5][0], s3 = false !== pt[t5][2];
            break;
          }
        if (null == i2)
          e3._isValid = false;
        else {
          if (u2[3]) {
            for (t5 = 0, n2 = l3; t5 < n2; t5++)
              if (kt[t5][1].exec(u2[3])) {
                r2 = (u2[2] || " ") + kt[t5][0];
                break;
              }
            if (null == r2)
              return void (e3._isValid = false);
          }
          if (s3 || null == r2) {
            if (u2[4]) {
              if (!wt2.exec(u2[4]))
                return void (e3._isValid = false);
              a3 = "Z";
            }
            e3._f = i2 + (r2 || "") + (a3 || ""), Tt2(e3);
          } else
            e3._isValid = false;
        }
      } else
        e3._isValid = false;
    }
    function Yt2(e3, t5, n2, s3, i2, r2) {
      e3 = [function(e4) {
        e4 = parseInt(e4, 10);
        {
          if (e4 <= 49)
            return 2e3 + e4;
          if (e4 <= 999)
            return 1900 + e4;
        }
        return e4;
      }(e3), Ue.indexOf(t5), parseInt(n2, 10), parseInt(s3, 10), parseInt(i2, 10)];
      return r2 && e3.push(parseInt(r2, 10)), e3;
    }
    function Ot2(e3) {
      var t5, n2, s3, i2, r2 = Mt2.exec(e3._i.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, ""));
      r2 ? (t5 = Yt2(r2[4], r2[3], r2[2], r2[5], r2[6], r2[7]), n2 = r2[1], s3 = t5, i2 = e3, n2 && Qe.indexOf(n2) !== new Date(s3[0], s3[1], s3[2]).getDay() ? (m(i2).weekdayMismatch = true, i2._isValid = false) : (e3._a = t5, e3._tzm = (n2 = r2[8], s3 = r2[9], i2 = r2[10], n2 ? Dt2[n2] : s3 ? 0 : 60 * (((n2 = parseInt(i2, 10)) - (s3 = n2 % 100)) / 100) + s3), e3._d = Ze.apply(null, e3._a), e3._d.setUTCMinutes(e3._d.getUTCMinutes() - e3._tzm), m(e3).rfc2822 = true)) : e3._isValid = false;
    }
    function bt(e3, t5, n2) {
      return null != e3 ? e3 : null != t5 ? t5 : n2;
    }
    function xt2(e3) {
      var t5, n2, s3, i2, r2, a3, o2, u2, l3, h3, d2, c3 = [];
      if (!e3._d) {
        for (s3 = e3, i2 = new Date(f2.now()), n2 = s3._useUTC ? [i2.getUTCFullYear(), i2.getUTCMonth(), i2.getUTCDate()] : [i2.getFullYear(), i2.getMonth(), i2.getDate()], e3._w && null == e3._a[b] && null == e3._a[O2] && (null != (i2 = (s3 = e3)._w).GG || null != i2.W || null != i2.E ? (u2 = 1, l3 = 4, r2 = bt(i2.GG, s3._a[Y3], qe(W2(), 1, 4).year), a3 = bt(i2.W, 1), ((o2 = bt(i2.E, 1)) < 1 || 7 < o2) && (h3 = true)) : (u2 = s3._locale._week.dow, l3 = s3._locale._week.doy, d2 = qe(W2(), u2, l3), r2 = bt(i2.gg, s3._a[Y3], d2.year), a3 = bt(i2.w, d2.week), null != i2.d ? ((o2 = i2.d) < 0 || 6 < o2) && (h3 = true) : null != i2.e ? (o2 = i2.e + u2, (i2.e < 0 || 6 < i2.e) && (h3 = true)) : o2 = u2), a3 < 1 || a3 > P2(r2, u2, l3) ? m(s3)._overflowWeeks = true : null != h3 ? m(s3)._overflowWeekday = true : (d2 = $e(r2, a3, o2, u2, l3), s3._a[Y3] = d2.year, s3._dayOfYear = d2.dayOfYear)), null != e3._dayOfYear && (i2 = bt(e3._a[Y3], n2[Y3]), (e3._dayOfYear > Ae2(i2) || 0 === e3._dayOfYear) && (m(e3)._overflowDayOfYear = true), h3 = Ze(i2, 0, e3._dayOfYear), e3._a[O2] = h3.getUTCMonth(), e3._a[b] = h3.getUTCDate()), t5 = 0; t5 < 3 && null == e3._a[t5]; ++t5)
          e3._a[t5] = c3[t5] = n2[t5];
        for (; t5 < 7; t5++)
          e3._a[t5] = c3[t5] = null == e3._a[t5] ? 2 === t5 ? 1 : 0 : e3._a[t5];
        24 === e3._a[x2] && 0 === e3._a[T] && 0 === e3._a[N2] && 0 === e3._a[Ne] && (e3._nextDay = true, e3._a[x2] = 0), e3._d = (e3._useUTC ? Ze : je2).apply(null, c3), r2 = e3._useUTC ? e3._d.getUTCDay() : e3._d.getDay(), null != e3._tzm && e3._d.setUTCMinutes(e3._d.getUTCMinutes() - e3._tzm), e3._nextDay && (e3._a[x2] = 24), e3._w && void 0 !== e3._w.d && e3._w.d !== r2 && (m(e3).weekdayMismatch = true);
      }
    }
    function Tt2(e3) {
      if (e3._f === f2.ISO_8601)
        St2(e3);
      else if (e3._f === f2.RFC_2822)
        Ot2(e3);
      else {
        e3._a = [], m(e3).empty = true;
        for (var t5, n2, s3, i2, r2, a3 = "" + e3._i, o2 = a3.length, u2 = 0, l3 = ae2(e3._f, e3._locale).match(te) || [], h3 = l3.length, d2 = 0; d2 < h3; d2++)
          n2 = l3[d2], (t5 = (a3.match(Oe(n2, e3)) || [])[0]) && (0 < (s3 = a3.substr(0, a3.indexOf(t5))).length && m(e3).unusedInput.push(s3), a3 = a3.slice(a3.indexOf(t5) + t5.length), u2 += t5.length), ie2[n2] ? (t5 ? m(e3).empty = false : m(e3).unusedTokens.push(n2), s3 = n2, r2 = e3, null != (i2 = t5) && c2(xe2, s3) && xe2[s3](i2, r2._a, r2, s3)) : e3._strict && !t5 && m(e3).unusedTokens.push(n2);
        m(e3).charsLeftOver = o2 - u2, 0 < a3.length && m(e3).unusedInput.push(a3), e3._a[x2] <= 12 && true === m(e3).bigHour && 0 < e3._a[x2] && (m(e3).bigHour = void 0), m(e3).parsedDateParts = e3._a.slice(0), m(e3).meridiem = e3._meridiem, e3._a[x2] = function(e4, t6, n3) {
          if (null == n3)
            return t6;
          return null != e4.meridiemHour ? e4.meridiemHour(t6, n3) : null != e4.isPM ? ((e4 = e4.isPM(n3)) && t6 < 12 && (t6 += 12), t6 = e4 || 12 !== t6 ? t6 : 0) : t6;
        }(e3._locale, e3._a[x2], e3._meridiem), null !== (o2 = m(e3).era) && (e3._a[Y3] = e3._locale.erasConvertYear(o2, e3._a[Y3])), xt2(e3), _t(e3);
      }
    }
    function Nt2(e3) {
      var t5, n2, s3, i2 = e3._i, r2 = e3._f;
      if (e3._locale = e3._locale || mt(e3._l), null === i2 || void 0 === r2 && "" === i2)
        return I({ nullInput: true });
      if ("string" == typeof i2 && (e3._i = i2 = e3._locale.preparse(i2)), h2(i2))
        return new q(_t(i2));
      if (V2(i2))
        e3._d = i2;
      else if (a2(r2))
        !function(e4) {
          var t6, n3, s4, i3, r3, a3, o2 = false, u2 = e4._f.length;
          if (0 === u2)
            return m(e4).invalidFormat = true, e4._d = new Date(NaN);
          for (i3 = 0; i3 < u2; i3++)
            r3 = 0, a3 = false, t6 = $2({}, e4), null != e4._useUTC && (t6._useUTC = e4._useUTC), t6._f = e4._f[i3], Tt2(t6), A5(t6) && (a3 = true), r3 = (r3 += m(t6).charsLeftOver) + 10 * m(t6).unusedTokens.length, m(t6).score = r3, o2 ? r3 < s4 && (s4 = r3, n3 = t6) : (null == s4 || r3 < s4 || a3) && (s4 = r3, n3 = t6, a3 && (o2 = true));
          E2(e4, n3 || t6);
        }(e3);
      else if (r2)
        Tt2(e3);
      else if (o(r2 = (i2 = e3)._i))
        i2._d = new Date(f2.now());
      else
        V2(r2) ? i2._d = new Date(r2.valueOf()) : "string" == typeof r2 ? (n2 = i2, null !== (t5 = vt2.exec(n2._i)) ? n2._d = new Date(+t5[1]) : (St2(n2), false === n2._isValid && (delete n2._isValid, Ot2(n2), false === n2._isValid && (delete n2._isValid, n2._strict ? n2._isValid = false : f2.createFromInputFallback(n2))))) : a2(r2) ? (i2._a = G2(r2.slice(0), function(e4) {
          return parseInt(e4, 10);
        }), xt2(i2)) : F(r2) ? (t5 = i2)._d || (s3 = void 0 === (n2 = ue2(t5._i)).day ? n2.date : n2.day, t5._a = G2([n2.year, n2.month, s3, n2.hour, n2.minute, n2.second, n2.millisecond], function(e4) {
          return e4 && parseInt(e4, 10);
        }), xt2(t5)) : u(r2) ? i2._d = new Date(r2) : f2.createFromInputFallback(i2);
      return A5(e3) || (e3._d = null), e3;
    }
    function Pt2(e3, t5, n2, s3, i2) {
      var r2 = {};
      return true !== t5 && false !== t5 || (s3 = t5, t5 = void 0), true !== n2 && false !== n2 || (s3 = n2, n2 = void 0), (F(e3) && L(e3) || a2(e3) && 0 === e3.length) && (e3 = void 0), r2._isAMomentObject = true, r2._useUTC = r2._isUTC = i2, r2._l = n2, r2._i = e3, r2._f = t5, r2._strict = s3, (i2 = new q(_t(Nt2(i2 = r2))))._nextDay && (i2.add(1, "d"), i2._nextDay = void 0), i2;
    }
    function W2(e3, t5, n2, s3) {
      return Pt2(e3, t5, n2, s3, false);
    }
    f2.createFromInputFallback = e("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(e3) {
      e3._d = new Date(e3._i + (e3._useUTC ? " UTC" : ""));
    }), f2.ISO_8601 = function() {
    }, f2.RFC_2822 = function() {
    };
    ge2 = e("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
      var e3 = W2.apply(null, arguments);
      return this.isValid() && e3.isValid() ? e3 < this ? this : e3 : I();
    }), we = e("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
      var e3 = W2.apply(null, arguments);
      return this.isValid() && e3.isValid() ? this < e3 ? this : e3 : I();
    });
    function Rt2(e3, t5) {
      var n2, s3;
      if (!(t5 = 1 === t5.length && a2(t5[0]) ? t5[0] : t5).length)
        return W2();
      for (n2 = t5[0], s3 = 1; s3 < t5.length; ++s3)
        t5[s3].isValid() && !t5[s3][e3](n2) || (n2 = t5[s3]);
      return n2;
    }
    var Wt2 = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];
    function Ct2(e3) {
      var e3 = ue2(e3), t5 = e3.year || 0, n2 = e3.quarter || 0, s3 = e3.month || 0, i2 = e3.week || e3.isoWeek || 0, r2 = e3.day || 0, a3 = e3.hour || 0, o2 = e3.minute || 0, u2 = e3.second || 0, l3 = e3.millisecond || 0;
      this._isValid = function(e4) {
        var t6, n3, s4 = false, i3 = Wt2.length;
        for (t6 in e4)
          if (c2(e4, t6) && (-1 === S2.call(Wt2, t6) || null != e4[t6] && isNaN(e4[t6])))
            return false;
        for (n3 = 0; n3 < i3; ++n3)
          if (e4[Wt2[n3]]) {
            if (s4)
              return false;
            parseFloat(e4[Wt2[n3]]) !== g2(e4[Wt2[n3]]) && (s4 = true);
          }
        return true;
      }(e3), this._milliseconds = +l3 + 1e3 * u2 + 6e4 * o2 + 1e3 * a3 * 60 * 60, this._days = +r2 + 7 * i2, this._months = +s3 + 3 * n2 + 12 * t5, this._data = {}, this._locale = mt(), this._bubble();
    }
    function Ut2(e3) {
      return e3 instanceof Ct2;
    }
    function Ht2(e3) {
      return e3 < 0 ? -1 * Math.round(-1 * e3) : Math.round(e3);
    }
    function Ft2(e3, n2) {
      s2(e3, 0, 0, function() {
        var e4 = this.utcOffset(), t5 = "+";
        return e4 < 0 && (e4 = -e4, t5 = "-"), t5 + r(~~(e4 / 60), 2) + n2 + r(~~e4 % 60, 2);
      });
    }
    Ft2("Z", ":"), Ft2("ZZ", ""), v("Z", Ye), v("ZZ", Ye), D2(["Z", "ZZ"], function(e3, t5, n2) {
      n2._useUTC = true, n2._tzm = Vt2(Ye, e3);
    });
    var Lt2 = /([\+\-]|\d\d)/gi;
    function Vt2(e3, t5) {
      var t5 = (t5 || "").match(e3);
      return null === t5 ? null : 0 === (t5 = 60 * (e3 = ((t5[t5.length - 1] || []) + "").match(Lt2) || ["-", 0, 0])[1] + g2(e3[2])) ? 0 : "+" === e3[0] ? t5 : -t5;
    }
    function Gt2(e3, t5) {
      var n2;
      return t5._isUTC ? (t5 = t5.clone(), n2 = (h2(e3) || V2(e3) ? e3 : W2(e3)).valueOf() - t5.valueOf(), t5._d.setTime(t5._d.valueOf() + n2), f2.updateOffset(t5, false), t5) : W2(e3).local();
    }
    function Et2(e3) {
      return -Math.round(e3._d.getTimezoneOffset());
    }
    function At2() {
      return !!this.isValid() && (this._isUTC && 0 === this._offset);
    }
    f2.updateOffset = function() {
    };
    var It2 = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, jt2 = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    function C2(e3, t5) {
      var n2, s3 = e3, i2 = null;
      return Ut2(e3) ? s3 = { ms: e3._milliseconds, d: e3._days, M: e3._months } : u(e3) || !isNaN(+e3) ? (s3 = {}, t5 ? s3[t5] = +e3 : s3.milliseconds = +e3) : (i2 = It2.exec(e3)) ? (n2 = "-" === i2[1] ? -1 : 1, s3 = { y: 0, d: g2(i2[b]) * n2, h: g2(i2[x2]) * n2, m: g2(i2[T]) * n2, s: g2(i2[N2]) * n2, ms: g2(Ht2(1e3 * i2[Ne])) * n2 }) : (i2 = jt2.exec(e3)) ? (n2 = "-" === i2[1] ? -1 : 1, s3 = { y: Zt2(i2[2], n2), M: Zt2(i2[3], n2), w: Zt2(i2[4], n2), d: Zt2(i2[5], n2), h: Zt2(i2[6], n2), m: Zt2(i2[7], n2), s: Zt2(i2[8], n2) }) : null == s3 ? s3 = {} : "object" == typeof s3 && ("from" in s3 || "to" in s3) && (t5 = function(e4, t6) {
        var n3;
        if (!e4.isValid() || !t6.isValid())
          return { milliseconds: 0, months: 0 };
        t6 = Gt2(t6, e4), e4.isBefore(t6) ? n3 = zt2(e4, t6) : ((n3 = zt2(t6, e4)).milliseconds = -n3.milliseconds, n3.months = -n3.months);
        return n3;
      }(W2(s3.from), W2(s3.to)), (s3 = {}).ms = t5.milliseconds, s3.M = t5.months), i2 = new Ct2(s3), Ut2(e3) && c2(e3, "_locale") && (i2._locale = e3._locale), Ut2(e3) && c2(e3, "_isValid") && (i2._isValid = e3._isValid), i2;
    }
    function Zt2(e3, t5) {
      e3 = e3 && parseFloat(e3.replace(",", "."));
      return (isNaN(e3) ? 0 : e3) * t5;
    }
    function zt2(e3, t5) {
      var n2 = {};
      return n2.months = t5.month() - e3.month() + 12 * (t5.year() - e3.year()), e3.clone().add(n2.months, "M").isAfter(t5) && --n2.months, n2.milliseconds = +t5 - +e3.clone().add(n2.months, "M"), n2;
    }
    function $t2(s3, i2) {
      return function(e3, t5) {
        var n2;
        return null === t5 || isNaN(+t5) || (Q(i2, "moment()." + i2 + "(period, number) is deprecated. Please use moment()." + i2 + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), n2 = e3, e3 = t5, t5 = n2), qt2(this, C2(e3, t5), s3), this;
      };
    }
    function qt2(e3, t5, n2, s3) {
      var i2 = t5._milliseconds, r2 = Ht2(t5._days), t5 = Ht2(t5._months);
      e3.isValid() && (s3 = null == s3 || s3, t5 && Ve2(e3, ce(e3, "Month") + t5 * n2), r2 && fe2(e3, "Date", ce(e3, "Date") + r2 * n2), i2 && e3._d.setTime(e3._d.valueOf() + i2 * n2), s3 && f2.updateOffset(e3, r2 || t5));
    }
    C2.fn = Ct2.prototype, C2.invalid = function() {
      return C2(NaN);
    };
    Ce2 = $t2(1, "add"), Je = $t2(-1, "subtract");
    function Bt2(e3) {
      return "string" == typeof e3 || e3 instanceof String;
    }
    function Jt2(e3) {
      return h2(e3) || V2(e3) || Bt2(e3) || u(e3) || function(t5) {
        var e4 = a2(t5), n2 = false;
        e4 && (n2 = 0 === t5.filter(function(e6) {
          return !u(e6) && Bt2(t5);
        }).length);
        return e4 && n2;
      }(e3) || function(e4) {
        var t5, n2, s3 = F(e4) && !L(e4), i2 = false, r2 = ["years", "year", "y", "months", "month", "M", "days", "day", "d", "dates", "date", "D", "hours", "hour", "h", "minutes", "minute", "m", "seconds", "second", "s", "milliseconds", "millisecond", "ms"], a3 = r2.length;
        for (t5 = 0; t5 < a3; t5 += 1)
          n2 = r2[t5], i2 = i2 || c2(e4, n2);
        return s3 && i2;
      }(e3) || null == e3;
    }
    function Qt2(e3, t5) {
      if (e3.date() < t5.date())
        return -Qt2(t5, e3);
      var n2 = 12 * (t5.year() - e3.year()) + (t5.month() - e3.month()), s3 = e3.clone().add(n2, "months"), t5 = t5 - s3 < 0 ? (t5 - s3) / (s3 - e3.clone().add(n2 - 1, "months")) : (t5 - s3) / (e3.clone().add(1 + n2, "months") - s3);
      return -(n2 + t5) || 0;
    }
    function Xt2(e3) {
      return void 0 === e3 ? this._locale._abbr : (null != (e3 = mt(e3)) && (this._locale = e3), this);
    }
    f2.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", f2.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    Xe = e("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(e3) {
      return void 0 === e3 ? this.localeData() : this.locale(e3);
    });
    function Kt2() {
      return this._locale;
    }
    var en2 = 126227808e5;
    function tn2(e3, t5) {
      return (e3 % t5 + t5) % t5;
    }
    function nn2(e3, t5, n2) {
      return e3 < 100 && 0 <= e3 ? new Date(e3 + 400, t5, n2) - en2 : new Date(e3, t5, n2).valueOf();
    }
    function sn2(e3, t5, n2) {
      return e3 < 100 && 0 <= e3 ? Date.UTC(e3 + 400, t5, n2) - en2 : Date.UTC(e3, t5, n2);
    }
    function rn2(e3, t5) {
      return t5.erasAbbrRegex(e3);
    }
    function an2() {
      for (var e3 = [], t5 = [], n2 = [], s3 = [], i2 = this.eras(), r2 = 0, a3 = i2.length; r2 < a3; ++r2)
        t5.push(M2(i2[r2].name)), e3.push(M2(i2[r2].abbr)), n2.push(M2(i2[r2].narrow)), s3.push(M2(i2[r2].name)), s3.push(M2(i2[r2].abbr)), s3.push(M2(i2[r2].narrow));
      this._erasRegex = new RegExp("^(" + s3.join("|") + ")", "i"), this._erasNameRegex = new RegExp("^(" + t5.join("|") + ")", "i"), this._erasAbbrRegex = new RegExp("^(" + e3.join("|") + ")", "i"), this._erasNarrowRegex = new RegExp("^(" + n2.join("|") + ")", "i");
    }
    function on2(e3, t5) {
      s2(0, [e3, e3.length], 0, t5);
    }
    function un2(e3, t5, n2, s3, i2) {
      var r2;
      return null == e3 ? qe(this, s3, i2).year : (r2 = P2(e3, s3, i2), function(e4, t6, n3, s4, i3) {
        e4 = $e(e4, t6, n3, s4, i3), t6 = Ze(e4.year, 0, e4.dayOfYear);
        return this.year(t6.getUTCFullYear()), this.month(t6.getUTCMonth()), this.date(t6.getUTCDate()), this;
      }.call(this, e3, t5 = r2 < t5 ? r2 : t5, n2, s3, i2));
    }
    s2("N", 0, 0, "eraAbbr"), s2("NN", 0, 0, "eraAbbr"), s2("NNN", 0, 0, "eraAbbr"), s2("NNNN", 0, 0, "eraName"), s2("NNNNN", 0, 0, "eraNarrow"), s2("y", ["y", 1], "yo", "eraYear"), s2("y", ["yy", 2], 0, "eraYear"), s2("y", ["yyy", 3], 0, "eraYear"), s2("y", ["yyyy", 4], 0, "eraYear"), v("N", rn2), v("NN", rn2), v("NNN", rn2), v("NNNN", function(e3, t5) {
      return t5.erasNameRegex(e3);
    }), v("NNNNN", function(e3, t5) {
      return t5.erasNarrowRegex(e3);
    }), D2(["N", "NN", "NNN", "NNNN", "NNNNN"], function(e3, t5, n2, s3) {
      s3 = n2._locale.erasParse(e3, s3, n2._strict);
      s3 ? m(n2).era = s3 : m(n2).invalidEra = e3;
    }), v("y", Me2), v("yy", Me2), v("yyy", Me2), v("yyyy", Me2), v("yo", function(e3, t5) {
      return t5._eraYearOrdinalRegex || Me2;
    }), D2(["y", "yy", "yyy", "yyyy"], Y3), D2(["yo"], function(e3, t5, n2, s3) {
      var i2;
      n2._locale._eraYearOrdinalRegex && (i2 = e3.match(n2._locale._eraYearOrdinalRegex)), n2._locale.eraYearOrdinalParse ? t5[Y3] = n2._locale.eraYearOrdinalParse(e3, i2) : t5[Y3] = parseInt(e3, 10);
    }), s2(0, ["gg", 2], 0, function() {
      return this.weekYear() % 100;
    }), s2(0, ["GG", 2], 0, function() {
      return this.isoWeekYear() % 100;
    }), on2("gggg", "weekYear"), on2("ggggg", "weekYear"), on2("GGGG", "isoWeekYear"), on2("GGGGG", "isoWeekYear"), t4("weekYear", "gg"), t4("isoWeekYear", "GG"), n("weekYear", 1), n("isoWeekYear", 1), v("G", De2), v("g", De2), v("GG", p, w2), v("gg", p, w2), v("GGGG", ke, _e), v("gggg", ke, _e), v("GGGGG", ve, ye), v("ggggg", ve, ye), Te(["gggg", "ggggg", "GGGG", "GGGGG"], function(e3, t5, n2, s3) {
      t5[s3.substr(0, 2)] = g2(e3);
    }), Te(["gg", "GG"], function(e3, t5, n2, s3) {
      t5[s3] = f2.parseTwoDigitYear(e3);
    }), s2("Q", 0, "Qo", "quarter"), t4("quarter", "Q"), n("quarter", 7), v("Q", i), D2("Q", function(e3, t5) {
      t5[O2] = 3 * (g2(e3) - 1);
    }), s2("D", ["DD", 2], "Do", "date"), t4("date", "D"), n("date", 9), v("D", p), v("DD", p, w2), v("Do", function(e3, t5) {
      return e3 ? t5._dayOfMonthOrdinalParse || t5._ordinalParse : t5._dayOfMonthOrdinalParseLenient;
    }), D2(["D", "DD"], b), D2("Do", function(e3, t5) {
      t5[b] = g2(e3.match(p)[0]);
    });
    ke = de("Date", true);
    s2("DDD", ["DDDD", 3], "DDDo", "dayOfYear"), t4("dayOfYear", "DDD"), n("dayOfYear", 4), v("DDD", pe2), v("DDDD", me), D2(["DDD", "DDDD"], function(e3, t5, n2) {
      n2._dayOfYear = g2(e3);
    }), s2("m", ["mm", 2], 0, "minute"), t4("minute", "m"), n("minute", 14), v("m", p), v("mm", p, w2), D2(["m", "mm"], T);
    var ln2, _e = de("Minutes", false), ve = (s2("s", ["ss", 2], 0, "second"), t4("second", "s"), n("second", 15), v("s", p), v("ss", p, w2), D2(["s", "ss"], N2), de("Seconds", false));
    for (s2("S", 0, 0, function() {
      return ~~(this.millisecond() / 100);
    }), s2(0, ["SS", 2], 0, function() {
      return ~~(this.millisecond() / 10);
    }), s2(0, ["SSS", 3], 0, "millisecond"), s2(0, ["SSSS", 4], 0, function() {
      return 10 * this.millisecond();
    }), s2(0, ["SSSSS", 5], 0, function() {
      return 100 * this.millisecond();
    }), s2(0, ["SSSSSS", 6], 0, function() {
      return 1e3 * this.millisecond();
    }), s2(0, ["SSSSSSS", 7], 0, function() {
      return 1e4 * this.millisecond();
    }), s2(0, ["SSSSSSSS", 8], 0, function() {
      return 1e5 * this.millisecond();
    }), s2(0, ["SSSSSSSSS", 9], 0, function() {
      return 1e6 * this.millisecond();
    }), t4("millisecond", "ms"), n("millisecond", 16), v("S", pe2, i), v("SS", pe2, w2), v("SSS", pe2, me), ln2 = "SSSS"; ln2.length <= 9; ln2 += "S")
      v(ln2, Me2);
    function hn2(e3, t5) {
      t5[Ne] = g2(1e3 * ("0." + e3));
    }
    for (ln2 = "S"; ln2.length <= 9; ln2 += "S")
      D2(ln2, hn2);
    ye = de("Milliseconds", false), s2("z", 0, 0, "zoneAbbr"), s2("zz", 0, 0, "zoneName");
    i = q.prototype;
    function dn2(e3) {
      return e3;
    }
    i.add = Ce2, i.calendar = function(e3, t5) {
      1 === arguments.length && (arguments[0] ? Jt2(arguments[0]) ? (e3 = arguments[0], t5 = void 0) : function(e4) {
        for (var t6 = F(e4) && !L(e4), n3 = false, s3 = ["sameDay", "nextDay", "lastDay", "nextWeek", "lastWeek", "sameElse"], i2 = 0; i2 < s3.length; i2 += 1)
          n3 = n3 || c2(e4, s3[i2]);
        return t6 && n3;
      }(arguments[0]) && (t5 = arguments[0], e3 = void 0) : t5 = e3 = void 0);
      var e3 = e3 || W2(), n2 = Gt2(e3, this).startOf("day"), n2 = f2.calendarFormat(this, n2) || "sameElse", t5 = t5 && (d(t5[n2]) ? t5[n2].call(this, e3) : t5[n2]);
      return this.format(t5 || this.localeData().calendar(n2, this, W2(e3)));
    }, i.clone = function() {
      return new q(this);
    }, i.diff = function(e3, t5, n2) {
      var s3, i2, r2;
      if (!this.isValid())
        return NaN;
      if (!(s3 = Gt2(e3, this)).isValid())
        return NaN;
      switch (i2 = 6e4 * (s3.utcOffset() - this.utcOffset()), t5 = _2(t5)) {
        case "year":
          r2 = Qt2(this, s3) / 12;
          break;
        case "month":
          r2 = Qt2(this, s3);
          break;
        case "quarter":
          r2 = Qt2(this, s3) / 3;
          break;
        case "second":
          r2 = (this - s3) / 1e3;
          break;
        case "minute":
          r2 = (this - s3) / 6e4;
          break;
        case "hour":
          r2 = (this - s3) / 36e5;
          break;
        case "day":
          r2 = (this - s3 - i2) / 864e5;
          break;
        case "week":
          r2 = (this - s3 - i2) / 6048e5;
          break;
        default:
          r2 = this - s3;
      }
      return n2 ? r2 : y2(r2);
    }, i.endOf = function(e3) {
      var t5, n2;
      if (void 0 === (e3 = _2(e3)) || "millisecond" === e3 || !this.isValid())
        return this;
      switch (n2 = this._isUTC ? sn2 : nn2, e3) {
        case "year":
          t5 = n2(this.year() + 1, 0, 1) - 1;
          break;
        case "quarter":
          t5 = n2(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
          break;
        case "month":
          t5 = n2(this.year(), this.month() + 1, 1) - 1;
          break;
        case "week":
          t5 = n2(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
          break;
        case "isoWeek":
          t5 = n2(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
          break;
        case "day":
        case "date":
          t5 = n2(this.year(), this.month(), this.date() + 1) - 1;
          break;
        case "hour":
          t5 = this._d.valueOf(), t5 += 36e5 - tn2(t5 + (this._isUTC ? 0 : 6e4 * this.utcOffset()), 36e5) - 1;
          break;
        case "minute":
          t5 = this._d.valueOf(), t5 += 6e4 - tn2(t5, 6e4) - 1;
          break;
        case "second":
          t5 = this._d.valueOf(), t5 += 1e3 - tn2(t5, 1e3) - 1;
          break;
      }
      return this._d.setTime(t5), f2.updateOffset(this, true), this;
    }, i.format = function(e3) {
      return e3 = e3 || (this.isUtc() ? f2.defaultFormatUtc : f2.defaultFormat), e3 = re2(this, e3), this.localeData().postformat(e3);
    }, i.from = function(e3, t5) {
      return this.isValid() && (h2(e3) && e3.isValid() || W2(e3).isValid()) ? C2({ to: this, from: e3 }).locale(this.locale()).humanize(!t5) : this.localeData().invalidDate();
    }, i.fromNow = function(e3) {
      return this.from(W2(), e3);
    }, i.to = function(e3, t5) {
      return this.isValid() && (h2(e3) && e3.isValid() || W2(e3).isValid()) ? C2({ from: this, to: e3 }).locale(this.locale()).humanize(!t5) : this.localeData().invalidDate();
    }, i.toNow = function(e3) {
      return this.to(W2(), e3);
    }, i.get = function(e3) {
      return d(this[e3 = _2(e3)]) ? this[e3]() : this;
    }, i.invalidAt = function() {
      return m(this).overflow;
    }, i.isAfter = function(e3, t5) {
      return e3 = h2(e3) ? e3 : W2(e3), !(!this.isValid() || !e3.isValid()) && ("millisecond" === (t5 = _2(t5) || "millisecond") ? this.valueOf() > e3.valueOf() : e3.valueOf() < this.clone().startOf(t5).valueOf());
    }, i.isBefore = function(e3, t5) {
      return e3 = h2(e3) ? e3 : W2(e3), !(!this.isValid() || !e3.isValid()) && ("millisecond" === (t5 = _2(t5) || "millisecond") ? this.valueOf() < e3.valueOf() : this.clone().endOf(t5).valueOf() < e3.valueOf());
    }, i.isBetween = function(e3, t5, n2, s3) {
      return e3 = h2(e3) ? e3 : W2(e3), t5 = h2(t5) ? t5 : W2(t5), !!(this.isValid() && e3.isValid() && t5.isValid()) && (("(" === (s3 = s3 || "()")[0] ? this.isAfter(e3, n2) : !this.isBefore(e3, n2)) && (")" === s3[1] ? this.isBefore(t5, n2) : !this.isAfter(t5, n2)));
    }, i.isSame = function(e3, t5) {
      var e3 = h2(e3) ? e3 : W2(e3);
      return !(!this.isValid() || !e3.isValid()) && ("millisecond" === (t5 = _2(t5) || "millisecond") ? this.valueOf() === e3.valueOf() : (e3 = e3.valueOf(), this.clone().startOf(t5).valueOf() <= e3 && e3 <= this.clone().endOf(t5).valueOf()));
    }, i.isSameOrAfter = function(e3, t5) {
      return this.isSame(e3, t5) || this.isAfter(e3, t5);
    }, i.isSameOrBefore = function(e3, t5) {
      return this.isSame(e3, t5) || this.isBefore(e3, t5);
    }, i.isValid = function() {
      return A5(this);
    }, i.lang = Xe, i.locale = Xt2, i.localeData = Kt2, i.max = we, i.min = ge2, i.parsingFlags = function() {
      return E2({}, m(this));
    }, i.set = function(e3, t5) {
      if ("object" == typeof e3)
        for (var n2 = function(e4) {
          var t6, n3 = [];
          for (t6 in e4)
            c2(e4, t6) && n3.push({ unit: t6, priority: le2[t6] });
          return n3.sort(function(e6, t7) {
            return e6.priority - t7.priority;
          }), n3;
        }(e3 = ue2(e3)), s3 = n2.length, i2 = 0; i2 < s3; i2++)
          this[n2[i2].unit](e3[n2[i2].unit]);
      else if (d(this[e3 = _2(e3)]))
        return this[e3](t5);
      return this;
    }, i.startOf = function(e3) {
      var t5, n2;
      if (void 0 === (e3 = _2(e3)) || "millisecond" === e3 || !this.isValid())
        return this;
      switch (n2 = this._isUTC ? sn2 : nn2, e3) {
        case "year":
          t5 = n2(this.year(), 0, 1);
          break;
        case "quarter":
          t5 = n2(this.year(), this.month() - this.month() % 3, 1);
          break;
        case "month":
          t5 = n2(this.year(), this.month(), 1);
          break;
        case "week":
          t5 = n2(this.year(), this.month(), this.date() - this.weekday());
          break;
        case "isoWeek":
          t5 = n2(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
          break;
        case "day":
        case "date":
          t5 = n2(this.year(), this.month(), this.date());
          break;
        case "hour":
          t5 = this._d.valueOf(), t5 -= tn2(t5 + (this._isUTC ? 0 : 6e4 * this.utcOffset()), 36e5);
          break;
        case "minute":
          t5 = this._d.valueOf(), t5 -= tn2(t5, 6e4);
          break;
        case "second":
          t5 = this._d.valueOf(), t5 -= tn2(t5, 1e3);
          break;
      }
      return this._d.setTime(t5), f2.updateOffset(this, true), this;
    }, i.subtract = Je, i.toArray = function() {
      var e3 = this;
      return [e3.year(), e3.month(), e3.date(), e3.hour(), e3.minute(), e3.second(), e3.millisecond()];
    }, i.toObject = function() {
      var e3 = this;
      return { years: e3.year(), months: e3.month(), date: e3.date(), hours: e3.hours(), minutes: e3.minutes(), seconds: e3.seconds(), milliseconds: e3.milliseconds() };
    }, i.toDate = function() {
      return new Date(this.valueOf());
    }, i.toISOString = function(e3) {
      if (!this.isValid())
        return null;
      var t5 = (e3 = true !== e3) ? this.clone().utc() : this;
      return t5.year() < 0 || 9999 < t5.year() ? re2(t5, e3 ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ") : d(Date.prototype.toISOString) ? e3 ? this.toDate().toISOString() : new Date(this.valueOf() + 60 * this.utcOffset() * 1e3).toISOString().replace("Z", re2(t5, "Z")) : re2(t5, e3 ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
    }, i.inspect = function() {
      if (!this.isValid())
        return "moment.invalid(/* " + this._i + " */)";
      var e3, t5 = "moment", n2 = "";
      return this.isLocal() || (t5 = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone", n2 = "Z"), t5 = "[" + t5 + '("]', e3 = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", this.format(t5 + e3 + "-MM-DD[T]HH:mm:ss.SSS" + (n2 + '[")]'));
    }, "undefined" != typeof Symbol && null != Symbol.for && (i[Symbol.for("nodejs.util.inspect.custom")] = function() {
      return "Moment<" + this.format() + ">";
    }), i.toJSON = function() {
      return this.isValid() ? this.toISOString() : null;
    }, i.toString = function() {
      return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
    }, i.unix = function() {
      return Math.floor(this.valueOf() / 1e3);
    }, i.valueOf = function() {
      return this._d.valueOf() - 6e4 * (this._offset || 0);
    }, i.creationData = function() {
      return { input: this._i, format: this._f, locale: this._locale, isUTC: this._isUTC, strict: this._strict };
    }, i.eraName = function() {
      for (var e3, t5 = this.localeData().eras(), n2 = 0, s3 = t5.length; n2 < s3; ++n2) {
        if (e3 = this.clone().startOf("day").valueOf(), t5[n2].since <= e3 && e3 <= t5[n2].until)
          return t5[n2].name;
        if (t5[n2].until <= e3 && e3 <= t5[n2].since)
          return t5[n2].name;
      }
      return "";
    }, i.eraNarrow = function() {
      for (var e3, t5 = this.localeData().eras(), n2 = 0, s3 = t5.length; n2 < s3; ++n2) {
        if (e3 = this.clone().startOf("day").valueOf(), t5[n2].since <= e3 && e3 <= t5[n2].until)
          return t5[n2].narrow;
        if (t5[n2].until <= e3 && e3 <= t5[n2].since)
          return t5[n2].narrow;
      }
      return "";
    }, i.eraAbbr = function() {
      for (var e3, t5 = this.localeData().eras(), n2 = 0, s3 = t5.length; n2 < s3; ++n2) {
        if (e3 = this.clone().startOf("day").valueOf(), t5[n2].since <= e3 && e3 <= t5[n2].until)
          return t5[n2].abbr;
        if (t5[n2].until <= e3 && e3 <= t5[n2].since)
          return t5[n2].abbr;
      }
      return "";
    }, i.eraYear = function() {
      for (var e3, t5, n2 = this.localeData().eras(), s3 = 0, i2 = n2.length; s3 < i2; ++s3)
        if (e3 = n2[s3].since <= n2[s3].until ? 1 : -1, t5 = this.clone().startOf("day").valueOf(), n2[s3].since <= t5 && t5 <= n2[s3].until || n2[s3].until <= t5 && t5 <= n2[s3].since)
          return (this.year() - f2(n2[s3].since).year()) * e3 + n2[s3].offset;
      return this.year();
    }, i.year = Ie, i.isLeapYear = function() {
      return he(this.year());
    }, i.weekYear = function(e3) {
      return un2.call(this, e3, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
    }, i.isoWeekYear = function(e3) {
      return un2.call(this, e3, this.isoWeek(), this.isoWeekday(), 1, 4);
    }, i.quarter = i.quarters = function(e3) {
      return null == e3 ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (e3 - 1) + this.month() % 3);
    }, i.month = Ge, i.daysInMonth = function() {
      return We(this.year(), this.month());
    }, i.week = i.weeks = function(e3) {
      var t5 = this.localeData().week(this);
      return null == e3 ? t5 : this.add(7 * (e3 - t5), "d");
    }, i.isoWeek = i.isoWeeks = function(e3) {
      var t5 = qe(this, 1, 4).week;
      return null == e3 ? t5 : this.add(7 * (e3 - t5), "d");
    }, i.weeksInYear = function() {
      var e3 = this.localeData()._week;
      return P2(this.year(), e3.dow, e3.doy);
    }, i.weeksInWeekYear = function() {
      var e3 = this.localeData()._week;
      return P2(this.weekYear(), e3.dow, e3.doy);
    }, i.isoWeeksInYear = function() {
      return P2(this.year(), 1, 4);
    }, i.isoWeeksInISOWeekYear = function() {
      return P2(this.isoWeekYear(), 1, 4);
    }, i.date = ke, i.day = i.days = function(e3) {
      if (!this.isValid())
        return null != e3 ? this : NaN;
      var t5, n2, s3 = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
      return null != e3 ? (t5 = e3, n2 = this.localeData(), e3 = "string" != typeof t5 ? t5 : isNaN(t5) ? "number" == typeof (t5 = n2.weekdaysParse(t5)) ? t5 : null : parseInt(t5, 10), this.add(e3 - s3, "d")) : s3;
    }, i.weekday = function(e3) {
      if (!this.isValid())
        return null != e3 ? this : NaN;
      var t5 = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return null == e3 ? t5 : this.add(e3 - t5, "d");
    }, i.isoWeekday = function(e3) {
      return this.isValid() ? null != e3 ? (t5 = e3, n2 = this.localeData(), n2 = "string" == typeof t5 ? n2.weekdaysParse(t5) % 7 || 7 : isNaN(t5) ? null : t5, this.day(this.day() % 7 ? n2 : n2 - 7)) : this.day() || 7 : null != e3 ? this : NaN;
      var t5, n2;
    }, i.dayOfYear = function(e3) {
      var t5 = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
      return null == e3 ? t5 : this.add(e3 - t5, "d");
    }, i.hour = i.hours = k2, i.minute = i.minutes = _e, i.second = i.seconds = ve, i.millisecond = i.milliseconds = ye, i.utcOffset = function(e3, t5, n2) {
      var s3, i2 = this._offset || 0;
      if (!this.isValid())
        return null != e3 ? this : NaN;
      if (null == e3)
        return this._isUTC ? i2 : Et2(this);
      if ("string" == typeof e3) {
        if (null === (e3 = Vt2(Ye, e3)))
          return this;
      } else
        Math.abs(e3) < 16 && !n2 && (e3 *= 60);
      return !this._isUTC && t5 && (s3 = Et2(this)), this._offset = e3, this._isUTC = true, null != s3 && this.add(s3, "m"), i2 !== e3 && (!t5 || this._changeInProgress ? qt2(this, C2(e3 - i2, "m"), 1, false) : this._changeInProgress || (this._changeInProgress = true, f2.updateOffset(this, true), this._changeInProgress = null)), this;
    }, i.utc = function(e3) {
      return this.utcOffset(0, e3);
    }, i.local = function(e3) {
      return this._isUTC && (this.utcOffset(0, e3), this._isUTC = false, e3 && this.subtract(Et2(this), "m")), this;
    }, i.parseZone = function() {
      var e3;
      return null != this._tzm ? this.utcOffset(this._tzm, false, true) : "string" == typeof this._i && (null != (e3 = Vt2(Se2, this._i)) ? this.utcOffset(e3) : this.utcOffset(0, true)), this;
    }, i.hasAlignedHourOffset = function(e3) {
      return !!this.isValid() && (e3 = e3 ? W2(e3).utcOffset() : 0, (this.utcOffset() - e3) % 60 == 0);
    }, i.isDST = function() {
      return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }, i.isLocal = function() {
      return !!this.isValid() && !this._isUTC;
    }, i.isUtcOffset = function() {
      return !!this.isValid() && this._isUTC;
    }, i.isUtc = At2, i.isUTC = At2, i.zoneAbbr = function() {
      return this._isUTC ? "UTC" : "";
    }, i.zoneName = function() {
      return this._isUTC ? "Coordinated Universal Time" : "";
    }, i.dates = e("dates accessor is deprecated. Use date instead.", ke), i.months = e("months accessor is deprecated. Use month instead", Ge), i.years = e("years accessor is deprecated. Use year instead", Ie), i.zone = e("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", function(e3, t5) {
      return null != e3 ? (this.utcOffset(e3 = "string" != typeof e3 ? -e3 : e3, t5), this) : -this.utcOffset();
    }), i.isDSTShifted = e("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", function() {
      if (!o(this._isDSTShifted))
        return this._isDSTShifted;
      var e3, t5 = {};
      return $2(t5, this), (t5 = Nt2(t5))._a ? (e3 = (t5._isUTC ? l2 : W2)(t5._a), this._isDSTShifted = this.isValid() && 0 < function(e4, t6, n2) {
        for (var s3 = Math.min(e4.length, t6.length), i2 = Math.abs(e4.length - t6.length), r2 = 0, a3 = 0; a3 < s3; a3++)
          (n2 && e4[a3] !== t6[a3] || !n2 && g2(e4[a3]) !== g2(t6[a3])) && r2++;
        return r2 + i2;
      }(t5._a, e3.toArray())) : this._isDSTShifted = false, this._isDSTShifted;
    });
    w2 = K2.prototype;
    function cn2(e3, t5, n2, s3) {
      var i2 = mt(), s3 = l2().set(s3, t5);
      return i2[n2](s3, e3);
    }
    function fn2(e3, t5, n2) {
      if (u(e3) && (t5 = e3, e3 = void 0), e3 = e3 || "", null != t5)
        return cn2(e3, t5, n2, "month");
      for (var s3 = [], i2 = 0; i2 < 12; i2++)
        s3[i2] = cn2(e3, i2, n2, "month");
      return s3;
    }
    function mn2(e3, t5, n2, s3) {
      t5 = ("boolean" == typeof e3 ? u(t5) && (n2 = t5, t5 = void 0) : (t5 = e3, e3 = false, u(n2 = t5) && (n2 = t5, t5 = void 0)), t5 || "");
      var i2, r2 = mt(), a3 = e3 ? r2._week.dow : 0, o2 = [];
      if (null != n2)
        return cn2(t5, (n2 + a3) % 7, s3, "day");
      for (i2 = 0; i2 < 7; i2++)
        o2[i2] = cn2(t5, (i2 + a3) % 7, s3, "day");
      return o2;
    }
    w2.calendar = function(e3, t5, n2) {
      return d(e3 = this._calendar[e3] || this._calendar.sameElse) ? e3.call(t5, n2) : e3;
    }, w2.longDateFormat = function(e3) {
      var t5 = this._longDateFormat[e3], n2 = this._longDateFormat[e3.toUpperCase()];
      return t5 || !n2 ? t5 : (this._longDateFormat[e3] = n2.match(te).map(function(e4) {
        return "MMMM" === e4 || "MM" === e4 || "DD" === e4 || "dddd" === e4 ? e4.slice(1) : e4;
      }).join(""), this._longDateFormat[e3]);
    }, w2.invalidDate = function() {
      return this._invalidDate;
    }, w2.ordinal = function(e3) {
      return this._ordinal.replace("%d", e3);
    }, w2.preparse = dn2, w2.postformat = dn2, w2.relativeTime = function(e3, t5, n2, s3) {
      var i2 = this._relativeTime[n2];
      return d(i2) ? i2(e3, t5, n2, s3) : i2.replace(/%d/i, e3);
    }, w2.pastFuture = function(e3, t5) {
      return d(e3 = this._relativeTime[0 < e3 ? "future" : "past"]) ? e3(t5) : e3.replace(/%s/i, t5);
    }, w2.set = function(e3) {
      var t5, n2;
      for (n2 in e3)
        c2(e3, n2) && (d(t5 = e3[n2]) ? this[n2] = t5 : this["_" + n2] = t5);
      this._config = e3, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
    }, w2.eras = function(e3, t5) {
      for (var n2, s3 = this._eras || mt("en")._eras, i2 = 0, r2 = s3.length; i2 < r2; ++i2) {
        switch (typeof s3[i2].since) {
          case "string":
            n2 = f2(s3[i2].since).startOf("day"), s3[i2].since = n2.valueOf();
            break;
        }
        switch (typeof s3[i2].until) {
          case "undefined":
            s3[i2].until = 1 / 0;
            break;
          case "string":
            n2 = f2(s3[i2].until).startOf("day").valueOf(), s3[i2].until = n2.valueOf();
            break;
        }
      }
      return s3;
    }, w2.erasParse = function(e3, t5, n2) {
      var s3, i2, r2, a3, o2, u2 = this.eras();
      for (e3 = e3.toUpperCase(), s3 = 0, i2 = u2.length; s3 < i2; ++s3)
        if (r2 = u2[s3].name.toUpperCase(), a3 = u2[s3].abbr.toUpperCase(), o2 = u2[s3].narrow.toUpperCase(), n2)
          switch (t5) {
            case "N":
            case "NN":
            case "NNN":
              if (a3 === e3)
                return u2[s3];
              break;
            case "NNNN":
              if (r2 === e3)
                return u2[s3];
              break;
            case "NNNNN":
              if (o2 === e3)
                return u2[s3];
              break;
          }
        else if (0 <= [r2, a3, o2].indexOf(e3))
          return u2[s3];
    }, w2.erasConvertYear = function(e3, t5) {
      var n2 = e3.since <= e3.until ? 1 : -1;
      return void 0 === t5 ? f2(e3.since).year() : f2(e3.since).year() + (t5 - e3.offset) * n2;
    }, w2.erasAbbrRegex = function(e3) {
      return c2(this, "_erasAbbrRegex") || an2.call(this), e3 ? this._erasAbbrRegex : this._erasRegex;
    }, w2.erasNameRegex = function(e3) {
      return c2(this, "_erasNameRegex") || an2.call(this), e3 ? this._erasNameRegex : this._erasRegex;
    }, w2.erasNarrowRegex = function(e3) {
      return c2(this, "_erasNarrowRegex") || an2.call(this), e3 ? this._erasNarrowRegex : this._erasRegex;
    }, w2.months = function(e3, t5) {
      return e3 ? (a2(this._months) ? this._months : this._months[(this._months.isFormat || He2).test(t5) ? "format" : "standalone"])[e3.month()] : a2(this._months) ? this._months : this._months.standalone;
    }, w2.monthsShort = function(e3, t5) {
      return e3 ? (a2(this._monthsShort) ? this._monthsShort : this._monthsShort[He2.test(t5) ? "format" : "standalone"])[e3.month()] : a2(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone;
    }, w2.monthsParse = function(e3, t5, n2) {
      var s3, i2;
      if (this._monthsParseExact)
        return function(e4, t6, n3) {
          var s4, i3, r2, e4 = e4.toLocaleLowerCase();
          if (!this._monthsParse)
            for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], s4 = 0; s4 < 12; ++s4)
              r2 = l2([2e3, s4]), this._shortMonthsParse[s4] = this.monthsShort(r2, "").toLocaleLowerCase(), this._longMonthsParse[s4] = this.months(r2, "").toLocaleLowerCase();
          return n3 ? "MMM" === t6 ? -1 !== (i3 = S2.call(this._shortMonthsParse, e4)) ? i3 : null : -1 !== (i3 = S2.call(this._longMonthsParse, e4)) ? i3 : null : "MMM" === t6 ? -1 !== (i3 = S2.call(this._shortMonthsParse, e4)) || -1 !== (i3 = S2.call(this._longMonthsParse, e4)) ? i3 : null : -1 !== (i3 = S2.call(this._longMonthsParse, e4)) || -1 !== (i3 = S2.call(this._shortMonthsParse, e4)) ? i3 : null;
        }.call(this, e3, t5, n2);
      for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), s3 = 0; s3 < 12; s3++) {
        if (i2 = l2([2e3, s3]), n2 && !this._longMonthsParse[s3] && (this._longMonthsParse[s3] = new RegExp("^" + this.months(i2, "").replace(".", "") + "$", "i"), this._shortMonthsParse[s3] = new RegExp("^" + this.monthsShort(i2, "").replace(".", "") + "$", "i")), n2 || this._monthsParse[s3] || (i2 = "^" + this.months(i2, "") + "|^" + this.monthsShort(i2, ""), this._monthsParse[s3] = new RegExp(i2.replace(".", ""), "i")), n2 && "MMMM" === t5 && this._longMonthsParse[s3].test(e3))
          return s3;
        if (n2 && "MMM" === t5 && this._shortMonthsParse[s3].test(e3))
          return s3;
        if (!n2 && this._monthsParse[s3].test(e3))
          return s3;
      }
    }, w2.monthsRegex = function(e3) {
      return this._monthsParseExact ? (c2(this, "_monthsRegex") || Ee2.call(this), e3 ? this._monthsStrictRegex : this._monthsRegex) : (c2(this, "_monthsRegex") || (this._monthsRegex = Le2), this._monthsStrictRegex && e3 ? this._monthsStrictRegex : this._monthsRegex);
    }, w2.monthsShortRegex = function(e3) {
      return this._monthsParseExact ? (c2(this, "_monthsRegex") || Ee2.call(this), e3 ? this._monthsShortStrictRegex : this._monthsShortRegex) : (c2(this, "_monthsShortRegex") || (this._monthsShortRegex = Fe), this._monthsShortStrictRegex && e3 ? this._monthsShortStrictRegex : this._monthsShortRegex);
    }, w2.week = function(e3) {
      return qe(e3, this._week.dow, this._week.doy).week;
    }, w2.firstDayOfYear = function() {
      return this._week.doy;
    }, w2.firstDayOfWeek = function() {
      return this._week.dow;
    }, w2.weekdays = function(e3, t5) {
      return t5 = a2(this._weekdays) ? this._weekdays : this._weekdays[e3 && true !== e3 && this._weekdays.isFormat.test(t5) ? "format" : "standalone"], true === e3 ? Be2(t5, this._week.dow) : e3 ? t5[e3.day()] : t5;
    }, w2.weekdaysMin = function(e3) {
      return true === e3 ? Be2(this._weekdaysMin, this._week.dow) : e3 ? this._weekdaysMin[e3.day()] : this._weekdaysMin;
    }, w2.weekdaysShort = function(e3) {
      return true === e3 ? Be2(this._weekdaysShort, this._week.dow) : e3 ? this._weekdaysShort[e3.day()] : this._weekdaysShort;
    }, w2.weekdaysParse = function(e3, t5, n2) {
      var s3, i2;
      if (this._weekdaysParseExact)
        return function(e4, t6, n3) {
          var s4, i3, r2, e4 = e4.toLocaleLowerCase();
          if (!this._weekdaysParse)
            for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], s4 = 0; s4 < 7; ++s4)
              r2 = l2([2e3, 1]).day(s4), this._minWeekdaysParse[s4] = this.weekdaysMin(r2, "").toLocaleLowerCase(), this._shortWeekdaysParse[s4] = this.weekdaysShort(r2, "").toLocaleLowerCase(), this._weekdaysParse[s4] = this.weekdays(r2, "").toLocaleLowerCase();
          return n3 ? "dddd" === t6 ? -1 !== (i3 = S2.call(this._weekdaysParse, e4)) ? i3 : null : "ddd" === t6 ? -1 !== (i3 = S2.call(this._shortWeekdaysParse, e4)) ? i3 : null : -1 !== (i3 = S2.call(this._minWeekdaysParse, e4)) ? i3 : null : "dddd" === t6 ? -1 !== (i3 = S2.call(this._weekdaysParse, e4)) || -1 !== (i3 = S2.call(this._shortWeekdaysParse, e4)) || -1 !== (i3 = S2.call(this._minWeekdaysParse, e4)) ? i3 : null : "ddd" === t6 ? -1 !== (i3 = S2.call(this._shortWeekdaysParse, e4)) || -1 !== (i3 = S2.call(this._weekdaysParse, e4)) || -1 !== (i3 = S2.call(this._minWeekdaysParse, e4)) ? i3 : null : -1 !== (i3 = S2.call(this._minWeekdaysParse, e4)) || -1 !== (i3 = S2.call(this._weekdaysParse, e4)) || -1 !== (i3 = S2.call(this._shortWeekdaysParse, e4)) ? i3 : null;
        }.call(this, e3, t5, n2);
      for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), s3 = 0; s3 < 7; s3++) {
        if (i2 = l2([2e3, 1]).day(s3), n2 && !this._fullWeekdaysParse[s3] && (this._fullWeekdaysParse[s3] = new RegExp("^" + this.weekdays(i2, "").replace(".", "\\.?") + "$", "i"), this._shortWeekdaysParse[s3] = new RegExp("^" + this.weekdaysShort(i2, "").replace(".", "\\.?") + "$", "i"), this._minWeekdaysParse[s3] = new RegExp("^" + this.weekdaysMin(i2, "").replace(".", "\\.?") + "$", "i")), this._weekdaysParse[s3] || (i2 = "^" + this.weekdays(i2, "") + "|^" + this.weekdaysShort(i2, "") + "|^" + this.weekdaysMin(i2, ""), this._weekdaysParse[s3] = new RegExp(i2.replace(".", ""), "i")), n2 && "dddd" === t5 && this._fullWeekdaysParse[s3].test(e3))
          return s3;
        if (n2 && "ddd" === t5 && this._shortWeekdaysParse[s3].test(e3))
          return s3;
        if (n2 && "dd" === t5 && this._minWeekdaysParse[s3].test(e3))
          return s3;
        if (!n2 && this._weekdaysParse[s3].test(e3))
          return s3;
      }
    }, w2.weekdaysRegex = function(e3) {
      return this._weekdaysParseExact ? (c2(this, "_weekdaysRegex") || nt.call(this), e3 ? this._weekdaysStrictRegex : this._weekdaysRegex) : (c2(this, "_weekdaysRegex") || (this._weekdaysRegex = Ke), this._weekdaysStrictRegex && e3 ? this._weekdaysStrictRegex : this._weekdaysRegex);
    }, w2.weekdaysShortRegex = function(e3) {
      return this._weekdaysParseExact ? (c2(this, "_weekdaysRegex") || nt.call(this), e3 ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (c2(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = et), this._weekdaysShortStrictRegex && e3 ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex);
    }, w2.weekdaysMinRegex = function(e3) {
      return this._weekdaysParseExact ? (c2(this, "_weekdaysRegex") || nt.call(this), e3 ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (c2(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = tt), this._weekdaysMinStrictRegex && e3 ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex);
    }, w2.isPM = function(e3) {
      return "p" === (e3 + "").toLowerCase().charAt(0);
    }, w2.meridiem = function(e3, t5, n2) {
      return 11 < e3 ? n2 ? "pm" : "PM" : n2 ? "am" : "AM";
    }, ct("en", { eras: [{ since: "0001-01-01", until: 1 / 0, offset: 1, name: "Anno Domini", narrow: "AD", abbr: "AD" }, { since: "0000-12-31", until: -1 / 0, offset: 1, name: "Before Christ", narrow: "BC", abbr: "BC" }], dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/, ordinal: function(e3) {
      var t5 = e3 % 10;
      return e3 + (1 === g2(e3 % 100 / 10) ? "th" : 1 == t5 ? "st" : 2 == t5 ? "nd" : 3 == t5 ? "rd" : "th");
    } }), f2.lang = e("moment.lang is deprecated. Use moment.locale instead.", ct), f2.langData = e("moment.langData is deprecated. Use moment.localeData instead.", mt);
    var _n2 = Math.abs;
    function yn2(e3, t5, n2, s3) {
      t5 = C2(t5, n2);
      return e3._milliseconds += s3 * t5._milliseconds, e3._days += s3 * t5._days, e3._months += s3 * t5._months, e3._bubble();
    }
    function gn2(e3) {
      return e3 < 0 ? Math.floor(e3) : Math.ceil(e3);
    }
    function wn2(e3) {
      return 4800 * e3 / 146097;
    }
    function pn2(e3) {
      return 146097 * e3 / 4800;
    }
    function kn2(e3) {
      return function() {
        return this.as(e3);
      };
    }
    pe2 = kn2("ms"), me = kn2("s"), Ce2 = kn2("m"), we = kn2("h"), ge2 = kn2("d"), Je = kn2("w"), k2 = kn2("M"), _e = kn2("Q"), ve = kn2("y");
    function vn2(e3) {
      return function() {
        return this.isValid() ? this._data[e3] : NaN;
      };
    }
    var ye = vn2("milliseconds"), ke = vn2("seconds"), Ie = vn2("minutes"), w2 = vn2("hours"), Mn2 = vn2("days"), Dn2 = vn2("months"), Sn2 = vn2("years");
    var Yn2 = Math.round, On2 = { ss: 44, s: 45, m: 45, h: 22, d: 26, w: null, M: 11 };
    function bn2(e3, t5, n2, s3) {
      var i2 = C2(e3).abs(), r2 = Yn2(i2.as("s")), a3 = Yn2(i2.as("m")), o2 = Yn2(i2.as("h")), u2 = Yn2(i2.as("d")), l3 = Yn2(i2.as("M")), h3 = Yn2(i2.as("w")), i2 = Yn2(i2.as("y")), r2 = (r2 <= n2.ss ? ["s", r2] : r2 < n2.s && ["ss", r2]) || a3 <= 1 && ["m"] || a3 < n2.m && ["mm", a3] || o2 <= 1 && ["h"] || o2 < n2.h && ["hh", o2] || u2 <= 1 && ["d"] || u2 < n2.d && ["dd", u2];
      return (r2 = (r2 = null != n2.w ? r2 || h3 <= 1 && ["w"] || h3 < n2.w && ["ww", h3] : r2) || l3 <= 1 && ["M"] || l3 < n2.M && ["MM", l3] || i2 <= 1 && ["y"] || ["yy", i2])[2] = t5, r2[3] = 0 < +e3, r2[4] = s3, function(e4, t6, n3, s4, i3) {
        return i3.relativeTime(t6 || 1, !!n3, e4, s4);
      }.apply(null, r2);
    }
    var xn2 = Math.abs;
    function Tn2(e3) {
      return (0 < e3) - (e3 < 0) || +e3;
    }
    function Nn2() {
      if (!this.isValid())
        return this.localeData().invalidDate();
      var e3, t5, n2, s3, i2, r2, a3, o2 = xn2(this._milliseconds) / 1e3, u2 = xn2(this._days), l3 = xn2(this._months), h3 = this.asSeconds();
      return h3 ? (e3 = y2(o2 / 60), t5 = y2(e3 / 60), o2 %= 60, e3 %= 60, n2 = y2(l3 / 12), l3 %= 12, s3 = o2 ? o2.toFixed(3).replace(/\.?0+$/, "") : "", i2 = Tn2(this._months) !== Tn2(h3) ? "-" : "", r2 = Tn2(this._days) !== Tn2(h3) ? "-" : "", a3 = Tn2(this._milliseconds) !== Tn2(h3) ? "-" : "", (h3 < 0 ? "-" : "") + "P" + (n2 ? i2 + n2 + "Y" : "") + (l3 ? i2 + l3 + "M" : "") + (u2 ? r2 + u2 + "D" : "") + (t5 || e3 || o2 ? "T" : "") + (t5 ? a3 + t5 + "H" : "") + (e3 ? a3 + e3 + "M" : "") + (o2 ? a3 + s3 + "S" : "")) : "P0D";
    }
    var U = Ct2.prototype;
    return U.isValid = function() {
      return this._isValid;
    }, U.abs = function() {
      var e3 = this._data;
      return this._milliseconds = _n2(this._milliseconds), this._days = _n2(this._days), this._months = _n2(this._months), e3.milliseconds = _n2(e3.milliseconds), e3.seconds = _n2(e3.seconds), e3.minutes = _n2(e3.minutes), e3.hours = _n2(e3.hours), e3.months = _n2(e3.months), e3.years = _n2(e3.years), this;
    }, U.add = function(e3, t5) {
      return yn2(this, e3, t5, 1);
    }, U.subtract = function(e3, t5) {
      return yn2(this, e3, t5, -1);
    }, U.as = function(e3) {
      if (!this.isValid())
        return NaN;
      var t5, n2, s3 = this._milliseconds;
      if ("month" === (e3 = _2(e3)) || "quarter" === e3 || "year" === e3)
        switch (t5 = this._days + s3 / 864e5, n2 = this._months + wn2(t5), e3) {
          case "month":
            return n2;
          case "quarter":
            return n2 / 3;
          case "year":
            return n2 / 12;
        }
      else
        switch (t5 = this._days + Math.round(pn2(this._months)), e3) {
          case "week":
            return t5 / 7 + s3 / 6048e5;
          case "day":
            return t5 + s3 / 864e5;
          case "hour":
            return 24 * t5 + s3 / 36e5;
          case "minute":
            return 1440 * t5 + s3 / 6e4;
          case "second":
            return 86400 * t5 + s3 / 1e3;
          case "millisecond":
            return Math.floor(864e5 * t5) + s3;
          default:
            throw new Error("Unknown unit " + e3);
        }
    }, U.asMilliseconds = pe2, U.asSeconds = me, U.asMinutes = Ce2, U.asHours = we, U.asDays = ge2, U.asWeeks = Je, U.asMonths = k2, U.asQuarters = _e, U.asYears = ve, U.valueOf = function() {
      return this.isValid() ? this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * g2(this._months / 12) : NaN;
    }, U._bubble = function() {
      var e3 = this._milliseconds, t5 = this._days, n2 = this._months, s3 = this._data;
      return 0 <= e3 && 0 <= t5 && 0 <= n2 || e3 <= 0 && t5 <= 0 && n2 <= 0 || (e3 += 864e5 * gn2(pn2(n2) + t5), n2 = t5 = 0), s3.milliseconds = e3 % 1e3, e3 = y2(e3 / 1e3), s3.seconds = e3 % 60, e3 = y2(e3 / 60), s3.minutes = e3 % 60, e3 = y2(e3 / 60), s3.hours = e3 % 24, t5 += y2(e3 / 24), n2 += e3 = y2(wn2(t5)), t5 -= gn2(pn2(e3)), e3 = y2(n2 / 12), n2 %= 12, s3.days = t5, s3.months = n2, s3.years = e3, this;
    }, U.clone = function() {
      return C2(this);
    }, U.get = function(e3) {
      return e3 = _2(e3), this.isValid() ? this[e3 + "s"]() : NaN;
    }, U.milliseconds = ye, U.seconds = ke, U.minutes = Ie, U.hours = w2, U.days = Mn2, U.weeks = function() {
      return y2(this.days() / 7);
    }, U.months = Dn2, U.years = Sn2, U.humanize = function(e3, t5) {
      if (!this.isValid())
        return this.localeData().invalidDate();
      var n2 = false, s3 = On2;
      return "object" == typeof e3 && (t5 = e3, e3 = false), "boolean" == typeof e3 && (n2 = e3), "object" == typeof t5 && (s3 = Object.assign({}, On2, t5), null != t5.s && null == t5.ss && (s3.ss = t5.s - 1)), e3 = this.localeData(), t5 = bn2(this, !n2, s3, e3), n2 && (t5 = e3.pastFuture(+this, t5)), e3.postformat(t5);
    }, U.toISOString = Nn2, U.toString = Nn2, U.toJSON = Nn2, U.locale = Xt2, U.localeData = Kt2, U.toIsoString = e("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", Nn2), U.lang = Xe, s2("X", 0, 0, "unix"), s2("x", 0, 0, "valueOf"), v("x", De2), v("X", /[+-]?\d+(\.\d{1,3})?/), D2("X", function(e3, t5, n2) {
      n2._d = new Date(1e3 * parseFloat(e3));
    }), D2("x", function(e3, t5, n2) {
      n2._d = new Date(g2(e3));
    }), f2.version = "2.29.4", H2 = W2, f2.fn = i, f2.min = function() {
      return Rt2("isBefore", [].slice.call(arguments, 0));
    }, f2.max = function() {
      return Rt2("isAfter", [].slice.call(arguments, 0));
    }, f2.now = function() {
      return Date.now ? Date.now() : +new Date();
    }, f2.utc = l2, f2.unix = function(e3) {
      return W2(1e3 * e3);
    }, f2.months = function(e3, t5) {
      return fn2(e3, t5, "months");
    }, f2.isDate = V2, f2.locale = ct, f2.invalid = I, f2.duration = C2, f2.isMoment = h2, f2.weekdays = function(e3, t5, n2) {
      return mn2(e3, t5, n2, "weekdays");
    }, f2.parseZone = function() {
      return W2.apply(null, arguments).parseZone();
    }, f2.localeData = mt, f2.isDuration = Ut2, f2.monthsShort = function(e3, t5) {
      return fn2(e3, t5, "monthsShort");
    }, f2.weekdaysMin = function(e3, t5, n2) {
      return mn2(e3, t5, n2, "weekdaysMin");
    }, f2.defineLocale = ft, f2.updateLocale = function(e3, t5) {
      var n2, s3;
      return null != t5 ? (s3 = ot, null != R[e3] && null != R[e3].parentLocale ? R[e3].set(X3(R[e3]._config, t5)) : (t5 = X3(s3 = null != (n2 = dt(e3)) ? n2._config : s3, t5), null == n2 && (t5.abbr = e3), (s3 = new K2(t5)).parentLocale = R[e3], R[e3] = s3), ct(e3)) : null != R[e3] && (null != R[e3].parentLocale ? (R[e3] = R[e3].parentLocale, e3 === ct() && ct(e3)) : null != R[e3] && delete R[e3]), R[e3];
    }, f2.locales = function() {
      return ee(R);
    }, f2.weekdaysShort = function(e3, t5, n2) {
      return mn2(e3, t5, n2, "weekdaysShort");
    }, f2.normalizeUnits = _2, f2.relativeTimeRounding = function(e3) {
      return void 0 === e3 ? Yn2 : "function" == typeof e3 && (Yn2 = e3, true);
    }, f2.relativeTimeThreshold = function(e3, t5) {
      return void 0 !== On2[e3] && (void 0 === t5 ? On2[e3] : (On2[e3] = t5, "s" === e3 && (On2.ss = t5 - 1), true));
    }, f2.calendarFormat = function(e3, t5) {
      return (e3 = e3.diff(t5, "days", true)) < -6 ? "sameElse" : e3 < -1 ? "lastWeek" : e3 < 0 ? "lastDay" : e3 < 1 ? "sameDay" : e3 < 2 ? "nextDay" : e3 < 7 ? "nextWeek" : "sameElse";
    }, f2.prototype = i, f2.HTML5_FMT = { DATETIME_LOCAL: "YYYY-MM-DDTHH:mm", DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss", DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS", DATE: "YYYY-MM-DD", TIME: "HH:mm", TIME_SECONDS: "HH:mm:ss", TIME_MS: "HH:mm:ss.SSS", WEEK: "GGGG-[W]WW", MONTH: "YYYY-MM" }, f2;
  });
})(moment_min);
const moment = moment_min.exports;
var dist = {};
Object.defineProperty(dist, "__esModule", { value: true });
var sanitizeUrl_1 = dist.sanitizeUrl = void 0;
var invalidProtocolRegex = /^([^\w]*)(javascript|data|vbscript)/im;
var htmlEntitiesRegex = /&#(\w+)(^\w|;)?/g;
var htmlTabEntityRegex = /&tab;/gi;
var ctrlCharactersRegex = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim;
var urlSchemeRegex = /^.+(:|&colon;)/gim;
var relativeFirstCharacters = [".", "/"];
function isRelativeUrlWithoutProtocol(url) {
  return relativeFirstCharacters.indexOf(url[0]) > -1;
}
function decodeHtmlCharacters(str) {
  str = str.replace(htmlTabEntityRegex, "&#9;");
  return str.replace(htmlEntitiesRegex, function(match, dec2) {
    return String.fromCharCode(dec2);
  });
}
function sanitizeUrl(url) {
  var sanitizedUrl = decodeHtmlCharacters(url || "").replace(ctrlCharactersRegex, "").trim();
  if (!sanitizedUrl) {
    return "about:blank";
  }
  if (isRelativeUrlWithoutProtocol(sanitizedUrl)) {
    return sanitizedUrl;
  }
  var urlSchemeParseResults = sanitizedUrl.match(urlSchemeRegex);
  if (!urlSchemeParseResults) {
    return sanitizedUrl;
  }
  var urlScheme = urlSchemeParseResults[0];
  if (invalidProtocolRegex.test(urlScheme)) {
    return "about:blank";
  }
  return sanitizedUrl;
}
sanitizeUrl_1 = dist.sanitizeUrl = sanitizeUrl;
function max$4(values2, valueof) {
  let max2;
  if (valueof === void 0) {
    for (const value of values2) {
      if (value != null && (max2 < value || max2 === void 0 && value >= value)) {
        max2 = value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof(value, ++index2, values2)) != null && (max2 < value || max2 === void 0 && value >= value)) {
        max2 = value;
      }
    }
  }
  return max2;
}
function min$3(values2, valueof) {
  let min2;
  if (valueof === void 0) {
    for (const value of values2) {
      if (value != null && (min2 > value || min2 === void 0 && value >= value)) {
        min2 = value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values2) {
      if ((value = valueof(value, ++index2, values2)) != null && (min2 > value || min2 === void 0 && value >= value)) {
        min2 = value;
      }
    }
  }
  return min2;
}
function identity$d(x2) {
  return x2;
}
var top$1 = 1, right$1 = 2, bottom$1 = 3, left$1 = 4, epsilon$7 = 1e-6;
function translateX$1(x2) {
  return "translate(" + x2 + ",0)";
}
function translateY$1(y2) {
  return "translate(0," + y2 + ")";
}
function number$7(scale) {
  return (d) => +scale(d);
}
function center$2(scale, offset) {
  offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;
  if (scale.round())
    offset = Math.round(offset);
  return (d) => +scale(d) + offset;
}
function entering$1() {
  return !this.__axis;
}
function axis$1(orient, scale) {
  var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5, k2 = orient === top$1 || orient === left$1 ? -1 : 1, x2 = orient === left$1 || orient === right$1 ? "x" : "y", transform2 = orient === top$1 || orient === bottom$1 ? translateX$1 : translateY$1;
  function axis2(context) {
    var values2 = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues, format2 = tickFormat2 == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$d : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range2 = scale.range(), range0 = +range2[0] + offset, range1 = +range2[range2.length - 1] + offset, position2 = (scale.bandwidth ? center$2 : number$7)(scale.copy(), offset), selection2 = context.selection ? context.selection() : context, path2 = selection2.selectAll(".domain").data([null]), tick = selection2.selectAll(".tick").data(values2, scale).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line2 = tick.select("line"), text2 = tick.select("text");
    path2 = path2.merge(path2.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
    tick = tick.merge(tickEnter);
    line2 = line2.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x2 + "2", k2 * tickSizeInner));
    text2 = text2.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x2, k2 * spacing).attr("dy", orient === top$1 ? "0em" : orient === bottom$1 ? "0.71em" : "0.32em"));
    if (context !== selection2) {
      path2 = path2.transition(context);
      tick = tick.transition(context);
      line2 = line2.transition(context);
      text2 = text2.transition(context);
      tickExit = tickExit.transition(context).attr("opacity", epsilon$7).attr("transform", function(d) {
        return isFinite(d = position2(d)) ? transform2(d + offset) : this.getAttribute("transform");
      });
      tickEnter.attr("opacity", epsilon$7).attr("transform", function(d) {
        var p = this.parentNode.__axis;
        return transform2((p && isFinite(p = p(d)) ? p : position2(d)) + offset);
      });
    }
    tickExit.remove();
    path2.attr("d", orient === left$1 || orient === right$1 ? tickSizeOuter ? "M" + k2 * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k2 * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k2 * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k2 * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1);
    tick.attr("opacity", 1).attr("transform", function(d) {
      return transform2(position2(d) + offset);
    });
    line2.attr(x2 + "2", k2 * tickSizeInner);
    text2.attr(x2, k2 * spacing).text(format2);
    selection2.filter(entering$1).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right$1 ? "start" : orient === left$1 ? "end" : "middle");
    selection2.each(function() {
      this.__axis = position2;
    });
  }
  axis2.scale = function(_2) {
    return arguments.length ? (scale = _2, axis2) : scale;
  };
  axis2.ticks = function() {
    return tickArguments = Array.from(arguments), axis2;
  };
  axis2.tickArguments = function(_2) {
    return arguments.length ? (tickArguments = _2 == null ? [] : Array.from(_2), axis2) : tickArguments.slice();
  };
  axis2.tickValues = function(_2) {
    return arguments.length ? (tickValues = _2 == null ? null : Array.from(_2), axis2) : tickValues && tickValues.slice();
  };
  axis2.tickFormat = function(_2) {
    return arguments.length ? (tickFormat2 = _2, axis2) : tickFormat2;
  };
  axis2.tickSize = function(_2) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_2, axis2) : tickSizeInner;
  };
  axis2.tickSizeInner = function(_2) {
    return arguments.length ? (tickSizeInner = +_2, axis2) : tickSizeInner;
  };
  axis2.tickSizeOuter = function(_2) {
    return arguments.length ? (tickSizeOuter = +_2, axis2) : tickSizeOuter;
  };
  axis2.tickPadding = function(_2) {
    return arguments.length ? (tickPadding = +_2, axis2) : tickPadding;
  };
  axis2.offset = function(_2) {
    return arguments.length ? (offset = +_2, axis2) : offset;
  };
  return axis2;
}
function axisTop$1(scale) {
  return axis$1(top$1, scale);
}
function axisBottom$1(scale) {
  return axis$1(bottom$1, scale);
}
function selectAll$1(selector2) {
  return typeof selector2 === "string" ? new Selection$2([document.querySelectorAll(selector2)], [document.documentElement]) : new Selection$2([array$5(selector2)], root$5);
}
const radians$1 = Math.PI / 180;
const degrees$2 = 180 / Math.PI;
const K$1 = 18, Xn$1 = 0.96422, Yn$1 = 1, Zn$1 = 0.82521, t0$3 = 4 / 29, t1$3 = 6 / 29, t2$1 = 3 * t1$3 * t1$3, t3$1 = t1$3 * t1$3 * t1$3;
function labConvert$1(o) {
  if (o instanceof Lab$1)
    return new Lab$1(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl$1)
    return hcl2lab$1(o);
  if (!(o instanceof Rgb$1))
    o = rgbConvert$1(o);
  var r = rgb2lrgb$1(o.r), g2 = rgb2lrgb$1(o.g), b = rgb2lrgb$1(o.b), y2 = xyz2lab$1((0.2225045 * r + 0.7168786 * g2 + 0.0606169 * b) / Yn$1), x2, z;
  if (r === g2 && g2 === b)
    x2 = z = y2;
  else {
    x2 = xyz2lab$1((0.4360747 * r + 0.3850649 * g2 + 0.1430804 * b) / Xn$1);
    z = xyz2lab$1((0.0139322 * r + 0.0971045 * g2 + 0.7141733 * b) / Zn$1);
  }
  return new Lab$1(116 * y2 - 16, 500 * (x2 - y2), 200 * (y2 - z), o.opacity);
}
function lab$2(l2, a2, b, opacity) {
  return arguments.length === 1 ? labConvert$1(l2) : new Lab$1(l2, a2, b, opacity == null ? 1 : opacity);
}
function Lab$1(l2, a2, b, opacity) {
  this.l = +l2;
  this.a = +a2;
  this.b = +b;
  this.opacity = +opacity;
}
define$1(Lab$1, lab$2, extend$2(Color$3, {
  brighter(k2) {
    return new Lab$1(this.l + K$1 * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  darker(k2) {
    return new Lab$1(this.l - K$1 * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  rgb() {
    var y2 = (this.l + 16) / 116, x2 = isNaN(this.a) ? y2 : y2 + this.a / 500, z = isNaN(this.b) ? y2 : y2 - this.b / 200;
    x2 = Xn$1 * lab2xyz$1(x2);
    y2 = Yn$1 * lab2xyz$1(y2);
    z = Zn$1 * lab2xyz$1(z);
    return new Rgb$1(
      lrgb2rgb$1(3.1338561 * x2 - 1.6168667 * y2 - 0.4906146 * z),
      lrgb2rgb$1(-0.9787684 * x2 + 1.9161415 * y2 + 0.033454 * z),
      lrgb2rgb$1(0.0719453 * x2 - 0.2289914 * y2 + 1.4052427 * z),
      this.opacity
    );
  }
}));
function xyz2lab$1(t4) {
  return t4 > t3$1 ? Math.pow(t4, 1 / 3) : t4 / t2$1 + t0$3;
}
function lab2xyz$1(t4) {
  return t4 > t1$3 ? t4 * t4 * t4 : t2$1 * (t4 - t0$3);
}
function lrgb2rgb$1(x2) {
  return 255 * (x2 <= 31308e-7 ? 12.92 * x2 : 1.055 * Math.pow(x2, 1 / 2.4) - 0.055);
}
function rgb2lrgb$1(x2) {
  return (x2 /= 255) <= 0.04045 ? x2 / 12.92 : Math.pow((x2 + 0.055) / 1.055, 2.4);
}
function hclConvert$1(o) {
  if (o instanceof Hcl$1)
    return new Hcl$1(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab$1))
    o = labConvert$1(o);
  if (o.a === 0 && o.b === 0)
    return new Hcl$1(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h2 = Math.atan2(o.b, o.a) * degrees$2;
  return new Hcl$1(h2 < 0 ? h2 + 360 : h2, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl$4(h2, c2, l2, opacity) {
  return arguments.length === 1 ? hclConvert$1(h2) : new Hcl$1(h2, c2, l2, opacity == null ? 1 : opacity);
}
function Hcl$1(h2, c2, l2, opacity) {
  this.h = +h2;
  this.c = +c2;
  this.l = +l2;
  this.opacity = +opacity;
}
function hcl2lab$1(o) {
  if (isNaN(o.h))
    return new Lab$1(o.l, 0, 0, o.opacity);
  var h2 = o.h * radians$1;
  return new Lab$1(o.l, Math.cos(h2) * o.c, Math.sin(h2) * o.c, o.opacity);
}
define$1(Hcl$1, hcl$4, extend$2(Color$3, {
  brighter(k2) {
    return new Hcl$1(this.h, this.c, this.l + K$1 * (k2 == null ? 1 : k2), this.opacity);
  },
  darker(k2) {
    return new Hcl$1(this.h, this.c, this.l - K$1 * (k2 == null ? 1 : k2), this.opacity);
  },
  rgb() {
    return hcl2lab$1(this).rgb();
  }
}));
function numberArray$1(a2, b) {
  if (!b)
    b = [];
  var n = a2 ? Math.min(b.length, a2.length) : 0, c2 = b.slice(), i;
  return function(t4) {
    for (i = 0; i < n; ++i)
      c2[i] = a2[i] * (1 - t4) + b[i] * t4;
    return c2;
  };
}
function isNumberArray$1(x2) {
  return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
}
function genericArray$1(a2, b) {
  var nb = b ? b.length : 0, na = a2 ? Math.min(nb, a2.length) : 0, x2 = new Array(na), c2 = new Array(nb), i;
  for (i = 0; i < na; ++i)
    x2[i] = interpolate$2(a2[i], b[i]);
  for (; i < nb; ++i)
    c2[i] = b[i];
  return function(t4) {
    for (i = 0; i < na; ++i)
      c2[i] = x2[i](t4);
    return c2;
  };
}
function date$3(a2, b) {
  var d = new Date();
  return a2 = +a2, b = +b, function(t4) {
    return d.setTime(a2 * (1 - t4) + b * t4), d;
  };
}
function object$2(a2, b) {
  var i = {}, c2 = {}, k2;
  if (a2 === null || typeof a2 !== "object")
    a2 = {};
  if (b === null || typeof b !== "object")
    b = {};
  for (k2 in b) {
    if (k2 in a2) {
      i[k2] = interpolate$2(a2[k2], b[k2]);
    } else {
      c2[k2] = b[k2];
    }
  }
  return function(t4) {
    for (k2 in i)
      c2[k2] = i[k2](t4);
    return c2;
  };
}
function interpolate$2(a2, b) {
  var t4 = typeof b, c2;
  return b == null || t4 === "boolean" ? constant$f(b) : (t4 === "number" ? interpolateNumber$1 : t4 === "string" ? (c2 = color$1(b)) ? (b = c2, interpolateRgb$1) : interpolateString$1 : b instanceof color$1 ? interpolateRgb$1 : b instanceof Date ? date$3 : isNumberArray$1(b) ? numberArray$1 : Array.isArray(b) ? genericArray$1 : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object$2 : interpolateNumber$1)(a2, b);
}
function interpolateRound$1(a2, b) {
  return a2 = +a2, b = +b, function(t4) {
    return Math.round(a2 * (1 - t4) + b * t4);
  };
}
function hcl$3(hue2) {
  return function(start2, end2) {
    var h2 = hue2((start2 = hcl$4(start2)).h, (end2 = hcl$4(end2)).h), c2 = nogamma$1(start2.c, end2.c), l2 = nogamma$1(start2.l, end2.l), opacity = nogamma$1(start2.opacity, end2.opacity);
    return function(t4) {
      start2.h = h2(t4);
      start2.c = c2(t4);
      start2.l = l2(t4);
      start2.opacity = opacity(t4);
      return start2 + "";
    };
  };
}
const interpolateHcl = hcl$3(hue$2);
const pi$6 = Math.PI, tau$6 = 2 * pi$6, epsilon$6 = 1e-6, tauEpsilon$1 = tau$6 - epsilon$6;
function Path$1() {
  this._x0 = this._y0 = this._x1 = this._y1 = null;
  this._ = "";
}
function path$1() {
  return new Path$1();
}
Path$1.prototype = path$1.prototype = {
  constructor: Path$1,
  moveTo: function(x2, y2) {
    this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x2, y2) {
    this._ += "L" + (this._x1 = +x2) + "," + (this._y1 = +y2);
  },
  quadraticCurveTo: function(x12, y12, x2, y2) {
    this._ += "Q" + +x12 + "," + +y12 + "," + (this._x1 = +x2) + "," + (this._y1 = +y2);
  },
  bezierCurveTo: function(x12, y12, x2, y2, x3, y3) {
    this._ += "C" + +x12 + "," + +y12 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x3) + "," + (this._y1 = +y3);
  },
  arcTo: function(x12, y12, x2, y2, r) {
    x12 = +x12, y12 = +y12, x2 = +x2, y2 = +y2, r = +r;
    var x02 = this._x1, y02 = this._y1, x21 = x2 - x12, y21 = y2 - y12, x01 = x02 - x12, y01 = y02 - y12, l01_2 = x01 * x01 + y01 * y01;
    if (r < 0)
      throw new Error("negative radius: " + r);
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x12) + "," + (this._y1 = y12);
    } else if (!(l01_2 > epsilon$6))
      ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$6) || !r) {
      this._ += "L" + (this._x1 = x12) + "," + (this._y1 = y12);
    } else {
      var x20 = x2 - x02, y20 = y2 - y02, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l2 = r * Math.tan((pi$6 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l2 / l01, t21 = l2 / l21;
      if (Math.abs(t01 - 1) > epsilon$6) {
        this._ += "L" + (x12 + t01 * x01) + "," + (y12 + t01 * y01);
      }
      this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x12 + t21 * x21) + "," + (this._y1 = y12 + t21 * y21);
    }
  },
  arc: function(x2, y2, r, a0, a1, ccw) {
    x2 = +x2, y2 = +y2, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0), dy = r * Math.sin(a0), x02 = x2 + dx, y02 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (r < 0)
      throw new Error("negative radius: " + r);
    if (this._x1 === null) {
      this._ += "M" + x02 + "," + y02;
    } else if (Math.abs(this._x1 - x02) > epsilon$6 || Math.abs(this._y1 - y02) > epsilon$6) {
      this._ += "L" + x02 + "," + y02;
    }
    if (!r)
      return;
    if (da < 0)
      da = da % tau$6 + tau$6;
    if (da > tauEpsilon$1) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x2 - dx) + "," + (y2 - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x02) + "," + (this._y1 = y02);
    } else if (da > epsilon$6) {
      this._ += "A" + r + "," + r + ",0," + +(da >= pi$6) + "," + cw + "," + (this._x1 = x2 + r * Math.cos(a1)) + "," + (this._y1 = y2 + r * Math.sin(a1));
    }
  },
  rect: function(x2, y2, w2, h2) {
    this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2) + "h" + +w2 + "v" + +h2 + "h" + -w2 + "Z";
  },
  toString: function() {
    return this._;
  }
};
function formatDecimal$1(x2) {
  return Math.abs(x2 = Math.round(x2)) >= 1e21 ? x2.toLocaleString("en").replace(/,/g, "") : x2.toString(10);
}
function formatDecimalParts$1(x2, p) {
  if ((i = (x2 = p ? x2.toExponential(p - 1) : x2.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x2.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x2.slice(i + 1)
  ];
}
function exponent$2(x2) {
  return x2 = formatDecimalParts$1(Math.abs(x2)), x2 ? x2[1] : NaN;
}
function formatGroup$1(grouping, thousands) {
  return function(value, width2) {
    var i = value.length, t4 = [], j2 = 0, g2 = grouping[0], length2 = 0;
    while (i > 0 && g2 > 0) {
      if (length2 + g2 + 1 > width2)
        g2 = Math.max(1, width2 - length2);
      t4.push(value.substring(i -= g2, i + g2));
      if ((length2 += g2 + 1) > width2)
        break;
      g2 = grouping[j2 = (j2 + 1) % grouping.length];
    }
    return t4.reverse().join(thousands);
  };
}
function formatNumerals$1(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}
var re$1 = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier$1(specifier) {
  if (!(match = re$1.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier$1({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier$1.prototype = FormatSpecifier$1.prototype;
function FormatSpecifier$1(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier$1.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function formatTrim$1(s2) {
  out:
    for (var n = s2.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s2[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s2[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
}
var prefixExponent$1;
function formatPrefixAuto$1(x2, p) {
  var d = formatDecimalParts$1(x2, p);
  if (!d)
    return x2 + "";
  var coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent$1 = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts$1(x2, Math.max(0, p + i - 1))[0];
}
function formatRounded$1(x2, p) {
  var d = formatDecimalParts$1(x2, p);
  if (!d)
    return x2 + "";
  var coefficient = d[0], exponent2 = d[1];
  return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
}
const formatTypes$1 = {
  "%": (x2, p) => (x2 * 100).toFixed(p),
  "b": (x2) => Math.round(x2).toString(2),
  "c": (x2) => x2 + "",
  "d": formatDecimal$1,
  "e": (x2, p) => x2.toExponential(p),
  "f": (x2, p) => x2.toFixed(p),
  "g": (x2, p) => x2.toPrecision(p),
  "o": (x2) => Math.round(x2).toString(8),
  "p": (x2, p) => formatRounded$1(x2 * 100, p),
  "r": formatRounded$1,
  "s": formatPrefixAuto$1,
  "X": (x2) => Math.round(x2).toString(16).toUpperCase(),
  "x": (x2) => Math.round(x2).toString(16)
};
function identity$c(x2) {
  return x2;
}
var map$4 = Array.prototype.map, prefixes$1 = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function formatLocale$3(locale2) {
  var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity$c : formatGroup$1(map$4.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity$c : formatNumerals$1(map$4.call(locale2.numerals, String)), percent2 = locale2.percent === void 0 ? "%" : locale2.percent + "", minus2 = locale2.minus === void 0 ? "\u2212" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier$1(specifier);
    var fill = specifier.fill, align = specifier.align, sign2 = specifier.sign, symbol2 = specifier.symbol, zero2 = specifier.zero, width2 = specifier.width, comma = specifier.comma, precision = specifier.precision, trim2 = specifier.trim, type2 = specifier.type;
    if (type2 === "n")
      comma = true, type2 = "g";
    else if (!formatTypes$1[type2])
      precision === void 0 && (precision = 12), trim2 = true, type2 = "g";
    if (zero2 || fill === "0" && align === "=")
      zero2 = true, fill = "0", align = "=";
    var prefix2 = symbol2 === "$" ? currencyPrefix : symbol2 === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol2 === "$" ? currencySuffix : /[%p]/.test(type2) ? percent2 : "";
    var formatType = formatTypes$1[type2], maybeSuffix = /[defgprs%]/.test(type2);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix2, valueSuffix = suffix, i, n, c2;
      if (type2 === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim2)
          value = formatTrim$1(value);
        if (valueNegative && +value === 0 && sign2 !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign2 === "(" ? sign2 : minus2 : sign2 === "-" || sign2 === "(" ? "" : sign2) + valuePrefix;
        valueSuffix = (type2 === "s" ? prefixes$1[8 + prefixExponent$1 / 3] : "") + valueSuffix + (valueNegative && sign2 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c2 = value.charCodeAt(i), 48 > c2 || c2 > 57) {
              valueSuffix = (c2 === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero2)
        value = group(value, Infinity);
      var length2 = valuePrefix.length + value.length + valueSuffix.length, padding2 = length2 < width2 ? new Array(width2 - length2 + 1).join(fill) : "";
      if (comma && zero2)
        value = group(padding2 + value, padding2.length ? width2 - valueSuffix.length : Infinity), padding2 = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding2;
          break;
        case "=":
          value = valuePrefix + padding2 + value + valueSuffix;
          break;
        case "^":
          value = padding2.slice(0, length2 = padding2.length >> 1) + valuePrefix + value + valueSuffix + padding2.slice(length2);
          break;
        default:
          value = padding2 + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var f2 = newFormat((specifier = formatSpecifier$1(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent$2(value) / 3))) * 3, k2 = Math.pow(10, -e), prefix2 = prefixes$1[8 + e / 3];
    return function(value2) {
      return f2(k2 * value2) + prefix2;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}
var locale$3;
var format$2;
var formatPrefix$1;
defaultLocale$3({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale$3(definition) {
  locale$3 = formatLocale$3(definition);
  format$2 = locale$3.format;
  formatPrefix$1 = locale$3.formatPrefix;
  return locale$3;
}
function precisionFixed$1(step2) {
  return Math.max(0, -exponent$2(Math.abs(step2)));
}
function precisionPrefix$1(step2, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent$2(value) / 3))) * 3 - exponent$2(Math.abs(step2)));
}
function precisionRound$1(step2, max2) {
  step2 = Math.abs(step2), max2 = Math.abs(max2) - step2;
  return Math.max(0, exponent$2(max2) - exponent$2(step2)) + 1;
}
function ascending$5(a2, b) {
  return a2 == null || b == null ? NaN : a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
}
function descending$5(a2, b) {
  return a2 == null || b == null ? NaN : b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
}
function bisector$2(f2) {
  let compare1, compare2, delta;
  if (f2.length !== 2) {
    compare1 = ascending$5;
    compare2 = (d, x2) => ascending$5(f2(d), x2);
    delta = (d, x2) => f2(d) - x2;
  } else {
    compare1 = f2 === ascending$5 || f2 === descending$5 ? f2 : zero$2;
    compare2 = f2;
    delta = f2;
  }
  function left2(a2, x2, lo = 0, hi = a2.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a2[mid], x2) < 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right2(a2, x2, lo = 0, hi = a2.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a2[mid], x2) <= 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center2(a2, x2, lo = 0, hi = a2.length) {
    const i = left2(a2, x2, lo, hi - 1);
    return i > lo && delta(a2[i - 1], x2) > -delta(a2[i], x2) ? i - 1 : i;
  }
  return { left: left2, center: center2, right: right2 };
}
function zero$2() {
  return 0;
}
function number$6(x2) {
  return x2 === null ? NaN : +x2;
}
const ascendingBisect$1 = bisector$2(ascending$5);
const bisectRight$1 = ascendingBisect$1.right;
bisector$2(number$6).center;
const bisect = bisectRight$1;
var e10$2 = Math.sqrt(50), e5$2 = Math.sqrt(10), e2$2 = Math.sqrt(2);
function ticks$1(start2, stop, count2) {
  var reverse2, i = -1, n, ticks2, step2;
  stop = +stop, start2 = +start2, count2 = +count2;
  if (start2 === stop && count2 > 0)
    return [start2];
  if (reverse2 = stop < start2)
    n = start2, start2 = stop, stop = n;
  if ((step2 = tickIncrement$1(start2, stop, count2)) === 0 || !isFinite(step2))
    return [];
  if (step2 > 0) {
    let r0 = Math.round(start2 / step2), r1 = Math.round(stop / step2);
    if (r0 * step2 < start2)
      ++r0;
    if (r1 * step2 > stop)
      --r1;
    ticks2 = new Array(n = r1 - r0 + 1);
    while (++i < n)
      ticks2[i] = (r0 + i) * step2;
  } else {
    step2 = -step2;
    let r0 = Math.round(start2 * step2), r1 = Math.round(stop * step2);
    if (r0 / step2 < start2)
      ++r0;
    if (r1 / step2 > stop)
      --r1;
    ticks2 = new Array(n = r1 - r0 + 1);
    while (++i < n)
      ticks2[i] = (r0 + i) / step2;
  }
  if (reverse2)
    ticks2.reverse();
  return ticks2;
}
function tickIncrement$1(start2, stop, count2) {
  var step2 = (stop - start2) / Math.max(0, count2), power = Math.floor(Math.log(step2) / Math.LN10), error = step2 / Math.pow(10, power);
  return power >= 0 ? (error >= e10$2 ? 10 : error >= e5$2 ? 5 : error >= e2$2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10$2 ? 10 : error >= e5$2 ? 5 : error >= e2$2 ? 2 : 1);
}
function tickStep$2(start2, stop, count2) {
  var step0 = Math.abs(stop - start2) / Math.max(0, count2), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
  if (error >= e10$2)
    step1 *= 10;
  else if (error >= e5$2)
    step1 *= 5;
  else if (error >= e2$2)
    step1 *= 2;
  return stop < start2 ? -step1 : step1;
}
function constants(x2) {
  return function() {
    return x2;
  };
}
function number$5(x2) {
  return +x2;
}
var unit$2 = [0, 1];
function identity$b(x2) {
  return x2;
}
function normalize$3(a2, b) {
  return (b -= a2 = +a2) ? function(x2) {
    return (x2 - a2) / b;
  } : constants(isNaN(b) ? NaN : 0.5);
}
function clamper$1(a2, b) {
  var t4;
  if (a2 > b)
    t4 = a2, a2 = b, b = t4;
  return function(x2) {
    return Math.max(a2, Math.min(b, x2));
  };
}
function bimap$1(domain, range2, interpolate2) {
  var d0 = domain[0], d1 = domain[1], r0 = range2[0], r1 = range2[1];
  if (d1 < d0)
    d0 = normalize$3(d1, d0), r0 = interpolate2(r1, r0);
  else
    d0 = normalize$3(d0, d1), r0 = interpolate2(r0, r1);
  return function(x2) {
    return r0(d0(x2));
  };
}
function polymap$1(domain, range2, interpolate2) {
  var j2 = Math.min(domain.length, range2.length) - 1, d = new Array(j2), r = new Array(j2), i = -1;
  if (domain[j2] < domain[0]) {
    domain = domain.slice().reverse();
    range2 = range2.slice().reverse();
  }
  while (++i < j2) {
    d[i] = normalize$3(domain[i], domain[i + 1]);
    r[i] = interpolate2(range2[i], range2[i + 1]);
  }
  return function(x2) {
    var i2 = bisect(domain, x2, 1, j2) - 1;
    return r[i2](d[i2](x2));
  };
}
function copy$3(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer$4() {
  var domain = unit$2, range2 = unit$2, interpolate2 = interpolate$2, transform2, untransform, unknown, clamp = identity$b, piecewise2, output, input;
  function rescale() {
    var n = Math.min(domain.length, range2.length);
    if (clamp !== identity$b)
      clamp = clamper$1(domain[0], domain[n - 1]);
    piecewise2 = n > 2 ? polymap$1 : bimap$1;
    output = input = null;
    return scale;
  }
  function scale(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : (output || (output = piecewise2(domain.map(transform2), range2, interpolate2)))(transform2(clamp(x2)));
  }
  scale.invert = function(y2) {
    return clamp(untransform((input || (input = piecewise2(range2, domain.map(transform2), interpolateNumber$1)))(y2)));
  };
  scale.domain = function(_2) {
    return arguments.length ? (domain = Array.from(_2, number$5), rescale()) : domain.slice();
  };
  scale.range = function(_2) {
    return arguments.length ? (range2 = Array.from(_2), rescale()) : range2.slice();
  };
  scale.rangeRound = function(_2) {
    return range2 = Array.from(_2), interpolate2 = interpolateRound$1, rescale();
  };
  scale.clamp = function(_2) {
    return arguments.length ? (clamp = _2 ? true : identity$b, rescale()) : clamp !== identity$b;
  };
  scale.interpolate = function(_2) {
    return arguments.length ? (interpolate2 = _2, rescale()) : interpolate2;
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  return function(t4, u) {
    transform2 = t4, untransform = u;
    return rescale();
  };
}
function continuous$1() {
  return transformer$4()(identity$b, identity$b);
}
function tickFormat$1(start2, stop, count2, specifier) {
  var step2 = tickStep$2(start2, stop, count2), precision;
  specifier = formatSpecifier$1(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start2), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix$1(step2, value)))
        specifier.precision = precision;
      return formatPrefix$1(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound$1(step2, Math.max(Math.abs(start2), Math.abs(stop)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed$1(step2)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format$2(specifier);
}
function linearish$1(scale) {
  var domain = scale.domain;
  scale.ticks = function(count2) {
    var d = domain();
    return ticks$1(d[0], d[d.length - 1], count2 == null ? 10 : count2);
  };
  scale.tickFormat = function(count2, specifier) {
    var d = domain();
    return tickFormat$1(d[0], d[d.length - 1], count2 == null ? 10 : count2, specifier);
  };
  scale.nice = function(count2) {
    if (count2 == null)
      count2 = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start2 = d[i0];
    var stop = d[i1];
    var prestep;
    var step2;
    var maxIter = 10;
    if (stop < start2) {
      step2 = start2, start2 = stop, stop = step2;
      step2 = i0, i0 = i1, i1 = step2;
    }
    while (maxIter-- > 0) {
      step2 = tickIncrement$1(start2, stop, count2);
      if (step2 === prestep) {
        d[i0] = start2;
        d[i1] = stop;
        return domain(d);
      } else if (step2 > 0) {
        start2 = Math.floor(start2 / step2) * step2;
        stop = Math.ceil(stop / step2) * step2;
      } else if (step2 < 0) {
        start2 = Math.ceil(start2 * step2) / step2;
        stop = Math.floor(stop * step2) / step2;
      } else {
        break;
      }
      prestep = step2;
    }
    return scale;
  };
  return scale;
}
function linear$3() {
  var scale = continuous$1();
  scale.copy = function() {
    return copy$3(scale, linear$3());
  };
  initRange$1.apply(scale, arguments);
  return linearish$1(scale);
}
function nice$1(domain, interval2) {
  domain = domain.slice();
  var i0 = 0, i1 = domain.length - 1, x02 = domain[i0], x12 = domain[i1], t4;
  if (x12 < x02) {
    t4 = i0, i0 = i1, i1 = t4;
    t4 = x02, x02 = x12, x12 = t4;
  }
  domain[i0] = interval2.floor(x02);
  domain[i1] = interval2.ceil(x12);
  return domain;
}
var t0$2 = new Date(), t1$2 = new Date();
function newInterval$1(floori, offseti, count2, field) {
  function interval2(date2) {
    return floori(date2 = arguments.length === 0 ? new Date() : new Date(+date2)), date2;
  }
  interval2.floor = function(date2) {
    return floori(date2 = new Date(+date2)), date2;
  };
  interval2.ceil = function(date2) {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval2.round = function(date2) {
    var d0 = interval2(date2), d1 = interval2.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval2.offset = function(date2, step2) {
    return offseti(date2 = new Date(+date2), step2 == null ? 1 : Math.floor(step2)), date2;
  };
  interval2.range = function(start2, stop, step2) {
    var range2 = [], previous;
    start2 = interval2.ceil(start2);
    step2 = step2 == null ? 1 : Math.floor(step2);
    if (!(start2 < stop) || !(step2 > 0))
      return range2;
    do
      range2.push(previous = new Date(+start2)), offseti(start2, step2), floori(start2);
    while (previous < start2 && start2 < stop);
    return range2;
  };
  interval2.filter = function(test) {
    return newInterval$1(function(date2) {
      if (date2 >= date2)
        while (floori(date2), !test(date2))
          date2.setTime(date2 - 1);
    }, function(date2, step2) {
      if (date2 >= date2) {
        if (step2 < 0)
          while (++step2 <= 0) {
            while (offseti(date2, -1), !test(date2)) {
            }
          }
        else
          while (--step2 >= 0) {
            while (offseti(date2, 1), !test(date2)) {
            }
          }
      }
    });
  };
  if (count2) {
    interval2.count = function(start2, end2) {
      t0$2.setTime(+start2), t1$2.setTime(+end2);
      floori(t0$2), floori(t1$2);
      return Math.floor(count2(t0$2, t1$2));
    };
    interval2.every = function(step2) {
      step2 = Math.floor(step2);
      return !isFinite(step2) || !(step2 > 0) ? null : !(step2 > 1) ? interval2 : interval2.filter(field ? function(d) {
        return field(d) % step2 === 0;
      } : function(d) {
        return interval2.count(0, d) % step2 === 0;
      });
    };
  }
  return interval2;
}
var millisecond$1 = newInterval$1(function() {
}, function(date2, step2) {
  date2.setTime(+date2 + step2);
}, function(start2, end2) {
  return end2 - start2;
});
millisecond$1.every = function(k2) {
  k2 = Math.floor(k2);
  if (!isFinite(k2) || !(k2 > 0))
    return null;
  if (!(k2 > 1))
    return millisecond$1;
  return newInterval$1(function(date2) {
    date2.setTime(Math.floor(date2 / k2) * k2);
  }, function(date2, step2) {
    date2.setTime(+date2 + step2 * k2);
  }, function(start2, end2) {
    return (end2 - start2) / k2;
  });
};
const millisecond$2 = millisecond$1;
millisecond$1.range;
const durationSecond$2 = 1e3;
const durationMinute$2 = durationSecond$2 * 60;
const durationHour$2 = durationMinute$2 * 60;
const durationDay$2 = durationHour$2 * 24;
const durationWeek$2 = durationDay$2 * 7;
const durationMonth$1 = durationDay$2 * 30;
const durationYear$1 = durationDay$2 * 365;
var second$1 = newInterval$1(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds());
}, function(date2, step2) {
  date2.setTime(+date2 + step2 * durationSecond$2);
}, function(start2, end2) {
  return (end2 - start2) / durationSecond$2;
}, function(date2) {
  return date2.getUTCSeconds();
});
const utcSecond$1 = second$1;
second$1.range;
var minute$1 = newInterval$1(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond$2);
}, function(date2, step2) {
  date2.setTime(+date2 + step2 * durationMinute$2);
}, function(start2, end2) {
  return (end2 - start2) / durationMinute$2;
}, function(date2) {
  return date2.getMinutes();
});
const timeMinute$1 = minute$1;
minute$1.range;
var hour$1 = newInterval$1(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond$2 - date2.getMinutes() * durationMinute$2);
}, function(date2, step2) {
  date2.setTime(+date2 + step2 * durationHour$2);
}, function(start2, end2) {
  return (end2 - start2) / durationHour$2;
}, function(date2) {
  return date2.getHours();
});
const timeHour$1 = hour$1;
hour$1.range;
var day$1 = newInterval$1(
  (date2) => date2.setHours(0, 0, 0, 0),
  (date2, step2) => date2.setDate(date2.getDate() + step2),
  (start2, end2) => (end2 - start2 - (end2.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute$2) / durationDay$2,
  (date2) => date2.getDate() - 1
);
const timeDay$1 = day$1;
day$1.range;
function weekday$1(i) {
  return newInterval$1(function(date2) {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
    date2.setHours(0, 0, 0, 0);
  }, function(date2, step2) {
    date2.setDate(date2.getDate() + step2 * 7);
  }, function(start2, end2) {
    return (end2 - start2 - (end2.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute$2) / durationWeek$2;
  });
}
var sunday$1 = weekday$1(0);
var monday$1 = weekday$1(1);
var tuesday$1 = weekday$1(2);
var wednesday$1 = weekday$1(3);
var thursday$1 = weekday$1(4);
var friday$1 = weekday$1(5);
var saturday$1 = weekday$1(6);
sunday$1.range;
monday$1.range;
tuesday$1.range;
wednesday$1.range;
thursday$1.range;
friday$1.range;
saturday$1.range;
var month$1 = newInterval$1(function(date2) {
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
}, function(date2, step2) {
  date2.setMonth(date2.getMonth() + step2);
}, function(start2, end2) {
  return end2.getMonth() - start2.getMonth() + (end2.getFullYear() - start2.getFullYear()) * 12;
}, function(date2) {
  return date2.getMonth();
});
const timeMonth$1 = month$1;
month$1.range;
var year$1 = newInterval$1(function(date2) {
  date2.setMonth(0, 1);
  date2.setHours(0, 0, 0, 0);
}, function(date2, step2) {
  date2.setFullYear(date2.getFullYear() + step2);
}, function(start2, end2) {
  return end2.getFullYear() - start2.getFullYear();
}, function(date2) {
  return date2.getFullYear();
});
year$1.every = function(k2) {
  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : newInterval$1(function(date2) {
    date2.setFullYear(Math.floor(date2.getFullYear() / k2) * k2);
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, function(date2, step2) {
    date2.setFullYear(date2.getFullYear() + step2 * k2);
  });
};
const timeYear$1 = year$1;
year$1.range;
var utcMinute$2 = newInterval$1(function(date2) {
  date2.setUTCSeconds(0, 0);
}, function(date2, step2) {
  date2.setTime(+date2 + step2 * durationMinute$2);
}, function(start2, end2) {
  return (end2 - start2) / durationMinute$2;
}, function(date2) {
  return date2.getUTCMinutes();
});
const utcMinute$3 = utcMinute$2;
utcMinute$2.range;
var utcHour$2 = newInterval$1(function(date2) {
  date2.setUTCMinutes(0, 0, 0);
}, function(date2, step2) {
  date2.setTime(+date2 + step2 * durationHour$2);
}, function(start2, end2) {
  return (end2 - start2) / durationHour$2;
}, function(date2) {
  return date2.getUTCHours();
});
const utcHour$3 = utcHour$2;
utcHour$2.range;
var utcDay$2 = newInterval$1(function(date2) {
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step2) {
  date2.setUTCDate(date2.getUTCDate() + step2);
}, function(start2, end2) {
  return (end2 - start2) / durationDay$2;
}, function(date2) {
  return date2.getUTCDate() - 1;
});
const utcDay$3 = utcDay$2;
utcDay$2.range;
function utcWeekday$1(i) {
  return newInterval$1(function(date2) {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step2) {
    date2.setUTCDate(date2.getUTCDate() + step2 * 7);
  }, function(start2, end2) {
    return (end2 - start2) / durationWeek$2;
  });
}
var utcSunday$1 = utcWeekday$1(0);
var utcMonday$1 = utcWeekday$1(1);
var utcTuesday$1 = utcWeekday$1(2);
var utcWednesday$1 = utcWeekday$1(3);
var utcThursday$1 = utcWeekday$1(4);
var utcFriday$1 = utcWeekday$1(5);
var utcSaturday$1 = utcWeekday$1(6);
utcSunday$1.range;
utcMonday$1.range;
utcTuesday$1.range;
utcWednesday$1.range;
utcThursday$1.range;
utcFriday$1.range;
utcSaturday$1.range;
var utcMonth$2 = newInterval$1(function(date2) {
  date2.setUTCDate(1);
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step2) {
  date2.setUTCMonth(date2.getUTCMonth() + step2);
}, function(start2, end2) {
  return end2.getUTCMonth() - start2.getUTCMonth() + (end2.getUTCFullYear() - start2.getUTCFullYear()) * 12;
}, function(date2) {
  return date2.getUTCMonth();
});
const utcMonth$3 = utcMonth$2;
utcMonth$2.range;
var utcYear$2 = newInterval$1(function(date2) {
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step2) {
  date2.setUTCFullYear(date2.getUTCFullYear() + step2);
}, function(start2, end2) {
  return end2.getUTCFullYear() - start2.getUTCFullYear();
}, function(date2) {
  return date2.getUTCFullYear();
});
utcYear$2.every = function(k2) {
  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : newInterval$1(function(date2) {
    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k2) * k2);
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step2) {
    date2.setUTCFullYear(date2.getUTCFullYear() + step2 * k2);
  });
};
const utcYear$3 = utcYear$2;
utcYear$2.range;
function ascending$4(a2, b) {
  return a2 == null || b == null ? NaN : a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
}
function descending$4(a2, b) {
  return a2 == null || b == null ? NaN : b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
}
function bisector$1(f2) {
  let compare1, compare2, delta;
  if (f2.length !== 2) {
    compare1 = ascending$4;
    compare2 = (d, x2) => ascending$4(f2(d), x2);
    delta = (d, x2) => f2(d) - x2;
  } else {
    compare1 = f2 === ascending$4 || f2 === descending$4 ? f2 : zero$1;
    compare2 = f2;
    delta = f2;
  }
  function left2(a2, x2, lo = 0, hi = a2.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a2[mid], x2) < 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right2(a2, x2, lo = 0, hi = a2.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a2[mid], x2) <= 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center2(a2, x2, lo = 0, hi = a2.length) {
    const i = left2(a2, x2, lo, hi - 1);
    return i > lo && delta(a2[i - 1], x2) > -delta(a2[i], x2) ? i - 1 : i;
  }
  return { left: left2, center: center2, right: right2 };
}
function zero$1() {
  return 0;
}
var e10$1 = Math.sqrt(50), e5$1 = Math.sqrt(10), e2$1 = Math.sqrt(2);
function tickStep$1(start2, stop, count2) {
  var step0 = Math.abs(stop - start2) / Math.max(0, count2), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
  if (error >= e10$1)
    step1 *= 10;
  else if (error >= e5$1)
    step1 *= 5;
  else if (error >= e2$1)
    step1 *= 2;
  return stop < start2 ? -step1 : step1;
}
function ticker(year2, month2, week, day2, hour2, minute2) {
  const tickIntervals = [
    [utcSecond$1, 1, durationSecond$2],
    [utcSecond$1, 5, 5 * durationSecond$2],
    [utcSecond$1, 15, 15 * durationSecond$2],
    [utcSecond$1, 30, 30 * durationSecond$2],
    [minute2, 1, durationMinute$2],
    [minute2, 5, 5 * durationMinute$2],
    [minute2, 15, 15 * durationMinute$2],
    [minute2, 30, 30 * durationMinute$2],
    [hour2, 1, durationHour$2],
    [hour2, 3, 3 * durationHour$2],
    [hour2, 6, 6 * durationHour$2],
    [hour2, 12, 12 * durationHour$2],
    [day2, 1, durationDay$2],
    [day2, 2, 2 * durationDay$2],
    [week, 1, durationWeek$2],
    [month2, 1, durationMonth$1],
    [month2, 3, 3 * durationMonth$1],
    [year2, 1, durationYear$1]
  ];
  function ticks2(start2, stop, count2) {
    const reverse2 = stop < start2;
    if (reverse2)
      [start2, stop] = [stop, start2];
    const interval2 = count2 && typeof count2.range === "function" ? count2 : tickInterval(start2, stop, count2);
    const ticks3 = interval2 ? interval2.range(start2, +stop + 1) : [];
    return reverse2 ? ticks3.reverse() : ticks3;
  }
  function tickInterval(start2, stop, count2) {
    const target = Math.abs(stop - start2) / count2;
    const i = bisector$1(([, , step3]) => step3).right(tickIntervals, target);
    if (i === tickIntervals.length)
      return year2.every(tickStep$1(start2 / durationYear$1, stop / durationYear$1, count2));
    if (i === 0)
      return millisecond$2.every(Math.max(tickStep$1(start2, stop, count2), 1));
    const [t4, step2] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
    return t4.every(step2);
  }
  return [ticks2, tickInterval];
}
ticker(utcYear$3, utcMonth$3, utcSunday$1, utcDay$3, utcHour$3, utcMinute$3);
const [timeTicks, timeTickInterval] = ticker(timeYear$1, timeMonth$1, sunday$1, timeDay$1, timeHour$1, timeMinute$1);
function localDate$1(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date2.setFullYear(d.y);
    return date2;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate$1(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date2.setUTCFullYear(d.y);
    return date2;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate$1(y2, m, d) {
  return { y: y2, m, d, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale$2(locale2) {
  var locale_dateTime = locale2.dateTime, locale_date = locale2.date, locale_time = locale2.time, locale_periods = locale2.periods, locale_weekdays = locale2.days, locale_shortWeekdays = locale2.shortDays, locale_months = locale2.months, locale_shortMonths = locale2.shortMonths;
  var periodRe = formatRe$1(locale_periods), periodLookup = formatLookup$1(locale_periods), weekdayRe = formatRe$1(locale_weekdays), weekdayLookup = formatLookup$1(locale_weekdays), shortWeekdayRe = formatRe$1(locale_shortWeekdays), shortWeekdayLookup = formatLookup$1(locale_shortWeekdays), monthRe = formatRe$1(locale_months), monthLookup = formatLookup$1(locale_months), shortMonthRe = formatRe$1(locale_shortMonths), shortMonthLookup = formatLookup$1(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth$1,
    "e": formatDayOfMonth$1,
    "f": formatMicroseconds$1,
    "g": formatYearISO$1,
    "G": formatFullYearISO$1,
    "H": formatHour24$1,
    "I": formatHour12$1,
    "j": formatDayOfYear$1,
    "L": formatMilliseconds$1,
    "m": formatMonthNumber$1,
    "M": formatMinutes$1,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp$1,
    "s": formatUnixTimestampSeconds$1,
    "S": formatSeconds$1,
    "u": formatWeekdayNumberMonday$1,
    "U": formatWeekNumberSunday$1,
    "V": formatWeekNumberISO$1,
    "w": formatWeekdayNumberSunday$1,
    "W": formatWeekNumberMonday$1,
    "x": null,
    "X": null,
    "y": formatYear$2,
    "Y": formatFullYear$1,
    "Z": formatZone$1,
    "%": formatLiteralPercent$1
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth$1,
    "e": formatUTCDayOfMonth$1,
    "f": formatUTCMicroseconds$1,
    "g": formatUTCYearISO$1,
    "G": formatUTCFullYearISO$1,
    "H": formatUTCHour24$1,
    "I": formatUTCHour12$1,
    "j": formatUTCDayOfYear$1,
    "L": formatUTCMilliseconds$1,
    "m": formatUTCMonthNumber$1,
    "M": formatUTCMinutes$1,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp$1,
    "s": formatUnixTimestampSeconds$1,
    "S": formatUTCSeconds$1,
    "u": formatUTCWeekdayNumberMonday$1,
    "U": formatUTCWeekNumberSunday$1,
    "V": formatUTCWeekNumberISO$1,
    "w": formatUTCWeekdayNumberSunday$1,
    "W": formatUTCWeekNumberMonday$1,
    "x": null,
    "X": null,
    "y": formatUTCYear$1,
    "Y": formatUTCFullYear$1,
    "Z": formatUTCZone$1,
    "%": formatLiteralPercent$1
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth$1,
    "e": parseDayOfMonth$1,
    "f": parseMicroseconds$1,
    "g": parseYear$1,
    "G": parseFullYear$1,
    "H": parseHour24$1,
    "I": parseHour24$1,
    "j": parseDayOfYear$1,
    "L": parseMilliseconds$1,
    "m": parseMonthNumber$1,
    "M": parseMinutes$1,
    "p": parsePeriod,
    "q": parseQuarter$1,
    "Q": parseUnixTimestamp$1,
    "s": parseUnixTimestampSeconds$1,
    "S": parseSeconds$1,
    "u": parseWeekdayNumberMonday$1,
    "U": parseWeekNumberSunday$1,
    "V": parseWeekNumberISO$1,
    "w": parseWeekdayNumberSunday$1,
    "W": parseWeekNumberMonday$1,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear$1,
    "Y": parseFullYear$1,
    "Z": parseZone$1,
    "%": parseLiteralPercent$1
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date2) {
      var string2 = [], i = -1, j2 = 0, n = specifier.length, c2, pad2, format2;
      if (!(date2 instanceof Date))
        date2 = new Date(+date2);
      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string2.push(specifier.slice(j2, i));
          if ((pad2 = pads$1[c2 = specifier.charAt(++i)]) != null)
            c2 = specifier.charAt(++i);
          else
            pad2 = c2 === "e" ? " " : "0";
          if (format2 = formats2[c2])
            c2 = format2(date2, pad2);
          string2.push(c2);
          j2 = i + 1;
        }
      }
      string2.push(specifier.slice(j2, i));
      return string2.join("");
    };
  }
  function newParse(specifier, Z3) {
    return function(string2) {
      var d = newDate$1(1900, void 0, 1), i = parseSpecifier(d, specifier, string2 += "", 0), week, day2;
      if (i != string2.length)
        return null;
      if ("Q" in d)
        return new Date(d.Q);
      if ("s" in d)
        return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z3 && !("Z" in d))
        d.Z = 0;
      if ("p" in d)
        d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0)
        d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53)
          return null;
        if (!("w" in d))
          d.w = 1;
        if ("Z" in d) {
          week = utcDate$1(newDate$1(d.y, 0, 1)), day2 = week.getUTCDay();
          week = day2 > 4 || day2 === 0 ? utcMonday$1.ceil(week) : utcMonday$1(week);
          week = utcDay$3.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate$1(newDate$1(d.y, 0, 1)), day2 = week.getDay();
          week = day2 > 4 || day2 === 0 ? monday$1.ceil(week) : monday$1(week);
          week = timeDay$1.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d))
          d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day2 = "Z" in d ? utcDate$1(newDate$1(d.y, 0, 1)).getUTCDay() : localDate$1(newDate$1(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day2 + 5) % 7 : d.w + d.U * 7 - (day2 + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate$1(d);
      }
      return localDate$1(d);
    };
  }
  function parseSpecifier(d, specifier, string2, j2) {
    var i = 0, n = specifier.length, m = string2.length, c2, parse2;
    while (i < n) {
      if (j2 >= m)
        return -1;
      c2 = specifier.charCodeAt(i++);
      if (c2 === 37) {
        c2 = specifier.charAt(i++);
        parse2 = parses[c2 in pads$1 ? specifier.charAt(i++) : c2];
        if (!parse2 || (j2 = parse2(d, string2, j2)) < 0)
          return -1;
      } else if (c2 != string2.charCodeAt(j2++)) {
        return -1;
      }
    }
    return j2;
  }
  function parsePeriod(d, string2, i) {
    var n = periodRe.exec(string2.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortWeekday(d, string2, i) {
    var n = shortWeekdayRe.exec(string2.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseWeekday(d, string2, i) {
    var n = weekdayRe.exec(string2.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortMonth(d, string2, i) {
    var n = shortMonthRe.exec(string2.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseMonth(d, string2, i) {
    var n = monthRe.exec(string2.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string2, i) {
    return parseSpecifier(d, locale_dateTime, string2, i);
  }
  function parseLocaleDate(d, string2, i) {
    return parseSpecifier(d, locale_date, string2, i);
  }
  function parseLocaleTime(d, string2, i) {
    return parseSpecifier(d, locale_time, string2, i);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f2 = newFormat(specifier += "", formats);
      f2.toString = function() {
        return specifier;
      };
      return f2;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() {
        return specifier;
      };
      return p;
    },
    utcFormat: function(specifier) {
      var f2 = newFormat(specifier += "", utcFormats);
      f2.toString = function() {
        return specifier;
      };
      return f2;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() {
        return specifier;
      };
      return p;
    }
  };
}
var pads$1 = { "-": "", "_": " ", "0": "0" }, numberRe$1 = /^\s*\d+/, percentRe$1 = /^%/, requoteRe$1 = /[\\^$*+?|[\]().{}]/g;
function pad$2(value, fill, width2) {
  var sign2 = value < 0 ? "-" : "", string2 = (sign2 ? -value : value) + "", length2 = string2.length;
  return sign2 + (length2 < width2 ? new Array(width2 - length2 + 1).join(fill) + string2 : string2);
}
function requote$1(s2) {
  return s2.replace(requoteRe$1, "\\$&");
}
function formatRe$1(names) {
  return new RegExp("^(?:" + names.map(requote$1).join("|") + ")", "i");
}
function formatLookup$1(names) {
  return new Map(names.map((name2, i) => [name2.toLowerCase(), i]));
}
function parseWeekdayNumberSunday$1(d, string2, i) {
  var n = numberRe$1.exec(string2.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday$1(d, string2, i) {
  var n = numberRe$1.exec(string2.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday$1(d, string2, i) {
  var n = numberRe$1.exec(string2.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO$1(d, string2, i) {
  var n = numberRe$1.exec(string2.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday$1(d, string2, i) {
  var n = numberRe$1.exec(string2.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear$1(d, string2, i) {
  var n = numberRe$1.exec(string2.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear$1(d, string2, i) {
  var n = numberRe$1.exec(string2.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
}
function parseZone$1(d, string2, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string2.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter$1(d, string2, i) {
  var n = numberRe$1.exec(string2.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber$1(d, string2, i) {
  var n = numberRe$1.exec(string2.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth$1(d, string2, i) {
  var n = numberRe$1.exec(string2.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear$1(d, string2, i) {
  var n = numberRe$1.exec(string2.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour24$1(d, string2, i) {
  var n = numberRe$1.exec(string2.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes$1(d, string2, i) {
  var n = numberRe$1.exec(string2.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds$1(d, string2, i) {
  var n = numberRe$1.exec(string2.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds$1(d, string2, i) {
  var n = numberRe$1.exec(string2.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds$1(d, string2, i) {
  var n = numberRe$1.exec(string2.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
}
function parseLiteralPercent$1(d, string2, i) {
  var n = percentRe$1.exec(string2.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}
function parseUnixTimestamp$1(d, string2, i) {
  var n = numberRe$1.exec(string2.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds$1(d, string2, i) {
  var n = numberRe$1.exec(string2.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth$1(d, p) {
  return pad$2(d.getDate(), p, 2);
}
function formatHour24$1(d, p) {
  return pad$2(d.getHours(), p, 2);
}
function formatHour12$1(d, p) {
  return pad$2(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear$1(d, p) {
  return pad$2(1 + timeDay$1.count(timeYear$1(d), d), p, 3);
}
function formatMilliseconds$1(d, p) {
  return pad$2(d.getMilliseconds(), p, 3);
}
function formatMicroseconds$1(d, p) {
  return formatMilliseconds$1(d, p) + "000";
}
function formatMonthNumber$1(d, p) {
  return pad$2(d.getMonth() + 1, p, 2);
}
function formatMinutes$1(d, p) {
  return pad$2(d.getMinutes(), p, 2);
}
function formatSeconds$1(d, p) {
  return pad$2(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday$1(d) {
  var day2 = d.getDay();
  return day2 === 0 ? 7 : day2;
}
function formatWeekNumberSunday$1(d, p) {
  return pad$2(sunday$1.count(timeYear$1(d) - 1, d), p, 2);
}
function dISO$1(d) {
  var day2 = d.getDay();
  return day2 >= 4 || day2 === 0 ? thursday$1(d) : thursday$1.ceil(d);
}
function formatWeekNumberISO$1(d, p) {
  d = dISO$1(d);
  return pad$2(thursday$1.count(timeYear$1(d), d) + (timeYear$1(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday$1(d) {
  return d.getDay();
}
function formatWeekNumberMonday$1(d, p) {
  return pad$2(monday$1.count(timeYear$1(d) - 1, d), p, 2);
}
function formatYear$2(d, p) {
  return pad$2(d.getFullYear() % 100, p, 2);
}
function formatYearISO$1(d, p) {
  d = dISO$1(d);
  return pad$2(d.getFullYear() % 100, p, 2);
}
function formatFullYear$1(d, p) {
  return pad$2(d.getFullYear() % 1e4, p, 4);
}
function formatFullYearISO$1(d, p) {
  var day2 = d.getDay();
  d = day2 >= 4 || day2 === 0 ? thursday$1(d) : thursday$1.ceil(d);
  return pad$2(d.getFullYear() % 1e4, p, 4);
}
function formatZone$1(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad$2(z / 60 | 0, "0", 2) + pad$2(z % 60, "0", 2);
}
function formatUTCDayOfMonth$1(d, p) {
  return pad$2(d.getUTCDate(), p, 2);
}
function formatUTCHour24$1(d, p) {
  return pad$2(d.getUTCHours(), p, 2);
}
function formatUTCHour12$1(d, p) {
  return pad$2(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear$1(d, p) {
  return pad$2(1 + utcDay$3.count(utcYear$3(d), d), p, 3);
}
function formatUTCMilliseconds$1(d, p) {
  return pad$2(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds$1(d, p) {
  return formatUTCMilliseconds$1(d, p) + "000";
}
function formatUTCMonthNumber$1(d, p) {
  return pad$2(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes$1(d, p) {
  return pad$2(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds$1(d, p) {
  return pad$2(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday$1(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday$1(d, p) {
  return pad$2(utcSunday$1.count(utcYear$3(d) - 1, d), p, 2);
}
function UTCdISO$1(d) {
  var day2 = d.getUTCDay();
  return day2 >= 4 || day2 === 0 ? utcThursday$1(d) : utcThursday$1.ceil(d);
}
function formatUTCWeekNumberISO$1(d, p) {
  d = UTCdISO$1(d);
  return pad$2(utcThursday$1.count(utcYear$3(d), d) + (utcYear$3(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday$1(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday$1(d, p) {
  return pad$2(utcMonday$1.count(utcYear$3(d) - 1, d), p, 2);
}
function formatUTCYear$1(d, p) {
  return pad$2(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO$1(d, p) {
  d = UTCdISO$1(d);
  return pad$2(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear$1(d, p) {
  return pad$2(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCFullYearISO$1(d, p) {
  var day2 = d.getUTCDay();
  d = day2 >= 4 || day2 === 0 ? utcThursday$1(d) : utcThursday$1.ceil(d);
  return pad$2(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCZone$1() {
  return "+0000";
}
function formatLiteralPercent$1() {
  return "%";
}
function formatUnixTimestamp$1(d) {
  return +d;
}
function formatUnixTimestampSeconds$1(d) {
  return Math.floor(+d / 1e3);
}
var locale$2;
var timeFormat$1;
defaultLocale$2({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale$2(definition) {
  locale$2 = formatLocale$2(definition);
  timeFormat$1 = locale$2.format;
  locale$2.parse;
  locale$2.utcFormat;
  locale$2.utcParse;
  return locale$2;
}
function date$2(t4) {
  return new Date(t4);
}
function number$4(t4) {
  return t4 instanceof Date ? +t4 : +new Date(+t4);
}
function calendar$1(ticks2, tickInterval, year2, month2, week, day2, hour2, minute2, second2, format2) {
  var scale = continuous$1(), invert2 = scale.invert, domain = scale.domain;
  var formatMillisecond = format2(".%L"), formatSecond = format2(":%S"), formatMinute = format2("%I:%M"), formatHour = format2("%I %p"), formatDay = format2("%a %d"), formatWeek = format2("%b %d"), formatMonth = format2("%B"), formatYear2 = format2("%Y");
  function tickFormat2(date2) {
    return (second2(date2) < date2 ? formatMillisecond : minute2(date2) < date2 ? formatSecond : hour2(date2) < date2 ? formatMinute : day2(date2) < date2 ? formatHour : month2(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year2(date2) < date2 ? formatMonth : formatYear2)(date2);
  }
  scale.invert = function(y2) {
    return new Date(invert2(y2));
  };
  scale.domain = function(_2) {
    return arguments.length ? domain(Array.from(_2, number$4)) : domain().map(date$2);
  };
  scale.ticks = function(interval2) {
    var d = domain();
    return ticks2(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
  };
  scale.tickFormat = function(count2, specifier) {
    return specifier == null ? tickFormat2 : format2(specifier);
  };
  scale.nice = function(interval2) {
    var d = domain();
    if (!interval2 || typeof interval2.range !== "function")
      interval2 = tickInterval(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
    return interval2 ? domain(nice$1(d, interval2)) : scale;
  };
  scale.copy = function() {
    return copy$3(scale, calendar$1(ticks2, tickInterval, year2, month2, week, day2, hour2, minute2, second2, format2));
  };
  return scale;
}
function time$2() {
  return initRange$1.apply(calendar$1(timeTicks, timeTickInterval, timeYear$1, timeMonth$1, sunday$1, timeDay$1, timeHour$1, timeMinute$1, utcSecond$1, timeFormat$1).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function constant$e(x2) {
  return function constant2() {
    return x2;
  };
}
const abs$3 = Math.abs;
const atan2$2 = Math.atan2;
const cos$3 = Math.cos;
const max$3 = Math.max;
const min$2 = Math.min;
const sin$3 = Math.sin;
const sqrt$3 = Math.sqrt;
const epsilon$5 = 1e-12;
const pi$5 = Math.PI;
const halfPi$4 = pi$5 / 2;
const tau$5 = 2 * pi$5;
function acos$2(x2) {
  return x2 > 1 ? 0 : x2 < -1 ? pi$5 : Math.acos(x2);
}
function asin$2(x2) {
  return x2 >= 1 ? halfPi$4 : x2 <= -1 ? -halfPi$4 : Math.asin(x2);
}
function arcInnerRadius$1(d) {
  return d.innerRadius;
}
function arcOuterRadius$1(d) {
  return d.outerRadius;
}
function arcStartAngle$1(d) {
  return d.startAngle;
}
function arcEndAngle$1(d) {
  return d.endAngle;
}
function arcPadAngle$1(d) {
  return d && d.padAngle;
}
function intersect$3(x02, y02, x12, y12, x2, y2, x3, y3) {
  var x10 = x12 - x02, y10 = y12 - y02, x32 = x3 - x2, y32 = y3 - y2, t4 = y32 * x10 - x32 * y10;
  if (t4 * t4 < epsilon$5)
    return;
  t4 = (x32 * (y02 - y2) - y32 * (x02 - x2)) / t4;
  return [x02 + t4 * x10, y02 + t4 * y10];
}
function cornerTangents$1(x02, y02, x12, y12, r1, rc, cw) {
  var x01 = x02 - x12, y01 = y02 - y12, lo = (cw ? rc : -rc) / sqrt$3(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x02 + ox, y11 = y02 + oy, x10 = x12 + ox, y10 = y12 + oy, x002 = (x11 + x10) / 2, y002 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D2 = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt$3(max$3(0, r * r * d2 - D2 * D2)), cx0 = (D2 * dy - dx * d) / d2, cy0 = (-D2 * dx - dy * d) / d2, cx1 = (D2 * dy + dx * d) / d2, cy1 = (-D2 * dx + dy * d) / d2, dx0 = cx0 - x002, dy0 = cy0 - y002, dx1 = cx1 - x002, dy1 = cy1 - y002;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
    cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}
function arc$1() {
  var innerRadius = arcInnerRadius$1, outerRadius = arcOuterRadius$1, cornerRadius = constant$e(0), padRadius = null, startAngle = arcStartAngle$1, endAngle = arcEndAngle$1, padAngle = arcPadAngle$1, context = null;
  function arc2() {
    var buffer2, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi$4, a1 = endAngle.apply(this, arguments) - halfPi$4, da = abs$3(a1 - a0), cw = a1 > a0;
    if (!context)
      context = buffer2 = path$1();
    if (r1 < r0)
      r = r1, r1 = r0, r0 = r;
    if (!(r1 > epsilon$5))
      context.moveTo(0, 0);
    else if (da > tau$5 - epsilon$5) {
      context.moveTo(r1 * cos$3(a0), r1 * sin$3(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon$5) {
        context.moveTo(r0 * cos$3(a1), r0 * sin$3(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon$5 && (padRadius ? +padRadius.apply(this, arguments) : sqrt$3(r0 * r0 + r1 * r1)), rc = min$2(abs$3(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t02, t12;
      if (rp > epsilon$5) {
        var p02 = asin$2(rp / r0 * sin$3(ap)), p1 = asin$2(rp / r1 * sin$3(ap));
        if ((da0 -= p02 * 2) > epsilon$5)
          p02 *= cw ? 1 : -1, a00 += p02, a10 -= p02;
        else
          da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon$5)
          p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
        else
          da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos$3(a01), y01 = r1 * sin$3(a01), x10 = r0 * cos$3(a10), y10 = r0 * sin$3(a10);
      if (rc > epsilon$5) {
        var x11 = r1 * cos$3(a11), y11 = r1 * sin$3(a11), x002 = r0 * cos$3(a00), y002 = r0 * sin$3(a00), oc;
        if (da < pi$5 && (oc = intersect$3(x01, y01, x002, y002, x11, y11, x10, y10))) {
          var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin$3(acos$2((ax * bx + ay * by) / (sqrt$3(ax * ax + ay * ay) * sqrt$3(bx * bx + by * by))) / 2), lc = sqrt$3(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = min$2(rc, (r0 - lc) / (kc - 1));
          rc1 = min$2(rc, (r1 - lc) / (kc + 1));
        }
      }
      if (!(da1 > epsilon$5))
        context.moveTo(x01, y01);
      else if (rc1 > epsilon$5) {
        t02 = cornerTangents$1(x002, y002, x01, y01, r1, rc1, cw);
        t12 = cornerTangents$1(x11, y11, x10, y10, r1, rc1, cw);
        context.moveTo(t02.cx + t02.x01, t02.cy + t02.y01);
        if (rc1 < rc)
          context.arc(t02.cx, t02.cy, rc1, atan2$2(t02.y01, t02.x01), atan2$2(t12.y01, t12.x01), !cw);
        else {
          context.arc(t02.cx, t02.cy, rc1, atan2$2(t02.y01, t02.x01), atan2$2(t02.y11, t02.x11), !cw);
          context.arc(0, 0, r1, atan2$2(t02.cy + t02.y11, t02.cx + t02.x11), atan2$2(t12.cy + t12.y11, t12.cx + t12.x11), !cw);
          context.arc(t12.cx, t12.cy, rc1, atan2$2(t12.y11, t12.x11), atan2$2(t12.y01, t12.x01), !cw);
        }
      } else
        context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
      if (!(r0 > epsilon$5) || !(da0 > epsilon$5))
        context.lineTo(x10, y10);
      else if (rc0 > epsilon$5) {
        t02 = cornerTangents$1(x10, y10, x11, y11, r0, -rc0, cw);
        t12 = cornerTangents$1(x01, y01, x002, y002, r0, -rc0, cw);
        context.lineTo(t02.cx + t02.x01, t02.cy + t02.y01);
        if (rc0 < rc)
          context.arc(t02.cx, t02.cy, rc0, atan2$2(t02.y01, t02.x01), atan2$2(t12.y01, t12.x01), !cw);
        else {
          context.arc(t02.cx, t02.cy, rc0, atan2$2(t02.y01, t02.x01), atan2$2(t02.y11, t02.x11), !cw);
          context.arc(0, 0, r0, atan2$2(t02.cy + t02.y11, t02.cx + t02.x11), atan2$2(t12.cy + t12.y11, t12.cx + t12.x11), cw);
          context.arc(t12.cx, t12.cy, rc0, atan2$2(t12.y11, t12.x11), atan2$2(t12.y01, t12.x01), !cw);
        }
      } else
        context.arc(0, 0, r0, a10, a00, cw);
    }
    context.closePath();
    if (buffer2)
      return context = null, buffer2 + "" || null;
  }
  arc2.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a2 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$5 / 2;
    return [cos$3(a2) * r, sin$3(a2) * r];
  };
  arc2.innerRadius = function(_2) {
    return arguments.length ? (innerRadius = typeof _2 === "function" ? _2 : constant$e(+_2), arc2) : innerRadius;
  };
  arc2.outerRadius = function(_2) {
    return arguments.length ? (outerRadius = typeof _2 === "function" ? _2 : constant$e(+_2), arc2) : outerRadius;
  };
  arc2.cornerRadius = function(_2) {
    return arguments.length ? (cornerRadius = typeof _2 === "function" ? _2 : constant$e(+_2), arc2) : cornerRadius;
  };
  arc2.padRadius = function(_2) {
    return arguments.length ? (padRadius = _2 == null ? null : typeof _2 === "function" ? _2 : constant$e(+_2), arc2) : padRadius;
  };
  arc2.startAngle = function(_2) {
    return arguments.length ? (startAngle = typeof _2 === "function" ? _2 : constant$e(+_2), arc2) : startAngle;
  };
  arc2.endAngle = function(_2) {
    return arguments.length ? (endAngle = typeof _2 === "function" ? _2 : constant$e(+_2), arc2) : endAngle;
  };
  arc2.padAngle = function(_2) {
    return arguments.length ? (padAngle = typeof _2 === "function" ? _2 : constant$e(+_2), arc2) : padAngle;
  };
  arc2.context = function(_2) {
    return arguments.length ? (context = _2 == null ? null : _2, arc2) : context;
  };
  return arc2;
}
function array$4(x2) {
  return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
}
function Linear$1(context) {
  this._context = context;
}
Linear$1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x2, y2);
        break;
    }
  }
};
function curveLinear$1(context) {
  return new Linear$1(context);
}
function x$5(p) {
  return p[0];
}
function y$5(p) {
  return p[1];
}
function line$2(x2, y2) {
  var defined = constant$e(true), context = null, curve = curveLinear$1, output = null;
  x2 = typeof x2 === "function" ? x2 : x2 === void 0 ? x$5 : constant$e(x2);
  y2 = typeof y2 === "function" ? y2 : y2 === void 0 ? y$5 : constant$e(y2);
  function line2(data2) {
    var i, n = (data2 = array$4(data2)).length, d, defined0 = false, buffer2;
    if (context == null)
      output = curve(buffer2 = path$1());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data2[i], i, data2)) === defined0) {
        if (defined0 = !defined0)
          output.lineStart();
        else
          output.lineEnd();
      }
      if (defined0)
        output.point(+x2(d, i, data2), +y2(d, i, data2));
    }
    if (buffer2)
      return output = null, buffer2 + "" || null;
  }
  line2.x = function(_2) {
    return arguments.length ? (x2 = typeof _2 === "function" ? _2 : constant$e(+_2), line2) : x2;
  };
  line2.y = function(_2) {
    return arguments.length ? (y2 = typeof _2 === "function" ? _2 : constant$e(+_2), line2) : y2;
  };
  line2.defined = function(_2) {
    return arguments.length ? (defined = typeof _2 === "function" ? _2 : constant$e(!!_2), line2) : defined;
  };
  line2.curve = function(_2) {
    return arguments.length ? (curve = _2, context != null && (output = curve(context)), line2) : curve;
  };
  line2.context = function(_2) {
    return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), line2) : context;
  };
  return line2;
}
function descending$3(a2, b) {
  return b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
}
function identity$a(d) {
  return d;
}
function pie$1() {
  var value = identity$a, sortValues = descending$3, sort2 = null, startAngle = constant$e(0), endAngle = constant$e(tau$5), padAngle = constant$e(0);
  function pie2(data2) {
    var i, n = (data2 = array$4(data2)).length, j2, k2, sum2 = 0, index2 = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da = Math.min(tau$5, Math.max(-tau$5, endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)), pa = p * (da < 0 ? -1 : 1), v;
    for (i = 0; i < n; ++i) {
      if ((v = arcs[index2[i] = i] = +value(data2[i], i, data2)) > 0) {
        sum2 += v;
      }
    }
    if (sortValues != null)
      index2.sort(function(i2, j3) {
        return sortValues(arcs[i2], arcs[j3]);
      });
    else if (sort2 != null)
      index2.sort(function(i2, j3) {
        return sort2(data2[i2], data2[j3]);
      });
    for (i = 0, k2 = sum2 ? (da - n * pa) / sum2 : 0; i < n; ++i, a0 = a1) {
      j2 = index2[i], v = arcs[j2], a1 = a0 + (v > 0 ? v * k2 : 0) + pa, arcs[j2] = {
        data: data2[j2],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }
    return arcs;
  }
  pie2.value = function(_2) {
    return arguments.length ? (value = typeof _2 === "function" ? _2 : constant$e(+_2), pie2) : value;
  };
  pie2.sortValues = function(_2) {
    return arguments.length ? (sortValues = _2, sort2 = null, pie2) : sortValues;
  };
  pie2.sort = function(_2) {
    return arguments.length ? (sort2 = _2, sortValues = null, pie2) : sort2;
  };
  pie2.startAngle = function(_2) {
    return arguments.length ? (startAngle = typeof _2 === "function" ? _2 : constant$e(+_2), pie2) : startAngle;
  };
  pie2.endAngle = function(_2) {
    return arguments.length ? (endAngle = typeof _2 === "function" ? _2 : constant$e(+_2), pie2) : endAngle;
  };
  pie2.padAngle = function(_2) {
    return arguments.length ? (padAngle = typeof _2 === "function" ? _2 : constant$e(+_2), pie2) : padAngle;
  };
  return pie2;
}
function noop$4() {
}
function point$8(that, x2, y2) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x2) / 6,
    (that._y0 + 4 * that._y1 + y2) / 6
  );
}
function Basis$1(context) {
  this._context = context;
}
Basis$1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point$8(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        point$8(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function curveBasis(context) {
  return new Basis$1(context);
}
function BasisClosed$1(context) {
  this._context = context;
}
BasisClosed$1.prototype = {
  areaStart: noop$4,
  areaEnd: noop$4,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x2, this._y2 = y2;
        break;
      case 1:
        this._point = 2;
        this._x3 = x2, this._y3 = y2;
        break;
      case 2:
        this._point = 3;
        this._x4 = x2, this._y4 = y2;
        this._context.moveTo((this._x0 + 4 * this._x1 + x2) / 6, (this._y0 + 4 * this._y1 + y2) / 6);
        break;
      default:
        point$8(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function curveBasisClosed(context) {
  return new BasisClosed$1(context);
}
function BasisOpen$1(context) {
  this._context = context;
}
BasisOpen$1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x02 = (this._x0 + 4 * this._x1 + x2) / 6, y02 = (this._y0 + 4 * this._y1 + y2) / 6;
        this._line ? this._context.lineTo(x02, y02) : this._context.moveTo(x02, y02);
        break;
      case 3:
        this._point = 4;
      default:
        point$8(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function curveBasisOpen(context) {
  return new BasisOpen$1(context);
}
function LinearClosed$1(context) {
  this._context = context;
}
LinearClosed$1.prototype = {
  areaStart: noop$4,
  areaEnd: noop$4,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point)
      this._context.closePath();
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point)
      this._context.lineTo(x2, y2);
    else
      this._point = 1, this._context.moveTo(x2, y2);
  }
};
function curveLinearClosed(context) {
  return new LinearClosed$1(context);
}
function sign$2(x2) {
  return x2 < 0 ? -1 : 1;
}
function slope3$1(that, x2, y2) {
  var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign$2(s0) + sign$2(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope2$1(that, t4) {
  var h2 = that._x1 - that._x0;
  return h2 ? (3 * (that._y1 - that._y0) / h2 - t4) / 2 : t4;
}
function point$7(that, t02, t12) {
  var x02 = that._x0, y02 = that._y0, x12 = that._x1, y12 = that._y1, dx = (x12 - x02) / 3;
  that._context.bezierCurveTo(x02 + dx, y02 + dx * t02, x12 - dx, y12 - dx * t12, x12, y12);
}
function MonotoneX$1(context) {
  this._context = context;
}
MonotoneX$1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point$7(this, this._t0, slope2$1(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    var t12 = NaN;
    x2 = +x2, y2 = +y2;
    if (x2 === this._x1 && y2 === this._y1)
      return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point$7(this, slope2$1(this, t12 = slope3$1(this, x2, y2)), t12);
        break;
      default:
        point$7(this, this._t0, t12 = slope3$1(this, x2, y2));
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
    this._t0 = t12;
  }
};
function MonotoneY$1(context) {
  this._context = new ReflectContext$1(context);
}
(MonotoneY$1.prototype = Object.create(MonotoneX$1.prototype)).point = function(x2, y2) {
  MonotoneX$1.prototype.point.call(this, y2, x2);
};
function ReflectContext$1(context) {
  this._context = context;
}
ReflectContext$1.prototype = {
  moveTo: function(x2, y2) {
    this._context.moveTo(y2, x2);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x2, y2) {
    this._context.lineTo(y2, x2);
  },
  bezierCurveTo: function(x12, y12, x2, y2, x3, y3) {
    this._context.bezierCurveTo(y12, x12, y2, x2, y3, x3);
  }
};
function monotoneX$1(context) {
  return new MonotoneX$1(context);
}
function monotoneY$1(context) {
  return new MonotoneY$1(context);
}
function Natural$1(context) {
  this._context = context;
}
Natural$1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x2 = this._x, y2 = this._y, n = x2.length;
    if (n) {
      this._line ? this._context.lineTo(x2[0], y2[0]) : this._context.moveTo(x2[0], y2[0]);
      if (n === 2) {
        this._context.lineTo(x2[1], y2[1]);
      } else {
        var px = controlPoints$1(x2), py = controlPoints$1(y2);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x2[i1], y2[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n === 1)
      this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x2, y2) {
    this._x.push(+x2);
    this._y.push(+y2);
  }
};
function controlPoints$1(x2) {
  var i, n = x2.length - 1, m, a2 = new Array(n), b = new Array(n), r = new Array(n);
  a2[0] = 0, b[0] = 2, r[0] = x2[0] + 2 * x2[1];
  for (i = 1; i < n - 1; ++i)
    a2[i] = 1, b[i] = 4, r[i] = 4 * x2[i] + 2 * x2[i + 1];
  a2[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x2[n - 1] + x2[n];
  for (i = 1; i < n; ++i)
    m = a2[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a2[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i)
    a2[i] = (r[i] - a2[i + 1]) / b[i];
  b[n - 1] = (x2[n] + a2[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i)
    b[i] = 2 * x2[i + 1] - a2[i + 1];
  return [a2, b];
}
function curveNatural(context) {
  return new Natural$1(context);
}
function Step$1(context, t4) {
  this._context = context;
  this._t = t4;
}
Step$1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2)
      this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    if (this._line >= 0)
      this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y2);
          this._context.lineTo(x2, y2);
        } else {
          var x12 = this._x * (1 - this._t) + x2 * this._t;
          this._context.lineTo(x12, this._y);
          this._context.lineTo(x12, y2);
        }
        break;
      }
    }
    this._x = x2, this._y = y2;
  }
};
function curveStep(context) {
  return new Step$1(context, 0.5);
}
function stepBefore$1(context) {
  return new Step$1(context, 0);
}
function stepAfter$1(context) {
  return new Step$1(context, 1);
}
/*! @license DOMPurify 2.4.0 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.0/LICENSE */
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a2 = [null];
      a2.push.apply(a2, args2);
      var Constructor = Function.bind.apply(Parent2, a2);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var hasOwnProperty$3 = Object.hasOwnProperty, setPrototypeOf = Object.setPrototypeOf, isFrozen = Object.isFrozen, getPrototypeOf = Object.getPrototypeOf, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var freeze = Object.freeze, seal = Object.seal, create$2 = Object.create;
var _ref = typeof Reflect !== "undefined" && Reflect, apply$1 = _ref.apply, construct = _ref.construct;
if (!apply$1) {
  apply$1 = function apply2(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}
if (!freeze) {
  freeze = function freeze2(x2) {
    return x2;
  };
}
if (!seal) {
  seal = function seal2(x2) {
    return x2;
  };
}
if (!construct) {
  construct = function construct2(Func, args) {
    return _construct(Func, _toConsumableArray(args));
  };
}
var arrayForEach = unapply(Array.prototype.forEach);
var arrayPop = unapply(Array.prototype.pop);
var arrayPush = unapply(Array.prototype.push);
var stringToLowerCase = unapply(String.prototype.toLowerCase);
var stringMatch = unapply(String.prototype.match);
var stringReplace = unapply(String.prototype.replace);
var stringIndexOf = unapply(String.prototype.indexOf);
var stringTrim = unapply(String.prototype.trim);
var regExpTest = unapply(RegExp.prototype.test);
var typeErrorCreate = unconstruct(TypeError);
function unapply(func) {
  return function(thisArg) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return apply$1(func, thisArg, args);
  };
}
function unconstruct(func) {
  return function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return construct(func, args);
  };
}
function addToSet(set2, array2, transformCaseFunc) {
  transformCaseFunc = transformCaseFunc ? transformCaseFunc : stringToLowerCase;
  if (setPrototypeOf) {
    setPrototypeOf(set2, null);
  }
  var l2 = array2.length;
  while (l2--) {
    var element = array2[l2];
    if (typeof element === "string") {
      var lcElement = transformCaseFunc(element);
      if (lcElement !== element) {
        if (!isFrozen(array2)) {
          array2[l2] = lcElement;
        }
        element = lcElement;
      }
    }
    set2[element] = true;
  }
  return set2;
}
function clone$1(object2) {
  var newObject = create$2(null);
  var property;
  for (property in object2) {
    if (apply$1(hasOwnProperty$3, object2, [property])) {
      newObject[property] = object2[property];
    }
  }
  return newObject;
}
function lookupGetter(object2, prop) {
  while (object2 !== null) {
    var desc = getOwnPropertyDescriptor(object2, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }
      if (typeof desc.value === "function") {
        return unapply(desc.value);
      }
    }
    object2 = getPrototypeOf(object2);
  }
  function fallbackValue(element) {
    console.warn("fallback value for", element);
    return null;
  }
  return fallbackValue;
}
var html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
var svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
var mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]);
var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
var text$1 = freeze(["#text"]);
var html$2 = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]);
var svg$2 = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
var mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
var xml$1 = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
var IS_ALLOWED_URI = seal(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
);
var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
var ATTR_WHITESPACE = seal(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
);
var DOCTYPE_NAME = seal(/^html$/i);
var getGlobal = function getGlobal2() {
  return typeof window === "undefined" ? null : window;
};
var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, document2) {
  if (_typeof(trustedTypes) !== "object" || typeof trustedTypes.createPolicy !== "function") {
    return null;
  }
  var suffix = null;
  var ATTR_NAME = "data-tt-policy-suffix";
  if (document2.currentScript && document2.currentScript.hasAttribute(ATTR_NAME)) {
    suffix = document2.currentScript.getAttribute(ATTR_NAME);
  }
  var policyName = "dompurify" + (suffix ? "#" + suffix : "");
  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML: function createHTML(html2) {
        return html2;
      },
      createScriptURL: function createScriptURL(scriptUrl) {
        return scriptUrl;
      }
    });
  } catch (_2) {
    console.warn("TrustedTypes policy " + policyName + " could not be created.");
    return null;
  }
};
function createDOMPurify() {
  var window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
  var DOMPurify = function DOMPurify2(root2) {
    return createDOMPurify(root2);
  };
  DOMPurify.version = "2.4.0";
  DOMPurify.removed = [];
  if (!window2 || !window2.document || window2.document.nodeType !== 9) {
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  var originalDocument = window2.document;
  var document2 = window2.document;
  var DocumentFragment = window2.DocumentFragment, HTMLTemplateElement = window2.HTMLTemplateElement, Node2 = window2.Node, Element2 = window2.Element, NodeFilter = window2.NodeFilter, _window$NamedNodeMap = window2.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window2.NamedNodeMap || window2.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement = window2.HTMLFormElement, DOMParser2 = window2.DOMParser, trustedTypes = window2.trustedTypes;
  var ElementPrototype = Element2.prototype;
  var cloneNode = lookupGetter(ElementPrototype, "cloneNode");
  var getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
  var getChildNodes = lookupGetter(ElementPrototype, "childNodes");
  var getParentNode = lookupGetter(ElementPrototype, "parentNode");
  if (typeof HTMLTemplateElement === "function") {
    var template2 = document2.createElement("template");
    if (template2.content && template2.content.ownerDocument) {
      document2 = template2.content.ownerDocument;
    }
  }
  var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
  var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML("") : "";
  var _document = document2, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
  var importNode = originalDocument.importNode;
  var documentMode = {};
  try {
    documentMode = clone$1(document2).documentMode ? document2.documentMode : {};
  } catch (_2) {
  }
  var hooks = {};
  DOMPurify.isSupported = typeof getParentNode === "function" && implementation && typeof implementation.createHTMLDocument !== "undefined" && documentMode !== 9;
  var MUSTACHE_EXPR$1 = MUSTACHE_EXPR, ERB_EXPR$1 = ERB_EXPR, DATA_ATTR$1 = DATA_ATTR, ARIA_ATTR$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$1 = ATTR_WHITESPACE;
  var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
  var ALLOWED_TAGS = null;
  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text$1)));
  var ALLOWED_ATTR = null;
  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html$2), _toConsumableArray(svg$2), _toConsumableArray(mathMl), _toConsumableArray(xml$1)));
  var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));
  var FORBID_TAGS = null;
  var FORBID_ATTR = null;
  var ALLOW_ARIA_ATTR = true;
  var ALLOW_DATA_ATTR = true;
  var ALLOW_UNKNOWN_PROTOCOLS = false;
  var SAFE_FOR_TEMPLATES = false;
  var WHOLE_DOCUMENT = false;
  var SET_CONFIG = false;
  var FORCE_BODY = false;
  var RETURN_DOM = false;
  var RETURN_DOM_FRAGMENT = false;
  var RETURN_TRUSTED_TYPE = false;
  var SANITIZE_DOM = true;
  var SANITIZE_NAMED_PROPS = false;
  var SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
  var KEEP_CONTENT = true;
  var IN_PLACE = false;
  var USE_PROFILES = {};
  var FORBID_CONTENTS = null;
  var DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  var DATA_URI_TAGS = null;
  var DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
  var URI_SAFE_ATTRIBUTES = null;
  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
  var MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
  var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
  var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
  var NAMESPACE = HTML_NAMESPACE;
  var IS_EMPTY_INPUT = false;
  var PARSER_MEDIA_TYPE;
  var SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
  var DEFAULT_PARSER_MEDIA_TYPE = "text/html";
  var transformCaseFunc;
  var CONFIG = null;
  var formElement = document2.createElement("form");
  var isRegexOrFunction = function isRegexOrFunction2(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };
  var _parseConfig = function _parseConfig2(cfg) {
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    if (!cfg || _typeof(cfg) !== "object") {
      cfg = {};
    }
    cfg = clone$1(cfg);
    PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
    transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? function(x2) {
      return x2;
    } : stringToLowerCase;
    ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
    URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(
      clone$1(DEFAULT_URI_SAFE_ATTRIBUTES),
      cfg.ADD_URI_SAFE_ATTR,
      transformCaseFunc
    ) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(
      clone$1(DEFAULT_DATA_URI_TAGS),
      cfg.ADD_DATA_URI_TAGS,
      transformCaseFunc
    ) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
    FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
    USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
    RETURN_DOM = cfg.RETURN_DOM || false;
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
    FORCE_BODY = cfg.FORCE_BODY || false;
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
    IN_PLACE = cfg.IN_PLACE || false;
    IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, _toConsumableArray(text$1));
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html$1);
        addToSet(ALLOWED_ATTR, html$2);
      }
      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg$1);
        addToSet(ALLOWED_ATTR, svg$2);
        addToSet(ALLOWED_ATTR, xml$1);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg$2);
        addToSet(ALLOWED_ATTR, xml$1);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl$1);
        addToSet(ALLOWED_ATTR, mathMl);
        addToSet(ALLOWED_ATTR, xml$1);
      }
    }
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone$1(ALLOWED_TAGS);
      }
      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
    }
    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone$1(ALLOWED_ATTR);
      }
      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone$1(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
    }
    if (KEEP_CONTENT) {
      ALLOWED_TAGS["#text"] = true;
    }
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
    }
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ["tbody"]);
      delete FORBID_TAGS.tbody;
    }
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
  var HTML_INTEGRATION_POINTS = addToSet({}, ["foreignobject", "desc", "title", "annotation-xml"]);
  var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
  var ALL_SVG_TAGS = addToSet({}, svg$1);
  addToSet(ALL_SVG_TAGS, svgFilters);
  addToSet(ALL_SVG_TAGS, svgDisallowed);
  var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
  var _checkValidNamespace = function _checkValidNamespace2(element) {
    var parent = getParentNode(element);
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: HTML_NAMESPACE,
        tagName: "template"
      };
    }
    var tagName = stringToLowerCase(element.tagName);
    var parentTagName = stringToLowerCase(parent.tagName);
    if (element.namespaceURI === SVG_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "svg";
      }
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }
      return Boolean(ALL_SVG_TAGS[tagName]);
    }
    if (element.namespaceURI === MATHML_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "math";
      }
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
      }
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }
    if (element.namespaceURI === HTML_NAMESPACE) {
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
    }
    return false;
  };
  var _forceRemove = function _forceRemove2(node2) {
    arrayPush(DOMPurify.removed, {
      element: node2
    });
    try {
      node2.parentNode.removeChild(node2);
    } catch (_2) {
      try {
        node2.outerHTML = emptyHTML;
      } catch (_3) {
        node2.remove();
      }
    }
  };
  var _removeAttribute = function _removeAttribute2(name2, node2) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: node2.getAttributeNode(name2),
        from: node2
      });
    } catch (_2) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: node2
      });
    }
    node2.removeAttribute(name2);
    if (name2 === "is" && !ALLOWED_ATTR[name2]) {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(node2);
        } catch (_2) {
        }
      } else {
        try {
          node2.setAttribute(name2, "");
        } catch (_2) {
        }
      }
    }
  };
  var _initDocument = function _initDocument2(dirty) {
    var doc2;
    var leadingWhitespace;
    if (FORCE_BODY) {
      dirty = "<remove></remove>" + dirty;
    } else {
      var matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml") {
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
    }
    var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc2 = new DOMParser2().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_2) {
      }
    }
    if (!doc2 || !doc2.documentElement) {
      doc2 = implementation.createDocument(NAMESPACE, "template", null);
      try {
        doc2.documentElement.innerHTML = IS_EMPTY_INPUT ? "" : dirtyPayload;
      } catch (_2) {
      }
    }
    var body = doc2.body || doc2.documentElement;
    if (dirty && leadingWhitespace) {
      body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc2, WHOLE_DOCUMENT ? "html" : "body")[0];
    }
    return WHOLE_DOCUMENT ? doc2.documentElement : body;
  };
  var _createIterator = function _createIterator2(root2) {
    return createNodeIterator.call(
      root2.ownerDocument || root2,
      root2,
      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT,
      null,
      false
    );
  };
  var _isClobbered = function _isClobbered2(elm) {
    return elm instanceof HTMLFormElement && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function");
  };
  var _isNode = function _isNode2(object2) {
    return _typeof(Node2) === "object" ? object2 instanceof Node2 : object2 && _typeof(object2) === "object" && typeof object2.nodeType === "number" && typeof object2.nodeName === "string";
  };
  var _executeHook = function _executeHook2(entryPoint, currentNode, data2) {
    if (!hooks[entryPoint]) {
      return;
    }
    arrayForEach(hooks[entryPoint], function(hook) {
      hook.call(DOMPurify, currentNode, data2, CONFIG);
    });
  };
  var _sanitizeElements = function _sanitizeElements2(currentNode) {
    var content2;
    _executeHook("beforeSanitizeElements", currentNode, null);
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
      _forceRemove(currentNode);
      return true;
    }
    var tagName = transformCaseFunc(currentNode.nodeName);
    _executeHook("uponSanitizeElement", currentNode, {
      tagName,
      allowedTags: ALLOWED_TAGS
    });
    if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }
    if (tagName === "select" && regExpTest(/<template/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))
          return false;
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))
          return false;
      }
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        var parentNode = getParentNode(currentNode) || currentNode.parentNode;
        var childNodes = getChildNodes(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode) {
          var childCount = childNodes.length;
          for (var i = childCount - 1; i >= 0; --i) {
            parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
          }
        }
      }
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if ((tagName === "noscript" || tagName === "noembed") && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
      content2 = currentNode.textContent;
      content2 = stringReplace(content2, MUSTACHE_EXPR$1, " ");
      content2 = stringReplace(content2, ERB_EXPR$1, " ");
      if (currentNode.textContent !== content2) {
        arrayPush(DOMPurify.removed, {
          element: currentNode.cloneNode()
        });
        currentNode.textContent = content2;
      }
    }
    _executeHook("afterSanitizeElements", currentNode, null);
    return false;
  };
  var _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
    if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
      return false;
    }
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName))
      ;
    else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName))
      ;
    else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value)))
        ;
      else {
        return false;
      }
    } else if (URI_SAFE_ATTRIBUTES[lcName])
      ;
    else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE$1, "")))
      ;
    else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag])
      ;
    else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value, ATTR_WHITESPACE$1, "")))
      ;
    else if (!value)
      ;
    else {
      return false;
    }
    return true;
  };
  var _basicCustomElementTest = function _basicCustomElementTest2(tagName) {
    return tagName.indexOf("-") > 0;
  };
  var _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
    var attr;
    var value;
    var lcName;
    var l2;
    _executeHook("beforeSanitizeAttributes", currentNode, null);
    var attributes = currentNode.attributes;
    if (!attributes) {
      return;
    }
    var hookEvent = {
      attrName: "",
      attrValue: "",
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR
    };
    l2 = attributes.length;
    while (l2--) {
      attr = attributes[l2];
      var _attr = attr, name2 = _attr.name, namespaceURI = _attr.namespaceURI;
      value = name2 === "value" ? attr.value : stringTrim(attr.value);
      lcName = transformCaseFunc(name2);
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = void 0;
      _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
      value = hookEvent.attrValue;
      if (hookEvent.forceKeepAttr) {
        continue;
      }
      _removeAttribute(name2, currentNode);
      if (!hookEvent.keepAttr) {
        continue;
      }
      if (regExpTest(/\/>/i, value)) {
        _removeAttribute(name2, currentNode);
        continue;
      }
      if (SAFE_FOR_TEMPLATES) {
        value = stringReplace(value, MUSTACHE_EXPR$1, " ");
        value = stringReplace(value, ERB_EXPR$1, " ");
      }
      var lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }
      if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
        _removeAttribute(name2, currentNode);
        value = SANITIZE_NAMED_PROPS_PREFIX + value;
      }
      if (trustedTypesPolicy && _typeof(trustedTypes) === "object" && typeof trustedTypes.getAttributeType === "function") {
        if (namespaceURI)
          ;
        else {
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case "TrustedHTML":
              value = trustedTypesPolicy.createHTML(value);
              break;
            case "TrustedScriptURL":
              value = trustedTypesPolicy.createScriptURL(value);
              break;
          }
        }
      }
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name2, value);
        } else {
          currentNode.setAttribute(name2, value);
        }
        arrayPop(DOMPurify.removed);
      } catch (_2) {
      }
    }
    _executeHook("afterSanitizeAttributes", currentNode, null);
  };
  var _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
    var shadowNode;
    var shadowIterator = _createIterator(fragment);
    _executeHook("beforeSanitizeShadowDOM", fragment, null);
    while (shadowNode = shadowIterator.nextNode()) {
      _executeHook("uponSanitizeShadowNode", shadowNode, null);
      if (_sanitizeElements(shadowNode)) {
        continue;
      }
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM2(shadowNode.content);
      }
      _sanitizeAttributes(shadowNode);
    }
    _executeHook("afterSanitizeShadowDOM", fragment, null);
  };
  DOMPurify.sanitize = function(dirty) {
    var cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var body;
    var importedNode;
    var currentNode;
    var oldNode;
    var returnNode;
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = "<!-->";
    }
    if (typeof dirty !== "string" && !_isNode(dirty)) {
      if (typeof dirty.toString !== "function") {
        throw typeErrorCreate("toString is not a function");
      } else {
        dirty = dirty.toString();
        if (typeof dirty !== "string") {
          throw typeErrorCreate("dirty is not a string, aborting");
        }
      }
    }
    if (!DOMPurify.isSupported) {
      if (_typeof(window2.toStaticHTML) === "object" || typeof window2.toStaticHTML === "function") {
        if (typeof dirty === "string") {
          return window2.toStaticHTML(dirty);
        }
        if (_isNode(dirty)) {
          return window2.toStaticHTML(dirty.outerHTML);
        }
      }
      return dirty;
    }
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    DOMPurify.removed = [];
    if (typeof dirty === "string") {
      IN_PLACE = false;
    }
    if (IN_PLACE) {
      if (dirty.nodeName) {
        var tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
        }
      }
    } else if (dirty instanceof Node2) {
      body = _initDocument("<!---->");
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
        body = importedNode;
      } else if (importedNode.nodeName === "HTML") {
        body = importedNode;
      } else {
        body.appendChild(importedNode);
      }
    } else {
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf("<") === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      body = _initDocument(dirty);
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
      }
    }
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
    while (currentNode = nodeIterator.nextNode()) {
      if (currentNode.nodeType === 3 && currentNode === oldNode) {
        continue;
      }
      if (_sanitizeElements(currentNode)) {
        continue;
      }
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }
      _sanitizeAttributes(currentNode);
      oldNode = currentNode;
    }
    oldNode = null;
    if (IN_PLACE) {
      return dirty;
    }
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);
        while (body.firstChild) {
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }
      if (ALLOWED_ATTR.shadowroot) {
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
    }
    if (SAFE_FOR_TEMPLATES) {
      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, " ");
      serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, " ");
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  DOMPurify.setConfig = function(cfg) {
    _parseConfig(cfg);
    SET_CONFIG = true;
  };
  DOMPurify.clearConfig = function() {
    CONFIG = null;
    SET_CONFIG = false;
  };
  DOMPurify.isValidAttribute = function(tag, attr, value) {
    if (!CONFIG) {
      _parseConfig({});
    }
    var lcTag = transformCaseFunc(tag);
    var lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };
  DOMPurify.addHook = function(entryPoint, hookFunction) {
    if (typeof hookFunction !== "function") {
      return;
    }
    hooks[entryPoint] = hooks[entryPoint] || [];
    arrayPush(hooks[entryPoint], hookFunction);
  };
  DOMPurify.removeHook = function(entryPoint) {
    if (hooks[entryPoint]) {
      return arrayPop(hooks[entryPoint]);
    }
  };
  DOMPurify.removeHooks = function(entryPoint) {
    if (hooks[entryPoint]) {
      hooks[entryPoint] = [];
    }
  };
  DOMPurify.removeAllHooks = function() {
    hooks = {};
  };
  return DOMPurify;
}
var purify = createDOMPurify();
const Channel = {
  min: {
    r: 0,
    g: 0,
    b: 0,
    s: 0,
    l: 0,
    a: 0
  },
  max: {
    r: 255,
    g: 255,
    b: 255,
    h: 360,
    s: 100,
    l: 100,
    a: 1
  },
  clamp: {
    r: (r) => r >= 255 ? 255 : r < 0 ? 0 : r,
    g: (g2) => g2 >= 255 ? 255 : g2 < 0 ? 0 : g2,
    b: (b) => b >= 255 ? 255 : b < 0 ? 0 : b,
    h: (h2) => h2 % 360,
    s: (s2) => s2 >= 100 ? 100 : s2 < 0 ? 0 : s2,
    l: (l2) => l2 >= 100 ? 100 : l2 < 0 ? 0 : l2,
    a: (a2) => a2 >= 1 ? 1 : a2 < 0 ? 0 : a2
  },
  toLinear: (c2) => {
    const n = c2 / 255;
    return c2 > 0.03928 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92;
  },
  hue2rgb: (p, q, t4) => {
    if (t4 < 0)
      t4 += 1;
    if (t4 > 1)
      t4 -= 1;
    if (t4 < 1 / 6)
      return p + (q - p) * 6 * t4;
    if (t4 < 1 / 2)
      return q;
    if (t4 < 2 / 3)
      return p + (q - p) * (2 / 3 - t4) * 6;
    return p;
  },
  hsl2rgb: ({ h: h2, s: s2, l: l2 }, channel2) => {
    if (!s2)
      return l2 * 2.55;
    h2 /= 360;
    s2 /= 100;
    l2 /= 100;
    const q = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
    const p = 2 * l2 - q;
    switch (channel2) {
      case "r":
        return Channel.hue2rgb(p, q, h2 + 1 / 3) * 255;
      case "g":
        return Channel.hue2rgb(p, q, h2) * 255;
      case "b":
        return Channel.hue2rgb(p, q, h2 - 1 / 3) * 255;
    }
  },
  rgb2hsl: ({ r, g: g2, b }, channel2) => {
    r /= 255;
    g2 /= 255;
    b /= 255;
    const max2 = Math.max(r, g2, b);
    const min2 = Math.min(r, g2, b);
    const l2 = (max2 + min2) / 2;
    if (channel2 === "l")
      return l2 * 100;
    if (max2 === min2)
      return 0;
    const d = max2 - min2;
    const s2 = l2 > 0.5 ? d / (2 - max2 - min2) : d / (max2 + min2);
    if (channel2 === "s")
      return s2 * 100;
    switch (max2) {
      case r:
        return ((g2 - b) / d + (g2 < b ? 6 : 0)) * 60;
      case g2:
        return ((b - r) / d + 2) * 60;
      case b:
        return ((r - g2) / d + 4) * 60;
      default:
        return -1;
    }
  }
};
const channel = Channel;
const Lang = {
  clamp: (number3, lower2, upper) => {
    if (lower2 > upper)
      return Math.min(lower2, Math.max(upper, number3));
    return Math.min(upper, Math.max(lower2, number3));
  },
  round: (number3) => {
    return Math.round(number3 * 1e10) / 1e10;
  }
};
const lang = Lang;
const Unit = {
  dec2hex: (dec2) => {
    const hex2 = Math.round(dec2).toString(16);
    return hex2.length > 1 ? hex2 : `0${hex2}`;
  }
};
const unit$1 = Unit;
const Utils = {
  channel,
  lang,
  unit: unit$1
};
const _$D = Utils;
const DEC2HEX = {};
for (let i = 0; i <= 255; i++)
  DEC2HEX[i] = _$D.unit.dec2hex(i);
const TYPE = {
  ALL: 0,
  RGB: 1,
  HSL: 2
};
class Type {
  constructor() {
    this.type = TYPE.ALL;
  }
  get() {
    return this.type;
  }
  set(type2) {
    if (this.type && this.type !== type2)
      throw new Error("Cannot change both RGB and HSL channels at the same time");
    this.type = type2;
  }
  reset() {
    this.type = TYPE.ALL;
  }
  is(type2) {
    return this.type === type2;
  }
}
const Type$1 = Type;
class Channels {
  constructor(data2, color2) {
    this.color = color2;
    this.changed = false;
    this.data = data2;
    this.type = new Type$1();
  }
  set(data2, color2) {
    this.color = color2;
    this.changed = false;
    this.data = data2;
    this.type.type = TYPE.ALL;
    return this;
  }
  _ensureHSL() {
    const data2 = this.data;
    const { h: h2, s: s2, l: l2 } = data2;
    if (h2 === void 0)
      data2.h = _$D.channel.rgb2hsl(data2, "h");
    if (s2 === void 0)
      data2.s = _$D.channel.rgb2hsl(data2, "s");
    if (l2 === void 0)
      data2.l = _$D.channel.rgb2hsl(data2, "l");
  }
  _ensureRGB() {
    const data2 = this.data;
    const { r, g: g2, b } = data2;
    if (r === void 0)
      data2.r = _$D.channel.hsl2rgb(data2, "r");
    if (g2 === void 0)
      data2.g = _$D.channel.hsl2rgb(data2, "g");
    if (b === void 0)
      data2.b = _$D.channel.hsl2rgb(data2, "b");
  }
  get r() {
    const data2 = this.data;
    const r = data2.r;
    if (!this.type.is(TYPE.HSL) && r !== void 0)
      return r;
    this._ensureHSL();
    return _$D.channel.hsl2rgb(data2, "r");
  }
  get g() {
    const data2 = this.data;
    const g2 = data2.g;
    if (!this.type.is(TYPE.HSL) && g2 !== void 0)
      return g2;
    this._ensureHSL();
    return _$D.channel.hsl2rgb(data2, "g");
  }
  get b() {
    const data2 = this.data;
    const b = data2.b;
    if (!this.type.is(TYPE.HSL) && b !== void 0)
      return b;
    this._ensureHSL();
    return _$D.channel.hsl2rgb(data2, "b");
  }
  get h() {
    const data2 = this.data;
    const h2 = data2.h;
    if (!this.type.is(TYPE.RGB) && h2 !== void 0)
      return h2;
    this._ensureRGB();
    return _$D.channel.rgb2hsl(data2, "h");
  }
  get s() {
    const data2 = this.data;
    const s2 = data2.s;
    if (!this.type.is(TYPE.RGB) && s2 !== void 0)
      return s2;
    this._ensureRGB();
    return _$D.channel.rgb2hsl(data2, "s");
  }
  get l() {
    const data2 = this.data;
    const l2 = data2.l;
    if (!this.type.is(TYPE.RGB) && l2 !== void 0)
      return l2;
    this._ensureRGB();
    return _$D.channel.rgb2hsl(data2, "l");
  }
  get a() {
    return this.data.a;
  }
  set r(r) {
    this.type.set(TYPE.RGB);
    this.changed = true;
    this.data.r = r;
  }
  set g(g2) {
    this.type.set(TYPE.RGB);
    this.changed = true;
    this.data.g = g2;
  }
  set b(b) {
    this.type.set(TYPE.RGB);
    this.changed = true;
    this.data.b = b;
  }
  set h(h2) {
    this.type.set(TYPE.HSL);
    this.changed = true;
    this.data.h = h2;
  }
  set s(s2) {
    this.type.set(TYPE.HSL);
    this.changed = true;
    this.data.s = s2;
  }
  set l(l2) {
    this.type.set(TYPE.HSL);
    this.changed = true;
    this.data.l = l2;
  }
  set a(a2) {
    this.changed = true;
    this.data.a = a2;
  }
}
const Channels$1 = Channels;
const channels = new Channels$1({ r: 0, g: 0, b: 0, a: 0 }, "transparent");
const ChannelsReusable = channels;
const Hex = {
  re: /^#((?:[a-f0-9]{2}){2,4}|[a-f0-9]{3})$/i,
  parse: (color2) => {
    if (color2.charCodeAt(0) !== 35)
      return;
    const match = color2.match(Hex.re);
    if (!match)
      return;
    const hex2 = match[1];
    const dec2 = parseInt(hex2, 16);
    const length2 = hex2.length;
    const hasAlpha = length2 % 4 === 0;
    const isFullLength = length2 > 4;
    const multiplier = isFullLength ? 1 : 17;
    const bits = isFullLength ? 8 : 4;
    const bitsOffset = hasAlpha ? 0 : -1;
    const mask = isFullLength ? 255 : 15;
    return ChannelsReusable.set({
      r: (dec2 >> bits * (bitsOffset + 3) & mask) * multiplier,
      g: (dec2 >> bits * (bitsOffset + 2) & mask) * multiplier,
      b: (dec2 >> bits * (bitsOffset + 1) & mask) * multiplier,
      a: hasAlpha ? (dec2 & mask) * multiplier / 255 : 1
    }, color2);
  },
  stringify: (channels2) => {
    const { r, g: g2, b, a: a2 } = channels2;
    if (a2 < 1) {
      return `#${DEC2HEX[Math.round(r)]}${DEC2HEX[Math.round(g2)]}${DEC2HEX[Math.round(b)]}${DEC2HEX[Math.round(a2 * 255)]}`;
    } else {
      return `#${DEC2HEX[Math.round(r)]}${DEC2HEX[Math.round(g2)]}${DEC2HEX[Math.round(b)]}`;
    }
  }
};
const Hex$1 = Hex;
const HSL = {
  re: /^hsla?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(?:deg|grad|rad|turn)?)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(%)?))?\s*?\)$/i,
  hueRe: /^(.+?)(deg|grad|rad|turn)$/i,
  _hue2deg: (hue2) => {
    const match = hue2.match(HSL.hueRe);
    if (match) {
      const [, number3, unit2] = match;
      switch (unit2) {
        case "grad":
          return _$D.channel.clamp.h(parseFloat(number3) * 0.9);
        case "rad":
          return _$D.channel.clamp.h(parseFloat(number3) * 180 / Math.PI);
        case "turn":
          return _$D.channel.clamp.h(parseFloat(number3) * 360);
      }
    }
    return _$D.channel.clamp.h(parseFloat(hue2));
  },
  parse: (color2) => {
    const charCode = color2.charCodeAt(0);
    if (charCode !== 104 && charCode !== 72)
      return;
    const match = color2.match(HSL.re);
    if (!match)
      return;
    const [, h2, s2, l2, a2, isAlphaPercentage] = match;
    return ChannelsReusable.set({
      h: HSL._hue2deg(h2),
      s: _$D.channel.clamp.s(parseFloat(s2)),
      l: _$D.channel.clamp.l(parseFloat(l2)),
      a: a2 ? _$D.channel.clamp.a(isAlphaPercentage ? parseFloat(a2) / 100 : parseFloat(a2)) : 1
    }, color2);
  },
  stringify: (channels2) => {
    const { h: h2, s: s2, l: l2, a: a2 } = channels2;
    if (a2 < 1) {
      return `hsla(${_$D.lang.round(h2)}, ${_$D.lang.round(s2)}%, ${_$D.lang.round(l2)}%, ${a2})`;
    } else {
      return `hsl(${_$D.lang.round(h2)}, ${_$D.lang.round(s2)}%, ${_$D.lang.round(l2)}%)`;
    }
  }
};
const HSL$1 = HSL;
const Keyword = {
  colors: {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyanaqua: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    transparent: "#00000000",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  },
  parse: (color2) => {
    color2 = color2.toLowerCase();
    const hex2 = Keyword.colors[color2];
    if (!hex2)
      return;
    return Hex$1.parse(hex2);
  },
  stringify: (channels2) => {
    const hex2 = Hex$1.stringify(channels2);
    for (const name2 in Keyword.colors) {
      if (Keyword.colors[name2] === hex2)
        return name2;
    }
    return;
  }
};
const Keyword$1 = Keyword;
const RGB = {
  re: /^rgba?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?)))?\s*?\)$/i,
  parse: (color2) => {
    const charCode = color2.charCodeAt(0);
    if (charCode !== 114 && charCode !== 82)
      return;
    const match = color2.match(RGB.re);
    if (!match)
      return;
    const [, r, isRedPercentage, g2, isGreenPercentage, b, isBluePercentage, a2, isAlphaPercentage] = match;
    return ChannelsReusable.set({
      r: _$D.channel.clamp.r(isRedPercentage ? parseFloat(r) * 2.55 : parseFloat(r)),
      g: _$D.channel.clamp.g(isGreenPercentage ? parseFloat(g2) * 2.55 : parseFloat(g2)),
      b: _$D.channel.clamp.b(isBluePercentage ? parseFloat(b) * 2.55 : parseFloat(b)),
      a: a2 ? _$D.channel.clamp.a(isAlphaPercentage ? parseFloat(a2) / 100 : parseFloat(a2)) : 1
    }, color2);
  },
  stringify: (channels2) => {
    const { r, g: g2, b, a: a2 } = channels2;
    if (a2 < 1) {
      return `rgba(${_$D.lang.round(r)}, ${_$D.lang.round(g2)}, ${_$D.lang.round(b)}, ${_$D.lang.round(a2)})`;
    } else {
      return `rgb(${_$D.lang.round(r)}, ${_$D.lang.round(g2)}, ${_$D.lang.round(b)})`;
    }
  }
};
const RGB$1 = RGB;
const Color$1 = {
  format: {
    keyword: Keyword$1,
    hex: Hex$1,
    rgb: RGB$1,
    rgba: RGB$1,
    hsl: HSL$1,
    hsla: HSL$1
  },
  parse: (color2) => {
    if (typeof color2 !== "string")
      return color2;
    const channels2 = Hex$1.parse(color2) || RGB$1.parse(color2) || HSL$1.parse(color2) || Keyword$1.parse(color2);
    if (channels2)
      return channels2;
    throw new Error(`Unsupported color format: "${color2}"`);
  },
  stringify: (channels2) => {
    if (!channels2.changed && channels2.color)
      return channels2.color;
    if (channels2.type.is(TYPE.HSL) || channels2.data.r === void 0) {
      return HSL$1.stringify(channels2);
    } else if (channels2.a < 1 || !Number.isInteger(channels2.r) || !Number.isInteger(channels2.g) || !Number.isInteger(channels2.b)) {
      return RGB$1.stringify(channels2);
    } else {
      return Hex$1.stringify(channels2);
    }
  }
};
const Color$2 = Color$1;
const change = (color2, channels2) => {
  const ch = Color$2.parse(color2);
  for (const c2 in channels2) {
    ch[c2] = _$D.channel.clamp[c2](channels2[c2]);
  }
  return Color$2.stringify(ch);
};
const change$1 = change;
const rgba$1 = (r, g2, b = 0, a2 = 1) => {
  if (typeof r !== "number")
    return change$1(r, { a: g2 });
  const channels2 = ChannelsReusable.set({
    r: _$D.channel.clamp.r(r),
    g: _$D.channel.clamp.g(g2),
    b: _$D.channel.clamp.b(b),
    a: _$D.channel.clamp.a(a2)
  });
  return Color$2.stringify(channels2);
};
const rgba$2 = rgba$1;
const luminance = (color2) => {
  const { r, g: g2, b } = Color$2.parse(color2);
  const luminance2 = 0.2126 * _$D.channel.toLinear(r) + 0.7152 * _$D.channel.toLinear(g2) + 0.0722 * _$D.channel.toLinear(b);
  return _$D.lang.round(luminance2);
};
const luminance$1 = luminance;
const contrast = (color1, color2) => {
  const luminance1 = luminance$1(color1);
  const luminance2 = luminance$1(color2);
  const max2 = Math.max(luminance1, luminance2);
  const min2 = Math.min(luminance1, luminance2);
  const ratio = (max2 + Number.EPSILON) / (min2 + Number.EPSILON);
  return _$D.lang.round(_$D.lang.clamp(ratio, 1, 10));
};
const contrast$1 = contrast;
const adjustChannel = (color2, channel2, amount) => {
  const channels2 = Color$2.parse(color2);
  const amountCurrent = channels2[channel2];
  const amountNext = _$D.channel.clamp[channel2](amountCurrent + amount);
  if (amountCurrent !== amountNext)
    channels2[channel2] = amountNext;
  return Color$2.stringify(channels2);
};
const adjustChannel$1 = adjustChannel;
const lighten = (color2, amount) => {
  return adjustChannel$1(color2, "l", amount);
};
const lighten$1 = lighten;
const darken = (color2, amount) => {
  return adjustChannel$1(color2, "l", -amount);
};
const darken$1 = darken;
const adjust$1 = (color2, channels2) => {
  const ch = Color$2.parse(color2);
  const changes = {};
  for (const c2 in channels2) {
    if (!channels2[c2])
      continue;
    changes[c2] = ch[c2] + channels2[c2];
  }
  return change$1(color2, changes);
};
const adjust$2 = adjust$1;
const mix = (color1, color2, weight = 50) => {
  const { r: r1, g: g1, b: b12, a: a1 } = Color$2.parse(color1);
  const { r: r2, g: g2, b: b22, a: a2 } = Color$2.parse(color2);
  const weightScale = weight / 100;
  const weightNormalized = weightScale * 2 - 1;
  const alphaDelta = a1 - a2;
  const weight1combined = weightNormalized * alphaDelta === -1 ? weightNormalized : (weightNormalized + alphaDelta) / (1 + weightNormalized * alphaDelta);
  const weight1 = (weight1combined + 1) / 2;
  const weight2 = 1 - weight1;
  const r = r1 * weight1 + r2 * weight2;
  const g3 = g1 * weight1 + g2 * weight2;
  const b = b12 * weight1 + b22 * weight2;
  const a3 = a1 * weightScale + a2 * (1 - weightScale);
  return rgba$2(r, g3, b, a3);
};
const mix$1 = mix;
const invert = (color2, weight = 100) => {
  const inverse = Color$2.parse(color2);
  inverse.r = 255 - inverse.r;
  inverse.g = 255 - inverse.g;
  inverse.b = 255 - inverse.b;
  return mix$1(inverse, color2, weight);
};
const invert$1 = invert;
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var abs$2 = Math.abs;
var from = String.fromCharCode;
function trim(value) {
  return value.trim();
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end2) {
  return value.slice(begin, end2);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array2) {
  return array2.push(value), value;
}
var line$1 = 1;
var column = 1;
var length$3 = 0;
var position$2 = 0;
var character = 0;
var characters = "";
function node(value, root2, parent, type2, props, children2, length2) {
  return { value, root: root2, parent, type: type2, props, children: children2, line: line$1, column, length: length2, return: "" };
}
function char() {
  return character;
}
function prev() {
  character = position$2 > 0 ? charat(characters, --position$2) : 0;
  if (column--, character === 10)
    column = 1, line$1--;
  return character;
}
function next() {
  character = position$2 < length$3 ? charat(characters, position$2++) : 0;
  if (column++, character === 10)
    column = 1, line$1++;
  return character;
}
function peek() {
  return charat(characters, position$2);
}
function caret() {
  return position$2;
}
function slice$7(begin, end2) {
  return substr(characters, begin, end2);
}
function token(type2) {
  switch (type2) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line$1 = column = 1, length$3 = strlen(characters = value), position$2 = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type2) {
  return trim(slice$7(position$2 - 1, delimiter(type2 === 91 ? type2 + 2 : type2 === 40 ? type2 + 1 : type2)));
}
function whitespace(type2) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type2) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count2) {
  while (--count2 && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice$7(index2, caret() + (count2 < 6 && peek() == 32 && next() == 32));
}
function delimiter(type2) {
  while (next())
    switch (character) {
      case type2:
        return position$2;
      case 34:
      case 39:
        if (type2 !== 34 && type2 !== 39)
          delimiter(character);
        break;
      case 40:
        if (type2 === 41)
          delimiter(type2);
        break;
      case 92:
        next();
        break;
    }
  return position$2;
}
function commenter(type2, index2) {
  while (next())
    if (type2 + character === 47 + 10)
      break;
    else if (type2 + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice$7(index2, position$2 - 1) + "*" + from(type2 === 47 ? type2 : next());
}
function identifier(index2) {
  while (!token(peek()))
    next();
  return slice$7(index2, position$2);
}
function compile(value) {
  return dealloc(parse$2("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse$2(value, root2, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type2 = "";
  var props = rules;
  var children2 = rulesets;
  var reference = rule;
  var characters2 = type2;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root2, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset:
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root2, parent, index2, offset, rules, points, type2, props = [], children2 = [], length2), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse$2(characters2, root2, reference, reference, props, rulesets, length2, points, children2);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 109:
                  case 115:
                    parse$2(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type2, rules, props = [], length2), children2), rules, children2, length2, points, rule ? props : children2);
                    break;
                  default:
                    parse$2(characters2, reference, reference, reference, [""], children2, 0, points, children2);
                }
        }
        index2 = offset = property = 0, variable = ampersand = 1, type2 = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset = length2 = strlen(type2 = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root2, parent, index2, offset, rules, points, type2, props, children2, length2) {
  var post = offset - 1;
  var rule = offset === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i = 0, j2 = 0, k2 = 0; i < index2; ++i)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs$2(j2 = points[i])), z = value; x2 < size; ++x2)
      if (z = trim(j2 > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
        props[k2++] = z;
  return node(value, root2, parent, offset === 0 ? RULESET : type2, props, children2, length2);
}
function comment(value, root2, parent) {
  return node(value, root2, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root2, parent, length2) {
  return node(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function serialize(children2, callback) {
  var output = "";
  var length2 = sizeof(children2);
  for (var i = 0; i < length2; i++)
    output += callback(children2[i], i, children2, callback) || "";
  return output;
}
function stringify(element, index2, children2, callback) {
  switch (element.type) {
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children2 = serialize(element.children, callback)) ? element.return = element.value + "{" + children2 + "}" : "";
}
var _listCacheClear$1;
var hasRequired_listCacheClear;
function require_listCacheClear() {
  if (hasRequired_listCacheClear)
    return _listCacheClear$1;
  hasRequired_listCacheClear = 1;
  function listCacheClear2() {
    this.__data__ = [];
    this.size = 0;
  }
  _listCacheClear$1 = listCacheClear2;
  return _listCacheClear$1;
}
var eq_1$1;
var hasRequiredEq$1;
function requireEq$1() {
  if (hasRequiredEq$1)
    return eq_1$1;
  hasRequiredEq$1 = 1;
  function eq2(value, other) {
    return value === other || value !== value && other !== other;
  }
  eq_1$1 = eq2;
  return eq_1$1;
}
var _assocIndexOf$1;
var hasRequired_assocIndexOf;
function require_assocIndexOf() {
  if (hasRequired_assocIndexOf)
    return _assocIndexOf$1;
  hasRequired_assocIndexOf = 1;
  var eq2 = requireEq$1();
  function assocIndexOf2(array2, key) {
    var length2 = array2.length;
    while (length2--) {
      if (eq2(array2[length2][0], key)) {
        return length2;
      }
    }
    return -1;
  }
  _assocIndexOf$1 = assocIndexOf2;
  return _assocIndexOf$1;
}
var _listCacheDelete$1;
var hasRequired_listCacheDelete;
function require_listCacheDelete() {
  if (hasRequired_listCacheDelete)
    return _listCacheDelete$1;
  hasRequired_listCacheDelete = 1;
  var assocIndexOf2 = require_assocIndexOf();
  var arrayProto2 = Array.prototype;
  var splice2 = arrayProto2.splice;
  function listCacheDelete2(key) {
    var data2 = this.__data__, index2 = assocIndexOf2(data2, key);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data2.length - 1;
    if (index2 == lastIndex) {
      data2.pop();
    } else {
      splice2.call(data2, index2, 1);
    }
    --this.size;
    return true;
  }
  _listCacheDelete$1 = listCacheDelete2;
  return _listCacheDelete$1;
}
var _listCacheGet$1;
var hasRequired_listCacheGet;
function require_listCacheGet() {
  if (hasRequired_listCacheGet)
    return _listCacheGet$1;
  hasRequired_listCacheGet = 1;
  var assocIndexOf2 = require_assocIndexOf();
  function listCacheGet2(key) {
    var data2 = this.__data__, index2 = assocIndexOf2(data2, key);
    return index2 < 0 ? void 0 : data2[index2][1];
  }
  _listCacheGet$1 = listCacheGet2;
  return _listCacheGet$1;
}
var _listCacheHas$1;
var hasRequired_listCacheHas;
function require_listCacheHas() {
  if (hasRequired_listCacheHas)
    return _listCacheHas$1;
  hasRequired_listCacheHas = 1;
  var assocIndexOf2 = require_assocIndexOf();
  function listCacheHas2(key) {
    return assocIndexOf2(this.__data__, key) > -1;
  }
  _listCacheHas$1 = listCacheHas2;
  return _listCacheHas$1;
}
var _listCacheSet$1;
var hasRequired_listCacheSet;
function require_listCacheSet() {
  if (hasRequired_listCacheSet)
    return _listCacheSet$1;
  hasRequired_listCacheSet = 1;
  var assocIndexOf2 = require_assocIndexOf();
  function listCacheSet2(key, value) {
    var data2 = this.__data__, index2 = assocIndexOf2(data2, key);
    if (index2 < 0) {
      ++this.size;
      data2.push([key, value]);
    } else {
      data2[index2][1] = value;
    }
    return this;
  }
  _listCacheSet$1 = listCacheSet2;
  return _listCacheSet$1;
}
var _ListCache$1;
var hasRequired_ListCache;
function require_ListCache() {
  if (hasRequired_ListCache)
    return _ListCache$1;
  hasRequired_ListCache = 1;
  var listCacheClear2 = require_listCacheClear(), listCacheDelete2 = require_listCacheDelete(), listCacheGet2 = require_listCacheGet(), listCacheHas2 = require_listCacheHas(), listCacheSet2 = require_listCacheSet();
  function ListCache2(entries2) {
    var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries2[index2];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache2.prototype.clear = listCacheClear2;
  ListCache2.prototype["delete"] = listCacheDelete2;
  ListCache2.prototype.get = listCacheGet2;
  ListCache2.prototype.has = listCacheHas2;
  ListCache2.prototype.set = listCacheSet2;
  _ListCache$1 = ListCache2;
  return _ListCache$1;
}
var _stackClear;
var hasRequired_stackClear;
function require_stackClear() {
  if (hasRequired_stackClear)
    return _stackClear;
  hasRequired_stackClear = 1;
  var ListCache2 = require_ListCache();
  function stackClear() {
    this.__data__ = new ListCache2();
    this.size = 0;
  }
  _stackClear = stackClear;
  return _stackClear;
}
var _stackDelete;
var hasRequired_stackDelete;
function require_stackDelete() {
  if (hasRequired_stackDelete)
    return _stackDelete;
  hasRequired_stackDelete = 1;
  function stackDelete(key) {
    var data2 = this.__data__, result = data2["delete"](key);
    this.size = data2.size;
    return result;
  }
  _stackDelete = stackDelete;
  return _stackDelete;
}
var _stackGet;
var hasRequired_stackGet;
function require_stackGet() {
  if (hasRequired_stackGet)
    return _stackGet;
  hasRequired_stackGet = 1;
  function stackGet(key) {
    return this.__data__.get(key);
  }
  _stackGet = stackGet;
  return _stackGet;
}
var _stackHas;
var hasRequired_stackHas;
function require_stackHas() {
  if (hasRequired_stackHas)
    return _stackHas;
  hasRequired_stackHas = 1;
  function stackHas(key) {
    return this.__data__.has(key);
  }
  _stackHas = stackHas;
  return _stackHas;
}
var _freeGlobal$1;
var hasRequired_freeGlobal;
function require_freeGlobal() {
  if (hasRequired_freeGlobal)
    return _freeGlobal$1;
  hasRequired_freeGlobal = 1;
  var freeGlobal2 = typeof commonjsGlobal$1 == "object" && commonjsGlobal$1 && commonjsGlobal$1.Object === Object && commonjsGlobal$1;
  _freeGlobal$1 = freeGlobal2;
  return _freeGlobal$1;
}
var _root$1;
var hasRequired_root;
function require_root() {
  if (hasRequired_root)
    return _root$1;
  hasRequired_root = 1;
  var freeGlobal2 = require_freeGlobal();
  var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
  var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
  _root$1 = root2;
  return _root$1;
}
var _Symbol$1;
var hasRequired_Symbol$1;
function require_Symbol$1() {
  if (hasRequired_Symbol$1)
    return _Symbol$1;
  hasRequired_Symbol$1 = 1;
  var root2 = require_root();
  var Symbol2 = root2.Symbol;
  _Symbol$1 = Symbol2;
  return _Symbol$1;
}
var _getRawTag$1;
var hasRequired_getRawTag$1;
function require_getRawTag$1() {
  if (hasRequired_getRawTag$1)
    return _getRawTag$1;
  hasRequired_getRawTag$1 = 1;
  var Symbol2 = require_Symbol$1();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var nativeObjectToString = objectProto2.toString;
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  function getRawTag(value) {
    var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  _getRawTag$1 = getRawTag;
  return _getRawTag$1;
}
var _objectToString$1;
var hasRequired_objectToString$1;
function require_objectToString$1() {
  if (hasRequired_objectToString$1)
    return _objectToString$1;
  hasRequired_objectToString$1 = 1;
  var objectProto2 = Object.prototype;
  var nativeObjectToString = objectProto2.toString;
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  _objectToString$1 = objectToString;
  return _objectToString$1;
}
var _baseGetTag$1;
var hasRequired_baseGetTag$1;
function require_baseGetTag$1() {
  if (hasRequired_baseGetTag$1)
    return _baseGetTag$1;
  hasRequired_baseGetTag$1 = 1;
  var Symbol2 = require_Symbol$1(), getRawTag = require_getRawTag$1(), objectToString = require_objectToString$1();
  var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  _baseGetTag$1 = baseGetTag;
  return _baseGetTag$1;
}
var isObject_1$1;
var hasRequiredIsObject$1;
function requireIsObject$1() {
  if (hasRequiredIsObject$1)
    return isObject_1$1;
  hasRequiredIsObject$1 = 1;
  function isObject2(value) {
    var type2 = typeof value;
    return value != null && (type2 == "object" || type2 == "function");
  }
  isObject_1$1 = isObject2;
  return isObject_1$1;
}
var isFunction_1$1;
var hasRequiredIsFunction$1;
function requireIsFunction$1() {
  if (hasRequiredIsFunction$1)
    return isFunction_1$1;
  hasRequiredIsFunction$1 = 1;
  var baseGetTag = require_baseGetTag$1(), isObject2 = requireIsObject$1();
  var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
  function isFunction2(value) {
    if (!isObject2(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  isFunction_1$1 = isFunction2;
  return isFunction_1$1;
}
var _coreJsData$1;
var hasRequired_coreJsData;
function require_coreJsData() {
  if (hasRequired_coreJsData)
    return _coreJsData$1;
  hasRequired_coreJsData = 1;
  var root2 = require_root();
  var coreJsData2 = root2["__core-js_shared__"];
  _coreJsData$1 = coreJsData2;
  return _coreJsData$1;
}
var _isMasked$1;
var hasRequired_isMasked;
function require_isMasked() {
  if (hasRequired_isMasked)
    return _isMasked$1;
  hasRequired_isMasked = 1;
  var coreJsData2 = require_coreJsData();
  var maskSrcKey2 = function() {
    var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  function isMasked2(func) {
    return !!maskSrcKey2 && maskSrcKey2 in func;
  }
  _isMasked$1 = isMasked2;
  return _isMasked$1;
}
var _toSource$1;
var hasRequired_toSource;
function require_toSource() {
  if (hasRequired_toSource)
    return _toSource$1;
  hasRequired_toSource = 1;
  var funcProto2 = Function.prototype;
  var funcToString2 = funcProto2.toString;
  function toSource2(func) {
    if (func != null) {
      try {
        return funcToString2.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  _toSource$1 = toSource2;
  return _toSource$1;
}
var _baseIsNative$1;
var hasRequired_baseIsNative;
function require_baseIsNative() {
  if (hasRequired_baseIsNative)
    return _baseIsNative$1;
  hasRequired_baseIsNative = 1;
  var isFunction2 = requireIsFunction$1(), isMasked2 = require_isMasked(), isObject2 = requireIsObject$1(), toSource2 = require_toSource();
  var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
  var funcProto2 = Function.prototype, objectProto2 = Object.prototype;
  var funcToString2 = funcProto2.toString;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var reIsNative2 = RegExp(
    "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function baseIsNative2(value) {
    if (!isObject2(value) || isMasked2(value)) {
      return false;
    }
    var pattern = isFunction2(value) ? reIsNative2 : reIsHostCtor2;
    return pattern.test(toSource2(value));
  }
  _baseIsNative$1 = baseIsNative2;
  return _baseIsNative$1;
}
var _getValue$1;
var hasRequired_getValue;
function require_getValue() {
  if (hasRequired_getValue)
    return _getValue$1;
  hasRequired_getValue = 1;
  function getValue2(object2, key) {
    return object2 == null ? void 0 : object2[key];
  }
  _getValue$1 = getValue2;
  return _getValue$1;
}
var _getNative$1;
var hasRequired_getNative;
function require_getNative() {
  if (hasRequired_getNative)
    return _getNative$1;
  hasRequired_getNative = 1;
  var baseIsNative2 = require_baseIsNative(), getValue2 = require_getValue();
  function getNative2(object2, key) {
    var value = getValue2(object2, key);
    return baseIsNative2(value) ? value : void 0;
  }
  _getNative$1 = getNative2;
  return _getNative$1;
}
var _Map$1;
var hasRequired_Map;
function require_Map() {
  if (hasRequired_Map)
    return _Map$1;
  hasRequired_Map = 1;
  var getNative2 = require_getNative(), root2 = require_root();
  var Map2 = getNative2(root2, "Map");
  _Map$1 = Map2;
  return _Map$1;
}
var _nativeCreate$1;
var hasRequired_nativeCreate;
function require_nativeCreate() {
  if (hasRequired_nativeCreate)
    return _nativeCreate$1;
  hasRequired_nativeCreate = 1;
  var getNative2 = require_getNative();
  var nativeCreate2 = getNative2(Object, "create");
  _nativeCreate$1 = nativeCreate2;
  return _nativeCreate$1;
}
var _hashClear$1;
var hasRequired_hashClear;
function require_hashClear() {
  if (hasRequired_hashClear)
    return _hashClear$1;
  hasRequired_hashClear = 1;
  var nativeCreate2 = require_nativeCreate();
  function hashClear2() {
    this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
    this.size = 0;
  }
  _hashClear$1 = hashClear2;
  return _hashClear$1;
}
var _hashDelete$1;
var hasRequired_hashDelete;
function require_hashDelete() {
  if (hasRequired_hashDelete)
    return _hashDelete$1;
  hasRequired_hashDelete = 1;
  function hashDelete2(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  _hashDelete$1 = hashDelete2;
  return _hashDelete$1;
}
var _hashGet$1;
var hasRequired_hashGet;
function require_hashGet() {
  if (hasRequired_hashGet)
    return _hashGet$1;
  hasRequired_hashGet = 1;
  var nativeCreate2 = require_nativeCreate();
  var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function hashGet2(key) {
    var data2 = this.__data__;
    if (nativeCreate2) {
      var result = data2[key];
      return result === HASH_UNDEFINED2 ? void 0 : result;
    }
    return hasOwnProperty2.call(data2, key) ? data2[key] : void 0;
  }
  _hashGet$1 = hashGet2;
  return _hashGet$1;
}
var _hashHas$1;
var hasRequired_hashHas;
function require_hashHas() {
  if (hasRequired_hashHas)
    return _hashHas$1;
  hasRequired_hashHas = 1;
  var nativeCreate2 = require_nativeCreate();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function hashHas2(key) {
    var data2 = this.__data__;
    return nativeCreate2 ? data2[key] !== void 0 : hasOwnProperty2.call(data2, key);
  }
  _hashHas$1 = hashHas2;
  return _hashHas$1;
}
var _hashSet$1;
var hasRequired_hashSet;
function require_hashSet() {
  if (hasRequired_hashSet)
    return _hashSet$1;
  hasRequired_hashSet = 1;
  var nativeCreate2 = require_nativeCreate();
  var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
  function hashSet2(key, value) {
    var data2 = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data2[key] = nativeCreate2 && value === void 0 ? HASH_UNDEFINED2 : value;
    return this;
  }
  _hashSet$1 = hashSet2;
  return _hashSet$1;
}
var _Hash$1;
var hasRequired_Hash;
function require_Hash() {
  if (hasRequired_Hash)
    return _Hash$1;
  hasRequired_Hash = 1;
  var hashClear2 = require_hashClear(), hashDelete2 = require_hashDelete(), hashGet2 = require_hashGet(), hashHas2 = require_hashHas(), hashSet2 = require_hashSet();
  function Hash2(entries2) {
    var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries2[index2];
      this.set(entry[0], entry[1]);
    }
  }
  Hash2.prototype.clear = hashClear2;
  Hash2.prototype["delete"] = hashDelete2;
  Hash2.prototype.get = hashGet2;
  Hash2.prototype.has = hashHas2;
  Hash2.prototype.set = hashSet2;
  _Hash$1 = Hash2;
  return _Hash$1;
}
var _mapCacheClear$1;
var hasRequired_mapCacheClear;
function require_mapCacheClear() {
  if (hasRequired_mapCacheClear)
    return _mapCacheClear$1;
  hasRequired_mapCacheClear = 1;
  var Hash2 = require_Hash(), ListCache2 = require_ListCache(), Map2 = require_Map();
  function mapCacheClear2() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash2(),
      "map": new (Map2 || ListCache2)(),
      "string": new Hash2()
    };
  }
  _mapCacheClear$1 = mapCacheClear2;
  return _mapCacheClear$1;
}
var _isKeyable$1;
var hasRequired_isKeyable;
function require_isKeyable() {
  if (hasRequired_isKeyable)
    return _isKeyable$1;
  hasRequired_isKeyable = 1;
  function isKeyable2(value) {
    var type2 = typeof value;
    return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
  }
  _isKeyable$1 = isKeyable2;
  return _isKeyable$1;
}
var _getMapData$1;
var hasRequired_getMapData;
function require_getMapData() {
  if (hasRequired_getMapData)
    return _getMapData$1;
  hasRequired_getMapData = 1;
  var isKeyable2 = require_isKeyable();
  function getMapData2(map2, key) {
    var data2 = map2.__data__;
    return isKeyable2(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
  }
  _getMapData$1 = getMapData2;
  return _getMapData$1;
}
var _mapCacheDelete$1;
var hasRequired_mapCacheDelete;
function require_mapCacheDelete() {
  if (hasRequired_mapCacheDelete)
    return _mapCacheDelete$1;
  hasRequired_mapCacheDelete = 1;
  var getMapData2 = require_getMapData();
  function mapCacheDelete2(key) {
    var result = getMapData2(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  _mapCacheDelete$1 = mapCacheDelete2;
  return _mapCacheDelete$1;
}
var _mapCacheGet$1;
var hasRequired_mapCacheGet;
function require_mapCacheGet() {
  if (hasRequired_mapCacheGet)
    return _mapCacheGet$1;
  hasRequired_mapCacheGet = 1;
  var getMapData2 = require_getMapData();
  function mapCacheGet2(key) {
    return getMapData2(this, key).get(key);
  }
  _mapCacheGet$1 = mapCacheGet2;
  return _mapCacheGet$1;
}
var _mapCacheHas$1;
var hasRequired_mapCacheHas;
function require_mapCacheHas() {
  if (hasRequired_mapCacheHas)
    return _mapCacheHas$1;
  hasRequired_mapCacheHas = 1;
  var getMapData2 = require_getMapData();
  function mapCacheHas2(key) {
    return getMapData2(this, key).has(key);
  }
  _mapCacheHas$1 = mapCacheHas2;
  return _mapCacheHas$1;
}
var _mapCacheSet$1;
var hasRequired_mapCacheSet;
function require_mapCacheSet() {
  if (hasRequired_mapCacheSet)
    return _mapCacheSet$1;
  hasRequired_mapCacheSet = 1;
  var getMapData2 = require_getMapData();
  function mapCacheSet2(key, value) {
    var data2 = getMapData2(this, key), size = data2.size;
    data2.set(key, value);
    this.size += data2.size == size ? 0 : 1;
    return this;
  }
  _mapCacheSet$1 = mapCacheSet2;
  return _mapCacheSet$1;
}
var _MapCache$1;
var hasRequired_MapCache;
function require_MapCache() {
  if (hasRequired_MapCache)
    return _MapCache$1;
  hasRequired_MapCache = 1;
  var mapCacheClear2 = require_mapCacheClear(), mapCacheDelete2 = require_mapCacheDelete(), mapCacheGet2 = require_mapCacheGet(), mapCacheHas2 = require_mapCacheHas(), mapCacheSet2 = require_mapCacheSet();
  function MapCache2(entries2) {
    var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries2[index2];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache2.prototype.clear = mapCacheClear2;
  MapCache2.prototype["delete"] = mapCacheDelete2;
  MapCache2.prototype.get = mapCacheGet2;
  MapCache2.prototype.has = mapCacheHas2;
  MapCache2.prototype.set = mapCacheSet2;
  _MapCache$1 = MapCache2;
  return _MapCache$1;
}
var _stackSet;
var hasRequired_stackSet;
function require_stackSet() {
  if (hasRequired_stackSet)
    return _stackSet;
  hasRequired_stackSet = 1;
  var ListCache2 = require_ListCache(), Map2 = require_Map(), MapCache2 = require_MapCache();
  var LARGE_ARRAY_SIZE = 200;
  function stackSet(key, value) {
    var data2 = this.__data__;
    if (data2 instanceof ListCache2) {
      var pairs2 = data2.__data__;
      if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
        pairs2.push([key, value]);
        this.size = ++data2.size;
        return this;
      }
      data2 = this.__data__ = new MapCache2(pairs2);
    }
    data2.set(key, value);
    this.size = data2.size;
    return this;
  }
  _stackSet = stackSet;
  return _stackSet;
}
var _Stack;
var hasRequired_Stack;
function require_Stack() {
  if (hasRequired_Stack)
    return _Stack;
  hasRequired_Stack = 1;
  var ListCache2 = require_ListCache(), stackClear = require_stackClear(), stackDelete = require_stackDelete(), stackGet = require_stackGet(), stackHas = require_stackHas(), stackSet = require_stackSet();
  function Stack2(entries2) {
    var data2 = this.__data__ = new ListCache2(entries2);
    this.size = data2.size;
  }
  Stack2.prototype.clear = stackClear;
  Stack2.prototype["delete"] = stackDelete;
  Stack2.prototype.get = stackGet;
  Stack2.prototype.has = stackHas;
  Stack2.prototype.set = stackSet;
  _Stack = Stack2;
  return _Stack;
}
var _arrayEach$1;
var hasRequired_arrayEach$1;
function require_arrayEach$1() {
  if (hasRequired_arrayEach$1)
    return _arrayEach$1;
  hasRequired_arrayEach$1 = 1;
  function arrayEach(array2, iteratee) {
    var index2 = -1, length2 = array2 == null ? 0 : array2.length;
    while (++index2 < length2) {
      if (iteratee(array2[index2], index2, array2) === false) {
        break;
      }
    }
    return array2;
  }
  _arrayEach$1 = arrayEach;
  return _arrayEach$1;
}
var _defineProperty$1;
var hasRequired_defineProperty$1;
function require_defineProperty$1() {
  if (hasRequired_defineProperty$1)
    return _defineProperty$1;
  hasRequired_defineProperty$1 = 1;
  var getNative2 = require_getNative();
  var defineProperty = function() {
    try {
      var func = getNative2(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e) {
    }
  }();
  _defineProperty$1 = defineProperty;
  return _defineProperty$1;
}
var _baseAssignValue$1;
var hasRequired_baseAssignValue$1;
function require_baseAssignValue$1() {
  if (hasRequired_baseAssignValue$1)
    return _baseAssignValue$1;
  hasRequired_baseAssignValue$1 = 1;
  var defineProperty = require_defineProperty$1();
  function baseAssignValue(object2, key, value) {
    if (key == "__proto__" && defineProperty) {
      defineProperty(object2, key, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object2[key] = value;
    }
  }
  _baseAssignValue$1 = baseAssignValue;
  return _baseAssignValue$1;
}
var _assignValue$1;
var hasRequired_assignValue$1;
function require_assignValue$1() {
  if (hasRequired_assignValue$1)
    return _assignValue$1;
  hasRequired_assignValue$1 = 1;
  var baseAssignValue = require_baseAssignValue$1(), eq2 = requireEq$1();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function assignValue(object2, key, value) {
    var objValue = object2[key];
    if (!(hasOwnProperty2.call(object2, key) && eq2(objValue, value)) || value === void 0 && !(key in object2)) {
      baseAssignValue(object2, key, value);
    }
  }
  _assignValue$1 = assignValue;
  return _assignValue$1;
}
var _copyObject;
var hasRequired_copyObject;
function require_copyObject() {
  if (hasRequired_copyObject)
    return _copyObject;
  hasRequired_copyObject = 1;
  var assignValue = require_assignValue$1(), baseAssignValue = require_baseAssignValue$1();
  function copyObject(source, props, object2, customizer) {
    var isNew = !object2;
    object2 || (object2 = {});
    var index2 = -1, length2 = props.length;
    while (++index2 < length2) {
      var key = props[index2];
      var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
      if (newValue === void 0) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object2, key, newValue);
      } else {
        assignValue(object2, key, newValue);
      }
    }
    return object2;
  }
  _copyObject = copyObject;
  return _copyObject;
}
var _baseTimes$1;
var hasRequired_baseTimes$1;
function require_baseTimes$1() {
  if (hasRequired_baseTimes$1)
    return _baseTimes$1;
  hasRequired_baseTimes$1 = 1;
  function baseTimes(n, iteratee) {
    var index2 = -1, result = Array(n);
    while (++index2 < n) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  _baseTimes$1 = baseTimes;
  return _baseTimes$1;
}
var isObjectLike_1$1;
var hasRequiredIsObjectLike$1;
function requireIsObjectLike$1() {
  if (hasRequiredIsObjectLike$1)
    return isObjectLike_1$1;
  hasRequiredIsObjectLike$1 = 1;
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  isObjectLike_1$1 = isObjectLike;
  return isObjectLike_1$1;
}
var _baseIsArguments$1;
var hasRequired_baseIsArguments$1;
function require_baseIsArguments$1() {
  if (hasRequired_baseIsArguments$1)
    return _baseIsArguments$1;
  hasRequired_baseIsArguments$1 = 1;
  var baseGetTag = require_baseGetTag$1(), isObjectLike = requireIsObjectLike$1();
  var argsTag = "[object Arguments]";
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }
  _baseIsArguments$1 = baseIsArguments;
  return _baseIsArguments$1;
}
var isArguments_1$1;
var hasRequiredIsArguments$1;
function requireIsArguments$1() {
  if (hasRequiredIsArguments$1)
    return isArguments_1$1;
  hasRequiredIsArguments$1 = 1;
  var baseIsArguments = require_baseIsArguments$1(), isObjectLike = requireIsObjectLike$1();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var propertyIsEnumerable = objectProto2.propertyIsEnumerable;
  var isArguments = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  isArguments_1$1 = isArguments;
  return isArguments_1$1;
}
var isArray_1$1;
var hasRequiredIsArray$1;
function requireIsArray$1() {
  if (hasRequiredIsArray$1)
    return isArray_1$1;
  hasRequiredIsArray$1 = 1;
  var isArray = Array.isArray;
  isArray_1$1 = isArray;
  return isArray_1$1;
}
var isBuffer$1 = { exports: {} };
var stubFalse_1$1;
var hasRequiredStubFalse$1;
function requireStubFalse$1() {
  if (hasRequiredStubFalse$1)
    return stubFalse_1$1;
  hasRequiredStubFalse$1 = 1;
  function stubFalse() {
    return false;
  }
  stubFalse_1$1 = stubFalse;
  return stubFalse_1$1;
}
var hasRequiredIsBuffer$1;
function requireIsBuffer$1() {
  if (hasRequiredIsBuffer$1)
    return isBuffer$1.exports;
  hasRequiredIsBuffer$1 = 1;
  (function(module2, exports2) {
    var root2 = require_root(), stubFalse = requireStubFalse$1();
    var freeExports = exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root2.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer2 = nativeIsBuffer || stubFalse;
    module2.exports = isBuffer2;
  })(isBuffer$1, isBuffer$1.exports);
  return isBuffer$1.exports;
}
var _isIndex$1;
var hasRequired_isIndex$1;
function require_isIndex$1() {
  if (hasRequired_isIndex$1)
    return _isIndex$1;
  hasRequired_isIndex$1 = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length2) {
    var type2 = typeof value;
    length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
    return !!length2 && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
  }
  _isIndex$1 = isIndex;
  return _isIndex$1;
}
var isLength_1$1;
var hasRequiredIsLength$1;
function requireIsLength$1() {
  if (hasRequiredIsLength$1)
    return isLength_1$1;
  hasRequiredIsLength$1 = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  isLength_1$1 = isLength;
  return isLength_1$1;
}
var _baseIsTypedArray$1;
var hasRequired_baseIsTypedArray$1;
function require_baseIsTypedArray$1() {
  if (hasRequired_baseIsTypedArray$1)
    return _baseIsTypedArray$1;
  hasRequired_baseIsTypedArray$1 = 1;
  var baseGetTag = require_baseGetTag$1(), isLength = requireIsLength$1(), isObjectLike = requireIsObjectLike$1();
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  _baseIsTypedArray$1 = baseIsTypedArray;
  return _baseIsTypedArray$1;
}
var _baseUnary$1;
var hasRequired_baseUnary$1;
function require_baseUnary$1() {
  if (hasRequired_baseUnary$1)
    return _baseUnary$1;
  hasRequired_baseUnary$1 = 1;
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  _baseUnary$1 = baseUnary;
  return _baseUnary$1;
}
var _nodeUtil$1 = { exports: {} };
var hasRequired_nodeUtil$1;
function require_nodeUtil$1() {
  if (hasRequired_nodeUtil$1)
    return _nodeUtil$1.exports;
  hasRequired_nodeUtil$1 = 1;
  (function(module2, exports2) {
    var freeGlobal2 = require_freeGlobal();
    var freeExports = exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal2.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module2.exports = nodeUtil;
  })(_nodeUtil$1, _nodeUtil$1.exports);
  return _nodeUtil$1.exports;
}
var isTypedArray_1$1;
var hasRequiredIsTypedArray$1;
function requireIsTypedArray$1() {
  if (hasRequiredIsTypedArray$1)
    return isTypedArray_1$1;
  hasRequiredIsTypedArray$1 = 1;
  var baseIsTypedArray = require_baseIsTypedArray$1(), baseUnary = require_baseUnary$1(), nodeUtil = require_nodeUtil$1();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  isTypedArray_1$1 = isTypedArray;
  return isTypedArray_1$1;
}
var _arrayLikeKeys$1;
var hasRequired_arrayLikeKeys$1;
function require_arrayLikeKeys$1() {
  if (hasRequired_arrayLikeKeys$1)
    return _arrayLikeKeys$1;
  hasRequired_arrayLikeKeys$1 = 1;
  var baseTimes = require_baseTimes$1(), isArguments = requireIsArguments$1(), isArray = requireIsArray$1(), isBuffer2 = requireIsBuffer$1(), isIndex = require_isIndex$1(), isTypedArray = requireIsTypedArray$1();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length2)))) {
        result.push(key);
      }
    }
    return result;
  }
  _arrayLikeKeys$1 = arrayLikeKeys;
  return _arrayLikeKeys$1;
}
var _isPrototype$1;
var hasRequired_isPrototype$1;
function require_isPrototype$1() {
  if (hasRequired_isPrototype$1)
    return _isPrototype$1;
  hasRequired_isPrototype$1 = 1;
  var objectProto2 = Object.prototype;
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto2;
    return value === proto2;
  }
  _isPrototype$1 = isPrototype;
  return _isPrototype$1;
}
var _overArg$1;
var hasRequired_overArg$1;
function require_overArg$1() {
  if (hasRequired_overArg$1)
    return _overArg$1;
  hasRequired_overArg$1 = 1;
  function overArg(func, transform2) {
    return function(arg) {
      return func(transform2(arg));
    };
  }
  _overArg$1 = overArg;
  return _overArg$1;
}
var _nativeKeys$1;
var hasRequired_nativeKeys$1;
function require_nativeKeys$1() {
  if (hasRequired_nativeKeys$1)
    return _nativeKeys$1;
  hasRequired_nativeKeys$1 = 1;
  var overArg = require_overArg$1();
  var nativeKeys = overArg(Object.keys, Object);
  _nativeKeys$1 = nativeKeys;
  return _nativeKeys$1;
}
var _baseKeys$1;
var hasRequired_baseKeys$1;
function require_baseKeys$1() {
  if (hasRequired_baseKeys$1)
    return _baseKeys$1;
  hasRequired_baseKeys$1 = 1;
  var isPrototype = require_isPrototype$1(), nativeKeys = require_nativeKeys$1();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function baseKeys(object2) {
    if (!isPrototype(object2)) {
      return nativeKeys(object2);
    }
    var result = [];
    for (var key in Object(object2)) {
      if (hasOwnProperty2.call(object2, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  _baseKeys$1 = baseKeys;
  return _baseKeys$1;
}
var isArrayLike_1$1;
var hasRequiredIsArrayLike$1;
function requireIsArrayLike$1() {
  if (hasRequiredIsArrayLike$1)
    return isArrayLike_1$1;
  hasRequiredIsArrayLike$1 = 1;
  var isFunction2 = requireIsFunction$1(), isLength = requireIsLength$1();
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
  }
  isArrayLike_1$1 = isArrayLike;
  return isArrayLike_1$1;
}
var keys_1$1;
var hasRequiredKeys$1;
function requireKeys$1() {
  if (hasRequiredKeys$1)
    return keys_1$1;
  hasRequiredKeys$1 = 1;
  var arrayLikeKeys = require_arrayLikeKeys$1(), baseKeys = require_baseKeys$1(), isArrayLike = requireIsArrayLike$1();
  function keys2(object2) {
    return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
  }
  keys_1$1 = keys2;
  return keys_1$1;
}
var _baseAssign;
var hasRequired_baseAssign;
function require_baseAssign() {
  if (hasRequired_baseAssign)
    return _baseAssign;
  hasRequired_baseAssign = 1;
  var copyObject = require_copyObject(), keys2 = requireKeys$1();
  function baseAssign(object2, source) {
    return object2 && copyObject(source, keys2(source), object2);
  }
  _baseAssign = baseAssign;
  return _baseAssign;
}
var _nativeKeysIn$1;
var hasRequired_nativeKeysIn$1;
function require_nativeKeysIn$1() {
  if (hasRequired_nativeKeysIn$1)
    return _nativeKeysIn$1;
  hasRequired_nativeKeysIn$1 = 1;
  function nativeKeysIn(object2) {
    var result = [];
    if (object2 != null) {
      for (var key in Object(object2)) {
        result.push(key);
      }
    }
    return result;
  }
  _nativeKeysIn$1 = nativeKeysIn;
  return _nativeKeysIn$1;
}
var _baseKeysIn$1;
var hasRequired_baseKeysIn$1;
function require_baseKeysIn$1() {
  if (hasRequired_baseKeysIn$1)
    return _baseKeysIn$1;
  hasRequired_baseKeysIn$1 = 1;
  var isObject2 = requireIsObject$1(), isPrototype = require_isPrototype$1(), nativeKeysIn = require_nativeKeysIn$1();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function baseKeysIn(object2) {
    if (!isObject2(object2)) {
      return nativeKeysIn(object2);
    }
    var isProto = isPrototype(object2), result = [];
    for (var key in object2) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object2, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  _baseKeysIn$1 = baseKeysIn;
  return _baseKeysIn$1;
}
var keysIn_1$1;
var hasRequiredKeysIn$1;
function requireKeysIn$1() {
  if (hasRequiredKeysIn$1)
    return keysIn_1$1;
  hasRequiredKeysIn$1 = 1;
  var arrayLikeKeys = require_arrayLikeKeys$1(), baseKeysIn = require_baseKeysIn$1(), isArrayLike = requireIsArrayLike$1();
  function keysIn(object2) {
    return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
  }
  keysIn_1$1 = keysIn;
  return keysIn_1$1;
}
var _baseAssignIn;
var hasRequired_baseAssignIn;
function require_baseAssignIn() {
  if (hasRequired_baseAssignIn)
    return _baseAssignIn;
  hasRequired_baseAssignIn = 1;
  var copyObject = require_copyObject(), keysIn = requireKeysIn$1();
  function baseAssignIn(object2, source) {
    return object2 && copyObject(source, keysIn(source), object2);
  }
  _baseAssignIn = baseAssignIn;
  return _baseAssignIn;
}
var _cloneBuffer = { exports: {} };
var hasRequired_cloneBuffer;
function require_cloneBuffer() {
  if (hasRequired_cloneBuffer)
    return _cloneBuffer.exports;
  hasRequired_cloneBuffer = 1;
  (function(module2, exports2) {
    var root2 = require_root();
    var freeExports = exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root2.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer2, isDeep) {
      if (isDeep) {
        return buffer2.slice();
      }
      var length2 = buffer2.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer2.constructor(length2);
      buffer2.copy(result);
      return result;
    }
    module2.exports = cloneBuffer;
  })(_cloneBuffer, _cloneBuffer.exports);
  return _cloneBuffer.exports;
}
var _copyArray;
var hasRequired_copyArray;
function require_copyArray() {
  if (hasRequired_copyArray)
    return _copyArray;
  hasRequired_copyArray = 1;
  function copyArray(source, array2) {
    var index2 = -1, length2 = source.length;
    array2 || (array2 = Array(length2));
    while (++index2 < length2) {
      array2[index2] = source[index2];
    }
    return array2;
  }
  _copyArray = copyArray;
  return _copyArray;
}
var _arrayFilter;
var hasRequired_arrayFilter;
function require_arrayFilter() {
  if (hasRequired_arrayFilter)
    return _arrayFilter;
  hasRequired_arrayFilter = 1;
  function arrayFilter(array2, predicate) {
    var index2 = -1, length2 = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
    while (++index2 < length2) {
      var value = array2[index2];
      if (predicate(value, index2, array2)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  _arrayFilter = arrayFilter;
  return _arrayFilter;
}
var stubArray_1;
var hasRequiredStubArray;
function requireStubArray() {
  if (hasRequiredStubArray)
    return stubArray_1;
  hasRequiredStubArray = 1;
  function stubArray() {
    return [];
  }
  stubArray_1 = stubArray;
  return stubArray_1;
}
var _getSymbols;
var hasRequired_getSymbols;
function require_getSymbols() {
  if (hasRequired_getSymbols)
    return _getSymbols;
  hasRequired_getSymbols = 1;
  var arrayFilter = require_arrayFilter(), stubArray = requireStubArray();
  var objectProto2 = Object.prototype;
  var propertyIsEnumerable = objectProto2.propertyIsEnumerable;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
    if (object2 == null) {
      return [];
    }
    object2 = Object(object2);
    return arrayFilter(nativeGetSymbols(object2), function(symbol2) {
      return propertyIsEnumerable.call(object2, symbol2);
    });
  };
  _getSymbols = getSymbols;
  return _getSymbols;
}
var _copySymbols;
var hasRequired_copySymbols;
function require_copySymbols() {
  if (hasRequired_copySymbols)
    return _copySymbols;
  hasRequired_copySymbols = 1;
  var copyObject = require_copyObject(), getSymbols = require_getSymbols();
  function copySymbols(source, object2) {
    return copyObject(source, getSymbols(source), object2);
  }
  _copySymbols = copySymbols;
  return _copySymbols;
}
var _arrayPush$1;
var hasRequired_arrayPush$1;
function require_arrayPush$1() {
  if (hasRequired_arrayPush$1)
    return _arrayPush$1;
  hasRequired_arrayPush$1 = 1;
  function arrayPush2(array2, values2) {
    var index2 = -1, length2 = values2.length, offset = array2.length;
    while (++index2 < length2) {
      array2[offset + index2] = values2[index2];
    }
    return array2;
  }
  _arrayPush$1 = arrayPush2;
  return _arrayPush$1;
}
var _getPrototype$1;
var hasRequired_getPrototype$1;
function require_getPrototype$1() {
  if (hasRequired_getPrototype$1)
    return _getPrototype$1;
  hasRequired_getPrototype$1 = 1;
  var overArg = require_overArg$1();
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  _getPrototype$1 = getPrototype;
  return _getPrototype$1;
}
var _getSymbolsIn;
var hasRequired_getSymbolsIn;
function require_getSymbolsIn() {
  if (hasRequired_getSymbolsIn)
    return _getSymbolsIn;
  hasRequired_getSymbolsIn = 1;
  var arrayPush2 = require_arrayPush$1(), getPrototype = require_getPrototype$1(), getSymbols = require_getSymbols(), stubArray = requireStubArray();
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
    var result = [];
    while (object2) {
      arrayPush2(result, getSymbols(object2));
      object2 = getPrototype(object2);
    }
    return result;
  };
  _getSymbolsIn = getSymbolsIn;
  return _getSymbolsIn;
}
var _copySymbolsIn;
var hasRequired_copySymbolsIn;
function require_copySymbolsIn() {
  if (hasRequired_copySymbolsIn)
    return _copySymbolsIn;
  hasRequired_copySymbolsIn = 1;
  var copyObject = require_copyObject(), getSymbolsIn = require_getSymbolsIn();
  function copySymbolsIn(source, object2) {
    return copyObject(source, getSymbolsIn(source), object2);
  }
  _copySymbolsIn = copySymbolsIn;
  return _copySymbolsIn;
}
var _baseGetAllKeys;
var hasRequired_baseGetAllKeys;
function require_baseGetAllKeys() {
  if (hasRequired_baseGetAllKeys)
    return _baseGetAllKeys;
  hasRequired_baseGetAllKeys = 1;
  var arrayPush2 = require_arrayPush$1(), isArray = requireIsArray$1();
  function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
    var result = keysFunc(object2);
    return isArray(object2) ? result : arrayPush2(result, symbolsFunc(object2));
  }
  _baseGetAllKeys = baseGetAllKeys;
  return _baseGetAllKeys;
}
var _getAllKeys;
var hasRequired_getAllKeys;
function require_getAllKeys() {
  if (hasRequired_getAllKeys)
    return _getAllKeys;
  hasRequired_getAllKeys = 1;
  var baseGetAllKeys = require_baseGetAllKeys(), getSymbols = require_getSymbols(), keys2 = requireKeys$1();
  function getAllKeys(object2) {
    return baseGetAllKeys(object2, keys2, getSymbols);
  }
  _getAllKeys = getAllKeys;
  return _getAllKeys;
}
var _getAllKeysIn;
var hasRequired_getAllKeysIn;
function require_getAllKeysIn() {
  if (hasRequired_getAllKeysIn)
    return _getAllKeysIn;
  hasRequired_getAllKeysIn = 1;
  var baseGetAllKeys = require_baseGetAllKeys(), getSymbolsIn = require_getSymbolsIn(), keysIn = requireKeysIn$1();
  function getAllKeysIn(object2) {
    return baseGetAllKeys(object2, keysIn, getSymbolsIn);
  }
  _getAllKeysIn = getAllKeysIn;
  return _getAllKeysIn;
}
var _DataView;
var hasRequired_DataView;
function require_DataView() {
  if (hasRequired_DataView)
    return _DataView;
  hasRequired_DataView = 1;
  var getNative2 = require_getNative(), root2 = require_root();
  var DataView2 = getNative2(root2, "DataView");
  _DataView = DataView2;
  return _DataView;
}
var _Promise;
var hasRequired_Promise;
function require_Promise() {
  if (hasRequired_Promise)
    return _Promise;
  hasRequired_Promise = 1;
  var getNative2 = require_getNative(), root2 = require_root();
  var Promise2 = getNative2(root2, "Promise");
  _Promise = Promise2;
  return _Promise;
}
var _Set;
var hasRequired_Set;
function require_Set() {
  if (hasRequired_Set)
    return _Set;
  hasRequired_Set = 1;
  var getNative2 = require_getNative(), root2 = require_root();
  var Set4 = getNative2(root2, "Set");
  _Set = Set4;
  return _Set;
}
var _WeakMap;
var hasRequired_WeakMap;
function require_WeakMap() {
  if (hasRequired_WeakMap)
    return _WeakMap;
  hasRequired_WeakMap = 1;
  var getNative2 = require_getNative(), root2 = require_root();
  var WeakMap2 = getNative2(root2, "WeakMap");
  _WeakMap = WeakMap2;
  return _WeakMap;
}
var _getTag;
var hasRequired_getTag;
function require_getTag() {
  if (hasRequired_getTag)
    return _getTag;
  hasRequired_getTag = 1;
  var DataView2 = require_DataView(), Map2 = require_Map(), Promise2 = require_Promise(), Set4 = require_Set(), WeakMap2 = require_WeakMap(), baseGetTag = require_baseGetTag$1(), toSource2 = require_toSource();
  var mapTag = "[object Map]", objectTag = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
  var dataViewTag = "[object DataView]";
  var dataViewCtorString = toSource2(DataView2), mapCtorString = toSource2(Map2), promiseCtorString = toSource2(Promise2), setCtorString = toSource2(Set4), weakMapCtorString = toSource2(WeakMap2);
  var getTag = baseGetTag;
  if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set4 && getTag(new Set4()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
    getTag = function(value) {
      var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource2(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  _getTag = getTag;
  return _getTag;
}
var _initCloneArray;
var hasRequired_initCloneArray;
function require_initCloneArray() {
  if (hasRequired_initCloneArray)
    return _initCloneArray;
  hasRequired_initCloneArray = 1;
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function initCloneArray(array2) {
    var length2 = array2.length, result = new array2.constructor(length2);
    if (length2 && typeof array2[0] == "string" && hasOwnProperty2.call(array2, "index")) {
      result.index = array2.index;
      result.input = array2.input;
    }
    return result;
  }
  _initCloneArray = initCloneArray;
  return _initCloneArray;
}
var _Uint8Array;
var hasRequired_Uint8Array;
function require_Uint8Array() {
  if (hasRequired_Uint8Array)
    return _Uint8Array;
  hasRequired_Uint8Array = 1;
  var root2 = require_root();
  var Uint8Array2 = root2.Uint8Array;
  _Uint8Array = Uint8Array2;
  return _Uint8Array;
}
var _cloneArrayBuffer;
var hasRequired_cloneArrayBuffer;
function require_cloneArrayBuffer() {
  if (hasRequired_cloneArrayBuffer)
    return _cloneArrayBuffer;
  hasRequired_cloneArrayBuffer = 1;
  var Uint8Array2 = require_Uint8Array();
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
    return result;
  }
  _cloneArrayBuffer = cloneArrayBuffer;
  return _cloneArrayBuffer;
}
var _cloneDataView;
var hasRequired_cloneDataView;
function require_cloneDataView() {
  if (hasRequired_cloneDataView)
    return _cloneDataView;
  hasRequired_cloneDataView = 1;
  var cloneArrayBuffer = require_cloneArrayBuffer();
  function cloneDataView(dataView, isDeep) {
    var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
  }
  _cloneDataView = cloneDataView;
  return _cloneDataView;
}
var _cloneRegExp;
var hasRequired_cloneRegExp;
function require_cloneRegExp() {
  if (hasRequired_cloneRegExp)
    return _cloneRegExp;
  hasRequired_cloneRegExp = 1;
  var reFlags = /\w*$/;
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }
  _cloneRegExp = cloneRegExp;
  return _cloneRegExp;
}
var _cloneSymbol;
var hasRequired_cloneSymbol;
function require_cloneSymbol() {
  if (hasRequired_cloneSymbol)
    return _cloneSymbol;
  hasRequired_cloneSymbol = 1;
  var Symbol2 = require_Symbol$1();
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function cloneSymbol(symbol2) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol2)) : {};
  }
  _cloneSymbol = cloneSymbol;
  return _cloneSymbol;
}
var _cloneTypedArray;
var hasRequired_cloneTypedArray;
function require_cloneTypedArray() {
  if (hasRequired_cloneTypedArray)
    return _cloneTypedArray;
  hasRequired_cloneTypedArray = 1;
  var cloneArrayBuffer = require_cloneArrayBuffer();
  function cloneTypedArray(typedArray, isDeep) {
    var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
  }
  _cloneTypedArray = cloneTypedArray;
  return _cloneTypedArray;
}
var _initCloneByTag;
var hasRequired_initCloneByTag;
function require_initCloneByTag() {
  if (hasRequired_initCloneByTag)
    return _initCloneByTag;
  hasRequired_initCloneByTag = 1;
  var cloneArrayBuffer = require_cloneArrayBuffer(), cloneDataView = require_cloneDataView(), cloneRegExp = require_cloneRegExp(), cloneSymbol = require_cloneSymbol(), cloneTypedArray = require_cloneTypedArray();
  var boolTag = "[object Boolean]", dateTag = "[object Date]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  function initCloneByTag(object2, tag, isDeep) {
    var Ctor = object2.constructor;
    switch (tag) {
      case arrayBufferTag:
        return cloneArrayBuffer(object2);
      case boolTag:
      case dateTag:
        return new Ctor(+object2);
      case dataViewTag:
        return cloneDataView(object2, isDeep);
      case float32Tag:
      case float64Tag:
      case int8Tag:
      case int16Tag:
      case int32Tag:
      case uint8Tag:
      case uint8ClampedTag:
      case uint16Tag:
      case uint32Tag:
        return cloneTypedArray(object2, isDeep);
      case mapTag:
        return new Ctor();
      case numberTag:
      case stringTag:
        return new Ctor(object2);
      case regexpTag:
        return cloneRegExp(object2);
      case setTag:
        return new Ctor();
      case symbolTag:
        return cloneSymbol(object2);
    }
  }
  _initCloneByTag = initCloneByTag;
  return _initCloneByTag;
}
var _baseCreate;
var hasRequired_baseCreate;
function require_baseCreate() {
  if (hasRequired_baseCreate)
    return _baseCreate;
  hasRequired_baseCreate = 1;
  var isObject2 = requireIsObject$1();
  var objectCreate = Object.create;
  var baseCreate = function() {
    function object2() {
    }
    return function(proto2) {
      if (!isObject2(proto2)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto2);
      }
      object2.prototype = proto2;
      var result = new object2();
      object2.prototype = void 0;
      return result;
    };
  }();
  _baseCreate = baseCreate;
  return _baseCreate;
}
var _initCloneObject;
var hasRequired_initCloneObject;
function require_initCloneObject() {
  if (hasRequired_initCloneObject)
    return _initCloneObject;
  hasRequired_initCloneObject = 1;
  var baseCreate = require_baseCreate(), getPrototype = require_getPrototype$1(), isPrototype = require_isPrototype$1();
  function initCloneObject(object2) {
    return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate(getPrototype(object2)) : {};
  }
  _initCloneObject = initCloneObject;
  return _initCloneObject;
}
var _baseIsMap;
var hasRequired_baseIsMap;
function require_baseIsMap() {
  if (hasRequired_baseIsMap)
    return _baseIsMap;
  hasRequired_baseIsMap = 1;
  var getTag = require_getTag(), isObjectLike = requireIsObjectLike$1();
  var mapTag = "[object Map]";
  function baseIsMap(value) {
    return isObjectLike(value) && getTag(value) == mapTag;
  }
  _baseIsMap = baseIsMap;
  return _baseIsMap;
}
var isMap_1;
var hasRequiredIsMap;
function requireIsMap() {
  if (hasRequiredIsMap)
    return isMap_1;
  hasRequiredIsMap = 1;
  var baseIsMap = require_baseIsMap(), baseUnary = require_baseUnary$1(), nodeUtil = require_nodeUtil$1();
  var nodeIsMap = nodeUtil && nodeUtil.isMap;
  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
  isMap_1 = isMap;
  return isMap_1;
}
var _baseIsSet;
var hasRequired_baseIsSet;
function require_baseIsSet() {
  if (hasRequired_baseIsSet)
    return _baseIsSet;
  hasRequired_baseIsSet = 1;
  var getTag = require_getTag(), isObjectLike = requireIsObjectLike$1();
  var setTag = "[object Set]";
  function baseIsSet(value) {
    return isObjectLike(value) && getTag(value) == setTag;
  }
  _baseIsSet = baseIsSet;
  return _baseIsSet;
}
var isSet_1;
var hasRequiredIsSet;
function requireIsSet() {
  if (hasRequiredIsSet)
    return isSet_1;
  hasRequiredIsSet = 1;
  var baseIsSet = require_baseIsSet(), baseUnary = require_baseUnary$1(), nodeUtil = require_nodeUtil$1();
  var nodeIsSet = nodeUtil && nodeUtil.isSet;
  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
  isSet_1 = isSet;
  return isSet_1;
}
var _baseClone;
var hasRequired_baseClone;
function require_baseClone() {
  if (hasRequired_baseClone)
    return _baseClone;
  hasRequired_baseClone = 1;
  var Stack2 = require_Stack(), arrayEach = require_arrayEach$1(), assignValue = require_assignValue$1(), baseAssign = require_baseAssign(), baseAssignIn = require_baseAssignIn(), cloneBuffer = require_cloneBuffer(), copyArray = require_copyArray(), copySymbols = require_copySymbols(), copySymbolsIn = require_copySymbolsIn(), getAllKeys = require_getAllKeys(), getAllKeysIn = require_getAllKeysIn(), getTag = require_getTag(), initCloneArray = require_initCloneArray(), initCloneByTag = require_initCloneByTag(), initCloneObject = require_initCloneObject(), isArray = requireIsArray$1(), isBuffer2 = requireIsBuffer$1(), isMap = requireIsMap(), isObject2 = requireIsObject$1(), isSet = requireIsSet(), keys2 = requireKeys$1(), keysIn = requireKeysIn$1();
  var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  function baseClone(value, bitmask, customizer, key, object2, stack2) {
    var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
    if (customizer) {
      result = object2 ? customizer(value, key, object2, stack2) : customizer(value);
    }
    if (result !== void 0) {
      return result;
    }
    if (!isObject2(value)) {
      return value;
    }
    var isArr = isArray(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
      if (isBuffer2(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag == objectTag || tag == argsTag || isFunc && !object2) {
        result = isFlat || isFunc ? {} : initCloneObject(value);
        if (!isDeep) {
          return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object2 ? value : {};
        }
        result = initCloneByTag(value, tag, isDeep);
      }
    }
    stack2 || (stack2 = new Stack2());
    var stacked = stack2.get(value);
    if (stacked) {
      return stacked;
    }
    stack2.set(value, result);
    if (isSet(value)) {
      value.forEach(function(subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
      });
    } else if (isMap(value)) {
      value.forEach(function(subValue, key2) {
        result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
      });
    }
    var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys2;
    var props = isArr ? void 0 : keysFunc(value);
    arrayEach(props || value, function(subValue, key2) {
      if (props) {
        key2 = subValue;
        subValue = value[key2];
      }
      assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
    });
    return result;
  }
  _baseClone = baseClone;
  return _baseClone;
}
var clone_1;
var hasRequiredClone;
function requireClone() {
  if (hasRequiredClone)
    return clone_1;
  hasRequiredClone = 1;
  var baseClone = require_baseClone();
  var CLONE_SYMBOLS_FLAG = 4;
  function clone2(value) {
    return baseClone(value, CLONE_SYMBOLS_FLAG);
  }
  clone_1 = clone2;
  return clone_1;
}
var constant_1$1;
var hasRequiredConstant$1;
function requireConstant$1() {
  if (hasRequiredConstant$1)
    return constant_1$1;
  hasRequiredConstant$1 = 1;
  function constant2(value) {
    return function() {
      return value;
    };
  }
  constant_1$1 = constant2;
  return constant_1$1;
}
var each$1 = { exports: {} };
var _createBaseFor$1;
var hasRequired_createBaseFor$1;
function require_createBaseFor$1() {
  if (hasRequired_createBaseFor$1)
    return _createBaseFor$1;
  hasRequired_createBaseFor$1 = 1;
  function createBaseFor(fromRight) {
    return function(object2, iteratee, keysFunc) {
      var index2 = -1, iterable = Object(object2), props = keysFunc(object2), length2 = props.length;
      while (length2--) {
        var key = props[fromRight ? length2 : ++index2];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object2;
    };
  }
  _createBaseFor$1 = createBaseFor;
  return _createBaseFor$1;
}
var _baseFor$1;
var hasRequired_baseFor$1;
function require_baseFor$1() {
  if (hasRequired_baseFor$1)
    return _baseFor$1;
  hasRequired_baseFor$1 = 1;
  var createBaseFor = require_createBaseFor$1();
  var baseFor = createBaseFor();
  _baseFor$1 = baseFor;
  return _baseFor$1;
}
var _baseForOwn$1;
var hasRequired_baseForOwn$1;
function require_baseForOwn$1() {
  if (hasRequired_baseForOwn$1)
    return _baseForOwn$1;
  hasRequired_baseForOwn$1 = 1;
  var baseFor = require_baseFor$1(), keys2 = requireKeys$1();
  function baseForOwn(object2, iteratee) {
    return object2 && baseFor(object2, iteratee, keys2);
  }
  _baseForOwn$1 = baseForOwn;
  return _baseForOwn$1;
}
var _createBaseEach$1;
var hasRequired_createBaseEach$1;
function require_createBaseEach$1() {
  if (hasRequired_createBaseEach$1)
    return _createBaseEach$1;
  hasRequired_createBaseEach$1 = 1;
  var isArrayLike = requireIsArrayLike$1();
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length2 = collection.length, index2 = fromRight ? length2 : -1, iterable = Object(collection);
      while (fromRight ? index2-- : ++index2 < length2) {
        if (iteratee(iterable[index2], index2, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }
  _createBaseEach$1 = createBaseEach;
  return _createBaseEach$1;
}
var _baseEach$1;
var hasRequired_baseEach$1;
function require_baseEach$1() {
  if (hasRequired_baseEach$1)
    return _baseEach$1;
  hasRequired_baseEach$1 = 1;
  var baseForOwn = require_baseForOwn$1(), createBaseEach = require_createBaseEach$1();
  var baseEach = createBaseEach(baseForOwn);
  _baseEach$1 = baseEach;
  return _baseEach$1;
}
var identity_1$1;
var hasRequiredIdentity$1;
function requireIdentity$1() {
  if (hasRequiredIdentity$1)
    return identity_1$1;
  hasRequiredIdentity$1 = 1;
  function identity2(value) {
    return value;
  }
  identity_1$1 = identity2;
  return identity_1$1;
}
var _castFunction$1;
var hasRequired_castFunction$1;
function require_castFunction$1() {
  if (hasRequired_castFunction$1)
    return _castFunction$1;
  hasRequired_castFunction$1 = 1;
  var identity2 = requireIdentity$1();
  function castFunction(value) {
    return typeof value == "function" ? value : identity2;
  }
  _castFunction$1 = castFunction;
  return _castFunction$1;
}
var forEach_1$1;
var hasRequiredForEach$1;
function requireForEach$1() {
  if (hasRequiredForEach$1)
    return forEach_1$1;
  hasRequiredForEach$1 = 1;
  var arrayEach = require_arrayEach$1(), baseEach = require_baseEach$1(), castFunction = require_castFunction$1(), isArray = requireIsArray$1();
  function forEach(collection, iteratee) {
    var func = isArray(collection) ? arrayEach : baseEach;
    return func(collection, castFunction(iteratee));
  }
  forEach_1$1 = forEach;
  return forEach_1$1;
}
var hasRequiredEach$1;
function requireEach$1() {
  if (hasRequiredEach$1)
    return each$1.exports;
  hasRequiredEach$1 = 1;
  (function(module2) {
    module2.exports = requireForEach$1();
  })(each$1);
  return each$1.exports;
}
var _baseFilter;
var hasRequired_baseFilter;
function require_baseFilter() {
  if (hasRequired_baseFilter)
    return _baseFilter;
  hasRequired_baseFilter = 1;
  var baseEach = require_baseEach$1();
  function baseFilter(collection, predicate) {
    var result = [];
    baseEach(collection, function(value, index2, collection2) {
      if (predicate(value, index2, collection2)) {
        result.push(value);
      }
    });
    return result;
  }
  _baseFilter = baseFilter;
  return _baseFilter;
}
var _setCacheAdd;
var hasRequired_setCacheAdd;
function require_setCacheAdd() {
  if (hasRequired_setCacheAdd)
    return _setCacheAdd;
  hasRequired_setCacheAdd = 1;
  var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED2);
    return this;
  }
  _setCacheAdd = setCacheAdd;
  return _setCacheAdd;
}
var _setCacheHas;
var hasRequired_setCacheHas;
function require_setCacheHas() {
  if (hasRequired_setCacheHas)
    return _setCacheHas;
  hasRequired_setCacheHas = 1;
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  _setCacheHas = setCacheHas;
  return _setCacheHas;
}
var _SetCache;
var hasRequired_SetCache;
function require_SetCache() {
  if (hasRequired_SetCache)
    return _SetCache;
  hasRequired_SetCache = 1;
  var MapCache2 = require_MapCache(), setCacheAdd = require_setCacheAdd(), setCacheHas = require_setCacheHas();
  function SetCache(values2) {
    var index2 = -1, length2 = values2 == null ? 0 : values2.length;
    this.__data__ = new MapCache2();
    while (++index2 < length2) {
      this.add(values2[index2]);
    }
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  _SetCache = SetCache;
  return _SetCache;
}
var _arraySome;
var hasRequired_arraySome;
function require_arraySome() {
  if (hasRequired_arraySome)
    return _arraySome;
  hasRequired_arraySome = 1;
  function arraySome(array2, predicate) {
    var index2 = -1, length2 = array2 == null ? 0 : array2.length;
    while (++index2 < length2) {
      if (predicate(array2[index2], index2, array2)) {
        return true;
      }
    }
    return false;
  }
  _arraySome = arraySome;
  return _arraySome;
}
var _cacheHas;
var hasRequired_cacheHas;
function require_cacheHas() {
  if (hasRequired_cacheHas)
    return _cacheHas;
  hasRequired_cacheHas = 1;
  function cacheHas(cache2, key) {
    return cache2.has(key);
  }
  _cacheHas = cacheHas;
  return _cacheHas;
}
var _equalArrays;
var hasRequired_equalArrays;
function require_equalArrays() {
  if (hasRequired_equalArrays)
    return _equalArrays;
  hasRequired_equalArrays = 1;
  var SetCache = require_SetCache(), arraySome = require_arraySome(), cacheHas = require_cacheHas();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function equalArrays(array2, other, bitmask, customizer, equalFunc, stack2) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var arrStacked = stack2.get(array2);
    var othStacked = stack2.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array2;
    }
    var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
    stack2.set(array2, other);
    stack2.set(other, array2);
    while (++index2 < arrLength) {
      var arrValue = array2[index2], othValue = other[index2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack2) : customizer(arrValue, othValue, index2, array2, other, stack2);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
        result = false;
        break;
      }
    }
    stack2["delete"](array2);
    stack2["delete"](other);
    return result;
  }
  _equalArrays = equalArrays;
  return _equalArrays;
}
var _mapToArray;
var hasRequired_mapToArray;
function require_mapToArray() {
  if (hasRequired_mapToArray)
    return _mapToArray;
  hasRequired_mapToArray = 1;
  function mapToArray(map2) {
    var index2 = -1, result = Array(map2.size);
    map2.forEach(function(value, key) {
      result[++index2] = [key, value];
    });
    return result;
  }
  _mapToArray = mapToArray;
  return _mapToArray;
}
var _setToArray;
var hasRequired_setToArray;
function require_setToArray() {
  if (hasRequired_setToArray)
    return _setToArray;
  hasRequired_setToArray = 1;
  function setToArray(set2) {
    var index2 = -1, result = Array(set2.size);
    set2.forEach(function(value) {
      result[++index2] = value;
    });
    return result;
  }
  _setToArray = setToArray;
  return _setToArray;
}
var _equalByTag;
var hasRequired_equalByTag;
function require_equalByTag() {
  if (hasRequired_equalByTag)
    return _equalByTag;
  hasRequired_equalByTag = 1;
  var Symbol2 = require_Symbol$1(), Uint8Array2 = require_Uint8Array(), eq2 = requireEq$1(), equalArrays = require_equalArrays(), mapToArray = require_mapToArray(), setToArray = require_setToArray();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack2) {
    switch (tag) {
      case dataViewTag:
        if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
          return false;
        }
        object2 = object2.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
          return false;
        }
        return true;
      case boolTag:
      case dateTag:
      case numberTag:
        return eq2(+object2, +other);
      case errorTag:
        return object2.name == other.name && object2.message == other.message;
      case regexpTag:
      case stringTag:
        return object2 == other + "";
      case mapTag:
        var convert = mapToArray;
      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert || (convert = setToArray);
        if (object2.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack2.get(object2);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;
        stack2.set(object2, other);
        var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack2);
        stack2["delete"](object2);
        return result;
      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object2) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  _equalByTag = equalByTag;
  return _equalByTag;
}
var _equalObjects;
var hasRequired_equalObjects;
function require_equalObjects() {
  if (hasRequired_equalObjects)
    return _equalObjects;
  hasRequired_equalObjects = 1;
  var getAllKeys = require_getAllKeys();
  var COMPARE_PARTIAL_FLAG = 1;
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function equalObjects(object2, other, bitmask, customizer, equalFunc, stack2) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index2 = objLength;
    while (index2--) {
      var key = objProps[index2];
      if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
        return false;
      }
    }
    var objStacked = stack2.get(object2);
    var othStacked = stack2.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object2;
    }
    var result = true;
    stack2.set(object2, other);
    stack2.set(other, object2);
    var skipCtor = isPartial;
    while (++index2 < objLength) {
      key = objProps[index2];
      var objValue = object2[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack2) : customizer(objValue, othValue, key, object2, other, stack2);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object2.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack2["delete"](object2);
    stack2["delete"](other);
    return result;
  }
  _equalObjects = equalObjects;
  return _equalObjects;
}
var _baseIsEqualDeep;
var hasRequired_baseIsEqualDeep;
function require_baseIsEqualDeep() {
  if (hasRequired_baseIsEqualDeep)
    return _baseIsEqualDeep;
  hasRequired_baseIsEqualDeep = 1;
  var Stack2 = require_Stack(), equalArrays = require_equalArrays(), equalByTag = require_equalByTag(), equalObjects = require_equalObjects(), getTag = require_getTag(), isArray = requireIsArray$1(), isBuffer2 = requireIsBuffer$1(), isTypedArray = requireIsTypedArray$1();
  var COMPARE_PARTIAL_FLAG = 1;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack2) {
    var objIsArr = isArray(object2), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer2(object2)) {
      if (!isBuffer2(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack2 || (stack2 = new Stack2());
      return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack2);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
        stack2 || (stack2 = new Stack2());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack2 || (stack2 = new Stack2());
    return equalObjects(object2, other, bitmask, customizer, equalFunc, stack2);
  }
  _baseIsEqualDeep = baseIsEqualDeep;
  return _baseIsEqualDeep;
}
var _baseIsEqual;
var hasRequired_baseIsEqual;
function require_baseIsEqual() {
  if (hasRequired_baseIsEqual)
    return _baseIsEqual;
  hasRequired_baseIsEqual = 1;
  var baseIsEqualDeep = require_baseIsEqualDeep(), isObjectLike = requireIsObjectLike$1();
  function baseIsEqual(value, other, bitmask, customizer, stack2) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
  }
  _baseIsEqual = baseIsEqual;
  return _baseIsEqual;
}
var _baseIsMatch;
var hasRequired_baseIsMatch;
function require_baseIsMatch() {
  if (hasRequired_baseIsMatch)
    return _baseIsMatch;
  hasRequired_baseIsMatch = 1;
  var Stack2 = require_Stack(), baseIsEqual = require_baseIsEqual();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function baseIsMatch(object2, source, matchData, customizer) {
    var index2 = matchData.length, length2 = index2, noCustomizer = !customizer;
    if (object2 == null) {
      return !length2;
    }
    object2 = Object(object2);
    while (index2--) {
      var data2 = matchData[index2];
      if (noCustomizer && data2[2] ? data2[1] !== object2[data2[0]] : !(data2[0] in object2)) {
        return false;
      }
    }
    while (++index2 < length2) {
      data2 = matchData[index2];
      var key = data2[0], objValue = object2[key], srcValue = data2[1];
      if (noCustomizer && data2[2]) {
        if (objValue === void 0 && !(key in object2)) {
          return false;
        }
      } else {
        var stack2 = new Stack2();
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object2, source, stack2);
        }
        if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack2) : result)) {
          return false;
        }
      }
    }
    return true;
  }
  _baseIsMatch = baseIsMatch;
  return _baseIsMatch;
}
var _isStrictComparable;
var hasRequired_isStrictComparable;
function require_isStrictComparable() {
  if (hasRequired_isStrictComparable)
    return _isStrictComparable;
  hasRequired_isStrictComparable = 1;
  var isObject2 = requireIsObject$1();
  function isStrictComparable(value) {
    return value === value && !isObject2(value);
  }
  _isStrictComparable = isStrictComparable;
  return _isStrictComparable;
}
var _getMatchData;
var hasRequired_getMatchData;
function require_getMatchData() {
  if (hasRequired_getMatchData)
    return _getMatchData;
  hasRequired_getMatchData = 1;
  var isStrictComparable = require_isStrictComparable(), keys2 = requireKeys$1();
  function getMatchData(object2) {
    var result = keys2(object2), length2 = result.length;
    while (length2--) {
      var key = result[length2], value = object2[key];
      result[length2] = [key, value, isStrictComparable(value)];
    }
    return result;
  }
  _getMatchData = getMatchData;
  return _getMatchData;
}
var _matchesStrictComparable;
var hasRequired_matchesStrictComparable;
function require_matchesStrictComparable() {
  if (hasRequired_matchesStrictComparable)
    return _matchesStrictComparable;
  hasRequired_matchesStrictComparable = 1;
  function matchesStrictComparable(key, srcValue) {
    return function(object2) {
      if (object2 == null) {
        return false;
      }
      return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
    };
  }
  _matchesStrictComparable = matchesStrictComparable;
  return _matchesStrictComparable;
}
var _baseMatches;
var hasRequired_baseMatches;
function require_baseMatches() {
  if (hasRequired_baseMatches)
    return _baseMatches;
  hasRequired_baseMatches = 1;
  var baseIsMatch = require_baseIsMatch(), getMatchData = require_getMatchData(), matchesStrictComparable = require_matchesStrictComparable();
  function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object2) {
      return object2 === source || baseIsMatch(object2, source, matchData);
    };
  }
  _baseMatches = baseMatches;
  return _baseMatches;
}
var isSymbol_1$1;
var hasRequiredIsSymbol$1;
function requireIsSymbol$1() {
  if (hasRequiredIsSymbol$1)
    return isSymbol_1$1;
  hasRequiredIsSymbol$1 = 1;
  var baseGetTag = require_baseGetTag$1(), isObjectLike = requireIsObjectLike$1();
  var symbolTag = "[object Symbol]";
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
  }
  isSymbol_1$1 = isSymbol;
  return isSymbol_1$1;
}
var _isKey$1;
var hasRequired_isKey$1;
function require_isKey$1() {
  if (hasRequired_isKey$1)
    return _isKey$1;
  hasRequired_isKey$1 = 1;
  var isArray = requireIsArray$1(), isSymbol = requireIsSymbol$1();
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
  function isKey(value, object2) {
    if (isArray(value)) {
      return false;
    }
    var type2 = typeof value;
    if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
  }
  _isKey$1 = isKey;
  return _isKey$1;
}
var memoize_1$1;
var hasRequiredMemoize;
function requireMemoize() {
  if (hasRequiredMemoize)
    return memoize_1$1;
  hasRequiredMemoize = 1;
  var MapCache2 = require_MapCache();
  var FUNC_ERROR_TEXT2 = "Expected a function";
  function memoize2(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT2);
    }
    var memoized = function() {
      var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
      if (cache2.has(key)) {
        return cache2.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache2.set(key, result) || cache2;
      return result;
    };
    memoized.cache = new (memoize2.Cache || MapCache2)();
    return memoized;
  }
  memoize2.Cache = MapCache2;
  memoize_1$1 = memoize2;
  return memoize_1$1;
}
var _memoizeCapped$1;
var hasRequired_memoizeCapped$1;
function require_memoizeCapped$1() {
  if (hasRequired_memoizeCapped$1)
    return _memoizeCapped$1;
  hasRequired_memoizeCapped$1 = 1;
  var memoize2 = requireMemoize();
  var MAX_MEMOIZE_SIZE = 500;
  function memoizeCapped(func) {
    var result = memoize2(func, function(key) {
      if (cache2.size === MAX_MEMOIZE_SIZE) {
        cache2.clear();
      }
      return key;
    });
    var cache2 = result.cache;
    return result;
  }
  _memoizeCapped$1 = memoizeCapped;
  return _memoizeCapped$1;
}
var _stringToPath$1;
var hasRequired_stringToPath$1;
function require_stringToPath$1() {
  if (hasRequired_stringToPath$1)
    return _stringToPath$1;
  hasRequired_stringToPath$1 = 1;
  var memoizeCapped = require_memoizeCapped$1();
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped(function(string2) {
    var result = [];
    if (string2.charCodeAt(0) === 46) {
      result.push("");
    }
    string2.replace(rePropName, function(match, number3, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number3 || match);
    });
    return result;
  });
  _stringToPath$1 = stringToPath;
  return _stringToPath$1;
}
var _arrayMap$1;
var hasRequired_arrayMap$1;
function require_arrayMap$1() {
  if (hasRequired_arrayMap$1)
    return _arrayMap$1;
  hasRequired_arrayMap$1 = 1;
  function arrayMap(array2, iteratee) {
    var index2 = -1, length2 = array2 == null ? 0 : array2.length, result = Array(length2);
    while (++index2 < length2) {
      result[index2] = iteratee(array2[index2], index2, array2);
    }
    return result;
  }
  _arrayMap$1 = arrayMap;
  return _arrayMap$1;
}
var _baseToString$1;
var hasRequired_baseToString$1;
function require_baseToString$1() {
  if (hasRequired_baseToString$1)
    return _baseToString$1;
  hasRequired_baseToString$1 = 1;
  var Symbol2 = require_Symbol$1(), arrayMap = require_arrayMap$1(), isArray = requireIsArray$1(), isSymbol = requireIsSymbol$1();
  var INFINITY = 1 / 0;
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray(value)) {
      return arrayMap(value, baseToString) + "";
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  _baseToString$1 = baseToString;
  return _baseToString$1;
}
var toString_1$1;
var hasRequiredToString$1;
function requireToString$1() {
  if (hasRequiredToString$1)
    return toString_1$1;
  hasRequiredToString$1 = 1;
  var baseToString = require_baseToString$1();
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  toString_1$1 = toString;
  return toString_1$1;
}
var _castPath$1;
var hasRequired_castPath$1;
function require_castPath$1() {
  if (hasRequired_castPath$1)
    return _castPath$1;
  hasRequired_castPath$1 = 1;
  var isArray = requireIsArray$1(), isKey = require_isKey$1(), stringToPath = require_stringToPath$1(), toString = requireToString$1();
  function castPath(value, object2) {
    if (isArray(value)) {
      return value;
    }
    return isKey(value, object2) ? [value] : stringToPath(toString(value));
  }
  _castPath$1 = castPath;
  return _castPath$1;
}
var _toKey$1;
var hasRequired_toKey$1;
function require_toKey$1() {
  if (hasRequired_toKey$1)
    return _toKey$1;
  hasRequired_toKey$1 = 1;
  var isSymbol = requireIsSymbol$1();
  var INFINITY = 1 / 0;
  function toKey(value) {
    if (typeof value == "string" || isSymbol(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  _toKey$1 = toKey;
  return _toKey$1;
}
var _baseGet$1;
var hasRequired_baseGet$1;
function require_baseGet$1() {
  if (hasRequired_baseGet$1)
    return _baseGet$1;
  hasRequired_baseGet$1 = 1;
  var castPath = require_castPath$1(), toKey = require_toKey$1();
  function baseGet(object2, path2) {
    path2 = castPath(path2, object2);
    var index2 = 0, length2 = path2.length;
    while (object2 != null && index2 < length2) {
      object2 = object2[toKey(path2[index2++])];
    }
    return index2 && index2 == length2 ? object2 : void 0;
  }
  _baseGet$1 = baseGet;
  return _baseGet$1;
}
var get_1;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet)
    return get_1;
  hasRequiredGet = 1;
  var baseGet = require_baseGet$1();
  function get2(object2, path2, defaultValue) {
    var result = object2 == null ? void 0 : baseGet(object2, path2);
    return result === void 0 ? defaultValue : result;
  }
  get_1 = get2;
  return get_1;
}
var _baseHasIn$1;
var hasRequired_baseHasIn$1;
function require_baseHasIn$1() {
  if (hasRequired_baseHasIn$1)
    return _baseHasIn$1;
  hasRequired_baseHasIn$1 = 1;
  function baseHasIn(object2, key) {
    return object2 != null && key in Object(object2);
  }
  _baseHasIn$1 = baseHasIn;
  return _baseHasIn$1;
}
var _hasPath$1;
var hasRequired_hasPath$1;
function require_hasPath$1() {
  if (hasRequired_hasPath$1)
    return _hasPath$1;
  hasRequired_hasPath$1 = 1;
  var castPath = require_castPath$1(), isArguments = requireIsArguments$1(), isArray = requireIsArray$1(), isIndex = require_isIndex$1(), isLength = requireIsLength$1(), toKey = require_toKey$1();
  function hasPath(object2, path2, hasFunc) {
    path2 = castPath(path2, object2);
    var index2 = -1, length2 = path2.length, result = false;
    while (++index2 < length2) {
      var key = toKey(path2[index2]);
      if (!(result = object2 != null && hasFunc(object2, key))) {
        break;
      }
      object2 = object2[key];
    }
    if (result || ++index2 != length2) {
      return result;
    }
    length2 = object2 == null ? 0 : object2.length;
    return !!length2 && isLength(length2) && isIndex(key, length2) && (isArray(object2) || isArguments(object2));
  }
  _hasPath$1 = hasPath;
  return _hasPath$1;
}
var hasIn_1$1;
var hasRequiredHasIn$1;
function requireHasIn$1() {
  if (hasRequiredHasIn$1)
    return hasIn_1$1;
  hasRequiredHasIn$1 = 1;
  var baseHasIn = require_baseHasIn$1(), hasPath = require_hasPath$1();
  function hasIn(object2, path2) {
    return object2 != null && hasPath(object2, path2, baseHasIn);
  }
  hasIn_1$1 = hasIn;
  return hasIn_1$1;
}
var _baseMatchesProperty;
var hasRequired_baseMatchesProperty;
function require_baseMatchesProperty() {
  if (hasRequired_baseMatchesProperty)
    return _baseMatchesProperty;
  hasRequired_baseMatchesProperty = 1;
  var baseIsEqual = require_baseIsEqual(), get2 = requireGet(), hasIn = requireHasIn$1(), isKey = require_isKey$1(), isStrictComparable = require_isStrictComparable(), matchesStrictComparable = require_matchesStrictComparable(), toKey = require_toKey$1();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function baseMatchesProperty(path2, srcValue) {
    if (isKey(path2) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path2), srcValue);
    }
    return function(object2) {
      var objValue = get2(object2, path2);
      return objValue === void 0 && objValue === srcValue ? hasIn(object2, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
  }
  _baseMatchesProperty = baseMatchesProperty;
  return _baseMatchesProperty;
}
var _baseProperty;
var hasRequired_baseProperty;
function require_baseProperty() {
  if (hasRequired_baseProperty)
    return _baseProperty;
  hasRequired_baseProperty = 1;
  function baseProperty(key) {
    return function(object2) {
      return object2 == null ? void 0 : object2[key];
    };
  }
  _baseProperty = baseProperty;
  return _baseProperty;
}
var _basePropertyDeep;
var hasRequired_basePropertyDeep;
function require_basePropertyDeep() {
  if (hasRequired_basePropertyDeep)
    return _basePropertyDeep;
  hasRequired_basePropertyDeep = 1;
  var baseGet = require_baseGet$1();
  function basePropertyDeep(path2) {
    return function(object2) {
      return baseGet(object2, path2);
    };
  }
  _basePropertyDeep = basePropertyDeep;
  return _basePropertyDeep;
}
var property_1;
var hasRequiredProperty;
function requireProperty() {
  if (hasRequiredProperty)
    return property_1;
  hasRequiredProperty = 1;
  var baseProperty = require_baseProperty(), basePropertyDeep = require_basePropertyDeep(), isKey = require_isKey$1(), toKey = require_toKey$1();
  function property(path2) {
    return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
  }
  property_1 = property;
  return property_1;
}
var _baseIteratee;
var hasRequired_baseIteratee;
function require_baseIteratee() {
  if (hasRequired_baseIteratee)
    return _baseIteratee;
  hasRequired_baseIteratee = 1;
  var baseMatches = require_baseMatches(), baseMatchesProperty = require_baseMatchesProperty(), identity2 = requireIdentity$1(), isArray = requireIsArray$1(), property = requireProperty();
  function baseIteratee(value) {
    if (typeof value == "function") {
      return value;
    }
    if (value == null) {
      return identity2;
    }
    if (typeof value == "object") {
      return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }
    return property(value);
  }
  _baseIteratee = baseIteratee;
  return _baseIteratee;
}
var filter_1;
var hasRequiredFilter;
function requireFilter() {
  if (hasRequiredFilter)
    return filter_1;
  hasRequiredFilter = 1;
  var arrayFilter = require_arrayFilter(), baseFilter = require_baseFilter(), baseIteratee = require_baseIteratee(), isArray = requireIsArray$1();
  function filter(collection, predicate) {
    var func = isArray(collection) ? arrayFilter : baseFilter;
    return func(collection, baseIteratee(predicate, 3));
  }
  filter_1 = filter;
  return filter_1;
}
var _baseHas$1;
var hasRequired_baseHas$1;
function require_baseHas$1() {
  if (hasRequired_baseHas$1)
    return _baseHas$1;
  hasRequired_baseHas$1 = 1;
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function baseHas(object2, key) {
    return object2 != null && hasOwnProperty2.call(object2, key);
  }
  _baseHas$1 = baseHas;
  return _baseHas$1;
}
var has_1$1;
var hasRequiredHas$1;
function requireHas$1() {
  if (hasRequiredHas$1)
    return has_1$1;
  hasRequiredHas$1 = 1;
  var baseHas = require_baseHas$1(), hasPath = require_hasPath$1();
  function has(object2, path2) {
    return object2 != null && hasPath(object2, path2, baseHas);
  }
  has_1$1 = has;
  return has_1$1;
}
var isEmpty_1;
var hasRequiredIsEmpty;
function requireIsEmpty() {
  if (hasRequiredIsEmpty)
    return isEmpty_1;
  hasRequiredIsEmpty = 1;
  var baseKeys = require_baseKeys$1(), getTag = require_getTag(), isArguments = requireIsArguments$1(), isArray = requireIsArray$1(), isArrayLike = requireIsArrayLike$1(), isBuffer2 = requireIsBuffer$1(), isPrototype = require_isPrototype$1(), isTypedArray = requireIsTypedArray$1();
  var mapTag = "[object Map]", setTag = "[object Set]";
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function isEmpty(value) {
    if (value == null) {
      return true;
    }
    if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray(value) || isArguments(value))) {
      return !value.length;
    }
    var tag = getTag(value);
    if (tag == mapTag || tag == setTag) {
      return !value.size;
    }
    if (isPrototype(value)) {
      return !baseKeys(value).length;
    }
    for (var key in value) {
      if (hasOwnProperty2.call(value, key)) {
        return false;
      }
    }
    return true;
  }
  isEmpty_1 = isEmpty;
  return isEmpty_1;
}
var isUndefined_1;
var hasRequiredIsUndefined;
function requireIsUndefined() {
  if (hasRequiredIsUndefined)
    return isUndefined_1;
  hasRequiredIsUndefined = 1;
  function isUndefined(value) {
    return value === void 0;
  }
  isUndefined_1 = isUndefined;
  return isUndefined_1;
}
var _baseMap;
var hasRequired_baseMap;
function require_baseMap() {
  if (hasRequired_baseMap)
    return _baseMap;
  hasRequired_baseMap = 1;
  var baseEach = require_baseEach$1(), isArrayLike = requireIsArrayLike$1();
  function baseMap(collection, iteratee) {
    var index2 = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
    baseEach(collection, function(value, key, collection2) {
      result[++index2] = iteratee(value, key, collection2);
    });
    return result;
  }
  _baseMap = baseMap;
  return _baseMap;
}
var map_1;
var hasRequiredMap;
function requireMap() {
  if (hasRequiredMap)
    return map_1;
  hasRequiredMap = 1;
  var arrayMap = require_arrayMap$1(), baseIteratee = require_baseIteratee(), baseMap = require_baseMap(), isArray = requireIsArray$1();
  function map2(collection, iteratee) {
    var func = isArray(collection) ? arrayMap : baseMap;
    return func(collection, baseIteratee(iteratee, 3));
  }
  map_1 = map2;
  return map_1;
}
var _arrayReduce;
var hasRequired_arrayReduce;
function require_arrayReduce() {
  if (hasRequired_arrayReduce)
    return _arrayReduce;
  hasRequired_arrayReduce = 1;
  function arrayReduce(array2, iteratee, accumulator, initAccum) {
    var index2 = -1, length2 = array2 == null ? 0 : array2.length;
    if (initAccum && length2) {
      accumulator = array2[++index2];
    }
    while (++index2 < length2) {
      accumulator = iteratee(accumulator, array2[index2], index2, array2);
    }
    return accumulator;
  }
  _arrayReduce = arrayReduce;
  return _arrayReduce;
}
var _baseReduce;
var hasRequired_baseReduce;
function require_baseReduce() {
  if (hasRequired_baseReduce)
    return _baseReduce;
  hasRequired_baseReduce = 1;
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index2, collection2) {
      accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
    });
    return accumulator;
  }
  _baseReduce = baseReduce;
  return _baseReduce;
}
var reduce_1;
var hasRequiredReduce;
function requireReduce() {
  if (hasRequiredReduce)
    return reduce_1;
  hasRequiredReduce = 1;
  var arrayReduce = require_arrayReduce(), baseEach = require_baseEach$1(), baseIteratee = require_baseIteratee(), baseReduce = require_baseReduce(), isArray = requireIsArray$1();
  function reduce(collection, iteratee, accumulator) {
    var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
    return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
  }
  reduce_1 = reduce;
  return reduce_1;
}
var isString_1;
var hasRequiredIsString;
function requireIsString() {
  if (hasRequiredIsString)
    return isString_1;
  hasRequiredIsString = 1;
  var baseGetTag = require_baseGetTag$1(), isArray = requireIsArray$1(), isObjectLike = requireIsObjectLike$1();
  var stringTag = "[object String]";
  function isString(value) {
    return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
  }
  isString_1 = isString;
  return isString_1;
}
var _asciiSize;
var hasRequired_asciiSize;
function require_asciiSize() {
  if (hasRequired_asciiSize)
    return _asciiSize;
  hasRequired_asciiSize = 1;
  var baseProperty = require_baseProperty();
  var asciiSize = baseProperty("length");
  _asciiSize = asciiSize;
  return _asciiSize;
}
var _hasUnicode;
var hasRequired_hasUnicode;
function require_hasUnicode() {
  if (hasRequired_hasUnicode)
    return _hasUnicode;
  hasRequired_hasUnicode = 1;
  var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
  var rsZWJ = "\\u200d";
  var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
  function hasUnicode(string2) {
    return reHasUnicode.test(string2);
  }
  _hasUnicode = hasUnicode;
  return _hasUnicode;
}
var _unicodeSize;
var hasRequired_unicodeSize;
function require_unicodeSize() {
  if (hasRequired_unicodeSize)
    return _unicodeSize;
  hasRequired_unicodeSize = 1;
  var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
  var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
  var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
  var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
  function unicodeSize(string2) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string2)) {
      ++result;
    }
    return result;
  }
  _unicodeSize = unicodeSize;
  return _unicodeSize;
}
var _stringSize;
var hasRequired_stringSize;
function require_stringSize() {
  if (hasRequired_stringSize)
    return _stringSize;
  hasRequired_stringSize = 1;
  var asciiSize = require_asciiSize(), hasUnicode = require_hasUnicode(), unicodeSize = require_unicodeSize();
  function stringSize(string2) {
    return hasUnicode(string2) ? unicodeSize(string2) : asciiSize(string2);
  }
  _stringSize = stringSize;
  return _stringSize;
}
var size_1;
var hasRequiredSize;
function requireSize() {
  if (hasRequiredSize)
    return size_1;
  hasRequiredSize = 1;
  var baseKeys = require_baseKeys$1(), getTag = require_getTag(), isArrayLike = requireIsArrayLike$1(), isString = requireIsString(), stringSize = require_stringSize();
  var mapTag = "[object Map]", setTag = "[object Set]";
  function size(collection) {
    if (collection == null) {
      return 0;
    }
    if (isArrayLike(collection)) {
      return isString(collection) ? stringSize(collection) : collection.length;
    }
    var tag = getTag(collection);
    if (tag == mapTag || tag == setTag) {
      return collection.size;
    }
    return baseKeys(collection).length;
  }
  size_1 = size;
  return size_1;
}
var transform_1;
var hasRequiredTransform;
function requireTransform() {
  if (hasRequiredTransform)
    return transform_1;
  hasRequiredTransform = 1;
  var arrayEach = require_arrayEach$1(), baseCreate = require_baseCreate(), baseForOwn = require_baseForOwn$1(), baseIteratee = require_baseIteratee(), getPrototype = require_getPrototype$1(), isArray = requireIsArray$1(), isBuffer2 = requireIsBuffer$1(), isFunction2 = requireIsFunction$1(), isObject2 = requireIsObject$1(), isTypedArray = requireIsTypedArray$1();
  function transform2(object2, iteratee, accumulator) {
    var isArr = isArray(object2), isArrLike = isArr || isBuffer2(object2) || isTypedArray(object2);
    iteratee = baseIteratee(iteratee, 4);
    if (accumulator == null) {
      var Ctor = object2 && object2.constructor;
      if (isArrLike) {
        accumulator = isArr ? new Ctor() : [];
      } else if (isObject2(object2)) {
        accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object2)) : {};
      } else {
        accumulator = {};
      }
    }
    (isArrLike ? arrayEach : baseForOwn)(object2, function(value, index2, object3) {
      return iteratee(accumulator, value, index2, object3);
    });
    return accumulator;
  }
  transform_1 = transform2;
  return transform_1;
}
var _isFlattenable$1;
var hasRequired_isFlattenable$1;
function require_isFlattenable$1() {
  if (hasRequired_isFlattenable$1)
    return _isFlattenable$1;
  hasRequired_isFlattenable$1 = 1;
  var Symbol2 = require_Symbol$1(), isArguments = requireIsArguments$1(), isArray = requireIsArray$1();
  var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
  function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  _isFlattenable$1 = isFlattenable;
  return _isFlattenable$1;
}
var _baseFlatten$1;
var hasRequired_baseFlatten$1;
function require_baseFlatten$1() {
  if (hasRequired_baseFlatten$1)
    return _baseFlatten$1;
  hasRequired_baseFlatten$1 = 1;
  var arrayPush2 = require_arrayPush$1(), isFlattenable = require_isFlattenable$1();
  function baseFlatten(array2, depth, predicate, isStrict, result) {
    var index2 = -1, length2 = array2.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index2 < length2) {
      var value = array2[index2];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush2(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }
  _baseFlatten$1 = baseFlatten;
  return _baseFlatten$1;
}
var _apply$1;
var hasRequired_apply$1;
function require_apply$1() {
  if (hasRequired_apply$1)
    return _apply$1;
  hasRequired_apply$1 = 1;
  function apply2(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  _apply$1 = apply2;
  return _apply$1;
}
var _overRest$1;
var hasRequired_overRest$1;
function require_overRest$1() {
  if (hasRequired_overRest$1)
    return _overRest$1;
  hasRequired_overRest$1 = 1;
  var apply2 = require_apply$1();
  var nativeMax = Math.max;
  function overRest(func, start2, transform2) {
    start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
    return function() {
      var args = arguments, index2 = -1, length2 = nativeMax(args.length - start2, 0), array2 = Array(length2);
      while (++index2 < length2) {
        array2[index2] = args[start2 + index2];
      }
      index2 = -1;
      var otherArgs = Array(start2 + 1);
      while (++index2 < start2) {
        otherArgs[index2] = args[index2];
      }
      otherArgs[start2] = transform2(array2);
      return apply2(func, this, otherArgs);
    };
  }
  _overRest$1 = overRest;
  return _overRest$1;
}
var _baseSetToString$1;
var hasRequired_baseSetToString$1;
function require_baseSetToString$1() {
  if (hasRequired_baseSetToString$1)
    return _baseSetToString$1;
  hasRequired_baseSetToString$1 = 1;
  var constant2 = requireConstant$1(), defineProperty = require_defineProperty$1(), identity2 = requireIdentity$1();
  var baseSetToString = !defineProperty ? identity2 : function(func, string2) {
    return defineProperty(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant2(string2),
      "writable": true
    });
  };
  _baseSetToString$1 = baseSetToString;
  return _baseSetToString$1;
}
var _shortOut$1;
var hasRequired_shortOut$1;
function require_shortOut$1() {
  if (hasRequired_shortOut$1)
    return _shortOut$1;
  hasRequired_shortOut$1 = 1;
  var HOT_COUNT = 800, HOT_SPAN = 16;
  var nativeNow = Date.now;
  function shortOut(func) {
    var count2 = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count2 >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count2 = 0;
      }
      return func.apply(void 0, arguments);
    };
  }
  _shortOut$1 = shortOut;
  return _shortOut$1;
}
var _setToString$1;
var hasRequired_setToString$1;
function require_setToString$1() {
  if (hasRequired_setToString$1)
    return _setToString$1;
  hasRequired_setToString$1 = 1;
  var baseSetToString = require_baseSetToString$1(), shortOut = require_shortOut$1();
  var setToString = shortOut(baseSetToString);
  _setToString$1 = setToString;
  return _setToString$1;
}
var _baseRest$1;
var hasRequired_baseRest$1;
function require_baseRest$1() {
  if (hasRequired_baseRest$1)
    return _baseRest$1;
  hasRequired_baseRest$1 = 1;
  var identity2 = requireIdentity$1(), overRest = require_overRest$1(), setToString = require_setToString$1();
  function baseRest(func, start2) {
    return setToString(overRest(func, start2, identity2), func + "");
  }
  _baseRest$1 = baseRest;
  return _baseRest$1;
}
var _baseFindIndex;
var hasRequired_baseFindIndex;
function require_baseFindIndex() {
  if (hasRequired_baseFindIndex)
    return _baseFindIndex;
  hasRequired_baseFindIndex = 1;
  function baseFindIndex(array2, predicate, fromIndex, fromRight) {
    var length2 = array2.length, index2 = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index2-- : ++index2 < length2) {
      if (predicate(array2[index2], index2, array2)) {
        return index2;
      }
    }
    return -1;
  }
  _baseFindIndex = baseFindIndex;
  return _baseFindIndex;
}
var _baseIsNaN;
var hasRequired_baseIsNaN;
function require_baseIsNaN() {
  if (hasRequired_baseIsNaN)
    return _baseIsNaN;
  hasRequired_baseIsNaN = 1;
  function baseIsNaN(value) {
    return value !== value;
  }
  _baseIsNaN = baseIsNaN;
  return _baseIsNaN;
}
var _strictIndexOf;
var hasRequired_strictIndexOf;
function require_strictIndexOf() {
  if (hasRequired_strictIndexOf)
    return _strictIndexOf;
  hasRequired_strictIndexOf = 1;
  function strictIndexOf(array2, value, fromIndex) {
    var index2 = fromIndex - 1, length2 = array2.length;
    while (++index2 < length2) {
      if (array2[index2] === value) {
        return index2;
      }
    }
    return -1;
  }
  _strictIndexOf = strictIndexOf;
  return _strictIndexOf;
}
var _baseIndexOf;
var hasRequired_baseIndexOf;
function require_baseIndexOf() {
  if (hasRequired_baseIndexOf)
    return _baseIndexOf;
  hasRequired_baseIndexOf = 1;
  var baseFindIndex = require_baseFindIndex(), baseIsNaN = require_baseIsNaN(), strictIndexOf = require_strictIndexOf();
  function baseIndexOf(array2, value, fromIndex) {
    return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
  }
  _baseIndexOf = baseIndexOf;
  return _baseIndexOf;
}
var _arrayIncludes;
var hasRequired_arrayIncludes;
function require_arrayIncludes() {
  if (hasRequired_arrayIncludes)
    return _arrayIncludes;
  hasRequired_arrayIncludes = 1;
  var baseIndexOf = require_baseIndexOf();
  function arrayIncludes(array2, value) {
    var length2 = array2 == null ? 0 : array2.length;
    return !!length2 && baseIndexOf(array2, value, 0) > -1;
  }
  _arrayIncludes = arrayIncludes;
  return _arrayIncludes;
}
var _arrayIncludesWith;
var hasRequired_arrayIncludesWith;
function require_arrayIncludesWith() {
  if (hasRequired_arrayIncludesWith)
    return _arrayIncludesWith;
  hasRequired_arrayIncludesWith = 1;
  function arrayIncludesWith(array2, value, comparator) {
    var index2 = -1, length2 = array2 == null ? 0 : array2.length;
    while (++index2 < length2) {
      if (comparator(value, array2[index2])) {
        return true;
      }
    }
    return false;
  }
  _arrayIncludesWith = arrayIncludesWith;
  return _arrayIncludesWith;
}
var noop_1;
var hasRequiredNoop;
function requireNoop() {
  if (hasRequiredNoop)
    return noop_1;
  hasRequiredNoop = 1;
  function noop2() {
  }
  noop_1 = noop2;
  return noop_1;
}
var _createSet;
var hasRequired_createSet;
function require_createSet() {
  if (hasRequired_createSet)
    return _createSet;
  hasRequired_createSet = 1;
  var Set4 = require_Set(), noop2 = requireNoop(), setToArray = require_setToArray();
  var INFINITY = 1 / 0;
  var createSet = !(Set4 && 1 / setToArray(new Set4([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
    return new Set4(values2);
  };
  _createSet = createSet;
  return _createSet;
}
var _baseUniq;
var hasRequired_baseUniq;
function require_baseUniq() {
  if (hasRequired_baseUniq)
    return _baseUniq;
  hasRequired_baseUniq = 1;
  var SetCache = require_SetCache(), arrayIncludes = require_arrayIncludes(), arrayIncludesWith = require_arrayIncludesWith(), cacheHas = require_cacheHas(), createSet = require_createSet(), setToArray = require_setToArray();
  var LARGE_ARRAY_SIZE = 200;
  function baseUniq(array2, iteratee, comparator) {
    var index2 = -1, includes2 = arrayIncludes, length2 = array2.length, isCommon = true, result = [], seen = result;
    if (comparator) {
      isCommon = false;
      includes2 = arrayIncludesWith;
    } else if (length2 >= LARGE_ARRAY_SIZE) {
      var set2 = iteratee ? null : createSet(array2);
      if (set2) {
        return setToArray(set2);
      }
      isCommon = false;
      includes2 = cacheHas;
      seen = new SetCache();
    } else {
      seen = iteratee ? [] : result;
    }
    outer:
      while (++index2 < length2) {
        var value = array2[index2], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        } else if (!includes2(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
    return result;
  }
  _baseUniq = baseUniq;
  return _baseUniq;
}
var isArrayLikeObject_1;
var hasRequiredIsArrayLikeObject;
function requireIsArrayLikeObject() {
  if (hasRequiredIsArrayLikeObject)
    return isArrayLikeObject_1;
  hasRequiredIsArrayLikeObject = 1;
  var isArrayLike = requireIsArrayLike$1(), isObjectLike = requireIsObjectLike$1();
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  isArrayLikeObject_1 = isArrayLikeObject;
  return isArrayLikeObject_1;
}
var union_1;
var hasRequiredUnion;
function requireUnion() {
  if (hasRequiredUnion)
    return union_1;
  hasRequiredUnion = 1;
  var baseFlatten = require_baseFlatten$1(), baseRest = require_baseRest$1(), baseUniq = require_baseUniq(), isArrayLikeObject = requireIsArrayLikeObject();
  var union = baseRest(function(arrays) {
    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
  });
  union_1 = union;
  return union_1;
}
var _baseValues;
var hasRequired_baseValues;
function require_baseValues() {
  if (hasRequired_baseValues)
    return _baseValues;
  hasRequired_baseValues = 1;
  var arrayMap = require_arrayMap$1();
  function baseValues(object2, props) {
    return arrayMap(props, function(key) {
      return object2[key];
    });
  }
  _baseValues = baseValues;
  return _baseValues;
}
var values_1;
var hasRequiredValues;
function requireValues() {
  if (hasRequiredValues)
    return values_1;
  hasRequiredValues = 1;
  var baseValues = require_baseValues(), keys2 = requireKeys$1();
  function values2(object2) {
    return object2 == null ? [] : baseValues(object2, keys2(object2));
  }
  values_1 = values2;
  return values_1;
}
var lodash$3;
if (typeof commonjsRequire$1 === "function") {
  try {
    lodash$3 = {
      clone: requireClone(),
      constant: requireConstant$1(),
      each: requireEach$1(),
      filter: requireFilter(),
      has: requireHas$1(),
      isArray: requireIsArray$1(),
      isEmpty: requireIsEmpty(),
      isFunction: requireIsFunction$1(),
      isUndefined: requireIsUndefined(),
      keys: requireKeys$1(),
      map: requireMap(),
      reduce: requireReduce(),
      size: requireSize(),
      transform: requireTransform(),
      union: requireUnion(),
      values: requireValues()
    };
  } catch (e) {
  }
}
if (!lodash$3) {
  lodash$3 = window._;
}
var lodash_1$3 = lodash$3;
var _$C = lodash_1$3;
var graph = Graph$a;
var DEFAULT_EDGE_NAME = "\0";
var GRAPH_NODE = "\0";
var EDGE_KEY_DELIM = "";
function Graph$a(opts) {
  this._isDirected = _$C.has(opts, "directed") ? opts.directed : true;
  this._isMultigraph = _$C.has(opts, "multigraph") ? opts.multigraph : false;
  this._isCompound = _$C.has(opts, "compound") ? opts.compound : false;
  this._label = void 0;
  this._defaultNodeLabelFn = _$C.constant(void 0);
  this._defaultEdgeLabelFn = _$C.constant(void 0);
  this._nodes = {};
  if (this._isCompound) {
    this._parent = {};
    this._children = {};
    this._children[GRAPH_NODE] = {};
  }
  this._in = {};
  this._preds = {};
  this._out = {};
  this._sucs = {};
  this._edgeObjs = {};
  this._edgeLabels = {};
}
Graph$a.prototype._nodeCount = 0;
Graph$a.prototype._edgeCount = 0;
Graph$a.prototype.isDirected = function() {
  return this._isDirected;
};
Graph$a.prototype.isMultigraph = function() {
  return this._isMultigraph;
};
Graph$a.prototype.isCompound = function() {
  return this._isCompound;
};
Graph$a.prototype.setGraph = function(label) {
  this._label = label;
  return this;
};
Graph$a.prototype.graph = function() {
  return this._label;
};
Graph$a.prototype.setDefaultNodeLabel = function(newDefault) {
  if (!_$C.isFunction(newDefault)) {
    newDefault = _$C.constant(newDefault);
  }
  this._defaultNodeLabelFn = newDefault;
  return this;
};
Graph$a.prototype.nodeCount = function() {
  return this._nodeCount;
};
Graph$a.prototype.nodes = function() {
  return _$C.keys(this._nodes);
};
Graph$a.prototype.sources = function() {
  var self2 = this;
  return _$C.filter(this.nodes(), function(v) {
    return _$C.isEmpty(self2._in[v]);
  });
};
Graph$a.prototype.sinks = function() {
  var self2 = this;
  return _$C.filter(this.nodes(), function(v) {
    return _$C.isEmpty(self2._out[v]);
  });
};
Graph$a.prototype.setNodes = function(vs, value) {
  var args = arguments;
  var self2 = this;
  _$C.each(vs, function(v) {
    if (args.length > 1) {
      self2.setNode(v, value);
    } else {
      self2.setNode(v);
    }
  });
  return this;
};
Graph$a.prototype.setNode = function(v, value) {
  if (_$C.has(this._nodes, v)) {
    if (arguments.length > 1) {
      this._nodes[v] = value;
    }
    return this;
  }
  this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v);
  if (this._isCompound) {
    this._parent[v] = GRAPH_NODE;
    this._children[v] = {};
    this._children[GRAPH_NODE][v] = true;
  }
  this._in[v] = {};
  this._preds[v] = {};
  this._out[v] = {};
  this._sucs[v] = {};
  ++this._nodeCount;
  return this;
};
Graph$a.prototype.node = function(v) {
  return this._nodes[v];
};
Graph$a.prototype.hasNode = function(v) {
  return _$C.has(this._nodes, v);
};
Graph$a.prototype.removeNode = function(v) {
  var self2 = this;
  if (_$C.has(this._nodes, v)) {
    var removeEdge = function(e) {
      self2.removeEdge(self2._edgeObjs[e]);
    };
    delete this._nodes[v];
    if (this._isCompound) {
      this._removeFromParentsChildList(v);
      delete this._parent[v];
      _$C.each(this.children(v), function(child) {
        self2.setParent(child);
      });
      delete this._children[v];
    }
    _$C.each(_$C.keys(this._in[v]), removeEdge);
    delete this._in[v];
    delete this._preds[v];
    _$C.each(_$C.keys(this._out[v]), removeEdge);
    delete this._out[v];
    delete this._sucs[v];
    --this._nodeCount;
  }
  return this;
};
Graph$a.prototype.setParent = function(v, parent) {
  if (!this._isCompound) {
    throw new Error("Cannot set parent in a non-compound graph");
  }
  if (_$C.isUndefined(parent)) {
    parent = GRAPH_NODE;
  } else {
    parent += "";
    for (var ancestor = parent; !_$C.isUndefined(ancestor); ancestor = this.parent(ancestor)) {
      if (ancestor === v) {
        throw new Error("Setting " + parent + " as parent of " + v + " would create a cycle");
      }
    }
    this.setNode(parent);
  }
  this.setNode(v);
  this._removeFromParentsChildList(v);
  this._parent[v] = parent;
  this._children[parent][v] = true;
  return this;
};
Graph$a.prototype._removeFromParentsChildList = function(v) {
  delete this._children[this._parent[v]][v];
};
Graph$a.prototype.parent = function(v) {
  if (this._isCompound) {
    var parent = this._parent[v];
    if (parent !== GRAPH_NODE) {
      return parent;
    }
  }
};
Graph$a.prototype.children = function(v) {
  if (_$C.isUndefined(v)) {
    v = GRAPH_NODE;
  }
  if (this._isCompound) {
    var children2 = this._children[v];
    if (children2) {
      return _$C.keys(children2);
    }
  } else if (v === GRAPH_NODE) {
    return this.nodes();
  } else if (this.hasNode(v)) {
    return [];
  }
};
Graph$a.prototype.predecessors = function(v) {
  var predsV = this._preds[v];
  if (predsV) {
    return _$C.keys(predsV);
  }
};
Graph$a.prototype.successors = function(v) {
  var sucsV = this._sucs[v];
  if (sucsV) {
    return _$C.keys(sucsV);
  }
};
Graph$a.prototype.neighbors = function(v) {
  var preds = this.predecessors(v);
  if (preds) {
    return _$C.union(preds, this.successors(v));
  }
};
Graph$a.prototype.isLeaf = function(v) {
  var neighbors;
  if (this.isDirected()) {
    neighbors = this.successors(v);
  } else {
    neighbors = this.neighbors(v);
  }
  return neighbors.length === 0;
};
Graph$a.prototype.filterNodes = function(filter) {
  var copy2 = new this.constructor({
    directed: this._isDirected,
    multigraph: this._isMultigraph,
    compound: this._isCompound
  });
  copy2.setGraph(this.graph());
  var self2 = this;
  _$C.each(this._nodes, function(value, v) {
    if (filter(v)) {
      copy2.setNode(v, value);
    }
  });
  _$C.each(this._edgeObjs, function(e) {
    if (copy2.hasNode(e.v) && copy2.hasNode(e.w)) {
      copy2.setEdge(e, self2.edge(e));
    }
  });
  var parents2 = {};
  function findParent(v) {
    var parent = self2.parent(v);
    if (parent === void 0 || copy2.hasNode(parent)) {
      parents2[v] = parent;
      return parent;
    } else if (parent in parents2) {
      return parents2[parent];
    } else {
      return findParent(parent);
    }
  }
  if (this._isCompound) {
    _$C.each(copy2.nodes(), function(v) {
      copy2.setParent(v, findParent(v));
    });
  }
  return copy2;
};
Graph$a.prototype.setDefaultEdgeLabel = function(newDefault) {
  if (!_$C.isFunction(newDefault)) {
    newDefault = _$C.constant(newDefault);
  }
  this._defaultEdgeLabelFn = newDefault;
  return this;
};
Graph$a.prototype.edgeCount = function() {
  return this._edgeCount;
};
Graph$a.prototype.edges = function() {
  return _$C.values(this._edgeObjs);
};
Graph$a.prototype.setPath = function(vs, value) {
  var self2 = this;
  var args = arguments;
  _$C.reduce(vs, function(v, w2) {
    if (args.length > 1) {
      self2.setEdge(v, w2, value);
    } else {
      self2.setEdge(v, w2);
    }
    return w2;
  });
  return this;
};
Graph$a.prototype.setEdge = function() {
  var v, w2, name2, value;
  var valueSpecified = false;
  var arg0 = arguments[0];
  if (typeof arg0 === "object" && arg0 !== null && "v" in arg0) {
    v = arg0.v;
    w2 = arg0.w;
    name2 = arg0.name;
    if (arguments.length === 2) {
      value = arguments[1];
      valueSpecified = true;
    }
  } else {
    v = arg0;
    w2 = arguments[1];
    name2 = arguments[3];
    if (arguments.length > 2) {
      value = arguments[2];
      valueSpecified = true;
    }
  }
  v = "" + v;
  w2 = "" + w2;
  if (!_$C.isUndefined(name2)) {
    name2 = "" + name2;
  }
  var e = edgeArgsToId(this._isDirected, v, w2, name2);
  if (_$C.has(this._edgeLabels, e)) {
    if (valueSpecified) {
      this._edgeLabels[e] = value;
    }
    return this;
  }
  if (!_$C.isUndefined(name2) && !this._isMultigraph) {
    throw new Error("Cannot set a named edge when isMultigraph = false");
  }
  this.setNode(v);
  this.setNode(w2);
  this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w2, name2);
  var edgeObj = edgeArgsToObj(this._isDirected, v, w2, name2);
  v = edgeObj.v;
  w2 = edgeObj.w;
  Object.freeze(edgeObj);
  this._edgeObjs[e] = edgeObj;
  incrementOrInitEntry(this._preds[w2], v);
  incrementOrInitEntry(this._sucs[v], w2);
  this._in[w2][e] = edgeObj;
  this._out[v][e] = edgeObj;
  this._edgeCount++;
  return this;
};
Graph$a.prototype.edge = function(v, w2, name2) {
  var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w2, name2);
  return this._edgeLabels[e];
};
Graph$a.prototype.hasEdge = function(v, w2, name2) {
  var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w2, name2);
  return _$C.has(this._edgeLabels, e);
};
Graph$a.prototype.removeEdge = function(v, w2, name2) {
  var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w2, name2);
  var edge = this._edgeObjs[e];
  if (edge) {
    v = edge.v;
    w2 = edge.w;
    delete this._edgeLabels[e];
    delete this._edgeObjs[e];
    decrementOrRemoveEntry(this._preds[w2], v);
    decrementOrRemoveEntry(this._sucs[v], w2);
    delete this._in[w2][e];
    delete this._out[v][e];
    this._edgeCount--;
  }
  return this;
};
Graph$a.prototype.inEdges = function(v, u) {
  var inV = this._in[v];
  if (inV) {
    var edges2 = _$C.values(inV);
    if (!u) {
      return edges2;
    }
    return _$C.filter(edges2, function(edge) {
      return edge.v === u;
    });
  }
};
Graph$a.prototype.outEdges = function(v, w2) {
  var outV = this._out[v];
  if (outV) {
    var edges2 = _$C.values(outV);
    if (!w2) {
      return edges2;
    }
    return _$C.filter(edges2, function(edge) {
      return edge.w === w2;
    });
  }
};
Graph$a.prototype.nodeEdges = function(v, w2) {
  var inEdges = this.inEdges(v, w2);
  if (inEdges) {
    return inEdges.concat(this.outEdges(v, w2));
  }
};
function incrementOrInitEntry(map2, k2) {
  if (map2[k2]) {
    map2[k2]++;
  } else {
    map2[k2] = 1;
  }
}
function decrementOrRemoveEntry(map2, k2) {
  if (!--map2[k2]) {
    delete map2[k2];
  }
}
function edgeArgsToId(isDirected, v_, w_, name2) {
  var v = "" + v_;
  var w2 = "" + w_;
  if (!isDirected && v > w2) {
    var tmp = v;
    v = w2;
    w2 = tmp;
  }
  return v + EDGE_KEY_DELIM + w2 + EDGE_KEY_DELIM + (_$C.isUndefined(name2) ? DEFAULT_EDGE_NAME : name2);
}
function edgeArgsToObj(isDirected, v_, w_, name2) {
  var v = "" + v_;
  var w2 = "" + w_;
  if (!isDirected && v > w2) {
    var tmp = v;
    v = w2;
    w2 = tmp;
  }
  var edgeObj = { v, w: w2 };
  if (name2) {
    edgeObj.name = name2;
  }
  return edgeObj;
}
function edgeObjToId(isDirected, edgeObj) {
  return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
}
var version$5 = "2.1.8";
var lib$1 = {
  Graph: graph,
  version: version$5
};
var _$B = lodash_1$3;
var Graph$9 = graph;
var json$1 = {
  write,
  read
};
function write(g2) {
  var json2 = {
    options: {
      directed: g2.isDirected(),
      multigraph: g2.isMultigraph(),
      compound: g2.isCompound()
    },
    nodes: writeNodes(g2),
    edges: writeEdges(g2)
  };
  if (!_$B.isUndefined(g2.graph())) {
    json2.value = _$B.clone(g2.graph());
  }
  return json2;
}
function writeNodes(g2) {
  return _$B.map(g2.nodes(), function(v) {
    var nodeValue = g2.node(v);
    var parent = g2.parent(v);
    var node2 = { v };
    if (!_$B.isUndefined(nodeValue)) {
      node2.value = nodeValue;
    }
    if (!_$B.isUndefined(parent)) {
      node2.parent = parent;
    }
    return node2;
  });
}
function writeEdges(g2) {
  return _$B.map(g2.edges(), function(e) {
    var edgeValue = g2.edge(e);
    var edge = { v: e.v, w: e.w };
    if (!_$B.isUndefined(e.name)) {
      edge.name = e.name;
    }
    if (!_$B.isUndefined(edgeValue)) {
      edge.value = edgeValue;
    }
    return edge;
  });
}
function read(json2) {
  var g2 = new Graph$9(json2.options).setGraph(json2.value);
  _$B.each(json2.nodes, function(entry) {
    g2.setNode(entry.v, entry.value);
    if (entry.parent) {
      g2.setParent(entry.v, entry.parent);
    }
  });
  _$B.each(json2.edges, function(entry) {
    g2.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
  });
  return g2;
}
var _$A = lodash_1$3;
var components_1 = components;
function components(g2) {
  var visited = {};
  var cmpts = [];
  var cmpt;
  function dfs2(v) {
    if (_$A.has(visited, v))
      return;
    visited[v] = true;
    cmpt.push(v);
    _$A.each(g2.successors(v), dfs2);
    _$A.each(g2.predecessors(v), dfs2);
  }
  _$A.each(g2.nodes(), function(v) {
    cmpt = [];
    dfs2(v);
    if (cmpt.length) {
      cmpts.push(cmpt);
    }
  });
  return cmpts;
}
var _$z = lodash_1$3;
var priorityQueue = PriorityQueue$2;
function PriorityQueue$2() {
  this._arr = [];
  this._keyIndices = {};
}
PriorityQueue$2.prototype.size = function() {
  return this._arr.length;
};
PriorityQueue$2.prototype.keys = function() {
  return this._arr.map(function(x2) {
    return x2.key;
  });
};
PriorityQueue$2.prototype.has = function(key) {
  return _$z.has(this._keyIndices, key);
};
PriorityQueue$2.prototype.priority = function(key) {
  var index2 = this._keyIndices[key];
  if (index2 !== void 0) {
    return this._arr[index2].priority;
  }
};
PriorityQueue$2.prototype.min = function() {
  if (this.size() === 0) {
    throw new Error("Queue underflow");
  }
  return this._arr[0].key;
};
PriorityQueue$2.prototype.add = function(key, priority) {
  var keyIndices = this._keyIndices;
  key = String(key);
  if (!_$z.has(keyIndices, key)) {
    var arr = this._arr;
    var index2 = arr.length;
    keyIndices[key] = index2;
    arr.push({ key, priority });
    this._decrease(index2);
    return true;
  }
  return false;
};
PriorityQueue$2.prototype.removeMin = function() {
  this._swap(0, this._arr.length - 1);
  var min2 = this._arr.pop();
  delete this._keyIndices[min2.key];
  this._heapify(0);
  return min2.key;
};
PriorityQueue$2.prototype.decrease = function(key, priority) {
  var index2 = this._keyIndices[key];
  if (priority > this._arr[index2].priority) {
    throw new Error("New priority is greater than current priority. Key: " + key + " Old: " + this._arr[index2].priority + " New: " + priority);
  }
  this._arr[index2].priority = priority;
  this._decrease(index2);
};
PriorityQueue$2.prototype._heapify = function(i) {
  var arr = this._arr;
  var l2 = 2 * i;
  var r = l2 + 1;
  var largest = i;
  if (l2 < arr.length) {
    largest = arr[l2].priority < arr[largest].priority ? l2 : largest;
    if (r < arr.length) {
      largest = arr[r].priority < arr[largest].priority ? r : largest;
    }
    if (largest !== i) {
      this._swap(i, largest);
      this._heapify(largest);
    }
  }
};
PriorityQueue$2.prototype._decrease = function(index2) {
  var arr = this._arr;
  var priority = arr[index2].priority;
  var parent;
  while (index2 !== 0) {
    parent = index2 >> 1;
    if (arr[parent].priority < priority) {
      break;
    }
    this._swap(index2, parent);
    index2 = parent;
  }
};
PriorityQueue$2.prototype._swap = function(i, j2) {
  var arr = this._arr;
  var keyIndices = this._keyIndices;
  var origArrI = arr[i];
  var origArrJ = arr[j2];
  arr[i] = origArrJ;
  arr[j2] = origArrI;
  keyIndices[origArrJ.key] = i;
  keyIndices[origArrI.key] = j2;
};
var _$y = lodash_1$3;
var PriorityQueue$1 = priorityQueue;
var dijkstra_1 = dijkstra$1;
var DEFAULT_WEIGHT_FUNC$1 = _$y.constant(1);
function dijkstra$1(g2, source, weightFn, edgeFn) {
  return runDijkstra(
    g2,
    String(source),
    weightFn || DEFAULT_WEIGHT_FUNC$1,
    edgeFn || function(v) {
      return g2.outEdges(v);
    }
  );
}
function runDijkstra(g2, source, weightFn, edgeFn) {
  var results = {};
  var pq = new PriorityQueue$1();
  var v, vEntry;
  var updateNeighbors = function(edge) {
    var w2 = edge.v !== v ? edge.v : edge.w;
    var wEntry = results[w2];
    var weight = weightFn(edge);
    var distance2 = vEntry.distance + weight;
    if (weight < 0) {
      throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + edge + " Weight: " + weight);
    }
    if (distance2 < wEntry.distance) {
      wEntry.distance = distance2;
      wEntry.predecessor = v;
      pq.decrease(w2, distance2);
    }
  };
  g2.nodes().forEach(function(v2) {
    var distance2 = v2 === source ? 0 : Number.POSITIVE_INFINITY;
    results[v2] = { distance: distance2 };
    pq.add(v2, distance2);
  });
  while (pq.size() > 0) {
    v = pq.removeMin();
    vEntry = results[v];
    if (vEntry.distance === Number.POSITIVE_INFINITY) {
      break;
    }
    edgeFn(v).forEach(updateNeighbors);
  }
  return results;
}
var dijkstra = dijkstra_1;
var _$x = lodash_1$3;
var dijkstraAll_1 = dijkstraAll;
function dijkstraAll(g2, weightFunc, edgeFunc) {
  return _$x.transform(g2.nodes(), function(acc, v) {
    acc[v] = dijkstra(g2, v, weightFunc, edgeFunc);
  }, {});
}
var _$w = lodash_1$3;
var tarjan_1 = tarjan$1;
function tarjan$1(g2) {
  var index2 = 0;
  var stack2 = [];
  var visited = {};
  var results = [];
  function dfs2(v) {
    var entry = visited[v] = {
      onStack: true,
      lowlink: index2,
      index: index2++
    };
    stack2.push(v);
    g2.successors(v).forEach(function(w3) {
      if (!_$w.has(visited, w3)) {
        dfs2(w3);
        entry.lowlink = Math.min(entry.lowlink, visited[w3].lowlink);
      } else if (visited[w3].onStack) {
        entry.lowlink = Math.min(entry.lowlink, visited[w3].index);
      }
    });
    if (entry.lowlink === entry.index) {
      var cmpt = [];
      var w2;
      do {
        w2 = stack2.pop();
        visited[w2].onStack = false;
        cmpt.push(w2);
      } while (v !== w2);
      results.push(cmpt);
    }
  }
  g2.nodes().forEach(function(v) {
    if (!_$w.has(visited, v)) {
      dfs2(v);
    }
  });
  return results;
}
var _$v = lodash_1$3;
var tarjan = tarjan_1;
var findCycles_1 = findCycles;
function findCycles(g2) {
  return _$v.filter(tarjan(g2), function(cmpt) {
    return cmpt.length > 1 || cmpt.length === 1 && g2.hasEdge(cmpt[0], cmpt[0]);
  });
}
var _$u = lodash_1$3;
var floydWarshall_1 = floydWarshall;
var DEFAULT_WEIGHT_FUNC = _$u.constant(1);
function floydWarshall(g2, weightFn, edgeFn) {
  return runFloydWarshall(
    g2,
    weightFn || DEFAULT_WEIGHT_FUNC,
    edgeFn || function(v) {
      return g2.outEdges(v);
    }
  );
}
function runFloydWarshall(g2, weightFn, edgeFn) {
  var results = {};
  var nodes = g2.nodes();
  nodes.forEach(function(v) {
    results[v] = {};
    results[v][v] = { distance: 0 };
    nodes.forEach(function(w2) {
      if (v !== w2) {
        results[v][w2] = { distance: Number.POSITIVE_INFINITY };
      }
    });
    edgeFn(v).forEach(function(edge) {
      var w2 = edge.v === v ? edge.w : edge.v;
      var d = weightFn(edge);
      results[v][w2] = { distance: d, predecessor: v };
    });
  });
  nodes.forEach(function(k2) {
    var rowK = results[k2];
    nodes.forEach(function(i) {
      var rowI = results[i];
      nodes.forEach(function(j2) {
        var ik = rowI[k2];
        var kj = rowK[j2];
        var ij = rowI[j2];
        var altDistance = ik.distance + kj.distance;
        if (altDistance < ij.distance) {
          ij.distance = altDistance;
          ij.predecessor = kj.predecessor;
        }
      });
    });
  });
  return results;
}
var _$t = lodash_1$3;
var topsort_1 = topsort$1;
topsort$1.CycleException = CycleException;
function topsort$1(g2) {
  var visited = {};
  var stack2 = {};
  var results = [];
  function visit(node2) {
    if (_$t.has(stack2, node2)) {
      throw new CycleException();
    }
    if (!_$t.has(visited, node2)) {
      stack2[node2] = true;
      visited[node2] = true;
      _$t.each(g2.predecessors(node2), visit);
      delete stack2[node2];
      results.push(node2);
    }
  }
  _$t.each(g2.sinks(), visit);
  if (_$t.size(visited) !== g2.nodeCount()) {
    throw new CycleException();
  }
  return results;
}
function CycleException() {
}
CycleException.prototype = new Error();
var topsort = topsort_1;
var isAcyclic_1 = isAcyclic;
function isAcyclic(g2) {
  try {
    topsort(g2);
  } catch (e) {
    if (e instanceof topsort.CycleException) {
      return false;
    }
    throw e;
  }
  return true;
}
var _$s = lodash_1$3;
var dfs_1 = dfs$3;
function dfs$3(g2, vs, order2) {
  if (!_$s.isArray(vs)) {
    vs = [vs];
  }
  var navigation = (g2.isDirected() ? g2.successors : g2.neighbors).bind(g2);
  var acc = [];
  var visited = {};
  _$s.each(vs, function(v) {
    if (!g2.hasNode(v)) {
      throw new Error("Graph does not have node: " + v);
    }
    doDfs(g2, v, order2 === "post", visited, navigation, acc);
  });
  return acc;
}
function doDfs(g2, v, postorder2, visited, navigation, acc) {
  if (!_$s.has(visited, v)) {
    visited[v] = true;
    if (!postorder2) {
      acc.push(v);
    }
    _$s.each(navigation(v), function(w2) {
      doDfs(g2, w2, postorder2, visited, navigation, acc);
    });
    if (postorder2) {
      acc.push(v);
    }
  }
}
var dfs$2 = dfs_1;
var postorder_1 = postorder$2;
function postorder$2(g2, vs) {
  return dfs$2(g2, vs, "post");
}
var dfs$1 = dfs_1;
var preorder_1 = preorder$1;
function preorder$1(g2, vs) {
  return dfs$1(g2, vs, "pre");
}
var _$r = lodash_1$3;
var Graph$8 = graph;
var PriorityQueue = priorityQueue;
var prim_1 = prim;
function prim(g2, weightFunc) {
  var result = new Graph$8();
  var parents2 = {};
  var pq = new PriorityQueue();
  var v;
  function updateNeighbors(edge) {
    var w2 = edge.v === v ? edge.w : edge.v;
    var pri = pq.priority(w2);
    if (pri !== void 0) {
      var edgeWeight = weightFunc(edge);
      if (edgeWeight < pri) {
        parents2[w2] = v;
        pq.decrease(w2, edgeWeight);
      }
    }
  }
  if (g2.nodeCount() === 0) {
    return result;
  }
  _$r.each(g2.nodes(), function(v2) {
    pq.add(v2, Number.POSITIVE_INFINITY);
    result.setNode(v2);
  });
  pq.decrease(g2.nodes()[0], 0);
  var init2 = false;
  while (pq.size() > 0) {
    v = pq.removeMin();
    if (_$r.has(parents2, v)) {
      result.setEdge(v, parents2[v]);
    } else if (init2) {
      throw new Error("Input graph is not connected: " + g2);
    } else {
      init2 = true;
    }
    g2.nodeEdges(v).forEach(updateNeighbors);
  }
  return result;
}
var alg = {
  components: components_1,
  dijkstra: dijkstra_1,
  dijkstraAll: dijkstraAll_1,
  findCycles: findCycles_1,
  floydWarshall: floydWarshall_1,
  isAcyclic: isAcyclic_1,
  postorder: postorder_1,
  preorder: preorder_1,
  prim: prim_1,
  tarjan: tarjan_1,
  topsort: topsort_1
};
var lib = lib$1;
var graphlib$2 = {
  Graph: lib.Graph,
  json: json$1,
  alg,
  version: lib.version
};
var graphlib$1;
if (typeof commonjsRequire$1 === "function") {
  try {
    graphlib$1 = graphlib$2;
  } catch (e) {
  }
}
if (!graphlib$1) {
  graphlib$1 = window.graphlib;
}
var graphlib_1$1 = graphlib$1;
var cloneDeep_1;
var hasRequiredCloneDeep;
function requireCloneDeep() {
  if (hasRequiredCloneDeep)
    return cloneDeep_1;
  hasRequiredCloneDeep = 1;
  var baseClone = require_baseClone();
  var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
  function cloneDeep(value) {
    return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
  }
  cloneDeep_1 = cloneDeep;
  return cloneDeep_1;
}
var _isIterateeCall$1;
var hasRequired_isIterateeCall$1;
function require_isIterateeCall$1() {
  if (hasRequired_isIterateeCall$1)
    return _isIterateeCall$1;
  hasRequired_isIterateeCall$1 = 1;
  var eq2 = requireEq$1(), isArrayLike = requireIsArrayLike$1(), isIndex = require_isIndex$1(), isObject2 = requireIsObject$1();
  function isIterateeCall(value, index2, object2) {
    if (!isObject2(object2)) {
      return false;
    }
    var type2 = typeof index2;
    if (type2 == "number" ? isArrayLike(object2) && isIndex(index2, object2.length) : type2 == "string" && index2 in object2) {
      return eq2(object2[index2], value);
    }
    return false;
  }
  _isIterateeCall$1 = isIterateeCall;
  return _isIterateeCall$1;
}
var defaults_1$1;
var hasRequiredDefaults$1;
function requireDefaults$1() {
  if (hasRequiredDefaults$1)
    return defaults_1$1;
  hasRequiredDefaults$1 = 1;
  var baseRest = require_baseRest$1(), eq2 = requireEq$1(), isIterateeCall = require_isIterateeCall$1(), keysIn = requireKeysIn$1();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var defaults2 = baseRest(function(object2, sources) {
    object2 = Object(object2);
    var index2 = -1;
    var length2 = sources.length;
    var guard = length2 > 2 ? sources[2] : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      length2 = 1;
    }
    while (++index2 < length2) {
      var source = sources[index2];
      var props = keysIn(source);
      var propsIndex = -1;
      var propsLength = props.length;
      while (++propsIndex < propsLength) {
        var key = props[propsIndex];
        var value = object2[key];
        if (value === void 0 || eq2(value, objectProto2[key]) && !hasOwnProperty2.call(object2, key)) {
          object2[key] = source[key];
        }
      }
    }
    return object2;
  });
  defaults_1$1 = defaults2;
  return defaults_1$1;
}
var _createFind;
var hasRequired_createFind;
function require_createFind() {
  if (hasRequired_createFind)
    return _createFind;
  hasRequired_createFind = 1;
  var baseIteratee = require_baseIteratee(), isArrayLike = requireIsArrayLike$1(), keys2 = requireKeys$1();
  function createFind(findIndexFunc) {
    return function(collection, predicate, fromIndex) {
      var iterable = Object(collection);
      if (!isArrayLike(collection)) {
        var iteratee = baseIteratee(predicate, 3);
        collection = keys2(collection);
        predicate = function(key) {
          return iteratee(iterable[key], key, iterable);
        };
      }
      var index2 = findIndexFunc(collection, predicate, fromIndex);
      return index2 > -1 ? iterable[iteratee ? collection[index2] : index2] : void 0;
    };
  }
  _createFind = createFind;
  return _createFind;
}
var _trimmedEndIndex$1;
var hasRequired_trimmedEndIndex$1;
function require_trimmedEndIndex$1() {
  if (hasRequired_trimmedEndIndex$1)
    return _trimmedEndIndex$1;
  hasRequired_trimmedEndIndex$1 = 1;
  var reWhitespace = /\s/;
  function trimmedEndIndex(string2) {
    var index2 = string2.length;
    while (index2-- && reWhitespace.test(string2.charAt(index2))) {
    }
    return index2;
  }
  _trimmedEndIndex$1 = trimmedEndIndex;
  return _trimmedEndIndex$1;
}
var _baseTrim$1;
var hasRequired_baseTrim$1;
function require_baseTrim$1() {
  if (hasRequired_baseTrim$1)
    return _baseTrim$1;
  hasRequired_baseTrim$1 = 1;
  var trimmedEndIndex = require_trimmedEndIndex$1();
  var reTrimStart = /^\s+/;
  function baseTrim(string2) {
    return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
  }
  _baseTrim$1 = baseTrim;
  return _baseTrim$1;
}
var toNumber_1$1;
var hasRequiredToNumber$1;
function requireToNumber$1() {
  if (hasRequiredToNumber$1)
    return toNumber_1$1;
  hasRequiredToNumber$1 = 1;
  var baseTrim = require_baseTrim$1(), isObject2 = requireIsObject$1(), isSymbol = requireIsSymbol$1();
  var NAN = 0 / 0;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject2(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject2(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  toNumber_1$1 = toNumber;
  return toNumber_1$1;
}
var toFinite_1$1;
var hasRequiredToFinite$1;
function requireToFinite$1() {
  if (hasRequiredToFinite$1)
    return toFinite_1$1;
  hasRequiredToFinite$1 = 1;
  var toNumber = requireToNumber$1();
  var INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292;
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign2 = value < 0 ? -1 : 1;
      return sign2 * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  toFinite_1$1 = toFinite;
  return toFinite_1$1;
}
var toInteger_1;
var hasRequiredToInteger;
function requireToInteger() {
  if (hasRequiredToInteger)
    return toInteger_1;
  hasRequiredToInteger = 1;
  var toFinite = requireToFinite$1();
  function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  toInteger_1 = toInteger;
  return toInteger_1;
}
var findIndex_1;
var hasRequiredFindIndex;
function requireFindIndex() {
  if (hasRequiredFindIndex)
    return findIndex_1;
  hasRequiredFindIndex = 1;
  var baseFindIndex = require_baseFindIndex(), baseIteratee = require_baseIteratee(), toInteger = requireToInteger();
  var nativeMax = Math.max;
  function findIndex(array2, predicate, fromIndex) {
    var length2 = array2 == null ? 0 : array2.length;
    if (!length2) {
      return -1;
    }
    var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
    if (index2 < 0) {
      index2 = nativeMax(length2 + index2, 0);
    }
    return baseFindIndex(array2, baseIteratee(predicate, 3), index2);
  }
  findIndex_1 = findIndex;
  return findIndex_1;
}
var find_1;
var hasRequiredFind;
function requireFind() {
  if (hasRequiredFind)
    return find_1;
  hasRequiredFind = 1;
  var createFind = require_createFind(), findIndex = requireFindIndex();
  var find2 = createFind(findIndex);
  find_1 = find2;
  return find_1;
}
var flatten_1$1;
var hasRequiredFlatten$1;
function requireFlatten$1() {
  if (hasRequiredFlatten$1)
    return flatten_1$1;
  hasRequiredFlatten$1 = 1;
  var baseFlatten = require_baseFlatten$1();
  function flatten2(array2) {
    var length2 = array2 == null ? 0 : array2.length;
    return length2 ? baseFlatten(array2, 1) : [];
  }
  flatten_1$1 = flatten2;
  return flatten_1$1;
}
var forIn_1;
var hasRequiredForIn;
function requireForIn() {
  if (hasRequiredForIn)
    return forIn_1;
  hasRequiredForIn = 1;
  var baseFor = require_baseFor$1(), castFunction = require_castFunction$1(), keysIn = requireKeysIn$1();
  function forIn(object2, iteratee) {
    return object2 == null ? object2 : baseFor(object2, castFunction(iteratee), keysIn);
  }
  forIn_1 = forIn;
  return forIn_1;
}
var last_1;
var hasRequiredLast;
function requireLast() {
  if (hasRequiredLast)
    return last_1;
  hasRequiredLast = 1;
  function last(array2) {
    var length2 = array2 == null ? 0 : array2.length;
    return length2 ? array2[length2 - 1] : void 0;
  }
  last_1 = last;
  return last_1;
}
var mapValues_1;
var hasRequiredMapValues;
function requireMapValues() {
  if (hasRequiredMapValues)
    return mapValues_1;
  hasRequiredMapValues = 1;
  var baseAssignValue = require_baseAssignValue$1(), baseForOwn = require_baseForOwn$1(), baseIteratee = require_baseIteratee();
  function mapValues(object2, iteratee) {
    var result = {};
    iteratee = baseIteratee(iteratee, 3);
    baseForOwn(object2, function(value, key, object3) {
      baseAssignValue(result, key, iteratee(value, key, object3));
    });
    return result;
  }
  mapValues_1 = mapValues;
  return mapValues_1;
}
var _baseExtremum;
var hasRequired_baseExtremum;
function require_baseExtremum() {
  if (hasRequired_baseExtremum)
    return _baseExtremum;
  hasRequired_baseExtremum = 1;
  var isSymbol = requireIsSymbol$1();
  function baseExtremum(array2, iteratee, comparator) {
    var index2 = -1, length2 = array2.length;
    while (++index2 < length2) {
      var value = array2[index2], current = iteratee(value);
      if (current != null && (computed === void 0 ? current === current && !isSymbol(current) : comparator(current, computed))) {
        var computed = current, result = value;
      }
    }
    return result;
  }
  _baseExtremum = baseExtremum;
  return _baseExtremum;
}
var _baseGt;
var hasRequired_baseGt;
function require_baseGt() {
  if (hasRequired_baseGt)
    return _baseGt;
  hasRequired_baseGt = 1;
  function baseGt(value, other) {
    return value > other;
  }
  _baseGt = baseGt;
  return _baseGt;
}
var max_1;
var hasRequiredMax;
function requireMax() {
  if (hasRequiredMax)
    return max_1;
  hasRequiredMax = 1;
  var baseExtremum = require_baseExtremum(), baseGt = require_baseGt(), identity2 = requireIdentity$1();
  function max2(array2) {
    return array2 && array2.length ? baseExtremum(array2, identity2, baseGt) : void 0;
  }
  max_1 = max2;
  return max_1;
}
var _assignMergeValue;
var hasRequired_assignMergeValue;
function require_assignMergeValue() {
  if (hasRequired_assignMergeValue)
    return _assignMergeValue;
  hasRequired_assignMergeValue = 1;
  var baseAssignValue = require_baseAssignValue$1(), eq2 = requireEq$1();
  function assignMergeValue(object2, key, value) {
    if (value !== void 0 && !eq2(object2[key], value) || value === void 0 && !(key in object2)) {
      baseAssignValue(object2, key, value);
    }
  }
  _assignMergeValue = assignMergeValue;
  return _assignMergeValue;
}
var isPlainObject_1$1;
var hasRequiredIsPlainObject$1;
function requireIsPlainObject$1() {
  if (hasRequiredIsPlainObject$1)
    return isPlainObject_1$1;
  hasRequiredIsPlainObject$1 = 1;
  var baseGetTag = require_baseGetTag$1(), getPrototype = require_getPrototype$1(), isObjectLike = requireIsObjectLike$1();
  var objectTag = "[object Object]";
  var funcProto2 = Function.prototype, objectProto2 = Object.prototype;
  var funcToString2 = funcProto2.toString;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var objectCtorString = funcToString2.call(Object);
  function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
      return false;
    }
    var proto2 = getPrototype(value);
    if (proto2 === null) {
      return true;
    }
    var Ctor = hasOwnProperty2.call(proto2, "constructor") && proto2.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString2.call(Ctor) == objectCtorString;
  }
  isPlainObject_1$1 = isPlainObject;
  return isPlainObject_1$1;
}
var _safeGet;
var hasRequired_safeGet;
function require_safeGet() {
  if (hasRequired_safeGet)
    return _safeGet;
  hasRequired_safeGet = 1;
  function safeGet(object2, key) {
    if (key === "constructor" && typeof object2[key] === "function") {
      return;
    }
    if (key == "__proto__") {
      return;
    }
    return object2[key];
  }
  _safeGet = safeGet;
  return _safeGet;
}
var toPlainObject_1;
var hasRequiredToPlainObject;
function requireToPlainObject() {
  if (hasRequiredToPlainObject)
    return toPlainObject_1;
  hasRequiredToPlainObject = 1;
  var copyObject = require_copyObject(), keysIn = requireKeysIn$1();
  function toPlainObject(value) {
    return copyObject(value, keysIn(value));
  }
  toPlainObject_1 = toPlainObject;
  return toPlainObject_1;
}
var _baseMergeDeep;
var hasRequired_baseMergeDeep;
function require_baseMergeDeep() {
  if (hasRequired_baseMergeDeep)
    return _baseMergeDeep;
  hasRequired_baseMergeDeep = 1;
  var assignMergeValue = require_assignMergeValue(), cloneBuffer = require_cloneBuffer(), cloneTypedArray = require_cloneTypedArray(), copyArray = require_copyArray(), initCloneObject = require_initCloneObject(), isArguments = requireIsArguments$1(), isArray = requireIsArray$1(), isArrayLikeObject = requireIsArrayLikeObject(), isBuffer2 = requireIsBuffer$1(), isFunction2 = requireIsFunction$1(), isObject2 = requireIsObject$1(), isPlainObject = requireIsPlainObject$1(), isTypedArray = requireIsTypedArray$1(), safeGet = require_safeGet(), toPlainObject = requireToPlainObject();
  function baseMergeDeep(object2, source, key, srcIndex, mergeFunc, customizer, stack2) {
    var objValue = safeGet(object2, key), srcValue = safeGet(source, key), stacked = stack2.get(srcValue);
    if (stacked) {
      assignMergeValue(object2, key, stacked);
      return;
    }
    var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source, stack2) : void 0;
    var isCommon = newValue === void 0;
    if (isCommon) {
      var isArr = isArray(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray(objValue)) {
          newValue = objValue;
        } else if (isArrayLikeObject(objValue)) {
          newValue = copyArray(objValue);
        } else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer(srcValue, true);
        } else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray(srcValue, true);
        } else {
          newValue = [];
        }
      } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
        newValue = objValue;
        if (isArguments(objValue)) {
          newValue = toPlainObject(objValue);
        } else if (!isObject2(objValue) || isFunction2(objValue)) {
          newValue = initCloneObject(srcValue);
        }
      } else {
        isCommon = false;
      }
    }
    if (isCommon) {
      stack2.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
      stack2["delete"](srcValue);
    }
    assignMergeValue(object2, key, newValue);
  }
  _baseMergeDeep = baseMergeDeep;
  return _baseMergeDeep;
}
var _baseMerge;
var hasRequired_baseMerge;
function require_baseMerge() {
  if (hasRequired_baseMerge)
    return _baseMerge;
  hasRequired_baseMerge = 1;
  var Stack2 = require_Stack(), assignMergeValue = require_assignMergeValue(), baseFor = require_baseFor$1(), baseMergeDeep = require_baseMergeDeep(), isObject2 = requireIsObject$1(), keysIn = requireKeysIn$1(), safeGet = require_safeGet();
  function baseMerge(object2, source, srcIndex, customizer, stack2) {
    if (object2 === source) {
      return;
    }
    baseFor(source, function(srcValue, key) {
      stack2 || (stack2 = new Stack2());
      if (isObject2(srcValue)) {
        baseMergeDeep(object2, source, key, srcIndex, baseMerge, customizer, stack2);
      } else {
        var newValue = customizer ? customizer(safeGet(object2, key), srcValue, key + "", object2, source, stack2) : void 0;
        if (newValue === void 0) {
          newValue = srcValue;
        }
        assignMergeValue(object2, key, newValue);
      }
    }, keysIn);
  }
  _baseMerge = baseMerge;
  return _baseMerge;
}
var _createAssigner;
var hasRequired_createAssigner;
function require_createAssigner() {
  if (hasRequired_createAssigner)
    return _createAssigner;
  hasRequired_createAssigner = 1;
  var baseRest = require_baseRest$1(), isIterateeCall = require_isIterateeCall$1();
  function createAssigner(assigner) {
    return baseRest(function(object2, sources) {
      var index2 = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : void 0, guard = length2 > 2 ? sources[2] : void 0;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length2 < 3 ? void 0 : customizer;
        length2 = 1;
      }
      object2 = Object(object2);
      while (++index2 < length2) {
        var source = sources[index2];
        if (source) {
          assigner(object2, source, index2, customizer);
        }
      }
      return object2;
    });
  }
  _createAssigner = createAssigner;
  return _createAssigner;
}
var merge_1;
var hasRequiredMerge;
function requireMerge() {
  if (hasRequiredMerge)
    return merge_1;
  hasRequiredMerge = 1;
  var baseMerge = require_baseMerge(), createAssigner = require_createAssigner();
  var merge2 = createAssigner(function(object2, source, srcIndex) {
    baseMerge(object2, source, srcIndex);
  });
  merge_1 = merge2;
  return merge_1;
}
var _baseLt;
var hasRequired_baseLt;
function require_baseLt() {
  if (hasRequired_baseLt)
    return _baseLt;
  hasRequired_baseLt = 1;
  function baseLt(value, other) {
    return value < other;
  }
  _baseLt = baseLt;
  return _baseLt;
}
var min_1;
var hasRequiredMin;
function requireMin() {
  if (hasRequiredMin)
    return min_1;
  hasRequiredMin = 1;
  var baseExtremum = require_baseExtremum(), baseLt = require_baseLt(), identity2 = requireIdentity$1();
  function min2(array2) {
    return array2 && array2.length ? baseExtremum(array2, identity2, baseLt) : void 0;
  }
  min_1 = min2;
  return min_1;
}
var minBy_1;
var hasRequiredMinBy;
function requireMinBy() {
  if (hasRequiredMinBy)
    return minBy_1;
  hasRequiredMinBy = 1;
  var baseExtremum = require_baseExtremum(), baseIteratee = require_baseIteratee(), baseLt = require_baseLt();
  function minBy(array2, iteratee) {
    return array2 && array2.length ? baseExtremum(array2, baseIteratee(iteratee, 2), baseLt) : void 0;
  }
  minBy_1 = minBy;
  return minBy_1;
}
var now_1;
var hasRequiredNow;
function requireNow() {
  if (hasRequiredNow)
    return now_1;
  hasRequiredNow = 1;
  var root2 = require_root();
  var now2 = function() {
    return root2.Date.now();
  };
  now_1 = now2;
  return now_1;
}
var _baseSet$1;
var hasRequired_baseSet$1;
function require_baseSet$1() {
  if (hasRequired_baseSet$1)
    return _baseSet$1;
  hasRequired_baseSet$1 = 1;
  var assignValue = require_assignValue$1(), castPath = require_castPath$1(), isIndex = require_isIndex$1(), isObject2 = requireIsObject$1(), toKey = require_toKey$1();
  function baseSet(object2, path2, value, customizer) {
    if (!isObject2(object2)) {
      return object2;
    }
    path2 = castPath(path2, object2);
    var index2 = -1, length2 = path2.length, lastIndex = length2 - 1, nested = object2;
    while (nested != null && ++index2 < length2) {
      var key = toKey(path2[index2]), newValue = value;
      if (key === "__proto__" || key === "constructor" || key === "prototype") {
        return object2;
      }
      if (index2 != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : void 0;
        if (newValue === void 0) {
          newValue = isObject2(objValue) ? objValue : isIndex(path2[index2 + 1]) ? [] : {};
        }
      }
      assignValue(nested, key, newValue);
      nested = nested[key];
    }
    return object2;
  }
  _baseSet$1 = baseSet;
  return _baseSet$1;
}
var _basePickBy$1;
var hasRequired_basePickBy$1;
function require_basePickBy$1() {
  if (hasRequired_basePickBy$1)
    return _basePickBy$1;
  hasRequired_basePickBy$1 = 1;
  var baseGet = require_baseGet$1(), baseSet = require_baseSet$1(), castPath = require_castPath$1();
  function basePickBy(object2, paths, predicate) {
    var index2 = -1, length2 = paths.length, result = {};
    while (++index2 < length2) {
      var path2 = paths[index2], value = baseGet(object2, path2);
      if (predicate(value, path2)) {
        baseSet(result, castPath(path2, object2), value);
      }
    }
    return result;
  }
  _basePickBy$1 = basePickBy;
  return _basePickBy$1;
}
var _basePick$1;
var hasRequired_basePick$1;
function require_basePick$1() {
  if (hasRequired_basePick$1)
    return _basePick$1;
  hasRequired_basePick$1 = 1;
  var basePickBy = require_basePickBy$1(), hasIn = requireHasIn$1();
  function basePick(object2, paths) {
    return basePickBy(object2, paths, function(value, path2) {
      return hasIn(object2, path2);
    });
  }
  _basePick$1 = basePick;
  return _basePick$1;
}
var _flatRest$1;
var hasRequired_flatRest$1;
function require_flatRest$1() {
  if (hasRequired_flatRest$1)
    return _flatRest$1;
  hasRequired_flatRest$1 = 1;
  var flatten2 = requireFlatten$1(), overRest = require_overRest$1(), setToString = require_setToString$1();
  function flatRest(func) {
    return setToString(overRest(func, void 0, flatten2), func + "");
  }
  _flatRest$1 = flatRest;
  return _flatRest$1;
}
var pick_1$1;
var hasRequiredPick$1;
function requirePick$1() {
  if (hasRequiredPick$1)
    return pick_1$1;
  hasRequiredPick$1 = 1;
  var basePick = require_basePick$1(), flatRest = require_flatRest$1();
  var pick = flatRest(function(object2, paths) {
    return object2 == null ? {} : basePick(object2, paths);
  });
  pick_1$1 = pick;
  return pick_1$1;
}
var _baseRange$1;
var hasRequired_baseRange$1;
function require_baseRange$1() {
  if (hasRequired_baseRange$1)
    return _baseRange$1;
  hasRequired_baseRange$1 = 1;
  var nativeCeil = Math.ceil, nativeMax = Math.max;
  function baseRange(start2, end2, step2, fromRight) {
    var index2 = -1, length2 = nativeMax(nativeCeil((end2 - start2) / (step2 || 1)), 0), result = Array(length2);
    while (length2--) {
      result[fromRight ? length2 : ++index2] = start2;
      start2 += step2;
    }
    return result;
  }
  _baseRange$1 = baseRange;
  return _baseRange$1;
}
var _createRange$1;
var hasRequired_createRange$1;
function require_createRange$1() {
  if (hasRequired_createRange$1)
    return _createRange$1;
  hasRequired_createRange$1 = 1;
  var baseRange = require_baseRange$1(), isIterateeCall = require_isIterateeCall$1(), toFinite = requireToFinite$1();
  function createRange(fromRight) {
    return function(start2, end2, step2) {
      if (step2 && typeof step2 != "number" && isIterateeCall(start2, end2, step2)) {
        end2 = step2 = void 0;
      }
      start2 = toFinite(start2);
      if (end2 === void 0) {
        end2 = start2;
        start2 = 0;
      } else {
        end2 = toFinite(end2);
      }
      step2 = step2 === void 0 ? start2 < end2 ? 1 : -1 : toFinite(step2);
      return baseRange(start2, end2, step2, fromRight);
    };
  }
  _createRange$1 = createRange;
  return _createRange$1;
}
var range_1$1;
var hasRequiredRange$1;
function requireRange$1() {
  if (hasRequiredRange$1)
    return range_1$1;
  hasRequiredRange$1 = 1;
  var createRange = require_createRange$1();
  var range2 = createRange();
  range_1$1 = range2;
  return range_1$1;
}
var _baseSortBy;
var hasRequired_baseSortBy;
function require_baseSortBy() {
  if (hasRequired_baseSortBy)
    return _baseSortBy;
  hasRequired_baseSortBy = 1;
  function baseSortBy(array2, comparer) {
    var length2 = array2.length;
    array2.sort(comparer);
    while (length2--) {
      array2[length2] = array2[length2].value;
    }
    return array2;
  }
  _baseSortBy = baseSortBy;
  return _baseSortBy;
}
var _compareAscending;
var hasRequired_compareAscending;
function require_compareAscending() {
  if (hasRequired_compareAscending)
    return _compareAscending;
  hasRequired_compareAscending = 1;
  var isSymbol = requireIsSymbol$1();
  function compareAscending(value, other) {
    if (value !== other) {
      var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
      var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
      if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
        return 1;
      }
      if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
        return -1;
      }
    }
    return 0;
  }
  _compareAscending = compareAscending;
  return _compareAscending;
}
var _compareMultiple;
var hasRequired_compareMultiple;
function require_compareMultiple() {
  if (hasRequired_compareMultiple)
    return _compareMultiple;
  hasRequired_compareMultiple = 1;
  var compareAscending = require_compareAscending();
  function compareMultiple(object2, other, orders) {
    var index2 = -1, objCriteria = object2.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length;
    while (++index2 < length2) {
      var result = compareAscending(objCriteria[index2], othCriteria[index2]);
      if (result) {
        if (index2 >= ordersLength) {
          return result;
        }
        var order2 = orders[index2];
        return result * (order2 == "desc" ? -1 : 1);
      }
    }
    return object2.index - other.index;
  }
  _compareMultiple = compareMultiple;
  return _compareMultiple;
}
var _baseOrderBy;
var hasRequired_baseOrderBy;
function require_baseOrderBy() {
  if (hasRequired_baseOrderBy)
    return _baseOrderBy;
  hasRequired_baseOrderBy = 1;
  var arrayMap = require_arrayMap$1(), baseGet = require_baseGet$1(), baseIteratee = require_baseIteratee(), baseMap = require_baseMap(), baseSortBy = require_baseSortBy(), baseUnary = require_baseUnary$1(), compareMultiple = require_compareMultiple(), identity2 = requireIdentity$1(), isArray = requireIsArray$1();
  function baseOrderBy(collection, iteratees, orders) {
    if (iteratees.length) {
      iteratees = arrayMap(iteratees, function(iteratee) {
        if (isArray(iteratee)) {
          return function(value) {
            return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
          };
        }
        return iteratee;
      });
    } else {
      iteratees = [identity2];
    }
    var index2 = -1;
    iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
    var result = baseMap(collection, function(value, key, collection2) {
      var criteria = arrayMap(iteratees, function(iteratee) {
        return iteratee(value);
      });
      return { "criteria": criteria, "index": ++index2, "value": value };
    });
    return baseSortBy(result, function(object2, other) {
      return compareMultiple(object2, other, orders);
    });
  }
  _baseOrderBy = baseOrderBy;
  return _baseOrderBy;
}
var sortBy_1;
var hasRequiredSortBy;
function requireSortBy() {
  if (hasRequiredSortBy)
    return sortBy_1;
  hasRequiredSortBy = 1;
  var baseFlatten = require_baseFlatten$1(), baseOrderBy = require_baseOrderBy(), baseRest = require_baseRest$1(), isIterateeCall = require_isIterateeCall$1();
  var sortBy = baseRest(function(collection, iteratees) {
    if (collection == null) {
      return [];
    }
    var length2 = iteratees.length;
    if (length2 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
      iteratees = [];
    } else if (length2 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
      iteratees = [iteratees[0]];
    }
    return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
  });
  sortBy_1 = sortBy;
  return sortBy_1;
}
var uniqueId_1$1;
var hasRequiredUniqueId$1;
function requireUniqueId$1() {
  if (hasRequiredUniqueId$1)
    return uniqueId_1$1;
  hasRequiredUniqueId$1 = 1;
  var toString = requireToString$1();
  var idCounter = 0;
  function uniqueId(prefix2) {
    var id2 = ++idCounter;
    return toString(prefix2) + id2;
  }
  uniqueId_1$1 = uniqueId;
  return uniqueId_1$1;
}
var _baseZipObject;
var hasRequired_baseZipObject;
function require_baseZipObject() {
  if (hasRequired_baseZipObject)
    return _baseZipObject;
  hasRequired_baseZipObject = 1;
  function baseZipObject(props, values2, assignFunc) {
    var index2 = -1, length2 = props.length, valsLength = values2.length, result = {};
    while (++index2 < length2) {
      var value = index2 < valsLength ? values2[index2] : void 0;
      assignFunc(result, props[index2], value);
    }
    return result;
  }
  _baseZipObject = baseZipObject;
  return _baseZipObject;
}
var zipObject_1;
var hasRequiredZipObject;
function requireZipObject() {
  if (hasRequiredZipObject)
    return zipObject_1;
  hasRequiredZipObject = 1;
  var assignValue = require_assignValue$1(), baseZipObject = require_baseZipObject();
  function zipObject(props, values2) {
    return baseZipObject(props || [], values2 || [], assignValue);
  }
  zipObject_1 = zipObject;
  return zipObject_1;
}
var lodash$2;
if (typeof commonjsRequire$1 === "function") {
  try {
    lodash$2 = {
      cloneDeep: requireCloneDeep(),
      constant: requireConstant$1(),
      defaults: requireDefaults$1(),
      each: requireEach$1(),
      filter: requireFilter(),
      find: requireFind(),
      flatten: requireFlatten$1(),
      forEach: requireForEach$1(),
      forIn: requireForIn(),
      has: requireHas$1(),
      isUndefined: requireIsUndefined(),
      last: requireLast(),
      map: requireMap(),
      mapValues: requireMapValues(),
      max: requireMax(),
      merge: requireMerge(),
      min: requireMin(),
      minBy: requireMinBy(),
      now: requireNow(),
      pick: requirePick$1(),
      range: requireRange$1(),
      reduce: requireReduce(),
      sortBy: requireSortBy(),
      uniqueId: requireUniqueId$1(),
      values: requireValues(),
      zipObject: requireZipObject()
    };
  } catch (e) {
  }
}
if (!lodash$2) {
  lodash$2 = window._;
}
var lodash_1$2 = lodash$2;
var list = List$1;
function List$1() {
  var sentinel = {};
  sentinel._next = sentinel._prev = sentinel;
  this._sentinel = sentinel;
}
List$1.prototype.dequeue = function() {
  var sentinel = this._sentinel;
  var entry = sentinel._prev;
  if (entry !== sentinel) {
    unlink(entry);
    return entry;
  }
};
List$1.prototype.enqueue = function(entry) {
  var sentinel = this._sentinel;
  if (entry._prev && entry._next) {
    unlink(entry);
  }
  entry._next = sentinel._next;
  sentinel._next._prev = entry;
  sentinel._next = entry;
  entry._prev = sentinel;
};
List$1.prototype.toString = function() {
  var strs = [];
  var sentinel = this._sentinel;
  var curr = sentinel._prev;
  while (curr !== sentinel) {
    strs.push(JSON.stringify(curr, filterOutLinks));
    curr = curr._prev;
  }
  return "[" + strs.join(", ") + "]";
};
function unlink(entry) {
  entry._prev._next = entry._next;
  entry._next._prev = entry._prev;
  delete entry._next;
  delete entry._prev;
}
function filterOutLinks(k2, v) {
  if (k2 !== "_next" && k2 !== "_prev") {
    return v;
  }
}
var _$q = lodash_1$2;
var Graph$7 = graphlib_1$1.Graph;
var List = list;
var greedyFas = greedyFAS$1;
var DEFAULT_WEIGHT_FN = _$q.constant(1);
function greedyFAS$1(g2, weightFn) {
  if (g2.nodeCount() <= 1) {
    return [];
  }
  var state = buildState(g2, weightFn || DEFAULT_WEIGHT_FN);
  var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);
  return _$q.flatten(_$q.map(results, function(e) {
    return g2.outEdges(e.v, e.w);
  }), true);
}
function doGreedyFAS(g2, buckets, zeroIdx) {
  var results = [];
  var sources = buckets[buckets.length - 1];
  var sinks = buckets[0];
  var entry;
  while (g2.nodeCount()) {
    while (entry = sinks.dequeue()) {
      removeNode(g2, buckets, zeroIdx, entry);
    }
    while (entry = sources.dequeue()) {
      removeNode(g2, buckets, zeroIdx, entry);
    }
    if (g2.nodeCount()) {
      for (var i = buckets.length - 2; i > 0; --i) {
        entry = buckets[i].dequeue();
        if (entry) {
          results = results.concat(removeNode(g2, buckets, zeroIdx, entry, true));
          break;
        }
      }
    }
  }
  return results;
}
function removeNode(g2, buckets, zeroIdx, entry, collectPredecessors) {
  var results = collectPredecessors ? [] : void 0;
  _$q.forEach(g2.inEdges(entry.v), function(edge) {
    var weight = g2.edge(edge);
    var uEntry = g2.node(edge.v);
    if (collectPredecessors) {
      results.push({ v: edge.v, w: edge.w });
    }
    uEntry.out -= weight;
    assignBucket(buckets, zeroIdx, uEntry);
  });
  _$q.forEach(g2.outEdges(entry.v), function(edge) {
    var weight = g2.edge(edge);
    var w2 = edge.w;
    var wEntry = g2.node(w2);
    wEntry["in"] -= weight;
    assignBucket(buckets, zeroIdx, wEntry);
  });
  g2.removeNode(entry.v);
  return results;
}
function buildState(g2, weightFn) {
  var fasGraph = new Graph$7();
  var maxIn = 0;
  var maxOut = 0;
  _$q.forEach(g2.nodes(), function(v) {
    fasGraph.setNode(v, { v, "in": 0, out: 0 });
  });
  _$q.forEach(g2.edges(), function(e) {
    var prevWeight = fasGraph.edge(e.v, e.w) || 0;
    var weight = weightFn(e);
    var edgeWeight = prevWeight + weight;
    fasGraph.setEdge(e.v, e.w, edgeWeight);
    maxOut = Math.max(maxOut, fasGraph.node(e.v).out += weight);
    maxIn = Math.max(maxIn, fasGraph.node(e.w)["in"] += weight);
  });
  var buckets = _$q.range(maxOut + maxIn + 3).map(function() {
    return new List();
  });
  var zeroIdx = maxIn + 1;
  _$q.forEach(fasGraph.nodes(), function(v) {
    assignBucket(buckets, zeroIdx, fasGraph.node(v));
  });
  return { graph: fasGraph, buckets, zeroIdx };
}
function assignBucket(buckets, zeroIdx, entry) {
  if (!entry.out) {
    buckets[0].enqueue(entry);
  } else if (!entry["in"]) {
    buckets[buckets.length - 1].enqueue(entry);
  } else {
    buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
  }
}
var _$p = lodash_1$2;
var greedyFAS = greedyFas;
var acyclic$1 = {
  run: run$2,
  undo: undo$2
};
function run$2(g2) {
  var fas = g2.graph().acyclicer === "greedy" ? greedyFAS(g2, weightFn(g2)) : dfsFAS(g2);
  _$p.forEach(fas, function(e) {
    var label = g2.edge(e);
    g2.removeEdge(e);
    label.forwardName = e.name;
    label.reversed = true;
    g2.setEdge(e.w, e.v, label, _$p.uniqueId("rev"));
  });
  function weightFn(g3) {
    return function(e) {
      return g3.edge(e).weight;
    };
  }
}
function dfsFAS(g2) {
  var fas = [];
  var stack2 = {};
  var visited = {};
  function dfs2(v) {
    if (_$p.has(visited, v)) {
      return;
    }
    visited[v] = true;
    stack2[v] = true;
    _$p.forEach(g2.outEdges(v), function(e) {
      if (_$p.has(stack2, e.w)) {
        fas.push(e);
      } else {
        dfs2(e.w);
      }
    });
    delete stack2[v];
  }
  _$p.forEach(g2.nodes(), dfs2);
  return fas;
}
function undo$2(g2) {
  _$p.forEach(g2.edges(), function(e) {
    var label = g2.edge(e);
    if (label.reversed) {
      g2.removeEdge(e);
      var forwardName = label.forwardName;
      delete label.reversed;
      delete label.forwardName;
      g2.setEdge(e.w, e.v, label, forwardName);
    }
  });
}
var _$o = lodash_1$2;
var Graph$6 = graphlib_1$1.Graph;
var util$d = {
  addDummyNode,
  simplify: simplify$1,
  asNonCompoundGraph,
  successorWeights,
  predecessorWeights,
  intersectRect: intersectRect$2,
  buildLayerMatrix,
  normalizeRanks: normalizeRanks$1,
  removeEmptyRanks: removeEmptyRanks$1,
  addBorderNode: addBorderNode$1,
  maxRank,
  partition: partition$1,
  time: time$1,
  notime
};
function addDummyNode(g2, type2, attrs, name2) {
  var v;
  do {
    v = _$o.uniqueId(name2);
  } while (g2.hasNode(v));
  attrs.dummy = type2;
  g2.setNode(v, attrs);
  return v;
}
function simplify$1(g2) {
  var simplified = new Graph$6().setGraph(g2.graph());
  _$o.forEach(g2.nodes(), function(v) {
    simplified.setNode(v, g2.node(v));
  });
  _$o.forEach(g2.edges(), function(e) {
    var simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 };
    var label = g2.edge(e);
    simplified.setEdge(e.v, e.w, {
      weight: simpleLabel.weight + label.weight,
      minlen: Math.max(simpleLabel.minlen, label.minlen)
    });
  });
  return simplified;
}
function asNonCompoundGraph(g2) {
  var simplified = new Graph$6({ multigraph: g2.isMultigraph() }).setGraph(g2.graph());
  _$o.forEach(g2.nodes(), function(v) {
    if (!g2.children(v).length) {
      simplified.setNode(v, g2.node(v));
    }
  });
  _$o.forEach(g2.edges(), function(e) {
    simplified.setEdge(e, g2.edge(e));
  });
  return simplified;
}
function successorWeights(g2) {
  var weightMap = _$o.map(g2.nodes(), function(v) {
    var sucs = {};
    _$o.forEach(g2.outEdges(v), function(e) {
      sucs[e.w] = (sucs[e.w] || 0) + g2.edge(e).weight;
    });
    return sucs;
  });
  return _$o.zipObject(g2.nodes(), weightMap);
}
function predecessorWeights(g2) {
  var weightMap = _$o.map(g2.nodes(), function(v) {
    var preds = {};
    _$o.forEach(g2.inEdges(v), function(e) {
      preds[e.v] = (preds[e.v] || 0) + g2.edge(e).weight;
    });
    return preds;
  });
  return _$o.zipObject(g2.nodes(), weightMap);
}
function intersectRect$2(rect2, point2) {
  var x2 = rect2.x;
  var y2 = rect2.y;
  var dx = point2.x - x2;
  var dy = point2.y - y2;
  var w2 = rect2.width / 2;
  var h2 = rect2.height / 2;
  if (!dx && !dy) {
    throw new Error("Not possible to find intersection inside of the rectangle");
  }
  var sx, sy;
  if (Math.abs(dy) * w2 > Math.abs(dx) * h2) {
    if (dy < 0) {
      h2 = -h2;
    }
    sx = h2 * dx / dy;
    sy = h2;
  } else {
    if (dx < 0) {
      w2 = -w2;
    }
    sx = w2;
    sy = w2 * dy / dx;
  }
  return { x: x2 + sx, y: y2 + sy };
}
function buildLayerMatrix(g2) {
  var layering = _$o.map(_$o.range(maxRank(g2) + 1), function() {
    return [];
  });
  _$o.forEach(g2.nodes(), function(v) {
    var node2 = g2.node(v);
    var rank2 = node2.rank;
    if (!_$o.isUndefined(rank2)) {
      layering[rank2][node2.order] = v;
    }
  });
  return layering;
}
function normalizeRanks$1(g2) {
  var min2 = _$o.min(_$o.map(g2.nodes(), function(v) {
    return g2.node(v).rank;
  }));
  _$o.forEach(g2.nodes(), function(v) {
    var node2 = g2.node(v);
    if (_$o.has(node2, "rank")) {
      node2.rank -= min2;
    }
  });
}
function removeEmptyRanks$1(g2) {
  var offset = _$o.min(_$o.map(g2.nodes(), function(v) {
    return g2.node(v).rank;
  }));
  var layers = [];
  _$o.forEach(g2.nodes(), function(v) {
    var rank2 = g2.node(v).rank - offset;
    if (!layers[rank2]) {
      layers[rank2] = [];
    }
    layers[rank2].push(v);
  });
  var delta = 0;
  var nodeRankFactor = g2.graph().nodeRankFactor;
  _$o.forEach(layers, function(vs, i) {
    if (_$o.isUndefined(vs) && i % nodeRankFactor !== 0) {
      --delta;
    } else if (delta) {
      _$o.forEach(vs, function(v) {
        g2.node(v).rank += delta;
      });
    }
  });
}
function addBorderNode$1(g2, prefix2, rank2, order2) {
  var node2 = {
    width: 0,
    height: 0
  };
  if (arguments.length >= 4) {
    node2.rank = rank2;
    node2.order = order2;
  }
  return addDummyNode(g2, "border", node2, prefix2);
}
function maxRank(g2) {
  return _$o.max(_$o.map(g2.nodes(), function(v) {
    var rank2 = g2.node(v).rank;
    if (!_$o.isUndefined(rank2)) {
      return rank2;
    }
  }));
}
function partition$1(collection, fn2) {
  var result = { lhs: [], rhs: [] };
  _$o.forEach(collection, function(value) {
    if (fn2(value)) {
      result.lhs.push(value);
    } else {
      result.rhs.push(value);
    }
  });
  return result;
}
function time$1(name2, fn2) {
  var start2 = _$o.now();
  try {
    return fn2();
  } finally {
    console.log(name2 + " time: " + (_$o.now() - start2) + "ms");
  }
}
function notime(name2, fn2) {
  return fn2();
}
var _$n = lodash_1$2;
var util$c = util$d;
var normalize$2 = {
  run: run$1,
  undo: undo$1
};
function run$1(g2) {
  g2.graph().dummyChains = [];
  _$n.forEach(g2.edges(), function(edge) {
    normalizeEdge(g2, edge);
  });
}
function normalizeEdge(g2, e) {
  var v = e.v;
  var vRank = g2.node(v).rank;
  var w2 = e.w;
  var wRank = g2.node(w2).rank;
  var name2 = e.name;
  var edgeLabel = g2.edge(e);
  var labelRank = edgeLabel.labelRank;
  if (wRank === vRank + 1)
    return;
  g2.removeEdge(e);
  var dummy, attrs, i;
  for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {
    edgeLabel.points = [];
    attrs = {
      width: 0,
      height: 0,
      edgeLabel,
      edgeObj: e,
      rank: vRank
    };
    dummy = util$c.addDummyNode(g2, "edge", attrs, "_d");
    if (vRank === labelRank) {
      attrs.width = edgeLabel.width;
      attrs.height = edgeLabel.height;
      attrs.dummy = "edge-label";
      attrs.labelpos = edgeLabel.labelpos;
    }
    g2.setEdge(v, dummy, { weight: edgeLabel.weight }, name2);
    if (i === 0) {
      g2.graph().dummyChains.push(dummy);
    }
    v = dummy;
  }
  g2.setEdge(v, w2, { weight: edgeLabel.weight }, name2);
}
function undo$1(g2) {
  _$n.forEach(g2.graph().dummyChains, function(v) {
    var node2 = g2.node(v);
    var origLabel = node2.edgeLabel;
    var w2;
    g2.setEdge(node2.edgeObj, origLabel);
    while (node2.dummy) {
      w2 = g2.successors(v)[0];
      g2.removeNode(v);
      origLabel.points.push({ x: node2.x, y: node2.y });
      if (node2.dummy === "edge-label") {
        origLabel.x = node2.x;
        origLabel.y = node2.y;
        origLabel.width = node2.width;
        origLabel.height = node2.height;
      }
      v = w2;
      node2 = g2.node(v);
    }
  });
}
var _$m = lodash_1$2;
var util$b = {
  longestPath: longestPath$1,
  slack: slack$2
};
function longestPath$1(g2) {
  var visited = {};
  function dfs2(v) {
    var label = g2.node(v);
    if (_$m.has(visited, v)) {
      return label.rank;
    }
    visited[v] = true;
    var rank2 = _$m.min(_$m.map(g2.outEdges(v), function(e) {
      return dfs2(e.w) - g2.edge(e).minlen;
    }));
    if (rank2 === Number.POSITIVE_INFINITY || rank2 === void 0 || rank2 === null) {
      rank2 = 0;
    }
    return label.rank = rank2;
  }
  _$m.forEach(g2.sources(), dfs2);
}
function slack$2(g2, e) {
  return g2.node(e.w).rank - g2.node(e.v).rank - g2.edge(e).minlen;
}
var _$l = lodash_1$2;
var Graph$5 = graphlib_1$1.Graph;
var slack$1 = util$b.slack;
var feasibleTree_1 = feasibleTree$2;
function feasibleTree$2(g2) {
  var t4 = new Graph$5({ directed: false });
  var start2 = g2.nodes()[0];
  var size = g2.nodeCount();
  t4.setNode(start2, {});
  var edge, delta;
  while (tightTree(t4, g2) < size) {
    edge = findMinSlackEdge(t4, g2);
    delta = t4.hasNode(edge.v) ? slack$1(g2, edge) : -slack$1(g2, edge);
    shiftRanks(t4, g2, delta);
  }
  return t4;
}
function tightTree(t4, g2) {
  function dfs2(v) {
    _$l.forEach(g2.nodeEdges(v), function(e) {
      var edgeV = e.v, w2 = v === edgeV ? e.w : edgeV;
      if (!t4.hasNode(w2) && !slack$1(g2, e)) {
        t4.setNode(w2, {});
        t4.setEdge(v, w2, {});
        dfs2(w2);
      }
    });
  }
  _$l.forEach(t4.nodes(), dfs2);
  return t4.nodeCount();
}
function findMinSlackEdge(t4, g2) {
  return _$l.minBy(g2.edges(), function(e) {
    if (t4.hasNode(e.v) !== t4.hasNode(e.w)) {
      return slack$1(g2, e);
    }
  });
}
function shiftRanks(t4, g2, delta) {
  _$l.forEach(t4.nodes(), function(v) {
    g2.node(v).rank += delta;
  });
}
var _$k = lodash_1$2;
var feasibleTree$1 = feasibleTree_1;
var slack = util$b.slack;
var initRank = util$b.longestPath;
var preorder = graphlib_1$1.alg.preorder;
var postorder$1 = graphlib_1$1.alg.postorder;
var simplify = util$d.simplify;
var networkSimplex_1 = networkSimplex$1;
networkSimplex$1.initLowLimValues = initLowLimValues;
networkSimplex$1.initCutValues = initCutValues;
networkSimplex$1.calcCutValue = calcCutValue;
networkSimplex$1.leaveEdge = leaveEdge;
networkSimplex$1.enterEdge = enterEdge;
networkSimplex$1.exchangeEdges = exchangeEdges;
function networkSimplex$1(g2) {
  g2 = simplify(g2);
  initRank(g2);
  var t4 = feasibleTree$1(g2);
  initLowLimValues(t4);
  initCutValues(t4, g2);
  var e, f2;
  while (e = leaveEdge(t4)) {
    f2 = enterEdge(t4, g2, e);
    exchangeEdges(t4, g2, e, f2);
  }
}
function initCutValues(t4, g2) {
  var vs = postorder$1(t4, t4.nodes());
  vs = vs.slice(0, vs.length - 1);
  _$k.forEach(vs, function(v) {
    assignCutValue(t4, g2, v);
  });
}
function assignCutValue(t4, g2, child) {
  var childLab = t4.node(child);
  var parent = childLab.parent;
  t4.edge(child, parent).cutvalue = calcCutValue(t4, g2, child);
}
function calcCutValue(t4, g2, child) {
  var childLab = t4.node(child);
  var parent = childLab.parent;
  var childIsTail = true;
  var graphEdge = g2.edge(child, parent);
  var cutValue = 0;
  if (!graphEdge) {
    childIsTail = false;
    graphEdge = g2.edge(parent, child);
  }
  cutValue = graphEdge.weight;
  _$k.forEach(g2.nodeEdges(child), function(e) {
    var isOutEdge = e.v === child, other = isOutEdge ? e.w : e.v;
    if (other !== parent) {
      var pointsToHead = isOutEdge === childIsTail, otherWeight = g2.edge(e).weight;
      cutValue += pointsToHead ? otherWeight : -otherWeight;
      if (isTreeEdge(t4, child, other)) {
        var otherCutValue = t4.edge(child, other).cutvalue;
        cutValue += pointsToHead ? -otherCutValue : otherCutValue;
      }
    }
  });
  return cutValue;
}
function initLowLimValues(tree2, root2) {
  if (arguments.length < 2) {
    root2 = tree2.nodes()[0];
  }
  dfsAssignLowLim(tree2, {}, 1, root2);
}
function dfsAssignLowLim(tree2, visited, nextLim, v, parent) {
  var low = nextLim;
  var label = tree2.node(v);
  visited[v] = true;
  _$k.forEach(tree2.neighbors(v), function(w2) {
    if (!_$k.has(visited, w2)) {
      nextLim = dfsAssignLowLim(tree2, visited, nextLim, w2, v);
    }
  });
  label.low = low;
  label.lim = nextLim++;
  if (parent) {
    label.parent = parent;
  } else {
    delete label.parent;
  }
  return nextLim;
}
function leaveEdge(tree2) {
  return _$k.find(tree2.edges(), function(e) {
    return tree2.edge(e).cutvalue < 0;
  });
}
function enterEdge(t4, g2, edge) {
  var v = edge.v;
  var w2 = edge.w;
  if (!g2.hasEdge(v, w2)) {
    v = edge.w;
    w2 = edge.v;
  }
  var vLabel = t4.node(v);
  var wLabel = t4.node(w2);
  var tailLabel = vLabel;
  var flip = false;
  if (vLabel.lim > wLabel.lim) {
    tailLabel = wLabel;
    flip = true;
  }
  var candidates = _$k.filter(g2.edges(), function(edge2) {
    return flip === isDescendant(t4, t4.node(edge2.v), tailLabel) && flip !== isDescendant(t4, t4.node(edge2.w), tailLabel);
  });
  return _$k.minBy(candidates, function(edge2) {
    return slack(g2, edge2);
  });
}
function exchangeEdges(t4, g2, e, f2) {
  var v = e.v;
  var w2 = e.w;
  t4.removeEdge(v, w2);
  t4.setEdge(f2.v, f2.w, {});
  initLowLimValues(t4);
  initCutValues(t4, g2);
  updateRanks(t4, g2);
}
function updateRanks(t4, g2) {
  var root2 = _$k.find(t4.nodes(), function(v) {
    return !g2.node(v).parent;
  });
  var vs = preorder(t4, root2);
  vs = vs.slice(1);
  _$k.forEach(vs, function(v) {
    var parent = t4.node(v).parent, edge = g2.edge(v, parent), flipped = false;
    if (!edge) {
      edge = g2.edge(parent, v);
      flipped = true;
    }
    g2.node(v).rank = g2.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
  });
}
function isTreeEdge(tree2, u, v) {
  return tree2.hasEdge(u, v);
}
function isDescendant(tree2, vLabel, rootLabel) {
  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
}
var rankUtil = util$b;
var longestPath = rankUtil.longestPath;
var feasibleTree = feasibleTree_1;
var networkSimplex = networkSimplex_1;
var rank_1 = rank$1;
function rank$1(g2) {
  switch (g2.graph().ranker) {
    case "network-simplex":
      networkSimplexRanker(g2);
      break;
    case "tight-tree":
      tightTreeRanker(g2);
      break;
    case "longest-path":
      longestPathRanker(g2);
      break;
    default:
      networkSimplexRanker(g2);
  }
}
var longestPathRanker = longestPath;
function tightTreeRanker(g2) {
  longestPath(g2);
  feasibleTree(g2);
}
function networkSimplexRanker(g2) {
  networkSimplex(g2);
}
var _$j = lodash_1$2;
var parentDummyChains_1 = parentDummyChains$1;
function parentDummyChains$1(g2) {
  var postorderNums = postorder(g2);
  _$j.forEach(g2.graph().dummyChains, function(v) {
    var node2 = g2.node(v);
    var edgeObj = node2.edgeObj;
    var pathData = findPath(g2, postorderNums, edgeObj.v, edgeObj.w);
    var path2 = pathData.path;
    var lca = pathData.lca;
    var pathIdx = 0;
    var pathV = path2[pathIdx];
    var ascending2 = true;
    while (v !== edgeObj.w) {
      node2 = g2.node(v);
      if (ascending2) {
        while ((pathV = path2[pathIdx]) !== lca && g2.node(pathV).maxRank < node2.rank) {
          pathIdx++;
        }
        if (pathV === lca) {
          ascending2 = false;
        }
      }
      if (!ascending2) {
        while (pathIdx < path2.length - 1 && g2.node(pathV = path2[pathIdx + 1]).minRank <= node2.rank) {
          pathIdx++;
        }
        pathV = path2[pathIdx];
      }
      g2.setParent(v, pathV);
      v = g2.successors(v)[0];
    }
  });
}
function findPath(g2, postorderNums, v, w2) {
  var vPath = [];
  var wPath = [];
  var low = Math.min(postorderNums[v].low, postorderNums[w2].low);
  var lim = Math.max(postorderNums[v].lim, postorderNums[w2].lim);
  var parent;
  var lca;
  parent = v;
  do {
    parent = g2.parent(parent);
    vPath.push(parent);
  } while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
  lca = parent;
  parent = w2;
  while ((parent = g2.parent(parent)) !== lca) {
    wPath.push(parent);
  }
  return { path: vPath.concat(wPath.reverse()), lca };
}
function postorder(g2) {
  var result = {};
  var lim = 0;
  function dfs2(v) {
    var low = lim;
    _$j.forEach(g2.children(v), dfs2);
    result[v] = { low, lim: lim++ };
  }
  _$j.forEach(g2.children(), dfs2);
  return result;
}
var _$i = lodash_1$2;
var util$a = util$d;
var nestingGraph$1 = {
  run,
  cleanup
};
function run(g2) {
  var root2 = util$a.addDummyNode(g2, "root", {}, "_root");
  var depths = treeDepths(g2);
  var height2 = _$i.max(_$i.values(depths)) - 1;
  var nodeSep = 2 * height2 + 1;
  g2.graph().nestingRoot = root2;
  _$i.forEach(g2.edges(), function(e) {
    g2.edge(e).minlen *= nodeSep;
  });
  var weight = sumWeights(g2) + 1;
  _$i.forEach(g2.children(), function(child) {
    dfs(g2, root2, nodeSep, weight, height2, depths, child);
  });
  g2.graph().nodeRankFactor = nodeSep;
}
function dfs(g2, root2, nodeSep, weight, height2, depths, v) {
  var children2 = g2.children(v);
  if (!children2.length) {
    if (v !== root2) {
      g2.setEdge(root2, v, { weight: 0, minlen: nodeSep });
    }
    return;
  }
  var top2 = util$a.addBorderNode(g2, "_bt");
  var bottom2 = util$a.addBorderNode(g2, "_bb");
  var label = g2.node(v);
  g2.setParent(top2, v);
  label.borderTop = top2;
  g2.setParent(bottom2, v);
  label.borderBottom = bottom2;
  _$i.forEach(children2, function(child) {
    dfs(g2, root2, nodeSep, weight, height2, depths, child);
    var childNode = g2.node(child);
    var childTop = childNode.borderTop ? childNode.borderTop : child;
    var childBottom = childNode.borderBottom ? childNode.borderBottom : child;
    var thisWeight = childNode.borderTop ? weight : 2 * weight;
    var minlen = childTop !== childBottom ? 1 : height2 - depths[v] + 1;
    g2.setEdge(top2, childTop, {
      weight: thisWeight,
      minlen,
      nestingEdge: true
    });
    g2.setEdge(childBottom, bottom2, {
      weight: thisWeight,
      minlen,
      nestingEdge: true
    });
  });
  if (!g2.parent(v)) {
    g2.setEdge(root2, top2, { weight: 0, minlen: height2 + depths[v] });
  }
}
function treeDepths(g2) {
  var depths = {};
  function dfs2(v, depth) {
    var children2 = g2.children(v);
    if (children2 && children2.length) {
      _$i.forEach(children2, function(child) {
        dfs2(child, depth + 1);
      });
    }
    depths[v] = depth;
  }
  _$i.forEach(g2.children(), function(v) {
    dfs2(v, 1);
  });
  return depths;
}
function sumWeights(g2) {
  return _$i.reduce(g2.edges(), function(acc, e) {
    return acc + g2.edge(e).weight;
  }, 0);
}
function cleanup(g2) {
  var graphLabel = g2.graph();
  g2.removeNode(graphLabel.nestingRoot);
  delete graphLabel.nestingRoot;
  _$i.forEach(g2.edges(), function(e) {
    var edge = g2.edge(e);
    if (edge.nestingEdge) {
      g2.removeEdge(e);
    }
  });
}
var _$h = lodash_1$2;
var util$9 = util$d;
var addBorderSegments_1 = addBorderSegments$1;
function addBorderSegments$1(g2) {
  function dfs2(v) {
    var children2 = g2.children(v);
    var node2 = g2.node(v);
    if (children2.length) {
      _$h.forEach(children2, dfs2);
    }
    if (_$h.has(node2, "minRank")) {
      node2.borderLeft = [];
      node2.borderRight = [];
      for (var rank2 = node2.minRank, maxRank2 = node2.maxRank + 1; rank2 < maxRank2; ++rank2) {
        addBorderNode(g2, "borderLeft", "_bl", v, node2, rank2);
        addBorderNode(g2, "borderRight", "_br", v, node2, rank2);
      }
    }
  }
  _$h.forEach(g2.children(), dfs2);
}
function addBorderNode(g2, prop, prefix2, sg, sgNode, rank2) {
  var label = { width: 0, height: 0, rank: rank2, borderType: prop };
  var prev2 = sgNode[prop][rank2 - 1];
  var curr = util$9.addDummyNode(g2, "border", label, prefix2);
  sgNode[prop][rank2] = curr;
  g2.setParent(curr, sg);
  if (prev2) {
    g2.setEdge(prev2, curr, { weight: 1 });
  }
}
var _$g = lodash_1$2;
var coordinateSystem$1 = {
  adjust,
  undo
};
function adjust(g2) {
  var rankDir = g2.graph().rankdir.toLowerCase();
  if (rankDir === "lr" || rankDir === "rl") {
    swapWidthHeight(g2);
  }
}
function undo(g2) {
  var rankDir = g2.graph().rankdir.toLowerCase();
  if (rankDir === "bt" || rankDir === "rl") {
    reverseY(g2);
  }
  if (rankDir === "lr" || rankDir === "rl") {
    swapXY(g2);
    swapWidthHeight(g2);
  }
}
function swapWidthHeight(g2) {
  _$g.forEach(g2.nodes(), function(v) {
    swapWidthHeightOne(g2.node(v));
  });
  _$g.forEach(g2.edges(), function(e) {
    swapWidthHeightOne(g2.edge(e));
  });
}
function swapWidthHeightOne(attrs) {
  var w2 = attrs.width;
  attrs.width = attrs.height;
  attrs.height = w2;
}
function reverseY(g2) {
  _$g.forEach(g2.nodes(), function(v) {
    reverseYOne(g2.node(v));
  });
  _$g.forEach(g2.edges(), function(e) {
    var edge = g2.edge(e);
    _$g.forEach(edge.points, reverseYOne);
    if (_$g.has(edge, "y")) {
      reverseYOne(edge);
    }
  });
}
function reverseYOne(attrs) {
  attrs.y = -attrs.y;
}
function swapXY(g2) {
  _$g.forEach(g2.nodes(), function(v) {
    swapXYOne(g2.node(v));
  });
  _$g.forEach(g2.edges(), function(e) {
    var edge = g2.edge(e);
    _$g.forEach(edge.points, swapXYOne);
    if (_$g.has(edge, "x")) {
      swapXYOne(edge);
    }
  });
}
function swapXYOne(attrs) {
  var x2 = attrs.x;
  attrs.x = attrs.y;
  attrs.y = x2;
}
var _$f = lodash_1$2;
var initOrder_1 = initOrder$1;
function initOrder$1(g2) {
  var visited = {};
  var simpleNodes = _$f.filter(g2.nodes(), function(v) {
    return !g2.children(v).length;
  });
  var maxRank2 = _$f.max(_$f.map(simpleNodes, function(v) {
    return g2.node(v).rank;
  }));
  var layers = _$f.map(_$f.range(maxRank2 + 1), function() {
    return [];
  });
  function dfs2(v) {
    if (_$f.has(visited, v))
      return;
    visited[v] = true;
    var node2 = g2.node(v);
    layers[node2.rank].push(v);
    _$f.forEach(g2.successors(v), dfs2);
  }
  var orderedVs = _$f.sortBy(simpleNodes, function(v) {
    return g2.node(v).rank;
  });
  _$f.forEach(orderedVs, dfs2);
  return layers;
}
var _$e = lodash_1$2;
var crossCount_1 = crossCount$1;
function crossCount$1(g2, layering) {
  var cc = 0;
  for (var i = 1; i < layering.length; ++i) {
    cc += twoLayerCrossCount(g2, layering[i - 1], layering[i]);
  }
  return cc;
}
function twoLayerCrossCount(g2, northLayer, southLayer) {
  var southPos = _$e.zipObject(
    southLayer,
    _$e.map(southLayer, function(v, i) {
      return i;
    })
  );
  var southEntries = _$e.flatten(_$e.map(northLayer, function(v) {
    return _$e.sortBy(_$e.map(g2.outEdges(v), function(e) {
      return { pos: southPos[e.w], weight: g2.edge(e).weight };
    }), "pos");
  }), true);
  var firstIndex = 1;
  while (firstIndex < southLayer.length)
    firstIndex <<= 1;
  var treeSize = 2 * firstIndex - 1;
  firstIndex -= 1;
  var tree2 = _$e.map(new Array(treeSize), function() {
    return 0;
  });
  var cc = 0;
  _$e.forEach(southEntries.forEach(function(entry) {
    var index2 = entry.pos + firstIndex;
    tree2[index2] += entry.weight;
    var weightSum = 0;
    while (index2 > 0) {
      if (index2 % 2) {
        weightSum += tree2[index2 + 1];
      }
      index2 = index2 - 1 >> 1;
      tree2[index2] += entry.weight;
    }
    cc += entry.weight * weightSum;
  }));
  return cc;
}
var _$d = lodash_1$2;
var barycenter_1 = barycenter$1;
function barycenter$1(g2, movable) {
  return _$d.map(movable, function(v) {
    var inV = g2.inEdges(v);
    if (!inV.length) {
      return { v };
    } else {
      var result = _$d.reduce(inV, function(acc, e) {
        var edge = g2.edge(e), nodeU = g2.node(e.v);
        return {
          sum: acc.sum + edge.weight * nodeU.order,
          weight: acc.weight + edge.weight
        };
      }, { sum: 0, weight: 0 });
      return {
        v,
        barycenter: result.sum / result.weight,
        weight: result.weight
      };
    }
  });
}
var _$c = lodash_1$2;
var resolveConflicts_1 = resolveConflicts$1;
function resolveConflicts$1(entries2, cg) {
  var mappedEntries = {};
  _$c.forEach(entries2, function(entry, i) {
    var tmp = mappedEntries[entry.v] = {
      indegree: 0,
      "in": [],
      out: [],
      vs: [entry.v],
      i
    };
    if (!_$c.isUndefined(entry.barycenter)) {
      tmp.barycenter = entry.barycenter;
      tmp.weight = entry.weight;
    }
  });
  _$c.forEach(cg.edges(), function(e) {
    var entryV = mappedEntries[e.v];
    var entryW = mappedEntries[e.w];
    if (!_$c.isUndefined(entryV) && !_$c.isUndefined(entryW)) {
      entryW.indegree++;
      entryV.out.push(mappedEntries[e.w]);
    }
  });
  var sourceSet = _$c.filter(mappedEntries, function(entry) {
    return !entry.indegree;
  });
  return doResolveConflicts(sourceSet);
}
function doResolveConflicts(sourceSet) {
  var entries2 = [];
  function handleIn(vEntry) {
    return function(uEntry) {
      if (uEntry.merged) {
        return;
      }
      if (_$c.isUndefined(uEntry.barycenter) || _$c.isUndefined(vEntry.barycenter) || uEntry.barycenter >= vEntry.barycenter) {
        mergeEntries(vEntry, uEntry);
      }
    };
  }
  function handleOut(vEntry) {
    return function(wEntry) {
      wEntry["in"].push(vEntry);
      if (--wEntry.indegree === 0) {
        sourceSet.push(wEntry);
      }
    };
  }
  while (sourceSet.length) {
    var entry = sourceSet.pop();
    entries2.push(entry);
    _$c.forEach(entry["in"].reverse(), handleIn(entry));
    _$c.forEach(entry.out, handleOut(entry));
  }
  return _$c.map(
    _$c.filter(entries2, function(entry2) {
      return !entry2.merged;
    }),
    function(entry2) {
      return _$c.pick(entry2, ["vs", "i", "barycenter", "weight"]);
    }
  );
}
function mergeEntries(target, source) {
  var sum2 = 0;
  var weight = 0;
  if (target.weight) {
    sum2 += target.barycenter * target.weight;
    weight += target.weight;
  }
  if (source.weight) {
    sum2 += source.barycenter * source.weight;
    weight += source.weight;
  }
  target.vs = source.vs.concat(target.vs);
  target.barycenter = sum2 / weight;
  target.weight = weight;
  target.i = Math.min(source.i, target.i);
  source.merged = true;
}
var _$b = lodash_1$2;
var util$8 = util$d;
var sort_1 = sort$1;
function sort$1(entries2, biasRight) {
  var parts = util$8.partition(entries2, function(entry) {
    return _$b.has(entry, "barycenter");
  });
  var sortable = parts.lhs, unsortable = _$b.sortBy(parts.rhs, function(entry) {
    return -entry.i;
  }), vs = [], sum2 = 0, weight = 0, vsIndex = 0;
  sortable.sort(compareWithBias(!!biasRight));
  vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
  _$b.forEach(sortable, function(entry) {
    vsIndex += entry.vs.length;
    vs.push(entry.vs);
    sum2 += entry.barycenter * entry.weight;
    weight += entry.weight;
    vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
  });
  var result = { vs: _$b.flatten(vs, true) };
  if (weight) {
    result.barycenter = sum2 / weight;
    result.weight = weight;
  }
  return result;
}
function consumeUnsortable(vs, unsortable, index2) {
  var last;
  while (unsortable.length && (last = _$b.last(unsortable)).i <= index2) {
    unsortable.pop();
    vs.push(last.vs);
    index2++;
  }
  return index2;
}
function compareWithBias(bias) {
  return function(entryV, entryW) {
    if (entryV.barycenter < entryW.barycenter) {
      return -1;
    } else if (entryV.barycenter > entryW.barycenter) {
      return 1;
    }
    return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
  };
}
var _$a = lodash_1$2;
var barycenter = barycenter_1;
var resolveConflicts = resolveConflicts_1;
var sort = sort_1;
var sortSubgraph_1 = sortSubgraph$1;
function sortSubgraph$1(g2, v, cg, biasRight) {
  var movable = g2.children(v);
  var node2 = g2.node(v);
  var bl = node2 ? node2.borderLeft : void 0;
  var br = node2 ? node2.borderRight : void 0;
  var subgraphs = {};
  if (bl) {
    movable = _$a.filter(movable, function(w2) {
      return w2 !== bl && w2 !== br;
    });
  }
  var barycenters = barycenter(g2, movable);
  _$a.forEach(barycenters, function(entry) {
    if (g2.children(entry.v).length) {
      var subgraphResult = sortSubgraph$1(g2, entry.v, cg, biasRight);
      subgraphs[entry.v] = subgraphResult;
      if (_$a.has(subgraphResult, "barycenter")) {
        mergeBarycenters(entry, subgraphResult);
      }
    }
  });
  var entries2 = resolveConflicts(barycenters, cg);
  expandSubgraphs(entries2, subgraphs);
  var result = sort(entries2, biasRight);
  if (bl) {
    result.vs = _$a.flatten([bl, result.vs, br], true);
    if (g2.predecessors(bl).length) {
      var blPred = g2.node(g2.predecessors(bl)[0]), brPred = g2.node(g2.predecessors(br)[0]);
      if (!_$a.has(result, "barycenter")) {
        result.barycenter = 0;
        result.weight = 0;
      }
      result.barycenter = (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2);
      result.weight += 2;
    }
  }
  return result;
}
function expandSubgraphs(entries2, subgraphs) {
  _$a.forEach(entries2, function(entry) {
    entry.vs = _$a.flatten(entry.vs.map(function(v) {
      if (subgraphs[v]) {
        return subgraphs[v].vs;
      }
      return v;
    }), true);
  });
}
function mergeBarycenters(target, other) {
  if (!_$a.isUndefined(target.barycenter)) {
    target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight);
    target.weight += other.weight;
  } else {
    target.barycenter = other.barycenter;
    target.weight = other.weight;
  }
}
var _$9 = lodash_1$2;
var Graph$4 = graphlib_1$1.Graph;
var buildLayerGraph_1 = buildLayerGraph$1;
function buildLayerGraph$1(g2, rank2, relationship) {
  var root2 = createRootNode(g2), result = new Graph$4({ compound: true }).setGraph({ root: root2 }).setDefaultNodeLabel(function(v) {
    return g2.node(v);
  });
  _$9.forEach(g2.nodes(), function(v) {
    var node2 = g2.node(v), parent = g2.parent(v);
    if (node2.rank === rank2 || node2.minRank <= rank2 && rank2 <= node2.maxRank) {
      result.setNode(v);
      result.setParent(v, parent || root2);
      _$9.forEach(g2[relationship](v), function(e) {
        var u = e.v === v ? e.w : e.v, edge = result.edge(u, v), weight = !_$9.isUndefined(edge) ? edge.weight : 0;
        result.setEdge(u, v, { weight: g2.edge(e).weight + weight });
      });
      if (_$9.has(node2, "minRank")) {
        result.setNode(v, {
          borderLeft: node2.borderLeft[rank2],
          borderRight: node2.borderRight[rank2]
        });
      }
    }
  });
  return result;
}
function createRootNode(g2) {
  var v;
  while (g2.hasNode(v = _$9.uniqueId("_root")))
    ;
  return v;
}
var _$8 = lodash_1$2;
var addSubgraphConstraints_1 = addSubgraphConstraints$1;
function addSubgraphConstraints$1(g2, cg, vs) {
  var prev2 = {}, rootPrev;
  _$8.forEach(vs, function(v) {
    var child = g2.parent(v), parent, prevChild;
    while (child) {
      parent = g2.parent(child);
      if (parent) {
        prevChild = prev2[parent];
        prev2[parent] = child;
      } else {
        prevChild = rootPrev;
        rootPrev = child;
      }
      if (prevChild && prevChild !== child) {
        cg.setEdge(prevChild, child);
        return;
      }
      child = parent;
    }
  });
}
var _$7 = lodash_1$2;
var initOrder = initOrder_1;
var crossCount = crossCount_1;
var sortSubgraph = sortSubgraph_1;
var buildLayerGraph = buildLayerGraph_1;
var addSubgraphConstraints = addSubgraphConstraints_1;
var Graph$3 = graphlib_1$1.Graph;
var util$7 = util$d;
var order_1 = order$1;
function order$1(g2) {
  var maxRank2 = util$7.maxRank(g2), downLayerGraphs = buildLayerGraphs(g2, _$7.range(1, maxRank2 + 1), "inEdges"), upLayerGraphs = buildLayerGraphs(g2, _$7.range(maxRank2 - 1, -1, -1), "outEdges");
  var layering = initOrder(g2);
  assignOrder(g2, layering);
  var bestCC = Number.POSITIVE_INFINITY, best;
  for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {
    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);
    layering = util$7.buildLayerMatrix(g2);
    var cc = crossCount(g2, layering);
    if (cc < bestCC) {
      lastBest = 0;
      best = _$7.cloneDeep(layering);
      bestCC = cc;
    }
  }
  assignOrder(g2, best);
}
function buildLayerGraphs(g2, ranks, relationship) {
  return _$7.map(ranks, function(rank2) {
    return buildLayerGraph(g2, rank2, relationship);
  });
}
function sweepLayerGraphs(layerGraphs, biasRight) {
  var cg = new Graph$3();
  _$7.forEach(layerGraphs, function(lg) {
    var root2 = lg.graph().root;
    var sorted = sortSubgraph(lg, root2, cg, biasRight);
    _$7.forEach(sorted.vs, function(v, i) {
      lg.node(v).order = i;
    });
    addSubgraphConstraints(lg, cg, sorted.vs);
  });
}
function assignOrder(g2, layering) {
  _$7.forEach(layering, function(layer) {
    _$7.forEach(layer, function(v, i) {
      g2.node(v).order = i;
    });
  });
}
var _$6 = lodash_1$2;
var Graph$2 = graphlib_1$1.Graph;
var util$6 = util$d;
var bk = {
  positionX: positionX$1,
  findType1Conflicts,
  findType2Conflicts,
  addConflict,
  hasConflict,
  verticalAlignment,
  horizontalCompaction,
  alignCoordinates,
  findSmallestWidthAlignment,
  balance
};
function findType1Conflicts(g2, layering) {
  var conflicts = {};
  function visitLayer(prevLayer, layer) {
    var k0 = 0, scanPos = 0, prevLayerLength = prevLayer.length, lastNode = _$6.last(layer);
    _$6.forEach(layer, function(v, i) {
      var w2 = findOtherInnerSegmentNode(g2, v), k1 = w2 ? g2.node(w2).order : prevLayerLength;
      if (w2 || v === lastNode) {
        _$6.forEach(layer.slice(scanPos, i + 1), function(scanNode) {
          _$6.forEach(g2.predecessors(scanNode), function(u) {
            var uLabel = g2.node(u), uPos = uLabel.order;
            if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && g2.node(scanNode).dummy)) {
              addConflict(conflicts, u, scanNode);
            }
          });
        });
        scanPos = i + 1;
        k0 = k1;
      }
    });
    return layer;
  }
  _$6.reduce(layering, visitLayer);
  return conflicts;
}
function findType2Conflicts(g2, layering) {
  var conflicts = {};
  function scan2(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
    var v;
    _$6.forEach(_$6.range(southPos, southEnd), function(i) {
      v = south[i];
      if (g2.node(v).dummy) {
        _$6.forEach(g2.predecessors(v), function(u) {
          var uNode = g2.node(u);
          if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {
            addConflict(conflicts, u, v);
          }
        });
      }
    });
  }
  function visitLayer(north, south) {
    var prevNorthPos = -1, nextNorthPos, southPos = 0;
    _$6.forEach(south, function(v, southLookahead) {
      if (g2.node(v).dummy === "border") {
        var predecessors = g2.predecessors(v);
        if (predecessors.length) {
          nextNorthPos = g2.node(predecessors[0]).order;
          scan2(south, southPos, southLookahead, prevNorthPos, nextNorthPos);
          southPos = southLookahead;
          prevNorthPos = nextNorthPos;
        }
      }
      scan2(south, southPos, south.length, nextNorthPos, north.length);
    });
    return south;
  }
  _$6.reduce(layering, visitLayer);
  return conflicts;
}
function findOtherInnerSegmentNode(g2, v) {
  if (g2.node(v).dummy) {
    return _$6.find(g2.predecessors(v), function(u) {
      return g2.node(u).dummy;
    });
  }
}
function addConflict(conflicts, v, w2) {
  if (v > w2) {
    var tmp = v;
    v = w2;
    w2 = tmp;
  }
  var conflictsV = conflicts[v];
  if (!conflictsV) {
    conflicts[v] = conflictsV = {};
  }
  conflictsV[w2] = true;
}
function hasConflict(conflicts, v, w2) {
  if (v > w2) {
    var tmp = v;
    v = w2;
    w2 = tmp;
  }
  return _$6.has(conflicts[v], w2);
}
function verticalAlignment(g2, layering, conflicts, neighborFn) {
  var root2 = {}, align = {}, pos = {};
  _$6.forEach(layering, function(layer) {
    _$6.forEach(layer, function(v, order2) {
      root2[v] = v;
      align[v] = v;
      pos[v] = order2;
    });
  });
  _$6.forEach(layering, function(layer) {
    var prevIdx = -1;
    _$6.forEach(layer, function(v) {
      var ws = neighborFn(v);
      if (ws.length) {
        ws = _$6.sortBy(ws, function(w3) {
          return pos[w3];
        });
        var mp = (ws.length - 1) / 2;
        for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {
          var w2 = ws[i];
          if (align[v] === v && prevIdx < pos[w2] && !hasConflict(conflicts, v, w2)) {
            align[w2] = v;
            align[v] = root2[v] = root2[w2];
            prevIdx = pos[w2];
          }
        }
      }
    });
  });
  return { root: root2, align };
}
function horizontalCompaction(g2, layering, root2, align, reverseSep) {
  var xs = {}, blockG = buildBlockGraph(g2, layering, root2, reverseSep), borderType = reverseSep ? "borderLeft" : "borderRight";
  function iterate(setXsFunc, nextNodesFunc) {
    var stack2 = blockG.nodes();
    var elem = stack2.pop();
    var visited = {};
    while (elem) {
      if (visited[elem]) {
        setXsFunc(elem);
      } else {
        visited[elem] = true;
        stack2.push(elem);
        stack2 = stack2.concat(nextNodesFunc(elem));
      }
      elem = stack2.pop();
    }
  }
  function pass1(elem) {
    xs[elem] = blockG.inEdges(elem).reduce(function(acc, e) {
      return Math.max(acc, xs[e.v] + blockG.edge(e));
    }, 0);
  }
  function pass2(elem) {
    var min2 = blockG.outEdges(elem).reduce(function(acc, e) {
      return Math.min(acc, xs[e.w] - blockG.edge(e));
    }, Number.POSITIVE_INFINITY);
    var node2 = g2.node(elem);
    if (min2 !== Number.POSITIVE_INFINITY && node2.borderType !== borderType) {
      xs[elem] = Math.max(xs[elem], min2);
    }
  }
  iterate(pass1, blockG.predecessors.bind(blockG));
  iterate(pass2, blockG.successors.bind(blockG));
  _$6.forEach(align, function(v) {
    xs[v] = xs[root2[v]];
  });
  return xs;
}
function buildBlockGraph(g2, layering, root2, reverseSep) {
  var blockGraph = new Graph$2(), graphLabel = g2.graph(), sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);
  _$6.forEach(layering, function(layer) {
    var u;
    _$6.forEach(layer, function(v) {
      var vRoot = root2[v];
      blockGraph.setNode(vRoot);
      if (u) {
        var uRoot = root2[u], prevMax = blockGraph.edge(uRoot, vRoot);
        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g2, v, u), prevMax || 0));
      }
      u = v;
    });
  });
  return blockGraph;
}
function findSmallestWidthAlignment(g2, xss) {
  return _$6.minBy(_$6.values(xss), function(xs) {
    var max2 = Number.NEGATIVE_INFINITY;
    var min2 = Number.POSITIVE_INFINITY;
    _$6.forIn(xs, function(x2, v) {
      var halfWidth = width$1(g2, v) / 2;
      max2 = Math.max(x2 + halfWidth, max2);
      min2 = Math.min(x2 - halfWidth, min2);
    });
    return max2 - min2;
  });
}
function alignCoordinates(xss, alignTo) {
  var alignToVals = _$6.values(alignTo), alignToMin = _$6.min(alignToVals), alignToMax = _$6.max(alignToVals);
  _$6.forEach(["u", "d"], function(vert) {
    _$6.forEach(["l", "r"], function(horiz) {
      var alignment = vert + horiz, xs = xss[alignment], delta;
      if (xs === alignTo)
        return;
      var xsVals = _$6.values(xs);
      delta = horiz === "l" ? alignToMin - _$6.min(xsVals) : alignToMax - _$6.max(xsVals);
      if (delta) {
        xss[alignment] = _$6.mapValues(xs, function(x2) {
          return x2 + delta;
        });
      }
    });
  });
}
function balance(xss, align) {
  return _$6.mapValues(xss.ul, function(ignore, v) {
    if (align) {
      return xss[align.toLowerCase()][v];
    } else {
      var xs = _$6.sortBy(_$6.map(xss, v));
      return (xs[1] + xs[2]) / 2;
    }
  });
}
function positionX$1(g2) {
  var layering = util$6.buildLayerMatrix(g2);
  var conflicts = _$6.merge(
    findType1Conflicts(g2, layering),
    findType2Conflicts(g2, layering)
  );
  var xss = {};
  var adjustedLayering;
  _$6.forEach(["u", "d"], function(vert) {
    adjustedLayering = vert === "u" ? layering : _$6.values(layering).reverse();
    _$6.forEach(["l", "r"], function(horiz) {
      if (horiz === "r") {
        adjustedLayering = _$6.map(adjustedLayering, function(inner) {
          return _$6.values(inner).reverse();
        });
      }
      var neighborFn = (vert === "u" ? g2.predecessors : g2.successors).bind(g2);
      var align = verticalAlignment(g2, adjustedLayering, conflicts, neighborFn);
      var xs = horizontalCompaction(
        g2,
        adjustedLayering,
        align.root,
        align.align,
        horiz === "r"
      );
      if (horiz === "r") {
        xs = _$6.mapValues(xs, function(x2) {
          return -x2;
        });
      }
      xss[vert + horiz] = xs;
    });
  });
  var smallestWidth = findSmallestWidthAlignment(g2, xss);
  alignCoordinates(xss, smallestWidth);
  return balance(xss, g2.graph().align);
}
function sep(nodeSep, edgeSep, reverseSep) {
  return function(g2, v, w2) {
    var vLabel = g2.node(v);
    var wLabel = g2.node(w2);
    var sum2 = 0;
    var delta;
    sum2 += vLabel.width / 2;
    if (_$6.has(vLabel, "labelpos")) {
      switch (vLabel.labelpos.toLowerCase()) {
        case "l":
          delta = -vLabel.width / 2;
          break;
        case "r":
          delta = vLabel.width / 2;
          break;
      }
    }
    if (delta) {
      sum2 += reverseSep ? delta : -delta;
    }
    delta = 0;
    sum2 += (vLabel.dummy ? edgeSep : nodeSep) / 2;
    sum2 += (wLabel.dummy ? edgeSep : nodeSep) / 2;
    sum2 += wLabel.width / 2;
    if (_$6.has(wLabel, "labelpos")) {
      switch (wLabel.labelpos.toLowerCase()) {
        case "l":
          delta = wLabel.width / 2;
          break;
        case "r":
          delta = -wLabel.width / 2;
          break;
      }
    }
    if (delta) {
      sum2 += reverseSep ? delta : -delta;
    }
    delta = 0;
    return sum2;
  };
}
function width$1(g2, v) {
  return g2.node(v).width;
}
var _$5 = lodash_1$2;
var util$5 = util$d;
var positionX = bk.positionX;
var position_1 = position$1;
function position$1(g2) {
  g2 = util$5.asNonCompoundGraph(g2);
  positionY(g2);
  _$5.forEach(positionX(g2), function(x2, v) {
    g2.node(v).x = x2;
  });
}
function positionY(g2) {
  var layering = util$5.buildLayerMatrix(g2);
  var rankSep = g2.graph().ranksep;
  var prevY = 0;
  _$5.forEach(layering, function(layer) {
    var maxHeight = _$5.max(_$5.map(layer, function(v) {
      return g2.node(v).height;
    }));
    _$5.forEach(layer, function(v) {
      g2.node(v).y = prevY + maxHeight / 2;
    });
    prevY += maxHeight + rankSep;
  });
}
var _$4 = lodash_1$2;
var acyclic = acyclic$1;
var normalize$1 = normalize$2;
var rank = rank_1;
var normalizeRanks = util$d.normalizeRanks;
var parentDummyChains = parentDummyChains_1;
var removeEmptyRanks = util$d.removeEmptyRanks;
var nestingGraph = nestingGraph$1;
var addBorderSegments = addBorderSegments_1;
var coordinateSystem = coordinateSystem$1;
var order = order_1;
var position = position_1;
var util$4 = util$d;
var Graph$1 = graphlib_1$1.Graph;
var layout_1 = layout$1;
function layout$1(g2, opts) {
  var time2 = opts && opts.debugTiming ? util$4.time : util$4.notime;
  time2("layout", function() {
    var layoutGraph = time2("  buildLayoutGraph", function() {
      return buildLayoutGraph(g2);
    });
    time2("  runLayout", function() {
      runLayout(layoutGraph, time2);
    });
    time2("  updateInputGraph", function() {
      updateInputGraph(g2, layoutGraph);
    });
  });
}
function runLayout(g2, time2) {
  time2("    makeSpaceForEdgeLabels", function() {
    makeSpaceForEdgeLabels(g2);
  });
  time2("    removeSelfEdges", function() {
    removeSelfEdges(g2);
  });
  time2("    acyclic", function() {
    acyclic.run(g2);
  });
  time2("    nestingGraph.run", function() {
    nestingGraph.run(g2);
  });
  time2("    rank", function() {
    rank(util$4.asNonCompoundGraph(g2));
  });
  time2("    injectEdgeLabelProxies", function() {
    injectEdgeLabelProxies(g2);
  });
  time2("    removeEmptyRanks", function() {
    removeEmptyRanks(g2);
  });
  time2("    nestingGraph.cleanup", function() {
    nestingGraph.cleanup(g2);
  });
  time2("    normalizeRanks", function() {
    normalizeRanks(g2);
  });
  time2("    assignRankMinMax", function() {
    assignRankMinMax(g2);
  });
  time2("    removeEdgeLabelProxies", function() {
    removeEdgeLabelProxies(g2);
  });
  time2("    normalize.run", function() {
    normalize$1.run(g2);
  });
  time2("    parentDummyChains", function() {
    parentDummyChains(g2);
  });
  time2("    addBorderSegments", function() {
    addBorderSegments(g2);
  });
  time2("    order", function() {
    order(g2);
  });
  time2("    insertSelfEdges", function() {
    insertSelfEdges(g2);
  });
  time2("    adjustCoordinateSystem", function() {
    coordinateSystem.adjust(g2);
  });
  time2("    position", function() {
    position(g2);
  });
  time2("    positionSelfEdges", function() {
    positionSelfEdges(g2);
  });
  time2("    removeBorderNodes", function() {
    removeBorderNodes(g2);
  });
  time2("    normalize.undo", function() {
    normalize$1.undo(g2);
  });
  time2("    fixupEdgeLabelCoords", function() {
    fixupEdgeLabelCoords(g2);
  });
  time2("    undoCoordinateSystem", function() {
    coordinateSystem.undo(g2);
  });
  time2("    translateGraph", function() {
    translateGraph(g2);
  });
  time2("    assignNodeIntersects", function() {
    assignNodeIntersects(g2);
  });
  time2("    reversePoints", function() {
    reversePointsForReversedEdges(g2);
  });
  time2("    acyclic.undo", function() {
    acyclic.undo(g2);
  });
}
function updateInputGraph(inputGraph, layoutGraph) {
  _$4.forEach(inputGraph.nodes(), function(v) {
    var inputLabel = inputGraph.node(v);
    var layoutLabel = layoutGraph.node(v);
    if (inputLabel) {
      inputLabel.x = layoutLabel.x;
      inputLabel.y = layoutLabel.y;
      if (layoutGraph.children(v).length) {
        inputLabel.width = layoutLabel.width;
        inputLabel.height = layoutLabel.height;
      }
    }
  });
  _$4.forEach(inputGraph.edges(), function(e) {
    var inputLabel = inputGraph.edge(e);
    var layoutLabel = layoutGraph.edge(e);
    inputLabel.points = layoutLabel.points;
    if (_$4.has(layoutLabel, "x")) {
      inputLabel.x = layoutLabel.x;
      inputLabel.y = layoutLabel.y;
    }
  });
  inputGraph.graph().width = layoutGraph.graph().width;
  inputGraph.graph().height = layoutGraph.graph().height;
}
var graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
var graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" };
var graphAttrs = ["acyclicer", "ranker", "rankdir", "align"];
var nodeNumAttrs = ["width", "height"];
var nodeDefaults = { width: 0, height: 0 };
var edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"];
var edgeDefaults = {
  minlen: 1,
  weight: 1,
  width: 0,
  height: 0,
  labeloffset: 10,
  labelpos: "r"
};
var edgeAttrs = ["labelpos"];
function buildLayoutGraph(inputGraph) {
  var g2 = new Graph$1({ multigraph: true, compound: true });
  var graph2 = canonicalize(inputGraph.graph());
  g2.setGraph(_$4.merge(
    {},
    graphDefaults,
    selectNumberAttrs(graph2, graphNumAttrs),
    _$4.pick(graph2, graphAttrs)
  ));
  _$4.forEach(inputGraph.nodes(), function(v) {
    var node2 = canonicalize(inputGraph.node(v));
    g2.setNode(v, _$4.defaults(selectNumberAttrs(node2, nodeNumAttrs), nodeDefaults));
    g2.setParent(v, inputGraph.parent(v));
  });
  _$4.forEach(inputGraph.edges(), function(e) {
    var edge = canonicalize(inputGraph.edge(e));
    g2.setEdge(e, _$4.merge(
      {},
      edgeDefaults,
      selectNumberAttrs(edge, edgeNumAttrs),
      _$4.pick(edge, edgeAttrs)
    ));
  });
  return g2;
}
function makeSpaceForEdgeLabels(g2) {
  var graph2 = g2.graph();
  graph2.ranksep /= 2;
  _$4.forEach(g2.edges(), function(e) {
    var edge = g2.edge(e);
    edge.minlen *= 2;
    if (edge.labelpos.toLowerCase() !== "c") {
      if (graph2.rankdir === "TB" || graph2.rankdir === "BT") {
        edge.width += edge.labeloffset;
      } else {
        edge.height += edge.labeloffset;
      }
    }
  });
}
function injectEdgeLabelProxies(g2) {
  _$4.forEach(g2.edges(), function(e) {
    var edge = g2.edge(e);
    if (edge.width && edge.height) {
      var v = g2.node(e.v);
      var w2 = g2.node(e.w);
      var label = { rank: (w2.rank - v.rank) / 2 + v.rank, e };
      util$4.addDummyNode(g2, "edge-proxy", label, "_ep");
    }
  });
}
function assignRankMinMax(g2) {
  var maxRank2 = 0;
  _$4.forEach(g2.nodes(), function(v) {
    var node2 = g2.node(v);
    if (node2.borderTop) {
      node2.minRank = g2.node(node2.borderTop).rank;
      node2.maxRank = g2.node(node2.borderBottom).rank;
      maxRank2 = _$4.max(maxRank2, node2.maxRank);
    }
  });
  g2.graph().maxRank = maxRank2;
}
function removeEdgeLabelProxies(g2) {
  _$4.forEach(g2.nodes(), function(v) {
    var node2 = g2.node(v);
    if (node2.dummy === "edge-proxy") {
      g2.edge(node2.e).labelRank = node2.rank;
      g2.removeNode(v);
    }
  });
}
function translateGraph(g2) {
  var minX = Number.POSITIVE_INFINITY;
  var maxX = 0;
  var minY = Number.POSITIVE_INFINITY;
  var maxY2 = 0;
  var graphLabel = g2.graph();
  var marginX = graphLabel.marginx || 0;
  var marginY = graphLabel.marginy || 0;
  function getExtremes(attrs) {
    var x2 = attrs.x;
    var y2 = attrs.y;
    var w2 = attrs.width;
    var h2 = attrs.height;
    minX = Math.min(minX, x2 - w2 / 2);
    maxX = Math.max(maxX, x2 + w2 / 2);
    minY = Math.min(minY, y2 - h2 / 2);
    maxY2 = Math.max(maxY2, y2 + h2 / 2);
  }
  _$4.forEach(g2.nodes(), function(v) {
    getExtremes(g2.node(v));
  });
  _$4.forEach(g2.edges(), function(e) {
    var edge = g2.edge(e);
    if (_$4.has(edge, "x")) {
      getExtremes(edge);
    }
  });
  minX -= marginX;
  minY -= marginY;
  _$4.forEach(g2.nodes(), function(v) {
    var node2 = g2.node(v);
    node2.x -= minX;
    node2.y -= minY;
  });
  _$4.forEach(g2.edges(), function(e) {
    var edge = g2.edge(e);
    _$4.forEach(edge.points, function(p) {
      p.x -= minX;
      p.y -= minY;
    });
    if (_$4.has(edge, "x")) {
      edge.x -= minX;
    }
    if (_$4.has(edge, "y")) {
      edge.y -= minY;
    }
  });
  graphLabel.width = maxX - minX + marginX;
  graphLabel.height = maxY2 - minY + marginY;
}
function assignNodeIntersects(g2) {
  _$4.forEach(g2.edges(), function(e) {
    var edge = g2.edge(e);
    var nodeV = g2.node(e.v);
    var nodeW = g2.node(e.w);
    var p1, p2;
    if (!edge.points) {
      edge.points = [];
      p1 = nodeW;
      p2 = nodeV;
    } else {
      p1 = edge.points[0];
      p2 = edge.points[edge.points.length - 1];
    }
    edge.points.unshift(util$4.intersectRect(nodeV, p1));
    edge.points.push(util$4.intersectRect(nodeW, p2));
  });
}
function fixupEdgeLabelCoords(g2) {
  _$4.forEach(g2.edges(), function(e) {
    var edge = g2.edge(e);
    if (_$4.has(edge, "x")) {
      if (edge.labelpos === "l" || edge.labelpos === "r") {
        edge.width -= edge.labeloffset;
      }
      switch (edge.labelpos) {
        case "l":
          edge.x -= edge.width / 2 + edge.labeloffset;
          break;
        case "r":
          edge.x += edge.width / 2 + edge.labeloffset;
          break;
      }
    }
  });
}
function reversePointsForReversedEdges(g2) {
  _$4.forEach(g2.edges(), function(e) {
    var edge = g2.edge(e);
    if (edge.reversed) {
      edge.points.reverse();
    }
  });
}
function removeBorderNodes(g2) {
  _$4.forEach(g2.nodes(), function(v) {
    if (g2.children(v).length) {
      var node2 = g2.node(v);
      var t4 = g2.node(node2.borderTop);
      var b = g2.node(node2.borderBottom);
      var l2 = g2.node(_$4.last(node2.borderLeft));
      var r = g2.node(_$4.last(node2.borderRight));
      node2.width = Math.abs(r.x - l2.x);
      node2.height = Math.abs(b.y - t4.y);
      node2.x = l2.x + node2.width / 2;
      node2.y = t4.y + node2.height / 2;
    }
  });
  _$4.forEach(g2.nodes(), function(v) {
    if (g2.node(v).dummy === "border") {
      g2.removeNode(v);
    }
  });
}
function removeSelfEdges(g2) {
  _$4.forEach(g2.edges(), function(e) {
    if (e.v === e.w) {
      var node2 = g2.node(e.v);
      if (!node2.selfEdges) {
        node2.selfEdges = [];
      }
      node2.selfEdges.push({ e, label: g2.edge(e) });
      g2.removeEdge(e);
    }
  });
}
function insertSelfEdges(g2) {
  var layers = util$4.buildLayerMatrix(g2);
  _$4.forEach(layers, function(layer) {
    var orderShift = 0;
    _$4.forEach(layer, function(v, i) {
      var node2 = g2.node(v);
      node2.order = i + orderShift;
      _$4.forEach(node2.selfEdges, function(selfEdge) {
        util$4.addDummyNode(g2, "selfedge", {
          width: selfEdge.label.width,
          height: selfEdge.label.height,
          rank: node2.rank,
          order: i + ++orderShift,
          e: selfEdge.e,
          label: selfEdge.label
        }, "_se");
      });
      delete node2.selfEdges;
    });
  });
}
function positionSelfEdges(g2) {
  _$4.forEach(g2.nodes(), function(v) {
    var node2 = g2.node(v);
    if (node2.dummy === "selfedge") {
      var selfNode = g2.node(node2.e.v);
      var x2 = selfNode.x + selfNode.width / 2;
      var y2 = selfNode.y;
      var dx = node2.x - x2;
      var dy = selfNode.height / 2;
      g2.setEdge(node2.e, node2.label);
      g2.removeNode(v);
      node2.label.points = [
        { x: x2 + 2 * dx / 3, y: y2 - dy },
        { x: x2 + 5 * dx / 6, y: y2 - dy },
        { x: x2 + dx, y: y2 },
        { x: x2 + 5 * dx / 6, y: y2 + dy },
        { x: x2 + 2 * dx / 3, y: y2 + dy }
      ];
      node2.label.x = node2.x;
      node2.label.y = node2.y;
    }
  });
}
function selectNumberAttrs(obj, attrs) {
  return _$4.mapValues(_$4.pick(obj, attrs), Number);
}
function canonicalize(attrs) {
  var newAttrs = {};
  _$4.forEach(attrs, function(v, k2) {
    newAttrs[k2.toLowerCase()] = v;
  });
  return newAttrs;
}
var _$3 = lodash_1$2;
var util$3 = util$d;
var Graph = graphlib_1$1.Graph;
var debug = {
  debugOrdering
};
function debugOrdering(g2) {
  var layerMatrix = util$3.buildLayerMatrix(g2);
  var h2 = new Graph({ compound: true, multigraph: true }).setGraph({});
  _$3.forEach(g2.nodes(), function(v) {
    h2.setNode(v, { label: v });
    h2.setParent(v, "layer" + g2.node(v).rank);
  });
  _$3.forEach(g2.edges(), function(e) {
    h2.setEdge(e.v, e.w, {}, e.name);
  });
  _$3.forEach(layerMatrix, function(layer, i) {
    var layerV = "layer" + i;
    h2.setNode(layerV, { rank: "same" });
    _$3.reduce(layer, function(u, v) {
      h2.setEdge(u, v, { style: "invis" });
      return v;
    });
  });
  return h2;
}
var version$4 = "0.8.5";
var dagre$1 = {
  graphlib: graphlib_1$1,
  layout: layout_1,
  debug,
  util: {
    time: util$d.time,
    notime: util$d.notime
  },
  version: version$4
};
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const native = {
  randomUUID
};
function v4(options2, buf, offset) {
  if (native.randomUUID && !buf && !options2) {
    return native.randomUUID();
  }
  options2 = options2 || {};
  const rnds = options2.random || (options2.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var graphlib;
if (typeof commonjsRequire$1 === "function") {
  try {
    graphlib = graphlib$2;
  } catch (e) {
  }
}
if (!graphlib) {
  graphlib = window.graphlib;
}
var graphlib_1 = graphlib;
var dagre;
if (typeof commonjsRequire$1 === "function") {
  try {
    dagre = dagre$1;
  } catch (e) {
  }
}
if (!dagre) {
  dagre = window.dagre;
}
var dagre_1 = dagre;
var intersectNode_1 = intersectNode$1;
function intersectNode$1(node2, point2) {
  return node2.intersect(point2);
}
var intersectEllipse_1 = intersectEllipse$2;
function intersectEllipse$2(node2, rx, ry, point2) {
  var cx = node2.x;
  var cy = node2.y;
  var px = cx - point2.x;
  var py = cy - point2.y;
  var det = Math.sqrt(rx * rx * py * py + ry * ry * px * px);
  var dx = Math.abs(rx * ry * px / det);
  if (point2.x < cx) {
    dx = -dx;
  }
  var dy = Math.abs(rx * ry * py / det);
  if (point2.y < cy) {
    dy = -dy;
  }
  return { x: cx + dx, y: cy + dy };
}
var intersectEllipse$1 = intersectEllipse_1;
var intersectCircle_1 = intersectCircle$1;
function intersectCircle$1(node2, rx, point2) {
  return intersectEllipse$1(node2, rx, rx, point2);
}
var intersectLine_1 = intersectLine$2;
function intersectLine$2(p1, p2, q1, q2) {
  var a1, a2, b12, b22, c1, c2;
  var r1, r2, r3, r4;
  var denom, offset, num;
  var x2, y2;
  a1 = p2.y - p1.y;
  b12 = p1.x - p2.x;
  c1 = p2.x * p1.y - p1.x * p2.y;
  r3 = a1 * q1.x + b12 * q1.y + c1;
  r4 = a1 * q2.x + b12 * q2.y + c1;
  if (r3 !== 0 && r4 !== 0 && sameSign$1(r3, r4)) {
    return;
  }
  a2 = q2.y - q1.y;
  b22 = q1.x - q2.x;
  c2 = q2.x * q1.y - q1.x * q2.y;
  r1 = a2 * p1.x + b22 * p1.y + c2;
  r2 = a2 * p2.x + b22 * p2.y + c2;
  if (r1 !== 0 && r2 !== 0 && sameSign$1(r1, r2)) {
    return;
  }
  denom = a1 * b22 - a2 * b12;
  if (denom === 0) {
    return;
  }
  offset = Math.abs(denom / 2);
  num = b12 * c2 - b22 * c1;
  x2 = num < 0 ? (num - offset) / denom : (num + offset) / denom;
  num = a2 * c1 - a1 * c2;
  y2 = num < 0 ? (num - offset) / denom : (num + offset) / denom;
  return { x: x2, y: y2 };
}
function sameSign$1(r1, r2) {
  return r1 * r2 > 0;
}
var intersectLine$1 = intersectLine_1;
var intersectPolygon_1 = intersectPolygon$1;
function intersectPolygon$1(node2, polyPoints, point2) {
  var x12 = node2.x;
  var y12 = node2.y;
  var intersections = [];
  var minX = Number.POSITIVE_INFINITY;
  var minY = Number.POSITIVE_INFINITY;
  polyPoints.forEach(function(entry) {
    minX = Math.min(minX, entry.x);
    minY = Math.min(minY, entry.y);
  });
  var left2 = x12 - node2.width / 2 - minX;
  var top2 = y12 - node2.height / 2 - minY;
  for (var i = 0; i < polyPoints.length; i++) {
    var p1 = polyPoints[i];
    var p2 = polyPoints[i < polyPoints.length - 1 ? i + 1 : 0];
    var intersect2 = intersectLine$1(
      node2,
      point2,
      { x: left2 + p1.x, y: top2 + p1.y },
      { x: left2 + p2.x, y: top2 + p2.y }
    );
    if (intersect2) {
      intersections.push(intersect2);
    }
  }
  if (!intersections.length) {
    console.log("NO INTERSECTION FOUND, RETURN NODE CENTER", node2);
    return node2;
  }
  if (intersections.length > 1) {
    intersections.sort(function(p, q) {
      var pdx = p.x - point2.x;
      var pdy = p.y - point2.y;
      var distp = Math.sqrt(pdx * pdx + pdy * pdy);
      var qdx = q.x - point2.x;
      var qdy = q.y - point2.y;
      var distq = Math.sqrt(qdx * qdx + qdy * qdy);
      return distp < distq ? -1 : distp === distq ? 0 : 1;
    });
  }
  return intersections[0];
}
var intersectRect_1 = intersectRect$1;
function intersectRect$1(node2, point2) {
  var x2 = node2.x;
  var y2 = node2.y;
  var dx = point2.x - x2;
  var dy = point2.y - y2;
  var w2 = node2.width / 2;
  var h2 = node2.height / 2;
  var sx, sy;
  if (Math.abs(dy) * w2 > Math.abs(dx) * h2) {
    if (dy < 0) {
      h2 = -h2;
    }
    sx = dy === 0 ? 0 : h2 * dx / dy;
    sy = h2;
  } else {
    if (dx < 0) {
      w2 = -w2;
    }
    sx = w2;
    sy = dx === 0 ? 0 : w2 * dy / dx;
  }
  return { x: x2 + sx, y: y2 + sy };
}
var intersect$2 = {
  node: intersectNode_1,
  circle: intersectCircle_1,
  ellipse: intersectEllipse_1,
  polygon: intersectPolygon_1,
  rect: intersectRect_1
};
var lodash$1;
if (typeof commonjsRequire$1 === "function") {
  try {
    lodash$1 = {
      defaults: requireDefaults$1(),
      each: requireEach$1(),
      isFunction: requireIsFunction$1(),
      isPlainObject: requireIsPlainObject$1(),
      pick: requirePick$1(),
      has: requireHas$1(),
      range: requireRange$1(),
      uniqueId: requireUniqueId$1()
    };
  } catch (e) {
  }
}
if (!lodash$1) {
  lodash$1 = window._;
}
var lodash_1$1 = lodash$1;
var version$3 = "5.16.0";
function ascending$3(a2, b) {
  return a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
}
function bisector(compare2) {
  if (compare2.length === 1)
    compare2 = ascendingComparator(compare2);
  return {
    left: function(a2, x2, lo, hi) {
      if (lo == null)
        lo = 0;
      if (hi == null)
        hi = a2.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare2(a2[mid], x2) < 0)
          lo = mid + 1;
        else
          hi = mid;
      }
      return lo;
    },
    right: function(a2, x2, lo, hi) {
      if (lo == null)
        lo = 0;
      if (hi == null)
        hi = a2.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare2(a2[mid], x2) > 0)
          hi = mid;
        else
          lo = mid + 1;
      }
      return lo;
    }
  };
}
function ascendingComparator(f2) {
  return function(d, x2) {
    return ascending$3(f2(d), x2);
  };
}
var ascendingBisect = bisector(ascending$3);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
function pairs(array2, f2) {
  if (f2 == null)
    f2 = pair;
  var i = 0, n = array2.length - 1, p = array2[0], pairs2 = new Array(n < 0 ? 0 : n);
  while (i < n)
    pairs2[i] = f2(p, p = array2[++i]);
  return pairs2;
}
function pair(a2, b) {
  return [a2, b];
}
function cross$3(values0, values1, reduce) {
  var n0 = values0.length, n1 = values1.length, values2 = new Array(n0 * n1), i0, i1, i, value0;
  if (reduce == null)
    reduce = pair;
  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values2[i] = reduce(value0, values1[i1]);
    }
  }
  return values2;
}
function descending$2(a2, b) {
  return b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
}
function number$3(x2) {
  return x2 === null ? NaN : +x2;
}
function variance(values2, valueof) {
  var n = values2.length, m = 0, i = -1, mean2 = 0, value, delta, sum2 = 0;
  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number$3(values2[i]))) {
        delta = value - mean2;
        mean2 += delta / ++m;
        sum2 += delta * (value - mean2);
      }
    }
  } else {
    while (++i < n) {
      if (!isNaN(value = number$3(valueof(values2[i], i, values2)))) {
        delta = value - mean2;
        mean2 += delta / ++m;
        sum2 += delta * (value - mean2);
      }
    }
  }
  if (m > 1)
    return sum2 / (m - 1);
}
function deviation(array2, f2) {
  var v = variance(array2, f2);
  return v ? Math.sqrt(v) : v;
}
function extent$1(values2, valueof) {
  var n = values2.length, i = -1, value, min2, max2;
  if (valueof == null) {
    while (++i < n) {
      if ((value = values2[i]) != null && value >= value) {
        min2 = max2 = value;
        while (++i < n) {
          if ((value = values2[i]) != null) {
            if (min2 > value)
              min2 = value;
            if (max2 < value)
              max2 = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      if ((value = valueof(values2[i], i, values2)) != null && value >= value) {
        min2 = max2 = value;
        while (++i < n) {
          if ((value = valueof(values2[i], i, values2)) != null) {
            if (min2 > value)
              min2 = value;
            if (max2 < value)
              max2 = value;
          }
        }
      }
    }
  }
  return [min2, max2];
}
var array$3 = Array.prototype;
var slice$6 = array$3.slice;
var map$3 = array$3.map;
function constant$d(x2) {
  return function() {
    return x2;
  };
}
function identity$9(x2) {
  return x2;
}
function sequence(start2, stop, step2) {
  start2 = +start2, stop = +stop, step2 = (n = arguments.length) < 2 ? (stop = start2, start2 = 0, 1) : n < 3 ? 1 : +step2;
  var i = -1, n = Math.max(0, Math.ceil((stop - start2) / step2)) | 0, range2 = new Array(n);
  while (++i < n) {
    range2[i] = start2 + i * step2;
  }
  return range2;
}
var e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
function ticks(start2, stop, count2) {
  var reverse2, i = -1, n, ticks2, step2;
  stop = +stop, start2 = +start2, count2 = +count2;
  if (start2 === stop && count2 > 0)
    return [start2];
  if (reverse2 = stop < start2)
    n = start2, start2 = stop, stop = n;
  if ((step2 = tickIncrement(start2, stop, count2)) === 0 || !isFinite(step2))
    return [];
  if (step2 > 0) {
    start2 = Math.ceil(start2 / step2);
    stop = Math.floor(stop / step2);
    ticks2 = new Array(n = Math.ceil(stop - start2 + 1));
    while (++i < n)
      ticks2[i] = (start2 + i) * step2;
  } else {
    start2 = Math.floor(start2 * step2);
    stop = Math.ceil(stop * step2);
    ticks2 = new Array(n = Math.ceil(start2 - stop + 1));
    while (++i < n)
      ticks2[i] = (start2 - i) / step2;
  }
  if (reverse2)
    ticks2.reverse();
  return ticks2;
}
function tickIncrement(start2, stop, count2) {
  var step2 = (stop - start2) / Math.max(0, count2), power = Math.floor(Math.log(step2) / Math.LN10), error = step2 / Math.pow(10, power);
  return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}
function tickStep(start2, stop, count2) {
  var step0 = Math.abs(stop - start2) / Math.max(0, count2), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
  if (error >= e10)
    step1 *= 10;
  else if (error >= e5)
    step1 *= 5;
  else if (error >= e2)
    step1 *= 2;
  return stop < start2 ? -step1 : step1;
}
function thresholdSturges(values2) {
  return Math.ceil(Math.log(values2.length) / Math.LN2) + 1;
}
function histogram() {
  var value = identity$9, domain = extent$1, threshold2 = thresholdSturges;
  function histogram2(data2) {
    var i, n = data2.length, x2, values2 = new Array(n);
    for (i = 0; i < n; ++i) {
      values2[i] = value(data2[i], i, data2);
    }
    var xz = domain(values2), x02 = xz[0], x12 = xz[1], tz = threshold2(values2, x02, x12);
    if (!Array.isArray(tz)) {
      tz = tickStep(x02, x12, tz);
      tz = sequence(Math.ceil(x02 / tz) * tz, x12, tz);
    }
    var m = tz.length;
    while (tz[0] <= x02)
      tz.shift(), --m;
    while (tz[m - 1] > x12)
      tz.pop(), --m;
    var bins = new Array(m + 1), bin;
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x02;
      bin.x1 = i < m ? tz[i] : x12;
    }
    for (i = 0; i < n; ++i) {
      x2 = values2[i];
      if (x02 <= x2 && x2 <= x12) {
        bins[bisectRight(tz, x2, 0, m)].push(data2[i]);
      }
    }
    return bins;
  }
  histogram2.value = function(_2) {
    return arguments.length ? (value = typeof _2 === "function" ? _2 : constant$d(_2), histogram2) : value;
  };
  histogram2.domain = function(_2) {
    return arguments.length ? (domain = typeof _2 === "function" ? _2 : constant$d([_2[0], _2[1]]), histogram2) : domain;
  };
  histogram2.thresholds = function(_2) {
    return arguments.length ? (threshold2 = typeof _2 === "function" ? _2 : Array.isArray(_2) ? constant$d(slice$6.call(_2)) : constant$d(_2), histogram2) : threshold2;
  };
  return histogram2;
}
function threshold$1(values2, p, valueof) {
  if (valueof == null)
    valueof = number$3;
  if (!(n = values2.length))
    return;
  if ((p = +p) <= 0 || n < 2)
    return +valueof(values2[0], 0, values2);
  if (p >= 1)
    return +valueof(values2[n - 1], n - 1, values2);
  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values2[i0], i0, values2), value1 = +valueof(values2[i0 + 1], i0 + 1, values2);
  return value0 + (value1 - value0) * (i - i0);
}
function freedmanDiaconis(values2, min2, max2) {
  values2 = map$3.call(values2, number$3).sort(ascending$3);
  return Math.ceil((max2 - min2) / (2 * (threshold$1(values2, 0.75) - threshold$1(values2, 0.25)) * Math.pow(values2.length, -1 / 3)));
}
function scott(values2, min2, max2) {
  return Math.ceil((max2 - min2) / (3.5 * deviation(values2) * Math.pow(values2.length, -1 / 3)));
}
function max$2(values2, valueof) {
  var n = values2.length, i = -1, value, max2;
  if (valueof == null) {
    while (++i < n) {
      if ((value = values2[i]) != null && value >= value) {
        max2 = value;
        while (++i < n) {
          if ((value = values2[i]) != null && value > max2) {
            max2 = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      if ((value = valueof(values2[i], i, values2)) != null && value >= value) {
        max2 = value;
        while (++i < n) {
          if ((value = valueof(values2[i], i, values2)) != null && value > max2) {
            max2 = value;
          }
        }
      }
    }
  }
  return max2;
}
function mean(values2, valueof) {
  var n = values2.length, m = n, i = -1, value, sum2 = 0;
  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number$3(values2[i])))
        sum2 += value;
      else
        --m;
    }
  } else {
    while (++i < n) {
      if (!isNaN(value = number$3(valueof(values2[i], i, values2))))
        sum2 += value;
      else
        --m;
    }
  }
  if (m)
    return sum2 / m;
}
function median(values2, valueof) {
  var n = values2.length, i = -1, value, numbers = [];
  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number$3(values2[i]))) {
        numbers.push(value);
      }
    }
  } else {
    while (++i < n) {
      if (!isNaN(value = number$3(valueof(values2[i], i, values2)))) {
        numbers.push(value);
      }
    }
  }
  return threshold$1(numbers.sort(ascending$3), 0.5);
}
function merge$1(arrays) {
  var n = arrays.length, m, i = -1, j2 = 0, merged, array2;
  while (++i < n)
    j2 += arrays[i].length;
  merged = new Array(j2);
  while (--n >= 0) {
    array2 = arrays[n];
    m = array2.length;
    while (--m >= 0) {
      merged[--j2] = array2[m];
    }
  }
  return merged;
}
function min$1(values2, valueof) {
  var n = values2.length, i = -1, value, min2;
  if (valueof == null) {
    while (++i < n) {
      if ((value = values2[i]) != null && value >= value) {
        min2 = value;
        while (++i < n) {
          if ((value = values2[i]) != null && min2 > value) {
            min2 = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      if ((value = valueof(values2[i], i, values2)) != null && value >= value) {
        min2 = value;
        while (++i < n) {
          if ((value = valueof(values2[i], i, values2)) != null && min2 > value) {
            min2 = value;
          }
        }
      }
    }
  }
  return min2;
}
function permute(array2, indexes) {
  var i = indexes.length, permutes = new Array(i);
  while (i--)
    permutes[i] = array2[indexes[i]];
  return permutes;
}
function scan(values2, compare2) {
  if (!(n = values2.length))
    return;
  var n, i = 0, j2 = 0, xi, xj = values2[j2];
  if (compare2 == null)
    compare2 = ascending$3;
  while (++i < n) {
    if (compare2(xi = values2[i], xj) < 0 || compare2(xj, xj) !== 0) {
      xj = xi, j2 = i;
    }
  }
  if (compare2(xj, xj) === 0)
    return j2;
}
function shuffle$1(array2, i0, i1) {
  var m = (i1 == null ? array2.length : i1) - (i0 = i0 == null ? 0 : +i0), t4, i;
  while (m) {
    i = Math.random() * m-- | 0;
    t4 = array2[m + i0];
    array2[m + i0] = array2[i + i0];
    array2[i + i0] = t4;
  }
  return array2;
}
function sum$2(values2, valueof) {
  var n = values2.length, i = -1, value, sum2 = 0;
  if (valueof == null) {
    while (++i < n) {
      if (value = +values2[i])
        sum2 += value;
    }
  } else {
    while (++i < n) {
      if (value = +valueof(values2[i], i, values2))
        sum2 += value;
    }
  }
  return sum2;
}
function transpose(matrix) {
  if (!(n = matrix.length))
    return [];
  for (var i = -1, m = min$1(matrix, length$2), transpose2 = new Array(m); ++i < m; ) {
    for (var j2 = -1, n, row = transpose2[i] = new Array(n); ++j2 < n; ) {
      row[j2] = matrix[j2][i];
    }
  }
  return transpose2;
}
function length$2(d) {
  return d.length;
}
function zip() {
  return transpose(arguments);
}
var slice$5 = Array.prototype.slice;
function identity$8(x2) {
  return x2;
}
var top = 1, right = 2, bottom = 3, left = 4, epsilon$4 = 1e-6;
function translateX(x2) {
  return "translate(" + (x2 + 0.5) + ",0)";
}
function translateY(y2) {
  return "translate(0," + (y2 + 0.5) + ")";
}
function number$2(scale) {
  return function(d) {
    return +scale(d);
  };
}
function center$1(scale) {
  var offset = Math.max(0, scale.bandwidth() - 1) / 2;
  if (scale.round())
    offset = Math.round(offset);
  return function(d) {
    return +scale(d) + offset;
  };
}
function entering() {
  return !this.__axis;
}
function axis(orient, scale) {
  var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, k2 = orient === top || orient === left ? -1 : 1, x2 = orient === left || orient === right ? "x" : "y", transform2 = orient === top || orient === bottom ? translateX : translateY;
  function axis2(context) {
    var values2 = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues, format2 = tickFormat2 == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$8 : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range2 = scale.range(), range0 = +range2[0] + 0.5, range1 = +range2[range2.length - 1] + 0.5, position2 = (scale.bandwidth ? center$1 : number$2)(scale.copy()), selection2 = context.selection ? context.selection() : context, path2 = selection2.selectAll(".domain").data([null]), tick = selection2.selectAll(".tick").data(values2, scale).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line2 = tick.select("line"), text2 = tick.select("text");
    path2 = path2.merge(path2.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
    tick = tick.merge(tickEnter);
    line2 = line2.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x2 + "2", k2 * tickSizeInner));
    text2 = text2.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x2, k2 * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
    if (context !== selection2) {
      path2 = path2.transition(context);
      tick = tick.transition(context);
      line2 = line2.transition(context);
      text2 = text2.transition(context);
      tickExit = tickExit.transition(context).attr("opacity", epsilon$4).attr("transform", function(d) {
        return isFinite(d = position2(d)) ? transform2(d) : this.getAttribute("transform");
      });
      tickEnter.attr("opacity", epsilon$4).attr("transform", function(d) {
        var p = this.parentNode.__axis;
        return transform2(p && isFinite(p = p(d)) ? p : position2(d));
      });
    }
    tickExit.remove();
    path2.attr("d", orient === left || orient == right ? tickSizeOuter ? "M" + k2 * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k2 * tickSizeOuter : "M0.5," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k2 * tickSizeOuter + "V0.5H" + range1 + "V" + k2 * tickSizeOuter : "M" + range0 + ",0.5H" + range1);
    tick.attr("opacity", 1).attr("transform", function(d) {
      return transform2(position2(d));
    });
    line2.attr(x2 + "2", k2 * tickSizeInner);
    text2.attr(x2, k2 * spacing).text(format2);
    selection2.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
    selection2.each(function() {
      this.__axis = position2;
    });
  }
  axis2.scale = function(_2) {
    return arguments.length ? (scale = _2, axis2) : scale;
  };
  axis2.ticks = function() {
    return tickArguments = slice$5.call(arguments), axis2;
  };
  axis2.tickArguments = function(_2) {
    return arguments.length ? (tickArguments = _2 == null ? [] : slice$5.call(_2), axis2) : tickArguments.slice();
  };
  axis2.tickValues = function(_2) {
    return arguments.length ? (tickValues = _2 == null ? null : slice$5.call(_2), axis2) : tickValues && tickValues.slice();
  };
  axis2.tickFormat = function(_2) {
    return arguments.length ? (tickFormat2 = _2, axis2) : tickFormat2;
  };
  axis2.tickSize = function(_2) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_2, axis2) : tickSizeInner;
  };
  axis2.tickSizeInner = function(_2) {
    return arguments.length ? (tickSizeInner = +_2, axis2) : tickSizeInner;
  };
  axis2.tickSizeOuter = function(_2) {
    return arguments.length ? (tickSizeOuter = +_2, axis2) : tickSizeOuter;
  };
  axis2.tickPadding = function(_2) {
    return arguments.length ? (tickPadding = +_2, axis2) : tickPadding;
  };
  return axis2;
}
function axisTop(scale) {
  return axis(top, scale);
}
function axisRight(scale) {
  return axis(right, scale);
}
function axisBottom(scale) {
  return axis(bottom, scale);
}
function axisLeft(scale) {
  return axis(left, scale);
}
var noop$3 = { value: function() {
} };
function dispatch() {
  for (var i = 0, n = arguments.length, _2 = {}, t4; i < n; ++i) {
    if (!(t4 = arguments[i] + "") || t4 in _2 || /[\s.]/.test(t4))
      throw new Error("illegal type: " + t4);
    _2[t4] = [];
  }
  return new Dispatch(_2);
}
function Dispatch(_2) {
  this._ = _2;
}
function parseTypenames$1(typenames, types2) {
  return typenames.trim().split(/^|\s+/).map(function(t4) {
    var name2 = "", i = t4.indexOf(".");
    if (i >= 0)
      name2 = t4.slice(i + 1), t4 = t4.slice(0, i);
    if (t4 && !types2.hasOwnProperty(t4))
      throw new Error("unknown type: " + t4);
    return { type: t4, name: name2 };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _2 = this._, T = parseTypenames$1(typename + "", _2), t4, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n)
        if ((t4 = (typename = T[i]).type) && (t4 = get$1(_2[t4], typename.name)))
          return t4;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t4 = (typename = T[i]).type)
        _2[t4] = set$2(_2[t4], typename.name, callback);
      else if (callback == null)
        for (t4 in _2)
          _2[t4] = set$2(_2[t4], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy2 = {}, _2 = this._;
    for (var t4 in _2)
      copy2[t4] = _2[t4].slice();
    return new Dispatch(copy2);
  },
  call: function(type2, that) {
    if ((n = arguments.length - 2) > 0)
      for (var args = new Array(n), i = 0, n, t4; i < n; ++i)
        args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (t4 = this._[type2], i = 0, n = t4.length; i < n; ++i)
      t4[i].value.apply(that, args);
  },
  apply: function(type2, that, args) {
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (var t4 = this._[type2], i = 0, n = t4.length; i < n; ++i)
      t4[i].value.apply(that, args);
  }
};
function get$1(type2, name2) {
  for (var i = 0, n = type2.length, c2; i < n; ++i) {
    if ((c2 = type2[i]).name === name2) {
      return c2.value;
    }
  }
}
function set$2(type2, name2, callback) {
  for (var i = 0, n = type2.length; i < n; ++i) {
    if (type2[i].name === name2) {
      type2[i] = noop$3, type2 = type2.slice(0, i).concat(type2.slice(i + 1));
      break;
    }
  }
  if (callback != null)
    type2.push({ name: name2, value: callback });
  return type2;
}
var xhtml = "http://www.w3.org/1999/xhtml";
const namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function namespace(name2) {
  var prefix2 = name2 += "", i = prefix2.indexOf(":");
  if (i >= 0 && (prefix2 = name2.slice(0, i)) !== "xmlns")
    name2 = name2.slice(i + 1);
  return namespaces.hasOwnProperty(prefix2) ? { space: namespaces[prefix2], local: name2 } : name2;
}
function creatorInherit(name2) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name2) : document2.createElementNS(uri, name2);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator(name2) {
  var fullname = namespace(name2);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}
function none$2() {
}
function selector(selector2) {
  return selector2 == null ? none$2 : function() {
    return this.querySelector(selector2);
  };
}
function selection_select(select2) {
  if (typeof select2 !== "function")
    select2 = selector(select2);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j2 = 0; j2 < m; ++j2) {
    for (var group = groups[j2], n = group.length, subgroup = subgroups[j2] = new Array(n), node2, subnode, i = 0; i < n; ++i) {
      if ((node2 = group[i]) && (subnode = select2.call(node2, node2.__data__, i, group))) {
        if ("__data__" in node2)
          subnode.__data__ = node2.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection$1(subgroups, this._parents);
}
function empty$1() {
  return [];
}
function selectorAll(selector2) {
  return selector2 == null ? empty$1 : function() {
    return this.querySelectorAll(selector2);
  };
}
function selection_selectAll(select2) {
  if (typeof select2 !== "function")
    select2 = selectorAll(select2);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents2 = [], j2 = 0; j2 < m; ++j2) {
    for (var group = groups[j2], n = group.length, node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        subgroups.push(select2.call(node2, node2.__data__, i, group));
        parents2.push(node2);
      }
    }
  }
  return new Selection$1(subgroups, parents2);
}
function matcher(selector2) {
  return function() {
    return this.matches(selector2);
  };
}
function selection_filter(match) {
  if (typeof match !== "function")
    match = matcher(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j2 = 0; j2 < m; ++j2) {
    for (var group = groups[j2], n = group.length, subgroup = subgroups[j2] = [], node2, i = 0; i < n; ++i) {
      if ((node2 = group[i]) && match.call(node2, node2.__data__, i, group)) {
        subgroup.push(node2);
      }
    }
  }
  return new Selection$1(subgroups, this._parents);
}
function sparse(update) {
  return new Array(update.length);
}
function selection_enter() {
  return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
}
function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next2) {
    return this._parent.insertBefore(child, next2);
  },
  querySelector: function(selector2) {
    return this._parent.querySelector(selector2);
  },
  querySelectorAll: function(selector2) {
    return this._parent.querySelectorAll(selector2);
  }
};
function constant$c(x2) {
  return function() {
    return x2;
  };
}
var keyPrefix$1 = "$";
function bindIndex(parent, group, enter, update, exit, data2) {
  var i = 0, node2, groupLength = group.length, dataLength = data2.length;
  for (; i < dataLength; ++i) {
    if (node2 = group[i]) {
      node2.__data__ = data2[i];
      update[i] = node2;
    } else {
      enter[i] = new EnterNode(parent, data2[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node2 = group[i]) {
      exit[i] = node2;
    }
  }
}
function bindKey(parent, group, enter, update, exit, data2, key) {
  var i, node2, nodeByKeyValue = {}, groupLength = group.length, dataLength = data2.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node2 = group[i]) {
      keyValues[i] = keyValue = keyPrefix$1 + key.call(node2, node2.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node2;
      } else {
        nodeByKeyValue[keyValue] = node2;
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix$1 + key.call(parent, data2[i], i, data2);
    if (node2 = nodeByKeyValue[keyValue]) {
      update[i] = node2;
      node2.__data__ = data2[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new EnterNode(parent, data2[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node2 = group[i]) && nodeByKeyValue[keyValues[i]] === node2) {
      exit[i] = node2;
    }
  }
}
function selection_data(value, key) {
  if (!value) {
    data2 = new Array(this.size()), j2 = -1;
    this.each(function(d) {
      data2[++j2] = d;
    });
    return data2;
  }
  var bind = key ? bindKey : bindIndex, parents2 = this._parents, groups = this._groups;
  if (typeof value !== "function")
    value = constant$c(value);
  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j2 = 0; j2 < m; ++j2) {
    var parent = parents2[j2], group = groups[j2], groupLength = group.length, data2 = value.call(parent, parent && parent.__data__, j2, parents2), dataLength = data2.length, enterGroup = enter[j2] = new Array(dataLength), updateGroup = update[j2] = new Array(dataLength), exitGroup = exit[j2] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data2, key);
    for (var i0 = 0, i1 = 0, previous, next2; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1)
          i1 = i0 + 1;
        while (!(next2 = updateGroup[i1]) && ++i1 < dataLength)
          ;
        previous._next = next2 || null;
      }
    }
  }
  update = new Selection$1(update, parents2);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function selection_exit() {
  return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
}
function selection_join(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
  if (onupdate != null)
    update = onupdate(update);
  if (onexit == null)
    exit.remove();
  else
    onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}
function selection_merge(selection2) {
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j2 = 0; j2 < m; ++j2) {
    for (var group0 = groups0[j2], group1 = groups1[j2], n = group0.length, merge2 = merges[j2] = new Array(n), node2, i = 0; i < n; ++i) {
      if (node2 = group0[i] || group1[i]) {
        merge2[i] = node2;
      }
    }
  }
  for (; j2 < m0; ++j2) {
    merges[j2] = groups0[j2];
  }
  return new Selection$1(merges, this._parents);
}
function selection_order() {
  for (var groups = this._groups, j2 = -1, m = groups.length; ++j2 < m; ) {
    for (var group = groups[j2], i = group.length - 1, next2 = group[i], node2; --i >= 0; ) {
      if (node2 = group[i]) {
        if (next2 && node2.compareDocumentPosition(next2) ^ 4)
          next2.parentNode.insertBefore(node2, next2);
        next2 = node2;
      }
    }
  }
  return this;
}
function selection_sort(compare2) {
  if (!compare2)
    compare2 = ascending$2;
  function compareNode(a2, b) {
    return a2 && b ? compare2(a2.__data__, b.__data__) : !a2 - !b;
  }
  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j2 = 0; j2 < m; ++j2) {
    for (var group = groups[j2], n = group.length, sortgroup = sortgroups[j2] = new Array(n), node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        sortgroup[i] = node2;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection$1(sortgroups, this._parents).order();
}
function ascending$2(a2, b) {
  return a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
}
function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}
function selection_nodes() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() {
    nodes[++i] = this;
  });
  return nodes;
}
function selection_node() {
  for (var groups = this._groups, j2 = 0, m = groups.length; j2 < m; ++j2) {
    for (var group = groups[j2], i = 0, n = group.length; i < n; ++i) {
      var node2 = group[i];
      if (node2)
        return node2;
    }
  }
  return null;
}
function selection_size() {
  var size = 0;
  this.each(function() {
    ++size;
  });
  return size;
}
function selection_empty() {
  return !this.node();
}
function selection_each(callback) {
  for (var groups = this._groups, j2 = 0, m = groups.length; j2 < m; ++j2) {
    for (var group = groups[j2], i = 0, n = group.length, node2; i < n; ++i) {
      if (node2 = group[i])
        callback.call(node2, node2.__data__, i, group);
    }
  }
  return this;
}
function attrRemove$1(name2) {
  return function() {
    this.removeAttribute(name2);
  };
}
function attrRemoveNS$1(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant$1(name2, value) {
  return function() {
    this.setAttribute(name2, value);
  };
}
function attrConstantNS$1(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction$1(name2, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.removeAttribute(name2);
    else
      this.setAttribute(name2, v);
  };
}
function attrFunctionNS$1(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.removeAttributeNS(fullname.space, fullname.local);
    else
      this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function selection_attr(name2, value) {
  var fullname = namespace(name2);
  if (arguments.length < 2) {
    var node2 = this.node();
    return fullname.local ? node2.getAttributeNS(fullname.space, fullname.local) : node2.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS$1 : attrRemove$1 : typeof value === "function" ? fullname.local ? attrFunctionNS$1 : attrFunction$1 : fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, value));
}
function defaultView(node2) {
  return node2.ownerDocument && node2.ownerDocument.defaultView || node2.document && node2 || node2.defaultView;
}
function styleRemove$1(name2) {
  return function() {
    this.style.removeProperty(name2);
  };
}
function styleConstant$1(name2, value, priority) {
  return function() {
    this.style.setProperty(name2, value, priority);
  };
}
function styleFunction$1(name2, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.style.removeProperty(name2);
    else
      this.style.setProperty(name2, v, priority);
  };
}
function selection_style(name2, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove$1 : typeof value === "function" ? styleFunction$1 : styleConstant$1)(name2, value, priority == null ? "" : priority)) : styleValue(this.node(), name2);
}
function styleValue(node2, name2) {
  return node2.style.getPropertyValue(name2) || defaultView(node2).getComputedStyle(node2, null).getPropertyValue(name2);
}
function propertyRemove(name2) {
  return function() {
    delete this[name2];
  };
}
function propertyConstant(name2, value) {
  return function() {
    this[name2] = value;
  };
}
function propertyFunction(name2, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      delete this[name2];
    else
      this[name2] = v;
  };
}
function selection_property(name2, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name2, value)) : this.node()[name2];
}
function classArray(string2) {
  return string2.trim().split(/^|\s+/);
}
function classList(node2) {
  return node2.classList || new ClassList(node2);
}
function ClassList(node2) {
  this._node = node2;
  this._names = classArray(node2.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name2) {
    var i = this._names.indexOf(name2);
    if (i < 0) {
      this._names.push(name2);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name2) {
    var i = this._names.indexOf(name2);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name2) {
    return this._names.indexOf(name2) >= 0;
  }
};
function classedAdd(node2, names) {
  var list2 = classList(node2), i = -1, n = names.length;
  while (++i < n)
    list2.add(names[i]);
}
function classedRemove(node2, names) {
  var list2 = classList(node2), i = -1, n = names.length;
  while (++i < n)
    list2.remove(names[i]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function selection_classed(name2, value) {
  var names = classArray(name2 + "");
  if (arguments.length < 2) {
    var list2 = classList(this.node()), i = -1, n = names.length;
    while (++i < n)
      if (!list2.contains(names[i]))
        return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}
function textRemove() {
  this.textContent = "";
}
function textConstant$1(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction$1(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}
function selection_text(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction$1 : textConstant$1)(value)) : this.node().textContent;
}
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}
function selection_html(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}
function raise() {
  if (this.nextSibling)
    this.parentNode.appendChild(this);
}
function selection_raise() {
  return this.each(raise);
}
function lower() {
  if (this.previousSibling)
    this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function selection_lower() {
  return this.each(lower);
}
function selection_append(name2) {
  var create2 = typeof name2 === "function" ? name2 : creator(name2);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}
function constantNull() {
  return null;
}
function selection_insert(name2, before) {
  var create2 = typeof name2 === "function" ? name2 : creator(name2), select2 = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select2.apply(this, arguments) || null);
  });
}
function remove() {
  var parent = this.parentNode;
  if (parent)
    parent.removeChild(this);
}
function selection_remove() {
  return this.each(remove);
}
function selection_cloneShallow() {
  var clone2 = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
}
function selection_cloneDeep() {
  var clone2 = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
}
function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}
function selection_datum(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}
var filterEvents = {};
var event = null;
if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!("onmouseenter" in element)) {
    filterEvents = { mouseenter: "mouseover", mouseleave: "mouseout" };
  }
}
function filterContextListener(listener, index2, group) {
  listener = contextListener(listener, index2, group);
  return function(event2) {
    var related = event2.relatedTarget;
    if (!related || related !== this && !(related.compareDocumentPosition(this) & 8)) {
      listener.call(this, event2);
    }
  };
}
function contextListener(listener, index2, group) {
  return function(event1) {
    var event0 = event;
    event = event1;
    try {
      listener.call(this, this.__data__, index2, group);
    } finally {
      event = event0;
    }
  };
}
function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t4) {
    var name2 = "", i = t4.indexOf(".");
    if (i >= 0)
      name2 = t4.slice(i + 1), t4 = t4.slice(0, i);
    return { type: t4, name: name2 };
  });
}
function onRemove(typename) {
  return function() {
    var on2 = this.__on;
    if (!on2)
      return;
    for (var j2 = 0, i = -1, m = on2.length, o; j2 < m; ++j2) {
      if (o = on2[j2], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on2[++i] = o;
      }
    }
    if (++i)
      on2.length = i;
    else
      delete this.__on;
  };
}
function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on2 = this.__on, o, listener = wrap(value, i, group);
    if (on2)
      for (var j2 = 0, m = on2.length; j2 < m; ++j2) {
        if ((o = on2[j2]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.capture);
          this.addEventListener(o.type, o.listener = listener, o.capture = capture);
          o.value = value;
          return;
        }
      }
    this.addEventListener(typename.type, listener, capture);
    o = { type: typename.type, name: typename.name, value, listener, capture };
    if (!on2)
      this.__on = [o];
    else
      on2.push(o);
  };
}
function selection_on(typename, value, capture) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t4;
  if (arguments.length < 2) {
    var on2 = this.node().__on;
    if (on2)
      for (var j2 = 0, m = on2.length, o; j2 < m; ++j2) {
        for (i = 0, o = on2[j2]; i < n; ++i) {
          if ((t4 = typenames[i]).type === o.type && t4.name === o.name) {
            return o.value;
          }
        }
      }
    return;
  }
  on2 = value ? onAdd : onRemove;
  if (capture == null)
    capture = false;
  for (i = 0; i < n; ++i)
    this.each(on2(typenames[i], value, capture));
  return this;
}
function customEvent(event1, listener, that, args) {
  var event0 = event;
  event1.sourceEvent = event;
  event = event1;
  try {
    return listener.apply(that, args);
  } finally {
    event = event0;
  }
}
function dispatchEvent(node2, type2, params) {
  var window2 = defaultView(node2), event2 = window2.CustomEvent;
  if (typeof event2 === "function") {
    event2 = new event2(type2, params);
  } else {
    event2 = window2.document.createEvent("Event");
    if (params)
      event2.initEvent(type2, params.bubbles, params.cancelable), event2.detail = params.detail;
    else
      event2.initEvent(type2, false, false);
  }
  node2.dispatchEvent(event2);
}
function dispatchConstant(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params);
  };
}
function dispatchFunction(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params.apply(this, arguments));
  };
}
function selection_dispatch(type2, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
}
var root$4 = [null];
function Selection$1(groups, parents2) {
  this._groups = groups;
  this._parents = parents2;
}
function selection() {
  return new Selection$1([[document.documentElement]], root$4);
}
Selection$1.prototype = selection.prototype = {
  constructor: Selection$1,
  select: selection_select,
  selectAll: selection_selectAll,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: selection_join,
  merge: selection_merge,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch
};
function select(selector2) {
  return typeof selector2 === "string" ? new Selection$1([[document.querySelector(selector2)]], [document.documentElement]) : new Selection$1([[selector2]], root$4);
}
function create$1(name2) {
  return select(creator(name2).call(document.documentElement));
}
var nextId = 0;
function local$1() {
  return new Local();
}
function Local() {
  this._ = "@" + (++nextId).toString(36);
}
Local.prototype = local$1.prototype = {
  constructor: Local,
  get: function(node2) {
    var id2 = this._;
    while (!(id2 in node2))
      if (!(node2 = node2.parentNode))
        return;
    return node2[id2];
  },
  set: function(node2, value) {
    return node2[this._] = value;
  },
  remove: function(node2) {
    return this._ in node2 && delete node2[this._];
  },
  toString: function() {
    return this._;
  }
};
function sourceEvent() {
  var current = event, source;
  while (source = current.sourceEvent)
    current = source;
  return current;
}
function point$6(node2, event2) {
  var svg2 = node2.ownerSVGElement || node2;
  if (svg2.createSVGPoint) {
    var point2 = svg2.createSVGPoint();
    point2.x = event2.clientX, point2.y = event2.clientY;
    point2 = point2.matrixTransform(node2.getScreenCTM().inverse());
    return [point2.x, point2.y];
  }
  var rect2 = node2.getBoundingClientRect();
  return [event2.clientX - rect2.left - node2.clientLeft, event2.clientY - rect2.top - node2.clientTop];
}
function mouse(node2) {
  var event2 = sourceEvent();
  if (event2.changedTouches)
    event2 = event2.changedTouches[0];
  return point$6(node2, event2);
}
function selectAll(selector2) {
  return typeof selector2 === "string" ? new Selection$1([document.querySelectorAll(selector2)], [document.documentElement]) : new Selection$1([selector2 == null ? [] : selector2], root$4);
}
function touch(node2, touches2, identifier2) {
  if (arguments.length < 3)
    identifier2 = touches2, touches2 = sourceEvent().changedTouches;
  for (var i = 0, n = touches2 ? touches2.length : 0, touch2; i < n; ++i) {
    if ((touch2 = touches2[i]).identifier === identifier2) {
      return point$6(node2, touch2);
    }
  }
  return null;
}
function touches(node2, touches2) {
  if (touches2 == null)
    touches2 = sourceEvent().touches;
  for (var i = 0, n = touches2 ? touches2.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = point$6(node2, touches2[i]);
  }
  return points;
}
function nopropagation$2() {
  event.stopImmediatePropagation();
}
function noevent$2() {
  event.preventDefault();
  event.stopImmediatePropagation();
}
function dragDisable(view) {
  var root2 = view.document.documentElement, selection2 = select(view).on("dragstart.drag", noevent$2, true);
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", noevent$2, true);
  } else {
    root2.__noselect = root2.style.MozUserSelect;
    root2.style.MozUserSelect = "none";
  }
}
function yesdrag(view, noclick) {
  var root2 = view.document.documentElement, selection2 = select(view).on("dragstart.drag", null);
  if (noclick) {
    selection2.on("click.drag", noevent$2, true);
    setTimeout(function() {
      selection2.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", null);
  } else {
    root2.style.MozUserSelect = root2.__noselect;
    delete root2.__noselect;
  }
}
function constant$b(x2) {
  return function() {
    return x2;
  };
}
function DragEvent(target, type2, subject, id2, active2, x2, y2, dx, dy, dispatch2) {
  this.target = target;
  this.type = type2;
  this.subject = subject;
  this.identifier = id2;
  this.active = active2;
  this.x = x2;
  this.y = y2;
  this.dx = dx;
  this.dy = dy;
  this._ = dispatch2;
}
DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};
function defaultFilter$2() {
  return !event.ctrlKey && !event.button;
}
function defaultContainer() {
  return this.parentNode;
}
function defaultSubject(d) {
  return d == null ? { x: event.x, y: event.y } : d;
}
function defaultTouchable$2() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function drag() {
  var filter = defaultFilter$2, container = defaultContainer, subject = defaultSubject, touchable = defaultTouchable$2, gestures = {}, listeners = dispatch("start", "drag", "end"), active2 = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
  function drag2(selection2) {
    selection2.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function mousedowned() {
    if (touchending || !filter.apply(this, arguments))
      return;
    var gesture = beforestart("mouse", container.apply(this, arguments), mouse, this, arguments);
    if (!gesture)
      return;
    select(event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
    dragDisable(event.view);
    nopropagation$2();
    mousemoving = false;
    mousedownx = event.clientX;
    mousedowny = event.clientY;
    gesture("start");
  }
  function mousemoved() {
    noevent$2();
    if (!mousemoving) {
      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag");
  }
  function mouseupped() {
    select(event.view).on("mousemove.drag mouseup.drag", null);
    yesdrag(event.view, mousemoving);
    noevent$2();
    gestures.mouse("end");
  }
  function touchstarted() {
    if (!filter.apply(this, arguments))
      return;
    var touches2 = event.changedTouches, c2 = container.apply(this, arguments), n = touches2.length, i, gesture;
    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(touches2[i].identifier, c2, touch, this, arguments)) {
        nopropagation$2();
        gesture("start");
      }
    }
  }
  function touchmoved() {
    var touches2 = event.changedTouches, n = touches2.length, i, gesture;
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches2[i].identifier]) {
        noevent$2();
        gesture("drag");
      }
    }
  }
  function touchended() {
    var touches2 = event.changedTouches, n = touches2.length, i, gesture;
    if (touchending)
      clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, 500);
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches2[i].identifier]) {
        nopropagation$2();
        gesture("end");
      }
    }
  }
  function beforestart(id2, container2, point2, that, args) {
    var p = point2(container2, id2), s2, dx, dy, sublisteners = listeners.copy();
    if (!customEvent(new DragEvent(drag2, "beforestart", s2, id2, active2, p[0], p[1], 0, 0, sublisteners), function() {
      if ((event.subject = s2 = subject.apply(that, args)) == null)
        return false;
      dx = s2.x - p[0] || 0;
      dy = s2.y - p[1] || 0;
      return true;
    }))
      return;
    return function gesture(type2) {
      var p02 = p, n;
      switch (type2) {
        case "start":
          gestures[id2] = gesture, n = active2++;
          break;
        case "end":
          delete gestures[id2], --active2;
        case "drag":
          p = point2(container2, id2), n = active2;
          break;
      }
      customEvent(new DragEvent(drag2, type2, s2, id2, n, p[0] + dx, p[1] + dy, p[0] - p02[0], p[1] - p02[1], sublisteners), sublisteners.apply, sublisteners, [type2, that, args]);
    };
  }
  drag2.filter = function(_2) {
    return arguments.length ? (filter = typeof _2 === "function" ? _2 : constant$b(!!_2), drag2) : filter;
  };
  drag2.container = function(_2) {
    return arguments.length ? (container = typeof _2 === "function" ? _2 : constant$b(_2), drag2) : container;
  };
  drag2.subject = function(_2) {
    return arguments.length ? (subject = typeof _2 === "function" ? _2 : constant$b(_2), drag2) : subject;
  };
  drag2.touchable = function(_2) {
    return arguments.length ? (touchable = typeof _2 === "function" ? _2 : constant$b(!!_2), drag2) : touchable;
  };
  drag2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag2 : value;
  };
  drag2.clickDistance = function(_2) {
    return arguments.length ? (clickDistance2 = (_2 = +_2) * _2, drag2) : Math.sqrt(clickDistance2);
  };
  return drag2;
}
function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"), reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"), reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"), reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"), reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"), reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define(Color, color, {
  copy: function(channels2) {
    return Object.assign(new this.constructor(), this, channels2);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m, l2;
  format2 = (format2 + "").trim().toLowerCase();
  return (m = reHex.exec(format2)) ? (l2 = m[1].length, m = parseInt(m[1], 16), l2 === 6 ? rgbn(m) : l2 === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l2 === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l2 === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g2, b, a2) {
  if (a2 <= 0)
    r = g2 = b = NaN;
  return new Rgb(r, g2, b, a2);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g2, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g2, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g2, b, opacity) {
  this.r = +r;
  this.g = +g2;
  this.b = +b;
  this.opacity = +opacity;
}
define(Rgb, rgb, extend(Color, {
  brighter: function(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  darker: function(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}
function rgb_formatRgb() {
  var a2 = this.opacity;
  a2 = isNaN(a2) ? 1 : Math.max(0, Math.min(1, a2));
  return (a2 === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a2 === 1 ? ")" : ", " + a2 + ")");
}
function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h2, s2, l2, a2) {
  if (a2 <= 0)
    h2 = s2 = l2 = NaN;
  else if (l2 <= 0 || l2 >= 1)
    h2 = s2 = NaN;
  else if (s2 <= 0)
    h2 = NaN;
  return new Hsl(h2, s2, l2, a2);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g2 = o.g / 255, b = o.b / 255, min2 = Math.min(r, g2, b), max2 = Math.max(r, g2, b), h2 = NaN, s2 = max2 - min2, l2 = (max2 + min2) / 2;
  if (s2) {
    if (r === max2)
      h2 = (g2 - b) / s2 + (g2 < b) * 6;
    else if (g2 === max2)
      h2 = (b - r) / s2 + 2;
    else
      h2 = (r - g2) / s2 + 4;
    s2 /= l2 < 0.5 ? max2 + min2 : 2 - max2 - min2;
    h2 *= 60;
  } else {
    s2 = l2 > 0 && l2 < 1 ? 0 : h2;
  }
  return new Hsl(h2, s2, l2, o.opacity);
}
function hsl$2(h2, s2, l2, opacity) {
  return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s2, l2, opacity == null ? 1 : opacity);
}
function Hsl(h2, s2, l2, opacity) {
  this.h = +h2;
  this.s = +s2;
  this.l = +l2;
  this.opacity = +opacity;
}
define(Hsl, hsl$2, extend(Color, {
  brighter: function(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  darker: function(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb: function() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l2 = this.l, m2 = l2 + (l2 < 0.5 ? l2 : 1 - l2) * s2, m1 = 2 * l2 - m2;
    return new Rgb(
      hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2),
      hsl2rgb(h2, m1, m2),
      hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a2 = this.opacity;
    a2 = isNaN(a2) ? 1 : Math.max(0, Math.min(1, a2));
    return (a2 === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a2 === 1 ? ")" : ", " + a2 + ")");
  }
}));
function hsl2rgb(h2, m1, m2) {
  return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
}
var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;
var K = 18, Xn = 0.96422, Yn = 1, Zn = 0.82521, t0$1 = 4 / 29, t1$1 = 6 / 29, t2 = 3 * t1$1 * t1$1, t3 = t1$1 * t1$1 * t1$1;
function labConvert(o) {
  if (o instanceof Lab)
    return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl)
    return hcl2lab(o);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = rgb2lrgb(o.r), g2 = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y2 = xyz2lab((0.2225045 * r + 0.7168786 * g2 + 0.0606169 * b) / Yn), x2, z;
  if (r === g2 && g2 === b)
    x2 = z = y2;
  else {
    x2 = xyz2lab((0.4360747 * r + 0.3850649 * g2 + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g2 + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y2 - 16, 500 * (x2 - y2), 200 * (y2 - z), o.opacity);
}
function gray(l2, opacity) {
  return new Lab(l2, 0, 0, opacity == null ? 1 : opacity);
}
function lab$1(l2, a2, b, opacity) {
  return arguments.length === 1 ? labConvert(l2) : new Lab(l2, a2, b, opacity == null ? 1 : opacity);
}
function Lab(l2, a2, b, opacity) {
  this.l = +l2;
  this.a = +a2;
  this.b = +b;
  this.opacity = +opacity;
}
define(Lab, lab$1, extend(Color, {
  brighter: function(k2) {
    return new Lab(this.l + K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  darker: function(k2) {
    return new Lab(this.l - K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y2 = (this.l + 16) / 116, x2 = isNaN(this.a) ? y2 : y2 + this.a / 500, z = isNaN(this.b) ? y2 : y2 - this.b / 200;
    x2 = Xn * lab2xyz(x2);
    y2 = Yn * lab2xyz(y2);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb(3.1338561 * x2 - 1.6168667 * y2 - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x2 + 1.9161415 * y2 + 0.033454 * z),
      lrgb2rgb(0.0719453 * x2 - 0.2289914 * y2 + 1.4052427 * z),
      this.opacity
    );
  }
}));
function xyz2lab(t4) {
  return t4 > t3 ? Math.pow(t4, 1 / 3) : t4 / t2 + t0$1;
}
function lab2xyz(t4) {
  return t4 > t1$1 ? t4 * t4 * t4 : t2 * (t4 - t0$1);
}
function lrgb2rgb(x2) {
  return 255 * (x2 <= 31308e-7 ? 12.92 * x2 : 1.055 * Math.pow(x2, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x2) {
  return (x2 /= 255) <= 0.04045 ? x2 / 12.92 : Math.pow((x2 + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl)
    return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab))
    o = labConvert(o);
  if (o.a === 0 && o.b === 0)
    return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h2 = Math.atan2(o.b, o.a) * rad2deg;
  return new Hcl(h2 < 0 ? h2 + 360 : h2, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function lch(l2, c2, h2, opacity) {
  return arguments.length === 1 ? hclConvert(l2) : new Hcl(h2, c2, l2, opacity == null ? 1 : opacity);
}
function hcl$2(h2, c2, l2, opacity) {
  return arguments.length === 1 ? hclConvert(h2) : new Hcl(h2, c2, l2, opacity == null ? 1 : opacity);
}
function Hcl(h2, c2, l2, opacity) {
  this.h = +h2;
  this.c = +c2;
  this.l = +l2;
  this.opacity = +opacity;
}
function hcl2lab(o) {
  if (isNaN(o.h))
    return new Lab(o.l, 0, 0, o.opacity);
  var h2 = o.h * deg2rad;
  return new Lab(o.l, Math.cos(h2) * o.c, Math.sin(h2) * o.c, o.opacity);
}
define(Hcl, hcl$2, extend(Color, {
  brighter: function(k2) {
    return new Hcl(this.h, this.c, this.l + K * (k2 == null ? 1 : k2), this.opacity);
  },
  darker: function(k2) {
    return new Hcl(this.h, this.c, this.l - K * (k2 == null ? 1 : k2), this.opacity);
  },
  rgb: function() {
    return hcl2lab(this).rgb();
  }
}));
var A = -0.14861, B = 1.78277, C = -0.29227, D = -0.90649, E = 1.97294, ED = E * D, EB = E * B, BC_DA = B * C - D * A;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix)
    return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = o.r / 255, g2 = o.g / 255, b = o.b / 255, l2 = (BC_DA * b + ED * r - EB * g2) / (BC_DA + ED - EB), bl = b - l2, k2 = (E * (g2 - l2) - C * bl) / D, s2 = Math.sqrt(k2 * k2 + bl * bl) / (E * l2 * (1 - l2)), h2 = s2 ? Math.atan2(k2, bl) * rad2deg - 120 : NaN;
  return new Cubehelix(h2 < 0 ? h2 + 360 : h2, s2, l2, o.opacity);
}
function cubehelix$3(h2, s2, l2, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h2) : new Cubehelix(h2, s2, l2, opacity == null ? 1 : opacity);
}
function Cubehelix(h2, s2, l2, opacity) {
  this.h = +h2;
  this.s = +s2;
  this.l = +l2;
  this.opacity = +opacity;
}
define(Cubehelix, cubehelix$3, extend(Color, {
  brighter: function(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
  },
  darker: function(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb: function() {
    var h2 = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad, l2 = +this.l, a2 = isNaN(this.s) ? 0 : this.s * l2 * (1 - l2), cosh2 = Math.cos(h2), sinh2 = Math.sin(h2);
    return new Rgb(
      255 * (l2 + a2 * (A * cosh2 + B * sinh2)),
      255 * (l2 + a2 * (C * cosh2 + D * sinh2)),
      255 * (l2 + a2 * (E * cosh2)),
      this.opacity
    );
  }
}));
function basis$1(t12, v0, v1, v2, v3) {
  var t22 = t12 * t12, t32 = t22 * t12;
  return ((1 - 3 * t12 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t12 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
}
function basis$2(values2) {
  var n = values2.length - 1;
  return function(t4) {
    var i = t4 <= 0 ? t4 = 0 : t4 >= 1 ? (t4 = 1, n - 1) : Math.floor(t4 * n), v1 = values2[i], v2 = values2[i + 1], v0 = i > 0 ? values2[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values2[i + 2] : 2 * v2 - v1;
    return basis$1((t4 - i / n) * n, v0, v1, v2, v3);
  };
}
function basisClosed$1(values2) {
  var n = values2.length;
  return function(t4) {
    var i = Math.floor(((t4 %= 1) < 0 ? ++t4 : t4) * n), v0 = values2[(i + n - 1) % n], v1 = values2[i % n], v2 = values2[(i + 1) % n], v3 = values2[(i + 2) % n];
    return basis$1((t4 - i / n) * n, v0, v1, v2, v3);
  };
}
function constant$a(x2) {
  return function() {
    return x2;
  };
}
function linear$2(a2, d) {
  return function(t4) {
    return a2 + t4 * d;
  };
}
function exponential$1(a2, b, y2) {
  return a2 = Math.pow(a2, y2), b = Math.pow(b, y2) - a2, y2 = 1 / y2, function(t4) {
    return Math.pow(a2 + t4 * b, y2);
  };
}
function hue$1(a2, b) {
  var d = b - a2;
  return d ? linear$2(a2, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$a(isNaN(a2) ? b : a2);
}
function gamma(y2) {
  return (y2 = +y2) === 1 ? nogamma : function(a2, b) {
    return b - a2 ? exponential$1(a2, b, y2) : constant$a(isNaN(a2) ? b : a2);
  };
}
function nogamma(a2, b) {
  var d = b - a2;
  return d ? linear$2(a2, d) : constant$a(isNaN(a2) ? b : a2);
}
const interpolateRgb = function rgbGamma(y2) {
  var color2 = gamma(y2);
  function rgb$1(start2, end2) {
    var r = color2((start2 = rgb(start2)).r, (end2 = rgb(end2)).r), g2 = color2(start2.g, end2.g), b = color2(start2.b, end2.b), opacity = nogamma(start2.opacity, end2.opacity);
    return function(t4) {
      start2.r = r(t4);
      start2.g = g2(t4);
      start2.b = b(t4);
      start2.opacity = opacity(t4);
      return start2 + "";
    };
  }
  rgb$1.gamma = rgbGamma;
  return rgb$1;
}(1);
function rgbSpline(spline) {
  return function(colors2) {
    var n = colors2.length, r = new Array(n), g2 = new Array(n), b = new Array(n), i, color2;
    for (i = 0; i < n; ++i) {
      color2 = rgb(colors2[i]);
      r[i] = color2.r || 0;
      g2[i] = color2.g || 0;
      b[i] = color2.b || 0;
    }
    r = spline(r);
    g2 = spline(g2);
    b = spline(b);
    color2.opacity = 1;
    return function(t4) {
      color2.r = r(t4);
      color2.g = g2(t4);
      color2.b = b(t4);
      return color2 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis$2);
var rgbBasisClosed = rgbSpline(basisClosed$1);
function numberArray(a2, b) {
  if (!b)
    b = [];
  var n = a2 ? Math.min(b.length, a2.length) : 0, c2 = b.slice(), i;
  return function(t4) {
    for (i = 0; i < n; ++i)
      c2[i] = a2[i] * (1 - t4) + b[i] * t4;
    return c2;
  };
}
function isNumberArray(x2) {
  return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
}
function array$2(a2, b) {
  return (isNumberArray(b) ? numberArray : genericArray)(a2, b);
}
function genericArray(a2, b) {
  var nb = b ? b.length : 0, na = a2 ? Math.min(nb, a2.length) : 0, x2 = new Array(na), c2 = new Array(nb), i;
  for (i = 0; i < na; ++i)
    x2[i] = interpolateValue(a2[i], b[i]);
  for (; i < nb; ++i)
    c2[i] = b[i];
  return function(t4) {
    for (i = 0; i < na; ++i)
      c2[i] = x2[i](t4);
    return c2;
  };
}
function date$1(a2, b) {
  var d = new Date();
  return a2 = +a2, b = +b, function(t4) {
    return d.setTime(a2 * (1 - t4) + b * t4), d;
  };
}
function interpolateNumber(a2, b) {
  return a2 = +a2, b = +b, function(t4) {
    return a2 * (1 - t4) + b * t4;
  };
}
function object$1(a2, b) {
  var i = {}, c2 = {}, k2;
  if (a2 === null || typeof a2 !== "object")
    a2 = {};
  if (b === null || typeof b !== "object")
    b = {};
  for (k2 in b) {
    if (k2 in a2) {
      i[k2] = interpolateValue(a2[k2], b[k2]);
    } else {
      c2[k2] = b[k2];
    }
  }
  return function(t4) {
    for (k2 in i)
      c2[k2] = i[k2](t4);
    return c2;
  };
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t4) {
    return b(t4) + "";
  };
}
function interpolateString(a2, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s2 = [], q = [];
  a2 = a2 + "", b = b + "";
  while ((am = reA.exec(a2)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s2[i])
        s2[i] += bs;
      else
        s2[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s2[i])
        s2[i] += bm;
      else
        s2[++i] = bm;
    } else {
      s2[++i] = null;
      q.push({ i, x: interpolateNumber(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s2[i])
      s2[i] += bs;
    else
      s2[++i] = bs;
  }
  return s2.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t4) {
    for (var i2 = 0, o; i2 < b; ++i2)
      s2[(o = q[i2]).i] = o.x(t4);
    return s2.join("");
  });
}
function interpolateValue(a2, b) {
  var t4 = typeof b, c2;
  return b == null || t4 === "boolean" ? constant$a(b) : (t4 === "number" ? interpolateNumber : t4 === "string" ? (c2 = color(b)) ? (b = c2, interpolateRgb) : interpolateString : b instanceof color ? interpolateRgb : b instanceof Date ? date$1 : isNumberArray(b) ? numberArray : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object$1 : interpolateNumber)(a2, b);
}
function discrete(range2) {
  var n = range2.length;
  return function(t4) {
    return range2[Math.max(0, Math.min(n - 1, Math.floor(t4 * n)))];
  };
}
function hue(a2, b) {
  var i = hue$1(+a2, +b);
  return function(t4) {
    var x2 = i(t4);
    return x2 - 360 * Math.floor(x2 / 360);
  };
}
function interpolateRound(a2, b) {
  return a2 = +a2, b = +b, function(t4) {
    return Math.round(a2 * (1 - t4) + b * t4);
  };
}
var degrees$1 = 180 / Math.PI;
var identity$7 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose(a2, b, c2, d, e, f2) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a2 * a2 + b * b))
    a2 /= scaleX, b /= scaleX;
  if (skewX = a2 * c2 + b * d)
    c2 -= a2 * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c2 * c2 + d * d))
    c2 /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a2 * d < b * c2)
    a2 = -a2, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f2,
    rotate: Math.atan2(b, a2) * degrees$1,
    skewX: Math.atan(skewX) * degrees$1,
    scaleX,
    scaleY
  };
}
var cssNode, cssRoot, cssView, svgNode;
function parseCss(value) {
  if (value === "none")
    return identity$7;
  if (!cssNode)
    cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}
function parseSvg(value) {
  if (value == null)
    return identity$7;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate()))
    return identity$7;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}
function interpolateTransform(parse2, pxComma, pxParen, degParen) {
  function pop(s2) {
    return s2.length ? s2.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      var i = s2.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
    } else if (xb || yb) {
      s2.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a2, b, s2, q) {
    if (a2 !== b) {
      if (a2 - b > 180)
        b += 360;
      else if (b - a2 > 180)
        a2 += 360;
      q.push({ i: s2.push(pop(s2) + "rotate(", null, degParen) - 2, x: interpolateNumber(a2, b) });
    } else if (b) {
      s2.push(pop(s2) + "rotate(" + b + degParen);
    }
  }
  function skewX(a2, b, s2, q) {
    if (a2 !== b) {
      q.push({ i: s2.push(pop(s2) + "skewX(", null, degParen) - 2, x: interpolateNumber(a2, b) });
    } else if (b) {
      s2.push(pop(s2) + "skewX(" + b + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      var i = s2.push(pop(s2) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s2.push(pop(s2) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a2, b) {
    var s2 = [], q = [];
    a2 = parse2(a2), b = parse2(b);
    translate(a2.translateX, a2.translateY, b.translateX, b.translateY, s2, q);
    rotate(a2.rotate, b.rotate, s2, q);
    skewX(a2.skewX, b.skewX, s2, q);
    scale(a2.scaleX, a2.scaleY, b.scaleX, b.scaleY, s2, q);
    a2 = b = null;
    return function(t4) {
      var i = -1, n = q.length, o;
      while (++i < n)
        s2[(o = q[i]).i] = o.x(t4);
      return s2.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");
var rho = Math.SQRT2, rho2 = 2, rho4 = 4, epsilon2$2 = 1e-12;
function cosh(x2) {
  return ((x2 = Math.exp(x2)) + 1 / x2) / 2;
}
function sinh(x2) {
  return ((x2 = Math.exp(x2)) - 1 / x2) / 2;
}
function tanh(x2) {
  return ((x2 = Math.exp(2 * x2)) - 1) / (x2 + 1);
}
function interpolateZoom(p02, p1) {
  var ux0 = p02[0], uy0 = p02[1], w0 = p02[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S2;
  if (d2 < epsilon2$2) {
    S2 = Math.log(w1 / w0) / rho;
    i = function(t4) {
      return [
        ux0 + t4 * dx,
        uy0 + t4 * dy,
        w0 * Math.exp(rho * t4 * S2)
      ];
    };
  } else {
    var d1 = Math.sqrt(d2), b02 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b12 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b02 * b02 + 1) - b02), r1 = Math.log(Math.sqrt(b12 * b12 + 1) - b12);
    S2 = (r1 - r0) / rho;
    i = function(t4) {
      var s2 = t4 * S2, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s2 + r0) - sinh(r0));
      return [
        ux0 + u * dx,
        uy0 + u * dy,
        w0 * coshr0 / cosh(rho * s2 + r0)
      ];
    };
  }
  i.duration = S2 * 1e3;
  return i;
}
function hsl(hue2) {
  return function(start2, end2) {
    var h2 = hue2((start2 = hsl$2(start2)).h, (end2 = hsl$2(end2)).h), s2 = nogamma(start2.s, end2.s), l2 = nogamma(start2.l, end2.l), opacity = nogamma(start2.opacity, end2.opacity);
    return function(t4) {
      start2.h = h2(t4);
      start2.s = s2(t4);
      start2.l = l2(t4);
      start2.opacity = opacity(t4);
      return start2 + "";
    };
  };
}
const hsl$1 = hsl(hue$1);
var hslLong = hsl(nogamma);
function lab(start2, end2) {
  var l2 = nogamma((start2 = lab$1(start2)).l, (end2 = lab$1(end2)).l), a2 = nogamma(start2.a, end2.a), b = nogamma(start2.b, end2.b), opacity = nogamma(start2.opacity, end2.opacity);
  return function(t4) {
    start2.l = l2(t4);
    start2.a = a2(t4);
    start2.b = b(t4);
    start2.opacity = opacity(t4);
    return start2 + "";
  };
}
function hcl(hue2) {
  return function(start2, end2) {
    var h2 = hue2((start2 = hcl$2(start2)).h, (end2 = hcl$2(end2)).h), c2 = nogamma(start2.c, end2.c), l2 = nogamma(start2.l, end2.l), opacity = nogamma(start2.opacity, end2.opacity);
    return function(t4) {
      start2.h = h2(t4);
      start2.c = c2(t4);
      start2.l = l2(t4);
      start2.opacity = opacity(t4);
      return start2 + "";
    };
  };
}
const hcl$1 = hcl(hue$1);
var hclLong = hcl(nogamma);
function cubehelix$1(hue2) {
  return function cubehelixGamma(y2) {
    y2 = +y2;
    function cubehelix2(start2, end2) {
      var h2 = hue2((start2 = cubehelix$3(start2)).h, (end2 = cubehelix$3(end2)).h), s2 = nogamma(start2.s, end2.s), l2 = nogamma(start2.l, end2.l), opacity = nogamma(start2.opacity, end2.opacity);
      return function(t4) {
        start2.h = h2(t4);
        start2.s = s2(t4);
        start2.l = l2(Math.pow(t4, y2));
        start2.opacity = opacity(t4);
        return start2 + "";
      };
    }
    cubehelix2.gamma = cubehelixGamma;
    return cubehelix2;
  }(1);
}
const cubehelix$2 = cubehelix$1(hue$1);
var cubehelixLong = cubehelix$1(nogamma);
function piecewise(interpolate2, values2) {
  var i = 0, n = values2.length - 1, v = values2[0], I = new Array(n < 0 ? 0 : n);
  while (i < n)
    I[i] = interpolate2(v, v = values2[++i]);
  return function(t4) {
    var i2 = Math.max(0, Math.min(n - 1, Math.floor(t4 *= n)));
    return I[i2](t4 - i2);
  };
}
function quantize$1(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i)
    samples[i] = interpolator(i / (n - 1));
  return samples;
}
var frame = 0, timeout$1 = 0, interval$1 = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance === "object" && performance.now ? performance : Date, setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f2) {
  setTimeout(f2, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time2) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time2 = (time2 == null ? now() : +time2) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time2;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time2) {
  var t4 = new Timer();
  t4.restart(callback, delay, time2);
  return t4;
}
function timerFlush() {
  now();
  ++frame;
  var t4 = taskHead, e;
  while (t4) {
    if ((e = clockNow - t4._time) >= 0)
      t4._call.call(null, e);
    t4 = t4._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout$1 = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t02, t12 = taskHead, t22, time2 = Infinity;
  while (t12) {
    if (t12._call) {
      if (time2 > t12._time)
        time2 = t12._time;
      t02 = t12, t12 = t12._next;
    } else {
      t22 = t12._next, t12._next = null;
      t12 = t02 ? t02._next = t22 : taskHead = t22;
    }
  }
  taskTail = t02;
  sleep(time2);
}
function sleep(time2) {
  if (frame)
    return;
  if (timeout$1)
    timeout$1 = clearTimeout(timeout$1);
  var delay = time2 - clockNow;
  if (delay > 24) {
    if (time2 < Infinity)
      timeout$1 = setTimeout(wake, time2 - clock.now() - clockSkew);
    if (interval$1)
      interval$1 = clearInterval(interval$1);
  } else {
    if (!interval$1)
      clockLast = clock.now(), interval$1 = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}
function timeout(callback, delay, time2) {
  var t4 = new Timer();
  delay = delay == null ? 0 : +delay;
  t4.restart(function(elapsed) {
    t4.stop();
    callback(elapsed + delay);
  }, delay, time2);
  return t4;
}
function interval(callback, delay, time2) {
  var t4 = new Timer(), total = delay;
  if (delay == null)
    return t4.restart(callback, delay, time2), t4;
  delay = +delay, time2 = time2 == null ? now() : +time2;
  t4.restart(function tick(elapsed) {
    elapsed += total;
    t4.restart(tick, total += delay, time2);
    callback(elapsed);
  }, delay, time2);
  return t4;
}
var emptyOn = dispatch("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule(node2, name2, id2, index2, group, timing) {
  var schedules = node2.__transition;
  if (!schedules)
    node2.__transition = {};
  else if (id2 in schedules)
    return;
  create(node2, id2, {
    name: name2,
    index: index2,
    group,
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init$1(node2, id2) {
  var schedule2 = get(node2, id2);
  if (schedule2.state > CREATED)
    throw new Error("too late; already scheduled");
  return schedule2;
}
function set$1(node2, id2) {
  var schedule2 = get(node2, id2);
  if (schedule2.state > STARTED)
    throw new Error("too late; already running");
  return schedule2;
}
function get(node2, id2) {
  var schedule2 = node2.__transition;
  if (!schedule2 || !(schedule2 = schedule2[id2]))
    throw new Error("transition not found");
  return schedule2;
}
function create(node2, id2, self2) {
  var schedules = node2.__transition, tween;
  schedules[id2] = self2;
  self2.timer = timer(schedule2, 0, self2.time);
  function schedule2(elapsed) {
    self2.state = SCHEDULED;
    self2.timer.restart(start2, self2.delay, self2.time);
    if (self2.delay <= elapsed)
      start2(elapsed - self2.delay);
  }
  function start2(elapsed) {
    var i, j2, n, o;
    if (self2.state !== SCHEDULED)
      return stop();
    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self2.name)
        continue;
      if (o.state === STARTED)
        return timeout(start2);
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node2, node2.__data__, o.index, o.group);
        delete schedules[i];
      } else if (+i < id2) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node2, node2.__data__, o.index, o.group);
        delete schedules[i];
      }
    }
    timeout(function() {
      if (self2.state === STARTED) {
        self2.state = RUNNING;
        self2.timer.restart(tick, self2.delay, self2.time);
        tick(elapsed);
      }
    });
    self2.state = STARTING;
    self2.on.call("start", node2, node2.__data__, self2.index, self2.group);
    if (self2.state !== STARTING)
      return;
    self2.state = STARTED;
    tween = new Array(n = self2.tween.length);
    for (i = 0, j2 = -1; i < n; ++i) {
      if (o = self2.tween[i].value.call(node2, node2.__data__, self2.index, self2.group)) {
        tween[++j2] = o;
      }
    }
    tween.length = j2 + 1;
  }
  function tick(elapsed) {
    var t4 = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i = -1, n = tween.length;
    while (++i < n) {
      tween[i].call(node2, t4);
    }
    if (self2.state === ENDING) {
      self2.on.call("end", node2, node2.__data__, self2.index, self2.group);
      stop();
    }
  }
  function stop() {
    self2.state = ENDED;
    self2.timer.stop();
    delete schedules[id2];
    for (var i in schedules)
      return;
    delete node2.__transition;
  }
}
function interrupt(node2, name2) {
  var schedules = node2.__transition, schedule2, active2, empty2 = true, i;
  if (!schedules)
    return;
  name2 = name2 == null ? null : name2 + "";
  for (i in schedules) {
    if ((schedule2 = schedules[i]).name !== name2) {
      empty2 = false;
      continue;
    }
    active2 = schedule2.state > STARTING && schedule2.state < ENDING;
    schedule2.state = ENDED;
    schedule2.timer.stop();
    schedule2.on.call(active2 ? "interrupt" : "cancel", node2, node2.__data__, schedule2.index, schedule2.group);
    delete schedules[i];
  }
  if (empty2)
    delete node2.__transition;
}
function selection_interrupt(name2) {
  return this.each(function() {
    interrupt(this, name2);
  });
}
function tweenRemove(id2, name2) {
  var tween0, tween1;
  return function() {
    var schedule2 = set$1(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name2) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }
    schedule2.tween = tween1;
  };
}
function tweenFunction(id2, name2, value) {
  var tween0, tween1;
  if (typeof value !== "function")
    throw new Error();
  return function() {
    var schedule2 = set$1(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t4 = { name: name2, value }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name2) {
          tween1[i] = t4;
          break;
        }
      }
      if (i === n)
        tween1.push(t4);
    }
    schedule2.tween = tween1;
  };
}
function transition_tween(name2, value) {
  var id2 = this._id;
  name2 += "";
  if (arguments.length < 2) {
    var tween = get(this.node(), id2).tween;
    for (var i = 0, n = tween.length, t4; i < n; ++i) {
      if ((t4 = tween[i]).name === name2) {
        return t4.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name2, value));
}
function tweenValue(transition2, name2, value) {
  var id2 = transition2._id;
  transition2.each(function() {
    var schedule2 = set$1(this, id2);
    (schedule2.value || (schedule2.value = {}))[name2] = value.apply(this, arguments);
  });
  return function(node2) {
    return get(node2, id2).value[name2];
  };
}
function interpolate$1(a2, b) {
  var c2;
  return (typeof b === "number" ? interpolateNumber : b instanceof color ? interpolateRgb : (c2 = color(b)) ? (b = c2, interpolateRgb) : interpolateString)(a2, b);
}
function attrRemove(name2) {
  return function() {
    this.removeAttribute(name2);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name2, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name2);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrConstantNS(fullname, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrFunction(name2, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttribute(name2);
    string0 = this.getAttribute(name2);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function attrFunctionNS(fullname, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function transition_attr(name2, value) {
  var fullname = namespace(name2), i = fullname === "transform" ? interpolateTransformSvg : interpolate$1;
  return this.attrTween(name2, typeof value === "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name2, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
}
function attrInterpolate(name2, i) {
  return function(t4) {
    this.setAttribute(name2, i.call(this, t4));
  };
}
function attrInterpolateNS(fullname, i) {
  return function(t4) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t4));
  };
}
function attrTweenNS(fullname, value) {
  var t02, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t02 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t02;
  }
  tween._value = value;
  return tween;
}
function attrTween(name2, value) {
  var t02, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t02 = (i0 = i) && attrInterpolate(name2, i);
    return t02;
  }
  tween._value = value;
  return tween;
}
function transition_attrTween(name2, value) {
  var key = "attr." + name2;
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  var fullname = namespace(name2);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}
function delayFunction(id2, value) {
  return function() {
    init$1(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init$1(this, id2).delay = value;
  };
}
function transition_delay(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get(this.node(), id2).delay;
}
function durationFunction(id2, value) {
  return function() {
    set$1(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set$1(this, id2).duration = value;
  };
}
function transition_duration(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get(this.node(), id2).duration;
}
function easeConstant(id2, value) {
  if (typeof value !== "function")
    throw new Error();
  return function() {
    set$1(this, id2).ease = value;
  };
}
function transition_ease(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get(this.node(), id2).ease;
}
function transition_filter(match) {
  if (typeof match !== "function")
    match = matcher(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j2 = 0; j2 < m; ++j2) {
    for (var group = groups[j2], n = group.length, subgroup = subgroups[j2] = [], node2, i = 0; i < n; ++i) {
      if ((node2 = group[i]) && match.call(node2, node2.__data__, i, group)) {
        subgroup.push(node2);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}
function transition_merge(transition2) {
  if (transition2._id !== this._id)
    throw new Error();
  for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j2 = 0; j2 < m; ++j2) {
    for (var group0 = groups0[j2], group1 = groups1[j2], n = group0.length, merge2 = merges[j2] = new Array(n), node2, i = 0; i < n; ++i) {
      if (node2 = group0[i] || group1[i]) {
        merge2[i] = node2;
      }
    }
  }
  for (; j2 < m0; ++j2) {
    merges[j2] = groups0[j2];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}
function start$1(name2) {
  return (name2 + "").trim().split(/^|\s+/).every(function(t4) {
    var i = t4.indexOf(".");
    if (i >= 0)
      t4 = t4.slice(0, i);
    return !t4 || t4 === "start";
  });
}
function onFunction(id2, name2, listener) {
  var on0, on1, sit = start$1(name2) ? init$1 : set$1;
  return function() {
    var schedule2 = sit(this, id2), on2 = schedule2.on;
    if (on2 !== on0)
      (on1 = (on0 = on2).copy()).on(name2, listener);
    schedule2.on = on1;
  };
}
function transition_on(name2, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get(this.node(), id2).on.on(name2) : this.each(onFunction(id2, name2, listener));
}
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition)
      if (+i !== id2)
        return;
    if (parent)
      parent.removeChild(this);
  };
}
function transition_remove() {
  return this.on("end.remove", removeFunction(this._id));
}
function transition_select(select2) {
  var name2 = this._name, id2 = this._id;
  if (typeof select2 !== "function")
    select2 = selector(select2);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j2 = 0; j2 < m; ++j2) {
    for (var group = groups[j2], n = group.length, subgroup = subgroups[j2] = new Array(n), node2, subnode, i = 0; i < n; ++i) {
      if ((node2 = group[i]) && (subnode = select2.call(node2, node2.__data__, i, group))) {
        if ("__data__" in node2)
          subnode.__data__ = node2.__data__;
        subgroup[i] = subnode;
        schedule(subgroup[i], name2, id2, i, subgroup, get(node2, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name2, id2);
}
function transition_selectAll(select2) {
  var name2 = this._name, id2 = this._id;
  if (typeof select2 !== "function")
    select2 = selectorAll(select2);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents2 = [], j2 = 0; j2 < m; ++j2) {
    for (var group = groups[j2], n = group.length, node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        for (var children2 = select2.call(node2, node2.__data__, i, group), child, inherit2 = get(node2, id2), k2 = 0, l2 = children2.length; k2 < l2; ++k2) {
          if (child = children2[k2]) {
            schedule(child, name2, id2, k2, children2, inherit2);
          }
        }
        subgroups.push(children2);
        parents2.push(node2);
      }
    }
  }
  return new Transition(subgroups, parents2, name2, id2);
}
var Selection = selection.prototype.constructor;
function transition_selection() {
  return new Selection(this._groups, this._parents);
}
function styleNull(name2, interpolate2) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name2), string1 = (this.style.removeProperty(name2), styleValue(this, name2));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, string10 = string1);
  };
}
function styleRemove(name2) {
  return function() {
    this.style.removeProperty(name2);
  };
}
function styleConstant(name2, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name2);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function styleFunction(name2, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name2), value1 = value(this), string1 = value1 + "";
    if (value1 == null)
      string1 = value1 = (this.style.removeProperty(name2), styleValue(this, name2));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name2) {
  var on0, on1, listener0, key = "style." + name2, event2 = "end." + key, remove2;
  return function() {
    var schedule2 = set$1(this, id2), on2 = schedule2.on, listener = schedule2.value[key] == null ? remove2 || (remove2 = styleRemove(name2)) : void 0;
    if (on2 !== on0 || listener0 !== listener)
      (on1 = (on0 = on2).copy()).on(event2, listener0 = listener);
    schedule2.on = on1;
  };
}
function transition_style(name2, value, priority) {
  var i = (name2 += "") === "transform" ? interpolateTransformCss : interpolate$1;
  return value == null ? this.styleTween(name2, styleNull(name2, i)).on("end.style." + name2, styleRemove(name2)) : typeof value === "function" ? this.styleTween(name2, styleFunction(name2, i, tweenValue(this, "style." + name2, value))).each(styleMaybeRemove(this._id, name2)) : this.styleTween(name2, styleConstant(name2, i, value), priority).on("end.style." + name2, null);
}
function styleInterpolate(name2, i, priority) {
  return function(t4) {
    this.style.setProperty(name2, i.call(this, t4), priority);
  };
}
function styleTween(name2, value, priority) {
  var t4, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t4 = (i0 = i) && styleInterpolate(name2, i, priority);
    return t4;
  }
  tween._value = value;
  return tween;
}
function transition_styleTween(name2, value, priority) {
  var key = "style." + (name2 += "");
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, styleTween(name2, value, priority == null ? "" : priority));
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function transition_text(value) {
  return this.tween("text", typeof value === "function" ? textFunction(tweenValue(this, "text", value)) : textConstant(value == null ? "" : value + ""));
}
function textInterpolate(i) {
  return function(t4) {
    this.textContent = i.call(this, t4);
  };
}
function textTween(value) {
  var t02, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t02 = (i0 = i) && textInterpolate(i);
    return t02;
  }
  tween._value = value;
  return tween;
}
function transition_textTween(value) {
  var key = "text";
  if (arguments.length < 1)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, textTween(value));
}
function transition_transition() {
  var name2 = this._name, id0 = this._id, id1 = newId();
  for (var groups = this._groups, m = groups.length, j2 = 0; j2 < m; ++j2) {
    for (var group = groups[j2], n = group.length, node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        var inherit2 = get(node2, id0);
        schedule(node2, name2, id1, i, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
    }
  }
  return new Transition(groups, this._parents, name2, id1);
}
function transition_end() {
  var on0, on1, that = this, id2 = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = { value: reject }, end2 = { value: function() {
      if (--size === 0)
        resolve();
    } };
    that.each(function() {
      var schedule2 = set$1(this, id2), on2 = schedule2.on;
      if (on2 !== on0) {
        on1 = (on0 = on2).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end2);
      }
      schedule2.on = on1;
    });
  });
}
var id = 0;
function Transition(groups, parents2, name2, id2) {
  this._groups = groups;
  this._parents = parents2;
  this._name = name2;
  this._id = id2;
}
function transition(name2) {
  return selection().transition(name2);
}
function newId() {
  return ++id;
}
var selection_prototype = selection.prototype;
Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  textTween: transition_textTween,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease,
  end: transition_end
};
function linear$1(t4) {
  return +t4;
}
function quadIn(t4) {
  return t4 * t4;
}
function quadOut(t4) {
  return t4 * (2 - t4);
}
function quadInOut(t4) {
  return ((t4 *= 2) <= 1 ? t4 * t4 : --t4 * (2 - t4) + 1) / 2;
}
function cubicIn(t4) {
  return t4 * t4 * t4;
}
function cubicOut(t4) {
  return --t4 * t4 * t4 + 1;
}
function cubicInOut(t4) {
  return ((t4 *= 2) <= 1 ? t4 * t4 * t4 : (t4 -= 2) * t4 * t4 + 2) / 2;
}
var exponent$1 = 3;
var polyIn = function custom(e) {
  e = +e;
  function polyIn2(t4) {
    return Math.pow(t4, e);
  }
  polyIn2.exponent = custom;
  return polyIn2;
}(exponent$1);
var polyOut = function custom2(e) {
  e = +e;
  function polyOut2(t4) {
    return 1 - Math.pow(1 - t4, e);
  }
  polyOut2.exponent = custom2;
  return polyOut2;
}(exponent$1);
var polyInOut = function custom3(e) {
  e = +e;
  function polyInOut2(t4) {
    return ((t4 *= 2) <= 1 ? Math.pow(t4, e) : 2 - Math.pow(2 - t4, e)) / 2;
  }
  polyInOut2.exponent = custom3;
  return polyInOut2;
}(exponent$1);
var pi$4 = Math.PI, halfPi$3 = pi$4 / 2;
function sinIn(t4) {
  return +t4 === 1 ? 1 : 1 - Math.cos(t4 * halfPi$3);
}
function sinOut(t4) {
  return Math.sin(t4 * halfPi$3);
}
function sinInOut(t4) {
  return (1 - Math.cos(pi$4 * t4)) / 2;
}
function tpmt(x2) {
  return (Math.pow(2, -10 * x2) - 9765625e-10) * 1.0009775171065494;
}
function expIn(t4) {
  return tpmt(1 - +t4);
}
function expOut(t4) {
  return 1 - tpmt(t4);
}
function expInOut(t4) {
  return ((t4 *= 2) <= 1 ? tpmt(1 - t4) : 2 - tpmt(t4 - 1)) / 2;
}
function circleIn(t4) {
  return 1 - Math.sqrt(1 - t4 * t4);
}
function circleOut(t4) {
  return Math.sqrt(1 - --t4 * t4);
}
function circleInOut(t4) {
  return ((t4 *= 2) <= 1 ? 1 - Math.sqrt(1 - t4 * t4) : Math.sqrt(1 - (t4 -= 2) * t4) + 1) / 2;
}
var b1 = 4 / 11, b2 = 6 / 11, b3 = 8 / 11, b4 = 3 / 4, b5 = 9 / 11, b6 = 10 / 11, b7 = 15 / 16, b8 = 21 / 22, b9 = 63 / 64, b0 = 1 / b1 / b1;
function bounceIn(t4) {
  return 1 - bounceOut(1 - t4);
}
function bounceOut(t4) {
  return (t4 = +t4) < b1 ? b0 * t4 * t4 : t4 < b3 ? b0 * (t4 -= b2) * t4 + b4 : t4 < b6 ? b0 * (t4 -= b5) * t4 + b7 : b0 * (t4 -= b8) * t4 + b9;
}
function bounceInOut(t4) {
  return ((t4 *= 2) <= 1 ? 1 - bounceOut(1 - t4) : bounceOut(t4 - 1) + 1) / 2;
}
var overshoot = 1.70158;
var backIn = function custom4(s2) {
  s2 = +s2;
  function backIn2(t4) {
    return (t4 = +t4) * t4 * (s2 * (t4 - 1) + t4);
  }
  backIn2.overshoot = custom4;
  return backIn2;
}(overshoot);
var backOut = function custom5(s2) {
  s2 = +s2;
  function backOut2(t4) {
    return --t4 * t4 * ((t4 + 1) * s2 + t4) + 1;
  }
  backOut2.overshoot = custom5;
  return backOut2;
}(overshoot);
var backInOut = function custom6(s2) {
  s2 = +s2;
  function backInOut2(t4) {
    return ((t4 *= 2) < 1 ? t4 * t4 * ((s2 + 1) * t4 - s2) : (t4 -= 2) * t4 * ((s2 + 1) * t4 + s2) + 2) / 2;
  }
  backInOut2.overshoot = custom6;
  return backInOut2;
}(overshoot);
var tau$4 = 2 * Math.PI, amplitude = 1, period = 0.3;
var elasticIn = function custom7(a2, p) {
  var s2 = Math.asin(1 / (a2 = Math.max(1, a2))) * (p /= tau$4);
  function elasticIn2(t4) {
    return a2 * tpmt(- --t4) * Math.sin((s2 - t4) / p);
  }
  elasticIn2.amplitude = function(a3) {
    return custom7(a3, p * tau$4);
  };
  elasticIn2.period = function(p2) {
    return custom7(a2, p2);
  };
  return elasticIn2;
}(amplitude, period);
var elasticOut = function custom8(a2, p) {
  var s2 = Math.asin(1 / (a2 = Math.max(1, a2))) * (p /= tau$4);
  function elasticOut2(t4) {
    return 1 - a2 * tpmt(t4 = +t4) * Math.sin((t4 + s2) / p);
  }
  elasticOut2.amplitude = function(a3) {
    return custom8(a3, p * tau$4);
  };
  elasticOut2.period = function(p2) {
    return custom8(a2, p2);
  };
  return elasticOut2;
}(amplitude, period);
var elasticInOut = function custom9(a2, p) {
  var s2 = Math.asin(1 / (a2 = Math.max(1, a2))) * (p /= tau$4);
  function elasticInOut2(t4) {
    return ((t4 = t4 * 2 - 1) < 0 ? a2 * tpmt(-t4) * Math.sin((s2 - t4) / p) : 2 - a2 * tpmt(t4) * Math.sin((s2 + t4) / p)) / 2;
  }
  elasticInOut2.amplitude = function(a3) {
    return custom9(a3, p * tau$4);
  };
  elasticInOut2.period = function(p2) {
    return custom9(a2, p2);
  };
  return elasticInOut2;
}(amplitude, period);
var defaultTiming = {
  time: null,
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node2, id2) {
  var timing;
  while (!(timing = node2.__transition) || !(timing = timing[id2])) {
    if (!(node2 = node2.parentNode)) {
      return defaultTiming.time = now(), defaultTiming;
    }
  }
  return timing;
}
function selection_transition(name2) {
  var id2, timing;
  if (name2 instanceof Transition) {
    id2 = name2._id, name2 = name2._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now(), name2 = name2 == null ? null : name2 + "";
  }
  for (var groups = this._groups, m = groups.length, j2 = 0; j2 < m; ++j2) {
    for (var group = groups[j2], n = group.length, node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        schedule(node2, name2, id2, i, group, timing || inherit(node2, id2));
      }
    }
  }
  return new Transition(groups, this._parents, name2, id2);
}
selection.prototype.interrupt = selection_interrupt;
selection.prototype.transition = selection_transition;
var root$3 = [null];
function active(node2, name2) {
  var schedules = node2.__transition, schedule2, i;
  if (schedules) {
    name2 = name2 == null ? null : name2 + "";
    for (i in schedules) {
      if ((schedule2 = schedules[i]).state > SCHEDULED && schedule2.name === name2) {
        return new Transition([[node2]], root$3, name2, +i);
      }
    }
  }
  return null;
}
function constant$9(x2) {
  return function() {
    return x2;
  };
}
function BrushEvent(target, type2, selection2) {
  this.target = target;
  this.type = type2;
  this.selection = selection2;
}
function nopropagation$1() {
  event.stopImmediatePropagation();
}
function noevent$1() {
  event.preventDefault();
  event.stopImmediatePropagation();
}
var MODE_DRAG = { name: "drag" }, MODE_SPACE = { name: "space" }, MODE_HANDLE = { name: "handle" }, MODE_CENTER = { name: "center" };
function number1(e) {
  return [+e[0], +e[1]];
}
function number2(e) {
  return [number1(e[0]), number1(e[1])];
}
function toucher(identifier2) {
  return function(target) {
    return touch(target, event.touches, identifier2);
  };
}
var X = {
  name: "x",
  handles: ["w", "e"].map(type$1),
  input: function(x2, e) {
    return x2 == null ? null : [[+x2[0], e[0][1]], [+x2[1], e[1][1]]];
  },
  output: function(xy) {
    return xy && [xy[0][0], xy[1][0]];
  }
};
var Y = {
  name: "y",
  handles: ["n", "s"].map(type$1),
  input: function(y2, e) {
    return y2 == null ? null : [[e[0][0], +y2[0]], [e[1][0], +y2[1]]];
  },
  output: function(xy) {
    return xy && [xy[0][1], xy[1][1]];
  }
};
var XY = {
  name: "xy",
  handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type$1),
  input: function(xy) {
    return xy == null ? null : number2(xy);
  },
  output: function(xy) {
    return xy;
  }
};
var cursors = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};
var flipX = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
};
var flipY = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
};
var signsX = {
  overlay: 1,
  selection: 1,
  n: null,
  e: 1,
  s: null,
  w: -1,
  nw: -1,
  ne: 1,
  se: 1,
  sw: -1
};
var signsY = {
  overlay: 1,
  selection: 1,
  n: -1,
  e: null,
  s: 1,
  w: null,
  nw: -1,
  ne: -1,
  se: 1,
  sw: 1
};
function type$1(t4) {
  return { type: t4 };
}
function defaultFilter$1() {
  return !event.ctrlKey && !event.button;
}
function defaultExtent$1() {
  var svg2 = this.ownerSVGElement || this;
  if (svg2.hasAttribute("viewBox")) {
    svg2 = svg2.viewBox.baseVal;
    return [[svg2.x, svg2.y], [svg2.x + svg2.width, svg2.y + svg2.height]];
  }
  return [[0, 0], [svg2.width.baseVal.value, svg2.height.baseVal.value]];
}
function defaultTouchable$1() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function local(node2) {
  while (!node2.__brush)
    if (!(node2 = node2.parentNode))
      return;
  return node2.__brush;
}
function empty(extent2) {
  return extent2[0][0] === extent2[1][0] || extent2[0][1] === extent2[1][1];
}
function brushSelection(node2) {
  var state = node2.__brush;
  return state ? state.dim.output(state.selection) : null;
}
function brushX() {
  return brush$1(X);
}
function brushY() {
  return brush$1(Y);
}
function brush() {
  return brush$1(XY);
}
function brush$1(dim) {
  var extent2 = defaultExtent$1, filter = defaultFilter$1, touchable = defaultTouchable$1, keys2 = true, listeners = dispatch("start", "brush", "end"), handleSize = 6, touchending;
  function brush2(group) {
    var overlay = group.property("__brush", initialize2).selectAll(".overlay").data([type$1("overlay")]);
    overlay.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", cursors.overlay).merge(overlay).each(function() {
      var extent3 = local(this).extent;
      select(this).attr("x", extent3[0][0]).attr("y", extent3[0][1]).attr("width", extent3[1][0] - extent3[0][0]).attr("height", extent3[1][1] - extent3[0][1]);
    });
    group.selectAll(".selection").data([type$1("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", cursors.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
    var handle = group.selectAll(".handle").data(dim.handles, function(d) {
      return d.type;
    });
    handle.exit().remove();
    handle.enter().append("rect").attr("class", function(d) {
      return "handle handle--" + d.type;
    }).attr("cursor", function(d) {
      return cursors[d.type];
    });
    group.each(redraw).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", started).filter(touchable).on("touchstart.brush", started).on("touchmove.brush", touchmoved).on("touchend.brush touchcancel.brush", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  brush2.move = function(group, selection2) {
    if (group.selection) {
      group.on("start.brush", function() {
        emitter(this, arguments).beforestart().start();
      }).on("interrupt.brush end.brush", function() {
        emitter(this, arguments).end();
      }).tween("brush", function() {
        var that = this, state = that.__brush, emit = emitter(that, arguments), selection0 = state.selection, selection1 = dim.input(typeof selection2 === "function" ? selection2.apply(this, arguments) : selection2, state.extent), i = interpolateValue(selection0, selection1);
        function tween(t4) {
          state.selection = t4 === 1 && selection1 === null ? null : i(t4);
          redraw.call(that);
          emit.brush();
        }
        return selection0 !== null && selection1 !== null ? tween : tween(1);
      });
    } else {
      group.each(function() {
        var that = this, args = arguments, state = that.__brush, selection1 = dim.input(typeof selection2 === "function" ? selection2.apply(that, args) : selection2, state.extent), emit = emitter(that, args).beforestart();
        interrupt(that);
        state.selection = selection1 === null ? null : selection1;
        redraw.call(that);
        emit.start().brush().end();
      });
    }
  };
  brush2.clear = function(group) {
    brush2.move(group, null);
  };
  function redraw() {
    var group = select(this), selection2 = local(this).selection;
    if (selection2) {
      group.selectAll(".selection").style("display", null).attr("x", selection2[0][0]).attr("y", selection2[0][1]).attr("width", selection2[1][0] - selection2[0][0]).attr("height", selection2[1][1] - selection2[0][1]);
      group.selectAll(".handle").style("display", null).attr("x", function(d) {
        return d.type[d.type.length - 1] === "e" ? selection2[1][0] - handleSize / 2 : selection2[0][0] - handleSize / 2;
      }).attr("y", function(d) {
        return d.type[0] === "s" ? selection2[1][1] - handleSize / 2 : selection2[0][1] - handleSize / 2;
      }).attr("width", function(d) {
        return d.type === "n" || d.type === "s" ? selection2[1][0] - selection2[0][0] + handleSize : handleSize;
      }).attr("height", function(d) {
        return d.type === "e" || d.type === "w" ? selection2[1][1] - selection2[0][1] + handleSize : handleSize;
      });
    } else {
      group.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
    }
  }
  function emitter(that, args, clean) {
    var emit = that.__brush.emitter;
    return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);
  }
  function Emitter(that, args, clean) {
    this.that = that;
    this.args = args;
    this.state = that.__brush;
    this.active = 0;
    this.clean = clean;
  }
  Emitter.prototype = {
    beforestart: function() {
      if (++this.active === 1)
        this.state.emitter = this, this.starting = true;
      return this;
    },
    start: function() {
      if (this.starting)
        this.starting = false, this.emit("start");
      else
        this.emit("brush");
      return this;
    },
    brush: function() {
      this.emit("brush");
      return this;
    },
    end: function() {
      if (--this.active === 0)
        delete this.state.emitter, this.emit("end");
      return this;
    },
    emit: function(type2) {
      customEvent(new BrushEvent(brush2, type2, dim.output(this.state.selection)), listeners.apply, listeners, [type2, this.that, this.args]);
    }
  };
  function started() {
    if (touchending && !event.touches)
      return;
    if (!filter.apply(this, arguments))
      return;
    var that = this, type2 = event.target.__data__.type, mode = (keys2 && event.metaKey ? type2 = "overlay" : type2) === "selection" ? MODE_DRAG : keys2 && event.altKey ? MODE_CENTER : MODE_HANDLE, signX = dim === Y ? null : signsX[type2], signY = dim === X ? null : signsY[type2], state = local(that), extent3 = state.extent, selection2 = state.selection, W2 = extent3[0][0], w0, w1, N2 = extent3[0][1], n0, n1, E2 = extent3[1][0], e0, e1, S2 = extent3[1][1], s0, s1, dx = 0, dy = 0, moving, shifting = signX && signY && keys2 && event.shiftKey, lockX, lockY, pointer = event.touches ? toucher(event.changedTouches[0].identifier) : mouse, point0 = pointer(that), point2 = point0, emit = emitter(that, arguments, true).beforestart();
    if (type2 === "overlay") {
      if (selection2)
        moving = true;
      state.selection = selection2 = [
        [w0 = dim === Y ? W2 : point0[0], n0 = dim === X ? N2 : point0[1]],
        [e0 = dim === Y ? E2 : w0, s0 = dim === X ? S2 : n0]
      ];
    } else {
      w0 = selection2[0][0];
      n0 = selection2[0][1];
      e0 = selection2[1][0];
      s0 = selection2[1][1];
    }
    w1 = w0;
    n1 = n0;
    e1 = e0;
    s1 = s0;
    var group = select(that).attr("pointer-events", "none");
    var overlay = group.selectAll(".overlay").attr("cursor", cursors[type2]);
    if (event.touches) {
      emit.moved = moved;
      emit.ended = ended;
    } else {
      var view = select(event.view).on("mousemove.brush", moved, true).on("mouseup.brush", ended, true);
      if (keys2)
        view.on("keydown.brush", keydowned, true).on("keyup.brush", keyupped, true);
      dragDisable(event.view);
    }
    nopropagation$1();
    interrupt(that);
    redraw.call(that);
    emit.start();
    function moved() {
      var point1 = pointer(that);
      if (shifting && !lockX && !lockY) {
        if (Math.abs(point1[0] - point2[0]) > Math.abs(point1[1] - point2[1]))
          lockY = true;
        else
          lockX = true;
      }
      point2 = point1;
      moving = true;
      noevent$1();
      move();
    }
    function move() {
      var t4;
      dx = point2[0] - point0[0];
      dy = point2[1] - point0[1];
      switch (mode) {
        case MODE_SPACE:
        case MODE_DRAG: {
          if (signX)
            dx = Math.max(W2 - w0, Math.min(E2 - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
          if (signY)
            dy = Math.max(N2 - n0, Math.min(S2 - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
          break;
        }
        case MODE_HANDLE: {
          if (signX < 0)
            dx = Math.max(W2 - w0, Math.min(E2 - w0, dx)), w1 = w0 + dx, e1 = e0;
          else if (signX > 0)
            dx = Math.max(W2 - e0, Math.min(E2 - e0, dx)), w1 = w0, e1 = e0 + dx;
          if (signY < 0)
            dy = Math.max(N2 - n0, Math.min(S2 - n0, dy)), n1 = n0 + dy, s1 = s0;
          else if (signY > 0)
            dy = Math.max(N2 - s0, Math.min(S2 - s0, dy)), n1 = n0, s1 = s0 + dy;
          break;
        }
        case MODE_CENTER: {
          if (signX)
            w1 = Math.max(W2, Math.min(E2, w0 - dx * signX)), e1 = Math.max(W2, Math.min(E2, e0 + dx * signX));
          if (signY)
            n1 = Math.max(N2, Math.min(S2, n0 - dy * signY)), s1 = Math.max(N2, Math.min(S2, s0 + dy * signY));
          break;
        }
      }
      if (e1 < w1) {
        signX *= -1;
        t4 = w0, w0 = e0, e0 = t4;
        t4 = w1, w1 = e1, e1 = t4;
        if (type2 in flipX)
          overlay.attr("cursor", cursors[type2 = flipX[type2]]);
      }
      if (s1 < n1) {
        signY *= -1;
        t4 = n0, n0 = s0, s0 = t4;
        t4 = n1, n1 = s1, s1 = t4;
        if (type2 in flipY)
          overlay.attr("cursor", cursors[type2 = flipY[type2]]);
      }
      if (state.selection)
        selection2 = state.selection;
      if (lockX)
        w1 = selection2[0][0], e1 = selection2[1][0];
      if (lockY)
        n1 = selection2[0][1], s1 = selection2[1][1];
      if (selection2[0][0] !== w1 || selection2[0][1] !== n1 || selection2[1][0] !== e1 || selection2[1][1] !== s1) {
        state.selection = [[w1, n1], [e1, s1]];
        redraw.call(that);
        emit.brush();
      }
    }
    function ended() {
      nopropagation$1();
      if (event.touches) {
        if (event.touches.length)
          return;
        if (touchending)
          clearTimeout(touchending);
        touchending = setTimeout(function() {
          touchending = null;
        }, 500);
      } else {
        yesdrag(event.view, moving);
        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      }
      group.attr("pointer-events", "all");
      overlay.attr("cursor", cursors.overlay);
      if (state.selection)
        selection2 = state.selection;
      if (empty(selection2))
        state.selection = null, redraw.call(that);
      emit.end();
    }
    function keydowned() {
      switch (event.keyCode) {
        case 16: {
          shifting = signX && signY;
          break;
        }
        case 18: {
          if (mode === MODE_HANDLE) {
            if (signX)
              e0 = e1 - dx * signX, w0 = w1 + dx * signX;
            if (signY)
              s0 = s1 - dy * signY, n0 = n1 + dy * signY;
            mode = MODE_CENTER;
            move();
          }
          break;
        }
        case 32: {
          if (mode === MODE_HANDLE || mode === MODE_CENTER) {
            if (signX < 0)
              e0 = e1 - dx;
            else if (signX > 0)
              w0 = w1 - dx;
            if (signY < 0)
              s0 = s1 - dy;
            else if (signY > 0)
              n0 = n1 - dy;
            mode = MODE_SPACE;
            overlay.attr("cursor", cursors.selection);
            move();
          }
          break;
        }
        default:
          return;
      }
      noevent$1();
    }
    function keyupped() {
      switch (event.keyCode) {
        case 16: {
          if (shifting) {
            lockX = lockY = shifting = false;
            move();
          }
          break;
        }
        case 18: {
          if (mode === MODE_CENTER) {
            if (signX < 0)
              e0 = e1;
            else if (signX > 0)
              w0 = w1;
            if (signY < 0)
              s0 = s1;
            else if (signY > 0)
              n0 = n1;
            mode = MODE_HANDLE;
            move();
          }
          break;
        }
        case 32: {
          if (mode === MODE_SPACE) {
            if (event.altKey) {
              if (signX)
                e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY)
                s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode = MODE_CENTER;
            } else {
              if (signX < 0)
                e0 = e1;
              else if (signX > 0)
                w0 = w1;
              if (signY < 0)
                s0 = s1;
              else if (signY > 0)
                n0 = n1;
              mode = MODE_HANDLE;
            }
            overlay.attr("cursor", cursors[type2]);
            move();
          }
          break;
        }
        default:
          return;
      }
      noevent$1();
    }
  }
  function touchmoved() {
    emitter(this, arguments).moved();
  }
  function touchended() {
    emitter(this, arguments).ended();
  }
  function initialize2() {
    var state = this.__brush || { selection: null };
    state.extent = number2(extent2.apply(this, arguments));
    state.dim = dim;
    return state;
  }
  brush2.extent = function(_2) {
    return arguments.length ? (extent2 = typeof _2 === "function" ? _2 : constant$9(number2(_2)), brush2) : extent2;
  };
  brush2.filter = function(_2) {
    return arguments.length ? (filter = typeof _2 === "function" ? _2 : constant$9(!!_2), brush2) : filter;
  };
  brush2.touchable = function(_2) {
    return arguments.length ? (touchable = typeof _2 === "function" ? _2 : constant$9(!!_2), brush2) : touchable;
  };
  brush2.handleSize = function(_2) {
    return arguments.length ? (handleSize = +_2, brush2) : handleSize;
  };
  brush2.keyModifiers = function(_2) {
    return arguments.length ? (keys2 = !!_2, brush2) : keys2;
  };
  brush2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? brush2 : value;
  };
  return brush2;
}
var cos$2 = Math.cos;
var sin$2 = Math.sin;
var pi$3 = Math.PI;
var halfPi$2 = pi$3 / 2;
var tau$3 = pi$3 * 2;
var max$1 = Math.max;
function compareValue(compare2) {
  return function(a2, b) {
    return compare2(
      a2.source.value + a2.target.value,
      b.source.value + b.target.value
    );
  };
}
function chord() {
  var padAngle = 0, sortGroups = null, sortSubgroups = null, sortChords = null;
  function chord2(matrix) {
    var n = matrix.length, groupSums = [], groupIndex = sequence(n), subgroupIndex = [], chords = [], groups = chords.groups = new Array(n), subgroups = new Array(n * n), k2, x2, x02, dx, i, j2;
    k2 = 0, i = -1;
    while (++i < n) {
      x2 = 0, j2 = -1;
      while (++j2 < n) {
        x2 += matrix[i][j2];
      }
      groupSums.push(x2);
      subgroupIndex.push(sequence(n));
      k2 += x2;
    }
    if (sortGroups)
      groupIndex.sort(function(a2, b) {
        return sortGroups(groupSums[a2], groupSums[b]);
      });
    if (sortSubgroups)
      subgroupIndex.forEach(function(d, i2) {
        d.sort(function(a2, b) {
          return sortSubgroups(matrix[i2][a2], matrix[i2][b]);
        });
      });
    k2 = max$1(0, tau$3 - padAngle * n) / k2;
    dx = k2 ? padAngle : tau$3 / n;
    x2 = 0, i = -1;
    while (++i < n) {
      x02 = x2, j2 = -1;
      while (++j2 < n) {
        var di = groupIndex[i], dj = subgroupIndex[di][j2], v = matrix[di][dj], a0 = x2, a1 = x2 += v * k2;
        subgroups[dj * n + di] = {
          index: di,
          subindex: dj,
          startAngle: a0,
          endAngle: a1,
          value: v
        };
      }
      groups[di] = {
        index: di,
        startAngle: x02,
        endAngle: x2,
        value: groupSums[di]
      };
      x2 += dx;
    }
    i = -1;
    while (++i < n) {
      j2 = i - 1;
      while (++j2 < n) {
        var source = subgroups[j2 * n + i], target = subgroups[i * n + j2];
        if (source.value || target.value) {
          chords.push(source.value < target.value ? { source: target, target: source } : { source, target });
        }
      }
    }
    return sortChords ? chords.sort(sortChords) : chords;
  }
  chord2.padAngle = function(_2) {
    return arguments.length ? (padAngle = max$1(0, _2), chord2) : padAngle;
  };
  chord2.sortGroups = function(_2) {
    return arguments.length ? (sortGroups = _2, chord2) : sortGroups;
  };
  chord2.sortSubgroups = function(_2) {
    return arguments.length ? (sortSubgroups = _2, chord2) : sortSubgroups;
  };
  chord2.sortChords = function(_2) {
    return arguments.length ? (_2 == null ? sortChords = null : (sortChords = compareValue(_2))._ = _2, chord2) : sortChords && sortChords._;
  };
  return chord2;
}
var slice$4 = Array.prototype.slice;
function constant$8(x2) {
  return function() {
    return x2;
  };
}
var pi$2 = Math.PI, tau$2 = 2 * pi$2, epsilon$3 = 1e-6, tauEpsilon = tau$2 - epsilon$3;
function Path() {
  this._x0 = this._y0 = this._x1 = this._y1 = null;
  this._ = "";
}
function path() {
  return new Path();
}
Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x2, y2) {
    this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x2, y2) {
    this._ += "L" + (this._x1 = +x2) + "," + (this._y1 = +y2);
  },
  quadraticCurveTo: function(x12, y12, x2, y2) {
    this._ += "Q" + +x12 + "," + +y12 + "," + (this._x1 = +x2) + "," + (this._y1 = +y2);
  },
  bezierCurveTo: function(x12, y12, x2, y2, x3, y3) {
    this._ += "C" + +x12 + "," + +y12 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x3) + "," + (this._y1 = +y3);
  },
  arcTo: function(x12, y12, x2, y2, r) {
    x12 = +x12, y12 = +y12, x2 = +x2, y2 = +y2, r = +r;
    var x02 = this._x1, y02 = this._y1, x21 = x2 - x12, y21 = y2 - y12, x01 = x02 - x12, y01 = y02 - y12, l01_2 = x01 * x01 + y01 * y01;
    if (r < 0)
      throw new Error("negative radius: " + r);
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x12) + "," + (this._y1 = y12);
    } else if (!(l01_2 > epsilon$3))
      ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$3) || !r) {
      this._ += "L" + (this._x1 = x12) + "," + (this._y1 = y12);
    } else {
      var x20 = x2 - x02, y20 = y2 - y02, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l2 = r * Math.tan((pi$2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l2 / l01, t21 = l2 / l21;
      if (Math.abs(t01 - 1) > epsilon$3) {
        this._ += "L" + (x12 + t01 * x01) + "," + (y12 + t01 * y01);
      }
      this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x12 + t21 * x21) + "," + (this._y1 = y12 + t21 * y21);
    }
  },
  arc: function(x2, y2, r, a0, a1, ccw) {
    x2 = +x2, y2 = +y2, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0), dy = r * Math.sin(a0), x02 = x2 + dx, y02 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (r < 0)
      throw new Error("negative radius: " + r);
    if (this._x1 === null) {
      this._ += "M" + x02 + "," + y02;
    } else if (Math.abs(this._x1 - x02) > epsilon$3 || Math.abs(this._y1 - y02) > epsilon$3) {
      this._ += "L" + x02 + "," + y02;
    }
    if (!r)
      return;
    if (da < 0)
      da = da % tau$2 + tau$2;
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x2 - dx) + "," + (y2 - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x02) + "," + (this._y1 = y02);
    } else if (da > epsilon$3) {
      this._ += "A" + r + "," + r + ",0," + +(da >= pi$2) + "," + cw + "," + (this._x1 = x2 + r * Math.cos(a1)) + "," + (this._y1 = y2 + r * Math.sin(a1));
    }
  },
  rect: function(x2, y2, w2, h2) {
    this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2) + "h" + +w2 + "v" + +h2 + "h" + -w2 + "Z";
  },
  toString: function() {
    return this._;
  }
};
function defaultSource$1(d) {
  return d.source;
}
function defaultTarget(d) {
  return d.target;
}
function defaultRadius$1(d) {
  return d.radius;
}
function defaultStartAngle(d) {
  return d.startAngle;
}
function defaultEndAngle(d) {
  return d.endAngle;
}
function ribbon() {
  var source = defaultSource$1, target = defaultTarget, radius = defaultRadius$1, startAngle = defaultStartAngle, endAngle = defaultEndAngle, context = null;
  function ribbon2() {
    var buffer2, argv = slice$4.call(arguments), s2 = source.apply(this, argv), t4 = target.apply(this, argv), sr = +radius.apply(this, (argv[0] = s2, argv)), sa0 = startAngle.apply(this, argv) - halfPi$2, sa1 = endAngle.apply(this, argv) - halfPi$2, sx0 = sr * cos$2(sa0), sy0 = sr * sin$2(sa0), tr = +radius.apply(this, (argv[0] = t4, argv)), ta0 = startAngle.apply(this, argv) - halfPi$2, ta1 = endAngle.apply(this, argv) - halfPi$2;
    if (!context)
      context = buffer2 = path();
    context.moveTo(sx0, sy0);
    context.arc(0, 0, sr, sa0, sa1);
    if (sa0 !== ta0 || sa1 !== ta1) {
      context.quadraticCurveTo(0, 0, tr * cos$2(ta0), tr * sin$2(ta0));
      context.arc(0, 0, tr, ta0, ta1);
    }
    context.quadraticCurveTo(0, 0, sx0, sy0);
    context.closePath();
    if (buffer2)
      return context = null, buffer2 + "" || null;
  }
  ribbon2.radius = function(_2) {
    return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant$8(+_2), ribbon2) : radius;
  };
  ribbon2.startAngle = function(_2) {
    return arguments.length ? (startAngle = typeof _2 === "function" ? _2 : constant$8(+_2), ribbon2) : startAngle;
  };
  ribbon2.endAngle = function(_2) {
    return arguments.length ? (endAngle = typeof _2 === "function" ? _2 : constant$8(+_2), ribbon2) : endAngle;
  };
  ribbon2.source = function(_2) {
    return arguments.length ? (source = _2, ribbon2) : source;
  };
  ribbon2.target = function(_2) {
    return arguments.length ? (target = _2, ribbon2) : target;
  };
  ribbon2.context = function(_2) {
    return arguments.length ? (context = _2 == null ? null : _2, ribbon2) : context;
  };
  return ribbon2;
}
var prefix = "$";
function Map$3() {
}
Map$3.prototype = map$2.prototype = {
  constructor: Map$3,
  has: function(key) {
    return prefix + key in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this)
      if (property[0] === prefix)
        delete this[property];
  },
  keys: function() {
    var keys2 = [];
    for (var property in this)
      if (property[0] === prefix)
        keys2.push(property.slice(1));
    return keys2;
  },
  values: function() {
    var values2 = [];
    for (var property in this)
      if (property[0] === prefix)
        values2.push(this[property]);
    return values2;
  },
  entries: function() {
    var entries2 = [];
    for (var property in this)
      if (property[0] === prefix)
        entries2.push({ key: property.slice(1), value: this[property] });
    return entries2;
  },
  size: function() {
    var size = 0;
    for (var property in this)
      if (property[0] === prefix)
        ++size;
    return size;
  },
  empty: function() {
    for (var property in this)
      if (property[0] === prefix)
        return false;
    return true;
  },
  each: function(f2) {
    for (var property in this)
      if (property[0] === prefix)
        f2(this[property], property.slice(1), this);
  }
};
function map$2(object2, f2) {
  var map2 = new Map$3();
  if (object2 instanceof Map$3)
    object2.each(function(value, key2) {
      map2.set(key2, value);
    });
  else if (Array.isArray(object2)) {
    var i = -1, n = object2.length, o;
    if (f2 == null)
      while (++i < n)
        map2.set(i, object2[i]);
    else
      while (++i < n)
        map2.set(f2(o = object2[i], i, object2), o);
  } else if (object2)
    for (var key in object2)
      map2.set(key, object2[key]);
  return map2;
}
function nest() {
  var keys2 = [], sortKeys = [], sortValues, rollup, nest2;
  function apply2(array2, depth, createResult, setResult) {
    if (depth >= keys2.length) {
      if (sortValues != null)
        array2.sort(sortValues);
      return rollup != null ? rollup(array2) : array2;
    }
    var i = -1, n = array2.length, key = keys2[depth++], keyValue, value, valuesByKey = map$2(), values2, result = createResult();
    while (++i < n) {
      if (values2 = valuesByKey.get(keyValue = key(value = array2[i]) + "")) {
        values2.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }
    valuesByKey.each(function(values3, key2) {
      setResult(result, key2, apply2(values3, depth, createResult, setResult));
    });
    return result;
  }
  function entries2(map2, depth) {
    if (++depth > keys2.length)
      return map2;
    var array2, sortKey = sortKeys[depth - 1];
    if (rollup != null && depth >= keys2.length)
      array2 = map2.entries();
    else
      array2 = [], map2.each(function(v, k2) {
        array2.push({ key: k2, values: entries2(v, depth) });
      });
    return sortKey != null ? array2.sort(function(a2, b) {
      return sortKey(a2.key, b.key);
    }) : array2;
  }
  return nest2 = {
    object: function(array2) {
      return apply2(array2, 0, createObject, setObject);
    },
    map: function(array2) {
      return apply2(array2, 0, createMap, setMap);
    },
    entries: function(array2) {
      return entries2(apply2(array2, 0, createMap, setMap), 0);
    },
    key: function(d) {
      keys2.push(d);
      return nest2;
    },
    sortKeys: function(order2) {
      sortKeys[keys2.length - 1] = order2;
      return nest2;
    },
    sortValues: function(order2) {
      sortValues = order2;
      return nest2;
    },
    rollup: function(f2) {
      rollup = f2;
      return nest2;
    }
  };
}
function createObject() {
  return {};
}
function setObject(object2, key, value) {
  object2[key] = value;
}
function createMap() {
  return map$2();
}
function setMap(map2, key, value) {
  map2.set(key, value);
}
function Set$1() {
}
var proto = map$2.prototype;
Set$1.prototype = set.prototype = {
  constructor: Set$1,
  has: proto.has,
  add: function(value) {
    value += "";
    this[prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};
function set(object2, f2) {
  var set2 = new Set$1();
  if (object2 instanceof Set$1)
    object2.each(function(value) {
      set2.add(value);
    });
  else if (object2) {
    var i = -1, n = object2.length;
    if (f2 == null)
      while (++i < n)
        set2.add(object2[i]);
    else
      while (++i < n)
        set2.add(f2(object2[i], i, object2));
  }
  return set2;
}
function keys(map2) {
  var keys2 = [];
  for (var key in map2)
    keys2.push(key);
  return keys2;
}
function values(map2) {
  var values2 = [];
  for (var key in map2)
    values2.push(map2[key]);
  return values2;
}
function entries(map2) {
  var entries2 = [];
  for (var key in map2)
    entries2.push({ key, value: map2[key] });
  return entries2;
}
var array$1 = Array.prototype;
var slice$3 = array$1.slice;
function ascending$1(a2, b) {
  return a2 - b;
}
function area$3(ring) {
  var i = 0, n = ring.length, area2 = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
  while (++i < n)
    area2 += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
  return area2;
}
function constant$7(x2) {
  return function() {
    return x2;
  };
}
function contains$2(ring, hole) {
  var i = -1, n = hole.length, c2;
  while (++i < n)
    if (c2 = ringContains(ring, hole[i]))
      return c2;
  return 0;
}
function ringContains(ring, point2) {
  var x2 = point2[0], y2 = point2[1], contains2 = -1;
  for (var i = 0, n = ring.length, j2 = n - 1; i < n; j2 = i++) {
    var pi2 = ring[i], xi = pi2[0], yi = pi2[1], pj = ring[j2], xj = pj[0], yj = pj[1];
    if (segmentContains(pi2, pj, point2))
      return 0;
    if (yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi)
      contains2 = -contains2;
  }
  return contains2;
}
function segmentContains(a2, b, c2) {
  var i;
  return collinear(a2, b, c2) && within(a2[i = +(a2[0] === b[0])], c2[i], b[i]);
}
function collinear(a2, b, c2) {
  return (b[0] - a2[0]) * (c2[1] - a2[1]) === (c2[0] - a2[0]) * (b[1] - a2[1]);
}
function within(p, q, r) {
  return p <= q && q <= r || r <= q && q <= p;
}
function noop$2() {
}
var cases = [
  [],
  [[[1, 1.5], [0.5, 1]]],
  [[[1.5, 1], [1, 1.5]]],
  [[[1.5, 1], [0.5, 1]]],
  [[[1, 0.5], [1.5, 1]]],
  [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]],
  [[[1, 0.5], [1, 1.5]]],
  [[[1, 0.5], [0.5, 1]]],
  [[[0.5, 1], [1, 0.5]]],
  [[[1, 1.5], [1, 0.5]]],
  [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]],
  [[[1.5, 1], [1, 0.5]]],
  [[[0.5, 1], [1.5, 1]]],
  [[[1, 1.5], [1.5, 1]]],
  [[[0.5, 1], [1, 1.5]]],
  []
];
function contours() {
  var dx = 1, dy = 1, threshold2 = thresholdSturges, smooth = smoothLinear;
  function contours2(values2) {
    var tz = threshold2(values2);
    if (!Array.isArray(tz)) {
      var domain = extent$1(values2), start2 = domain[0], stop = domain[1];
      tz = tickStep(start2, stop, tz);
      tz = sequence(Math.floor(start2 / tz) * tz, Math.floor(stop / tz) * tz, tz);
    } else {
      tz = tz.slice().sort(ascending$1);
    }
    return tz.map(function(value) {
      return contour(values2, value);
    });
  }
  function contour(values2, value) {
    var polygons = [], holes = [];
    isorings(values2, value, function(ring) {
      smooth(ring, values2, value);
      if (area$3(ring) > 0)
        polygons.push([ring]);
      else
        holes.push(ring);
    });
    holes.forEach(function(hole) {
      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
        if (contains$2((polygon = polygons[i])[0], hole) !== -1) {
          polygon.push(hole);
          return;
        }
      }
    });
    return {
      type: "MultiPolygon",
      value,
      coordinates: polygons
    };
  }
  function isorings(values2, value, callback) {
    var fragmentByStart = new Array(), fragmentByEnd = new Array(), x2, y2, t02, t12, t22, t32;
    x2 = y2 = -1;
    t12 = values2[0] >= value;
    cases[t12 << 1].forEach(stitch);
    while (++x2 < dx - 1) {
      t02 = t12, t12 = values2[x2 + 1] >= value;
      cases[t02 | t12 << 1].forEach(stitch);
    }
    cases[t12 << 0].forEach(stitch);
    while (++y2 < dy - 1) {
      x2 = -1;
      t12 = values2[y2 * dx + dx] >= value;
      t22 = values2[y2 * dx] >= value;
      cases[t12 << 1 | t22 << 2].forEach(stitch);
      while (++x2 < dx - 1) {
        t02 = t12, t12 = values2[y2 * dx + dx + x2 + 1] >= value;
        t32 = t22, t22 = values2[y2 * dx + x2 + 1] >= value;
        cases[t02 | t12 << 1 | t22 << 2 | t32 << 3].forEach(stitch);
      }
      cases[t12 | t22 << 3].forEach(stitch);
    }
    x2 = -1;
    t22 = values2[y2 * dx] >= value;
    cases[t22 << 2].forEach(stitch);
    while (++x2 < dx - 1) {
      t32 = t22, t22 = values2[y2 * dx + x2 + 1] >= value;
      cases[t22 << 2 | t32 << 3].forEach(stitch);
    }
    cases[t22 << 3].forEach(stitch);
    function stitch(line2) {
      var start2 = [line2[0][0] + x2, line2[0][1] + y2], end2 = [line2[1][0] + x2, line2[1][1] + y2], startIndex = index2(start2), endIndex = index2(end2), f2, g2;
      if (f2 = fragmentByEnd[startIndex]) {
        if (g2 = fragmentByStart[endIndex]) {
          delete fragmentByEnd[f2.end];
          delete fragmentByStart[g2.start];
          if (f2 === g2) {
            f2.ring.push(end2);
            callback(f2.ring);
          } else {
            fragmentByStart[f2.start] = fragmentByEnd[g2.end] = { start: f2.start, end: g2.end, ring: f2.ring.concat(g2.ring) };
          }
        } else {
          delete fragmentByEnd[f2.end];
          f2.ring.push(end2);
          fragmentByEnd[f2.end = endIndex] = f2;
        }
      } else if (f2 = fragmentByStart[endIndex]) {
        if (g2 = fragmentByEnd[startIndex]) {
          delete fragmentByStart[f2.start];
          delete fragmentByEnd[g2.end];
          if (f2 === g2) {
            f2.ring.push(end2);
            callback(f2.ring);
          } else {
            fragmentByStart[g2.start] = fragmentByEnd[f2.end] = { start: g2.start, end: f2.end, ring: g2.ring.concat(f2.ring) };
          }
        } else {
          delete fragmentByStart[f2.start];
          f2.ring.unshift(start2);
          fragmentByStart[f2.start = startIndex] = f2;
        }
      } else {
        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = { start: startIndex, end: endIndex, ring: [start2, end2] };
      }
    }
  }
  function index2(point2) {
    return point2[0] * 2 + point2[1] * (dx + 1) * 4;
  }
  function smoothLinear(ring, values2, value) {
    ring.forEach(function(point2) {
      var x2 = point2[0], y2 = point2[1], xt2 = x2 | 0, yt2 = y2 | 0, v0, v1 = values2[yt2 * dx + xt2];
      if (x2 > 0 && x2 < dx && xt2 === x2) {
        v0 = values2[yt2 * dx + xt2 - 1];
        point2[0] = x2 + (value - v0) / (v1 - v0) - 0.5;
      }
      if (y2 > 0 && y2 < dy && yt2 === y2) {
        v0 = values2[(yt2 - 1) * dx + xt2];
        point2[1] = y2 + (value - v0) / (v1 - v0) - 0.5;
      }
    });
  }
  contours2.contour = contour;
  contours2.size = function(_2) {
    if (!arguments.length)
      return [dx, dy];
    var _0 = Math.ceil(_2[0]), _1 = Math.ceil(_2[1]);
    if (!(_0 > 0) || !(_1 > 0))
      throw new Error("invalid size");
    return dx = _0, dy = _1, contours2;
  };
  contours2.thresholds = function(_2) {
    return arguments.length ? (threshold2 = typeof _2 === "function" ? _2 : Array.isArray(_2) ? constant$7(slice$3.call(_2)) : constant$7(_2), contours2) : threshold2;
  };
  contours2.smooth = function(_2) {
    return arguments.length ? (smooth = _2 ? smoothLinear : noop$2, contours2) : smooth === smoothLinear;
  };
  return contours2;
}
function blurX(source, target, r) {
  var n = source.width, m = source.height, w2 = (r << 1) + 1;
  for (var j2 = 0; j2 < m; ++j2) {
    for (var i = 0, sr = 0; i < n + r; ++i) {
      if (i < n) {
        sr += source.data[i + j2 * n];
      }
      if (i >= r) {
        if (i >= w2) {
          sr -= source.data[i - w2 + j2 * n];
        }
        target.data[i - r + j2 * n] = sr / Math.min(i + 1, n - 1 + w2 - i, w2);
      }
    }
  }
}
function blurY(source, target, r) {
  var n = source.width, m = source.height, w2 = (r << 1) + 1;
  for (var i = 0; i < n; ++i) {
    for (var j2 = 0, sr = 0; j2 < m + r; ++j2) {
      if (j2 < m) {
        sr += source.data[i + j2 * n];
      }
      if (j2 >= r) {
        if (j2 >= w2) {
          sr -= source.data[i + (j2 - w2) * n];
        }
        target.data[i + (j2 - r) * n] = sr / Math.min(j2 + 1, m - 1 + w2 - j2, w2);
      }
    }
  }
}
function defaultX$1(d) {
  return d[0];
}
function defaultY$1(d) {
  return d[1];
}
function defaultWeight() {
  return 1;
}
function density() {
  var x2 = defaultX$1, y2 = defaultY$1, weight = defaultWeight, dx = 960, dy = 500, r = 20, k2 = 2, o = r * 3, n = dx + o * 2 >> k2, m = dy + o * 2 >> k2, threshold2 = constant$7(20);
  function density2(data2) {
    var values0 = new Float32Array(n * m), values1 = new Float32Array(n * m);
    data2.forEach(function(d, i, data3) {
      var xi = +x2(d, i, data3) + o >> k2, yi = +y2(d, i, data3) + o >> k2, wi = +weight(d, i, data3);
      if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
        values0[xi + yi * n] += wi;
      }
    });
    blurX({ width: n, height: m, data: values0 }, { width: n, height: m, data: values1 }, r >> k2);
    blurY({ width: n, height: m, data: values1 }, { width: n, height: m, data: values0 }, r >> k2);
    blurX({ width: n, height: m, data: values0 }, { width: n, height: m, data: values1 }, r >> k2);
    blurY({ width: n, height: m, data: values1 }, { width: n, height: m, data: values0 }, r >> k2);
    blurX({ width: n, height: m, data: values0 }, { width: n, height: m, data: values1 }, r >> k2);
    blurY({ width: n, height: m, data: values1 }, { width: n, height: m, data: values0 }, r >> k2);
    var tz = threshold2(values0);
    if (!Array.isArray(tz)) {
      var stop = max$2(values0);
      tz = tickStep(0, stop, tz);
      tz = sequence(0, Math.floor(stop / tz) * tz, tz);
      tz.shift();
    }
    return contours().thresholds(tz).size([n, m])(values0).map(transform2);
  }
  function transform2(geometry) {
    geometry.value *= Math.pow(2, -2 * k2);
    geometry.coordinates.forEach(transformPolygon);
    return geometry;
  }
  function transformPolygon(coordinates2) {
    coordinates2.forEach(transformRing);
  }
  function transformRing(coordinates2) {
    coordinates2.forEach(transformPoint);
  }
  function transformPoint(coordinates2) {
    coordinates2[0] = coordinates2[0] * Math.pow(2, k2) - o;
    coordinates2[1] = coordinates2[1] * Math.pow(2, k2) - o;
  }
  function resize() {
    o = r * 3;
    n = dx + o * 2 >> k2;
    m = dy + o * 2 >> k2;
    return density2;
  }
  density2.x = function(_2) {
    return arguments.length ? (x2 = typeof _2 === "function" ? _2 : constant$7(+_2), density2) : x2;
  };
  density2.y = function(_2) {
    return arguments.length ? (y2 = typeof _2 === "function" ? _2 : constant$7(+_2), density2) : y2;
  };
  density2.weight = function(_2) {
    return arguments.length ? (weight = typeof _2 === "function" ? _2 : constant$7(+_2), density2) : weight;
  };
  density2.size = function(_2) {
    if (!arguments.length)
      return [dx, dy];
    var _0 = Math.ceil(_2[0]), _1 = Math.ceil(_2[1]);
    if (!(_0 >= 0) && !(_0 >= 0))
      throw new Error("invalid size");
    return dx = _0, dy = _1, resize();
  };
  density2.cellSize = function(_2) {
    if (!arguments.length)
      return 1 << k2;
    if (!((_2 = +_2) >= 1))
      throw new Error("invalid cell size");
    return k2 = Math.floor(Math.log(_2) / Math.LN2), resize();
  };
  density2.thresholds = function(_2) {
    return arguments.length ? (threshold2 = typeof _2 === "function" ? _2 : Array.isArray(_2) ? constant$7(slice$3.call(_2)) : constant$7(_2), density2) : threshold2;
  };
  density2.bandwidth = function(_2) {
    if (!arguments.length)
      return Math.sqrt(r * (r + 1));
    if (!((_2 = +_2) >= 0))
      throw new Error("invalid bandwidth");
    return r = Math.round((Math.sqrt(4 * _2 * _2 + 1) - 1) / 2), resize();
  };
  return density2;
}
var EOL = {}, EOF = {}, QUOTE = 34, NEWLINE = 10, RETURN = 13;
function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name2, i) {
    return JSON.stringify(name2) + ": d[" + i + '] || ""';
  }).join(",") + "}");
}
function customConverter(columns, f2) {
  var object2 = objectConverter(columns);
  return function(row, i) {
    return f2(object2(row), i, columns);
  };
}
function inferColumns(rows) {
  var columnSet = /* @__PURE__ */ Object.create(null), columns = [];
  rows.forEach(function(row) {
    for (var column2 in row) {
      if (!(column2 in columnSet)) {
        columns.push(columnSet[column2] = column2);
      }
    }
  });
  return columns;
}
function pad$1(value, width2) {
  var s2 = value + "", length2 = s2.length;
  return length2 < width2 ? new Array(width2 - length2 + 1).join(0) + s2 : s2;
}
function formatYear$1(year2) {
  return year2 < 0 ? "-" + pad$1(-year2, 6) : year2 > 9999 ? "+" + pad$1(year2, 6) : pad$1(year2, 4);
}
function formatDate(date2) {
  var hours2 = date2.getUTCHours(), minutes2 = date2.getUTCMinutes(), seconds2 = date2.getUTCSeconds(), milliseconds2 = date2.getUTCMilliseconds();
  return isNaN(date2) ? "Invalid Date" : formatYear$1(date2.getUTCFullYear()) + "-" + pad$1(date2.getUTCMonth() + 1, 2) + "-" + pad$1(date2.getUTCDate(), 2) + (milliseconds2 ? "T" + pad$1(hours2, 2) + ":" + pad$1(minutes2, 2) + ":" + pad$1(seconds2, 2) + "." + pad$1(milliseconds2, 3) + "Z" : seconds2 ? "T" + pad$1(hours2, 2) + ":" + pad$1(minutes2, 2) + ":" + pad$1(seconds2, 2) + "Z" : minutes2 || hours2 ? "T" + pad$1(hours2, 2) + ":" + pad$1(minutes2, 2) + "Z" : "");
}
function dsvFormat(delimiter2) {
  var reFormat = new RegExp('["' + delimiter2 + "\n\r]"), DELIMITER = delimiter2.charCodeAt(0);
  function parse2(text2, f2) {
    var convert, columns, rows = parseRows(text2, function(row, i) {
      if (convert)
        return convert(row, i - 1);
      columns = row, convert = f2 ? customConverter(row, f2) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }
  function parseRows(text2, f2) {
    var rows = [], N2 = text2.length, I = 0, n = 0, t4, eof = N2 <= 0, eol = false;
    if (text2.charCodeAt(N2 - 1) === NEWLINE)
      --N2;
    if (text2.charCodeAt(N2 - 1) === RETURN)
      --N2;
    function token2() {
      if (eof)
        return EOF;
      if (eol)
        return eol = false, EOL;
      var i, j2 = I, c2;
      if (text2.charCodeAt(j2) === QUOTE) {
        while (I++ < N2 && text2.charCodeAt(I) !== QUOTE || text2.charCodeAt(++I) === QUOTE)
          ;
        if ((i = I) >= N2)
          eof = true;
        else if ((c2 = text2.charCodeAt(I++)) === NEWLINE)
          eol = true;
        else if (c2 === RETURN) {
          eol = true;
          if (text2.charCodeAt(I) === NEWLINE)
            ++I;
        }
        return text2.slice(j2 + 1, i - 1).replace(/""/g, '"');
      }
      while (I < N2) {
        if ((c2 = text2.charCodeAt(i = I++)) === NEWLINE)
          eol = true;
        else if (c2 === RETURN) {
          eol = true;
          if (text2.charCodeAt(I) === NEWLINE)
            ++I;
        } else if (c2 !== DELIMITER)
          continue;
        return text2.slice(j2, i);
      }
      return eof = true, text2.slice(j2, N2);
    }
    while ((t4 = token2()) !== EOF) {
      var row = [];
      while (t4 !== EOL && t4 !== EOF)
        row.push(t4), t4 = token2();
      if (f2 && (row = f2(row, n++)) == null)
        continue;
      rows.push(row);
    }
    return rows;
  }
  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column2) {
        return formatValue(row[column2]);
      }).join(delimiter2);
    });
  }
  function format2(rows, columns) {
    if (columns == null)
      columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter2)].concat(preformatBody(rows, columns)).join("\n");
  }
  function formatBody(rows, columns) {
    if (columns == null)
      columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }
  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }
  function formatRow(row) {
    return row.map(formatValue).join(delimiter2);
  }
  function formatValue(value) {
    return value == null ? "" : value instanceof Date ? formatDate(value) : reFormat.test(value += "") ? '"' + value.replace(/"/g, '""') + '"' : value;
  }
  return {
    parse: parse2,
    parseRows,
    format: format2,
    formatBody,
    formatRows,
    formatRow,
    formatValue
  };
}
var csv$1 = dsvFormat(",");
var csvParse = csv$1.parse;
var csvParseRows = csv$1.parseRows;
var csvFormat = csv$1.format;
var csvFormatBody = csv$1.formatBody;
var csvFormatRows = csv$1.formatRows;
var csvFormatRow = csv$1.formatRow;
var csvFormatValue = csv$1.formatValue;
var tsv$1 = dsvFormat("	");
var tsvParse = tsv$1.parse;
var tsvParseRows = tsv$1.parseRows;
var tsvFormat = tsv$1.format;
var tsvFormatBody = tsv$1.formatBody;
var tsvFormatRows = tsv$1.formatRows;
var tsvFormatRow = tsv$1.formatRow;
var tsvFormatValue = tsv$1.formatValue;
function autoType(object2) {
  for (var key in object2) {
    var value = object2[key].trim(), number3, m;
    if (!value)
      value = null;
    else if (value === "true")
      value = true;
    else if (value === "false")
      value = false;
    else if (value === "NaN")
      value = NaN;
    else if (!isNaN(number3 = +value))
      value = number3;
    else if (m = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
      if (fixtz && !!m[4] && !m[7])
        value = value.replace(/-/g, "/").replace(/T/, " ");
      value = new Date(value);
    } else
      continue;
    object2[key] = value;
  }
  return object2;
}
var fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();
function responseBlob(response) {
  if (!response.ok)
    throw new Error(response.status + " " + response.statusText);
  return response.blob();
}
function blob(input, init2) {
  return fetch(input, init2).then(responseBlob);
}
function responseArrayBuffer(response) {
  if (!response.ok)
    throw new Error(response.status + " " + response.statusText);
  return response.arrayBuffer();
}
function buffer(input, init2) {
  return fetch(input, init2).then(responseArrayBuffer);
}
function responseText(response) {
  if (!response.ok)
    throw new Error(response.status + " " + response.statusText);
  return response.text();
}
function text(input, init2) {
  return fetch(input, init2).then(responseText);
}
function dsvParse(parse2) {
  return function(input, init2, row) {
    if (arguments.length === 2 && typeof init2 === "function")
      row = init2, init2 = void 0;
    return text(input, init2).then(function(response) {
      return parse2(response, row);
    });
  };
}
function dsv(delimiter2, input, init2, row) {
  if (arguments.length === 3 && typeof init2 === "function")
    row = init2, init2 = void 0;
  var format2 = dsvFormat(delimiter2);
  return text(input, init2).then(function(response) {
    return format2.parse(response, row);
  });
}
var csv = dsvParse(csvParse);
var tsv = dsvParse(tsvParse);
function image(input, init2) {
  return new Promise(function(resolve, reject) {
    var image2 = new Image();
    for (var key in init2)
      image2[key] = init2[key];
    image2.onerror = reject;
    image2.onload = function() {
      resolve(image2);
    };
    image2.src = input;
  });
}
function responseJson(response) {
  if (!response.ok)
    throw new Error(response.status + " " + response.statusText);
  if (response.status === 204 || response.status === 205)
    return;
  return response.json();
}
function json(input, init2) {
  return fetch(input, init2).then(responseJson);
}
function parser$c(type2) {
  return function(input, init2) {
    return text(input, init2).then(function(text2) {
      return new DOMParser().parseFromString(text2, type2);
    });
  };
}
const xml = parser$c("application/xml");
var html = parser$c("text/html");
var svg = parser$c("image/svg+xml");
function center(x2, y2) {
  var nodes;
  if (x2 == null)
    x2 = 0;
  if (y2 == null)
    y2 = 0;
  function force() {
    var i, n = nodes.length, node2, sx = 0, sy = 0;
    for (i = 0; i < n; ++i) {
      node2 = nodes[i], sx += node2.x, sy += node2.y;
    }
    for (sx = sx / n - x2, sy = sy / n - y2, i = 0; i < n; ++i) {
      node2 = nodes[i], node2.x -= sx, node2.y -= sy;
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
  };
  force.x = function(_2) {
    return arguments.length ? (x2 = +_2, force) : x2;
  };
  force.y = function(_2) {
    return arguments.length ? (y2 = +_2, force) : y2;
  };
  return force;
}
function constant$6(x2) {
  return function() {
    return x2;
  };
}
function jiggle() {
  return (Math.random() - 0.5) * 1e-6;
}
function tree_add(d) {
  var x2 = +this._x.call(null, d), y2 = +this._y.call(null, d);
  return add$1(this.cover(x2, y2), x2, y2, d);
}
function add$1(tree2, x2, y2, d) {
  if (isNaN(x2) || isNaN(y2))
    return tree2;
  var parent, node2 = tree2._root, leaf = { data: d }, x02 = tree2._x0, y02 = tree2._y0, x12 = tree2._x1, y12 = tree2._y1, xm, ym, xp, yp, right2, bottom2, i, j2;
  if (!node2)
    return tree2._root = leaf, tree2;
  while (node2.length) {
    if (right2 = x2 >= (xm = (x02 + x12) / 2))
      x02 = xm;
    else
      x12 = xm;
    if (bottom2 = y2 >= (ym = (y02 + y12) / 2))
      y02 = ym;
    else
      y12 = ym;
    if (parent = node2, !(node2 = node2[i = bottom2 << 1 | right2]))
      return parent[i] = leaf, tree2;
  }
  xp = +tree2._x.call(null, node2.data);
  yp = +tree2._y.call(null, node2.data);
  if (x2 === xp && y2 === yp)
    return leaf.next = node2, parent ? parent[i] = leaf : tree2._root = leaf, tree2;
  do {
    parent = parent ? parent[i] = new Array(4) : tree2._root = new Array(4);
    if (right2 = x2 >= (xm = (x02 + x12) / 2))
      x02 = xm;
    else
      x12 = xm;
    if (bottom2 = y2 >= (ym = (y02 + y12) / 2))
      y02 = ym;
    else
      y12 = ym;
  } while ((i = bottom2 << 1 | right2) === (j2 = (yp >= ym) << 1 | xp >= xm));
  return parent[j2] = node2, parent[i] = leaf, tree2;
}
function addAll(data2) {
  var d, i, n = data2.length, x2, y2, xz = new Array(n), yz = new Array(n), x02 = Infinity, y02 = Infinity, x12 = -Infinity, y12 = -Infinity;
  for (i = 0; i < n; ++i) {
    if (isNaN(x2 = +this._x.call(null, d = data2[i])) || isNaN(y2 = +this._y.call(null, d)))
      continue;
    xz[i] = x2;
    yz[i] = y2;
    if (x2 < x02)
      x02 = x2;
    if (x2 > x12)
      x12 = x2;
    if (y2 < y02)
      y02 = y2;
    if (y2 > y12)
      y12 = y2;
  }
  if (x02 > x12 || y02 > y12)
    return this;
  this.cover(x02, y02).cover(x12, y12);
  for (i = 0; i < n; ++i) {
    add$1(this, xz[i], yz[i], data2[i]);
  }
  return this;
}
function tree_cover(x2, y2) {
  if (isNaN(x2 = +x2) || isNaN(y2 = +y2))
    return this;
  var x02 = this._x0, y02 = this._y0, x12 = this._x1, y12 = this._y1;
  if (isNaN(x02)) {
    x12 = (x02 = Math.floor(x2)) + 1;
    y12 = (y02 = Math.floor(y2)) + 1;
  } else {
    var z = x12 - x02, node2 = this._root, parent, i;
    while (x02 > x2 || x2 >= x12 || y02 > y2 || y2 >= y12) {
      i = (y2 < y02) << 1 | x2 < x02;
      parent = new Array(4), parent[i] = node2, node2 = parent, z *= 2;
      switch (i) {
        case 0:
          x12 = x02 + z, y12 = y02 + z;
          break;
        case 1:
          x02 = x12 - z, y12 = y02 + z;
          break;
        case 2:
          x12 = x02 + z, y02 = y12 - z;
          break;
        case 3:
          x02 = x12 - z, y02 = y12 - z;
          break;
      }
    }
    if (this._root && this._root.length)
      this._root = node2;
  }
  this._x0 = x02;
  this._y0 = y02;
  this._x1 = x12;
  this._y1 = y12;
  return this;
}
function tree_data() {
  var data2 = [];
  this.visit(function(node2) {
    if (!node2.length)
      do
        data2.push(node2.data);
      while (node2 = node2.next);
  });
  return data2;
}
function tree_extent(_2) {
  return arguments.length ? this.cover(+_2[0][0], +_2[0][1]).cover(+_2[1][0], +_2[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}
function Quad(node2, x02, y02, x12, y12) {
  this.node = node2;
  this.x0 = x02;
  this.y0 = y02;
  this.x1 = x12;
  this.y1 = y12;
}
function tree_find(x2, y2, radius) {
  var data2, x02 = this._x0, y02 = this._y0, x12, y12, x22, y22, x3 = this._x1, y3 = this._y1, quads = [], node2 = this._root, q, i;
  if (node2)
    quads.push(new Quad(node2, x02, y02, x3, y3));
  if (radius == null)
    radius = Infinity;
  else {
    x02 = x2 - radius, y02 = y2 - radius;
    x3 = x2 + radius, y3 = y2 + radius;
    radius *= radius;
  }
  while (q = quads.pop()) {
    if (!(node2 = q.node) || (x12 = q.x0) > x3 || (y12 = q.y0) > y3 || (x22 = q.x1) < x02 || (y22 = q.y1) < y02)
      continue;
    if (node2.length) {
      var xm = (x12 + x22) / 2, ym = (y12 + y22) / 2;
      quads.push(
        new Quad(node2[3], xm, ym, x22, y22),
        new Quad(node2[2], x12, ym, xm, y22),
        new Quad(node2[1], xm, y12, x22, ym),
        new Quad(node2[0], x12, y12, xm, ym)
      );
      if (i = (y2 >= ym) << 1 | x2 >= xm) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    } else {
      var dx = x2 - +this._x.call(null, node2.data), dy = y2 - +this._y.call(null, node2.data), d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x02 = x2 - d, y02 = y2 - d;
        x3 = x2 + d, y3 = y2 + d;
        data2 = node2.data;
      }
    }
  }
  return data2;
}
function tree_remove(d) {
  if (isNaN(x2 = +this._x.call(null, d)) || isNaN(y2 = +this._y.call(null, d)))
    return this;
  var parent, node2 = this._root, retainer, previous, next2, x02 = this._x0, y02 = this._y0, x12 = this._x1, y12 = this._y1, x2, y2, xm, ym, right2, bottom2, i, j2;
  if (!node2)
    return this;
  if (node2.length)
    while (true) {
      if (right2 = x2 >= (xm = (x02 + x12) / 2))
        x02 = xm;
      else
        x12 = xm;
      if (bottom2 = y2 >= (ym = (y02 + y12) / 2))
        y02 = ym;
      else
        y12 = ym;
      if (!(parent = node2, node2 = node2[i = bottom2 << 1 | right2]))
        return this;
      if (!node2.length)
        break;
      if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3])
        retainer = parent, j2 = i;
    }
  while (node2.data !== d)
    if (!(previous = node2, node2 = node2.next))
      return this;
  if (next2 = node2.next)
    delete node2.next;
  if (previous)
    return next2 ? previous.next = next2 : delete previous.next, this;
  if (!parent)
    return this._root = next2, this;
  next2 ? parent[i] = next2 : delete parent[i];
  if ((node2 = parent[0] || parent[1] || parent[2] || parent[3]) && node2 === (parent[3] || parent[2] || parent[1] || parent[0]) && !node2.length) {
    if (retainer)
      retainer[j2] = node2;
    else
      this._root = node2;
  }
  return this;
}
function removeAll(data2) {
  for (var i = 0, n = data2.length; i < n; ++i)
    this.remove(data2[i]);
  return this;
}
function tree_root() {
  return this._root;
}
function tree_size() {
  var size = 0;
  this.visit(function(node2) {
    if (!node2.length)
      do
        ++size;
      while (node2 = node2.next);
  });
  return size;
}
function tree_visit(callback) {
  var quads = [], q, node2 = this._root, child, x02, y02, x12, y12;
  if (node2)
    quads.push(new Quad(node2, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node2 = q.node, x02 = q.x0, y02 = q.y0, x12 = q.x1, y12 = q.y1) && node2.length) {
      var xm = (x02 + x12) / 2, ym = (y02 + y12) / 2;
      if (child = node2[3])
        quads.push(new Quad(child, xm, ym, x12, y12));
      if (child = node2[2])
        quads.push(new Quad(child, x02, ym, xm, y12));
      if (child = node2[1])
        quads.push(new Quad(child, xm, y02, x12, ym));
      if (child = node2[0])
        quads.push(new Quad(child, x02, y02, xm, ym));
    }
  }
  return this;
}
function tree_visitAfter(callback) {
  var quads = [], next2 = [], q;
  if (this._root)
    quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node2 = q.node;
    if (node2.length) {
      var child, x02 = q.x0, y02 = q.y0, x12 = q.x1, y12 = q.y1, xm = (x02 + x12) / 2, ym = (y02 + y12) / 2;
      if (child = node2[0])
        quads.push(new Quad(child, x02, y02, xm, ym));
      if (child = node2[1])
        quads.push(new Quad(child, xm, y02, x12, ym));
      if (child = node2[2])
        quads.push(new Quad(child, x02, ym, xm, y12));
      if (child = node2[3])
        quads.push(new Quad(child, xm, ym, x12, y12));
    }
    next2.push(q);
  }
  while (q = next2.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}
function defaultX(d) {
  return d[0];
}
function tree_x(_2) {
  return arguments.length ? (this._x = _2, this) : this._x;
}
function defaultY(d) {
  return d[1];
}
function tree_y(_2) {
  return arguments.length ? (this._y = _2, this) : this._y;
}
function quadtree(nodes, x2, y2) {
  var tree2 = new Quadtree(x2 == null ? defaultX : x2, y2 == null ? defaultY : y2, NaN, NaN, NaN, NaN);
  return nodes == null ? tree2 : tree2.addAll(nodes);
}
function Quadtree(x2, y2, x02, y02, x12, y12) {
  this._x = x2;
  this._y = y2;
  this._x0 = x02;
  this._y0 = y02;
  this._x1 = x12;
  this._y1 = y12;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy2 = { data: leaf.data }, next2 = copy2;
  while (leaf = leaf.next)
    next2 = next2.next = { data: leaf.data };
  return copy2;
}
var treeProto = quadtree.prototype = Quadtree.prototype;
treeProto.copy = function() {
  var copy2 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node2 = this._root, nodes, child;
  if (!node2)
    return copy2;
  if (!node2.length)
    return copy2._root = leaf_copy(node2), copy2;
  nodes = [{ source: node2, target: copy2._root = new Array(4) }];
  while (node2 = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node2.source[i]) {
        if (child.length)
          nodes.push({ source: child, target: node2.target[i] = new Array(4) });
        else
          node2.target[i] = leaf_copy(child);
      }
    }
  }
  return copy2;
};
treeProto.add = tree_add;
treeProto.addAll = addAll;
treeProto.cover = tree_cover;
treeProto.data = tree_data;
treeProto.extent = tree_extent;
treeProto.find = tree_find;
treeProto.remove = tree_remove;
treeProto.removeAll = removeAll;
treeProto.root = tree_root;
treeProto.size = tree_size;
treeProto.visit = tree_visit;
treeProto.visitAfter = tree_visitAfter;
treeProto.x = tree_x;
treeProto.y = tree_y;
function x$4(d) {
  return d.x + d.vx;
}
function y$4(d) {
  return d.y + d.vy;
}
function collide(radius) {
  var nodes, radii, strength = 1, iterations2 = 1;
  if (typeof radius !== "function")
    radius = constant$6(radius == null ? 1 : +radius);
  function force() {
    var i, n = nodes.length, tree2, node2, xi, yi, ri, ri2;
    for (var k2 = 0; k2 < iterations2; ++k2) {
      tree2 = quadtree(nodes, x$4, y$4).visitAfter(prepare);
      for (i = 0; i < n; ++i) {
        node2 = nodes[i];
        ri = radii[node2.index], ri2 = ri * ri;
        xi = node2.x + node2.vx;
        yi = node2.y + node2.vy;
        tree2.visit(apply2);
      }
    }
    function apply2(quad, x02, y02, x12, y12) {
      var data2 = quad.data, rj = quad.r, r = ri + rj;
      if (data2) {
        if (data2.index > node2.index) {
          var x2 = xi - data2.x - data2.vx, y2 = yi - data2.y - data2.vy, l2 = x2 * x2 + y2 * y2;
          if (l2 < r * r) {
            if (x2 === 0)
              x2 = jiggle(), l2 += x2 * x2;
            if (y2 === 0)
              y2 = jiggle(), l2 += y2 * y2;
            l2 = (r - (l2 = Math.sqrt(l2))) / l2 * strength;
            node2.vx += (x2 *= l2) * (r = (rj *= rj) / (ri2 + rj));
            node2.vy += (y2 *= l2) * r;
            data2.vx -= x2 * (r = 1 - r);
            data2.vy -= y2 * r;
          }
        }
        return;
      }
      return x02 > xi + r || x12 < xi - r || y02 > yi + r || y12 < yi - r;
    }
  }
  function prepare(quad) {
    if (quad.data)
      return quad.r = radii[quad.data.index];
    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }
  function initialize2() {
    if (!nodes)
      return;
    var i, n = nodes.length, node2;
    radii = new Array(n);
    for (i = 0; i < n; ++i)
      node2 = nodes[i], radii[node2.index] = +radius(node2, i, nodes);
  }
  force.initialize = function(_2) {
    nodes = _2;
    initialize2();
  };
  force.iterations = function(_2) {
    return arguments.length ? (iterations2 = +_2, force) : iterations2;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = +_2, force) : strength;
  };
  force.radius = function(_2) {
    return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant$6(+_2), initialize2(), force) : radius;
  };
  return force;
}
function index$3(d) {
  return d.index;
}
function find(nodeById, nodeId) {
  var node2 = nodeById.get(nodeId);
  if (!node2)
    throw new Error("missing: " + nodeId);
  return node2;
}
function link$2(links2) {
  var id2 = index$3, strength = defaultStrength, strengths, distance2 = constant$6(30), distances, nodes, count2, bias, iterations2 = 1;
  if (links2 == null)
    links2 = [];
  function defaultStrength(link2) {
    return 1 / Math.min(count2[link2.source.index], count2[link2.target.index]);
  }
  function force(alpha2) {
    for (var k2 = 0, n = links2.length; k2 < iterations2; ++k2) {
      for (var i = 0, link2, source, target, x2, y2, l2, b; i < n; ++i) {
        link2 = links2[i], source = link2.source, target = link2.target;
        x2 = target.x + target.vx - source.x - source.vx || jiggle();
        y2 = target.y + target.vy - source.y - source.vy || jiggle();
        l2 = Math.sqrt(x2 * x2 + y2 * y2);
        l2 = (l2 - distances[i]) / l2 * alpha2 * strengths[i];
        x2 *= l2, y2 *= l2;
        target.vx -= x2 * (b = bias[i]);
        target.vy -= y2 * b;
        source.vx += x2 * (b = 1 - b);
        source.vy += y2 * b;
      }
    }
  }
  function initialize2() {
    if (!nodes)
      return;
    var i, n = nodes.length, m = links2.length, nodeById = map$2(nodes, id2), link2;
    for (i = 0, count2 = new Array(n); i < m; ++i) {
      link2 = links2[i], link2.index = i;
      if (typeof link2.source !== "object")
        link2.source = find(nodeById, link2.source);
      if (typeof link2.target !== "object")
        link2.target = find(nodeById, link2.target);
      count2[link2.source.index] = (count2[link2.source.index] || 0) + 1;
      count2[link2.target.index] = (count2[link2.target.index] || 0) + 1;
    }
    for (i = 0, bias = new Array(m); i < m; ++i) {
      link2 = links2[i], bias[i] = count2[link2.source.index] / (count2[link2.source.index] + count2[link2.target.index]);
    }
    strengths = new Array(m), initializeStrength();
    distances = new Array(m), initializeDistance();
  }
  function initializeStrength() {
    if (!nodes)
      return;
    for (var i = 0, n = links2.length; i < n; ++i) {
      strengths[i] = +strength(links2[i], i, links2);
    }
  }
  function initializeDistance() {
    if (!nodes)
      return;
    for (var i = 0, n = links2.length; i < n; ++i) {
      distances[i] = +distance2(links2[i], i, links2);
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
    initialize2();
  };
  force.links = function(_2) {
    return arguments.length ? (links2 = _2, initialize2(), force) : links2;
  };
  force.id = function(_2) {
    return arguments.length ? (id2 = _2, force) : id2;
  };
  force.iterations = function(_2) {
    return arguments.length ? (iterations2 = +_2, force) : iterations2;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant$6(+_2), initializeStrength(), force) : strength;
  };
  force.distance = function(_2) {
    return arguments.length ? (distance2 = typeof _2 === "function" ? _2 : constant$6(+_2), initializeDistance(), force) : distance2;
  };
  return force;
}
function x$3(d) {
  return d.x;
}
function y$3(d) {
  return d.y;
}
var initialRadius = 10, initialAngle = Math.PI * (3 - Math.sqrt(5));
function simulation(nodes) {
  var simulation2, alpha2 = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = map$2(), stepper = timer(step2), event2 = dispatch("tick", "end");
  if (nodes == null)
    nodes = [];
  function step2() {
    tick();
    event2.call("tick", simulation2);
    if (alpha2 < alphaMin) {
      stepper.stop();
      event2.call("end", simulation2);
    }
  }
  function tick(iterations2) {
    var i, n = nodes.length, node2;
    if (iterations2 === void 0)
      iterations2 = 1;
    for (var k2 = 0; k2 < iterations2; ++k2) {
      alpha2 += (alphaTarget - alpha2) * alphaDecay;
      forces.each(function(force) {
        force(alpha2);
      });
      for (i = 0; i < n; ++i) {
        node2 = nodes[i];
        if (node2.fx == null)
          node2.x += node2.vx *= velocityDecay;
        else
          node2.x = node2.fx, node2.vx = 0;
        if (node2.fy == null)
          node2.y += node2.vy *= velocityDecay;
        else
          node2.y = node2.fy, node2.vy = 0;
      }
    }
    return simulation2;
  }
  function initializeNodes() {
    for (var i = 0, n = nodes.length, node2; i < n; ++i) {
      node2 = nodes[i], node2.index = i;
      if (node2.fx != null)
        node2.x = node2.fx;
      if (node2.fy != null)
        node2.y = node2.fy;
      if (isNaN(node2.x) || isNaN(node2.y)) {
        var radius = initialRadius * Math.sqrt(i), angle2 = i * initialAngle;
        node2.x = radius * Math.cos(angle2);
        node2.y = radius * Math.sin(angle2);
      }
      if (isNaN(node2.vx) || isNaN(node2.vy)) {
        node2.vx = node2.vy = 0;
      }
    }
  }
  function initializeForce(force) {
    if (force.initialize)
      force.initialize(nodes);
    return force;
  }
  initializeNodes();
  return simulation2 = {
    tick,
    restart: function() {
      return stepper.restart(step2), simulation2;
    },
    stop: function() {
      return stepper.stop(), simulation2;
    },
    nodes: function(_2) {
      return arguments.length ? (nodes = _2, initializeNodes(), forces.each(initializeForce), simulation2) : nodes;
    },
    alpha: function(_2) {
      return arguments.length ? (alpha2 = +_2, simulation2) : alpha2;
    },
    alphaMin: function(_2) {
      return arguments.length ? (alphaMin = +_2, simulation2) : alphaMin;
    },
    alphaDecay: function(_2) {
      return arguments.length ? (alphaDecay = +_2, simulation2) : +alphaDecay;
    },
    alphaTarget: function(_2) {
      return arguments.length ? (alphaTarget = +_2, simulation2) : alphaTarget;
    },
    velocityDecay: function(_2) {
      return arguments.length ? (velocityDecay = 1 - _2, simulation2) : 1 - velocityDecay;
    },
    force: function(name2, _2) {
      return arguments.length > 1 ? (_2 == null ? forces.remove(name2) : forces.set(name2, initializeForce(_2)), simulation2) : forces.get(name2);
    },
    find: function(x2, y2, radius) {
      var i = 0, n = nodes.length, dx, dy, d2, node2, closest;
      if (radius == null)
        radius = Infinity;
      else
        radius *= radius;
      for (i = 0; i < n; ++i) {
        node2 = nodes[i];
        dx = x2 - node2.x;
        dy = y2 - node2.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius)
          closest = node2, radius = d2;
      }
      return closest;
    },
    on: function(name2, _2) {
      return arguments.length > 1 ? (event2.on(name2, _2), simulation2) : event2.on(name2);
    }
  };
}
function manyBody() {
  var nodes, node2, alpha2, strength = constant$6(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
  function force(_2) {
    var i, n = nodes.length, tree2 = quadtree(nodes, x$3, y$3).visitAfter(accumulate);
    for (alpha2 = _2, i = 0; i < n; ++i)
      node2 = nodes[i], tree2.visit(apply2);
  }
  function initialize2() {
    if (!nodes)
      return;
    var i, n = nodes.length, node3;
    strengths = new Array(n);
    for (i = 0; i < n; ++i)
      node3 = nodes[i], strengths[node3.index] = +strength(node3, i, nodes);
  }
  function accumulate(quad) {
    var strength2 = 0, q, c2, weight = 0, x2, y2, i;
    if (quad.length) {
      for (x2 = y2 = i = 0; i < 4; ++i) {
        if ((q = quad[i]) && (c2 = Math.abs(q.value))) {
          strength2 += q.value, weight += c2, x2 += c2 * q.x, y2 += c2 * q.y;
        }
      }
      quad.x = x2 / weight;
      quad.y = y2 / weight;
    } else {
      q = quad;
      q.x = q.data.x;
      q.y = q.data.y;
      do
        strength2 += strengths[q.data.index];
      while (q = q.next);
    }
    quad.value = strength2;
  }
  function apply2(quad, x12, _2, x2) {
    if (!quad.value)
      return true;
    var x3 = quad.x - node2.x, y2 = quad.y - node2.y, w2 = x2 - x12, l2 = x3 * x3 + y2 * y2;
    if (w2 * w2 / theta2 < l2) {
      if (l2 < distanceMax2) {
        if (x3 === 0)
          x3 = jiggle(), l2 += x3 * x3;
        if (y2 === 0)
          y2 = jiggle(), l2 += y2 * y2;
        if (l2 < distanceMin2)
          l2 = Math.sqrt(distanceMin2 * l2);
        node2.vx += x3 * quad.value * alpha2 / l2;
        node2.vy += y2 * quad.value * alpha2 / l2;
      }
      return true;
    } else if (quad.length || l2 >= distanceMax2)
      return;
    if (quad.data !== node2 || quad.next) {
      if (x3 === 0)
        x3 = jiggle(), l2 += x3 * x3;
      if (y2 === 0)
        y2 = jiggle(), l2 += y2 * y2;
      if (l2 < distanceMin2)
        l2 = Math.sqrt(distanceMin2 * l2);
    }
    do
      if (quad.data !== node2) {
        w2 = strengths[quad.data.index] * alpha2 / l2;
        node2.vx += x3 * w2;
        node2.vy += y2 * w2;
      }
    while (quad = quad.next);
  }
  force.initialize = function(_2) {
    nodes = _2;
    initialize2();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant$6(+_2), initialize2(), force) : strength;
  };
  force.distanceMin = function(_2) {
    return arguments.length ? (distanceMin2 = _2 * _2, force) : Math.sqrt(distanceMin2);
  };
  force.distanceMax = function(_2) {
    return arguments.length ? (distanceMax2 = _2 * _2, force) : Math.sqrt(distanceMax2);
  };
  force.theta = function(_2) {
    return arguments.length ? (theta2 = _2 * _2, force) : Math.sqrt(theta2);
  };
  return force;
}
function radial(radius, x2, y2) {
  var nodes, strength = constant$6(0.1), strengths, radiuses;
  if (typeof radius !== "function")
    radius = constant$6(+radius);
  if (x2 == null)
    x2 = 0;
  if (y2 == null)
    y2 = 0;
  function force(alpha2) {
    for (var i = 0, n = nodes.length; i < n; ++i) {
      var node2 = nodes[i], dx = node2.x - x2 || 1e-6, dy = node2.y - y2 || 1e-6, r = Math.sqrt(dx * dx + dy * dy), k2 = (radiuses[i] - r) * strengths[i] * alpha2 / r;
      node2.vx += dx * k2;
      node2.vy += dy * k2;
    }
  }
  function initialize2() {
    if (!nodes)
      return;
    var i, n = nodes.length;
    strengths = new Array(n);
    radiuses = new Array(n);
    for (i = 0; i < n; ++i) {
      radiuses[i] = +radius(nodes[i], i, nodes);
      strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
    }
  }
  force.initialize = function(_2) {
    nodes = _2, initialize2();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant$6(+_2), initialize2(), force) : strength;
  };
  force.radius = function(_2) {
    return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant$6(+_2), initialize2(), force) : radius;
  };
  force.x = function(_2) {
    return arguments.length ? (x2 = +_2, force) : x2;
  };
  force.y = function(_2) {
    return arguments.length ? (y2 = +_2, force) : y2;
  };
  return force;
}
function x$2(x2) {
  var strength = constant$6(0.1), nodes, strengths, xz;
  if (typeof x2 !== "function")
    x2 = constant$6(x2 == null ? 0 : +x2);
  function force(alpha2) {
    for (var i = 0, n = nodes.length, node2; i < n; ++i) {
      node2 = nodes[i], node2.vx += (xz[i] - node2.x) * strengths[i] * alpha2;
    }
  }
  function initialize2() {
    if (!nodes)
      return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x2(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
    initialize2();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant$6(+_2), initialize2(), force) : strength;
  };
  force.x = function(_2) {
    return arguments.length ? (x2 = typeof _2 === "function" ? _2 : constant$6(+_2), initialize2(), force) : x2;
  };
  return force;
}
function y$2(y2) {
  var strength = constant$6(0.1), nodes, strengths, yz;
  if (typeof y2 !== "function")
    y2 = constant$6(y2 == null ? 0 : +y2);
  function force(alpha2) {
    for (var i = 0, n = nodes.length, node2; i < n; ++i) {
      node2 = nodes[i], node2.vy += (yz[i] - node2.y) * strengths[i] * alpha2;
    }
  }
  function initialize2() {
    if (!nodes)
      return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y2(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
    initialize2();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant$6(+_2), initialize2(), force) : strength;
  };
  force.y = function(_2) {
    return arguments.length ? (y2 = typeof _2 === "function" ? _2 : constant$6(+_2), initialize2(), force) : y2;
  };
  return force;
}
function formatDecimal(x2) {
  return Math.abs(x2 = Math.round(x2)) >= 1e21 ? x2.toLocaleString("en").replace(/,/g, "") : x2.toString(10);
}
function formatDecimalParts(x2, p) {
  if ((i = (x2 = p ? x2.toExponential(p - 1) : x2.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x2.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x2.slice(i + 1)
  ];
}
function exponent(x2) {
  return x2 = formatDecimalParts(Math.abs(x2)), x2 ? x2[1] : NaN;
}
function formatGroup(grouping, thousands) {
  return function(value, width2) {
    var i = value.length, t4 = [], j2 = 0, g2 = grouping[0], length2 = 0;
    while (i > 0 && g2 > 0) {
      if (length2 + g2 + 1 > width2)
        g2 = Math.max(1, width2 - length2);
      t4.push(value.substring(i -= g2, i + g2));
      if ((length2 += g2 + 1) > width2)
        break;
      g2 = grouping[j2 = (j2 + 1) % grouping.length];
    }
    return t4.reverse().join(thousands);
  };
}
function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function formatTrim(s2) {
  out:
    for (var n = s2.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s2[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s2[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
}
var prefixExponent;
function formatPrefixAuto(x2, p) {
  var d = formatDecimalParts(x2, p);
  if (!d)
    return x2 + "";
  var coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x2, Math.max(0, p + i - 1))[0];
}
function formatRounded(x2, p) {
  var d = formatDecimalParts(x2, p);
  if (!d)
    return x2 + "";
  var coefficient = d[0], exponent2 = d[1];
  return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
}
const formatTypes = {
  "%": function(x2, p) {
    return (x2 * 100).toFixed(p);
  },
  "b": function(x2) {
    return Math.round(x2).toString(2);
  },
  "c": function(x2) {
    return x2 + "";
  },
  "d": formatDecimal,
  "e": function(x2, p) {
    return x2.toExponential(p);
  },
  "f": function(x2, p) {
    return x2.toFixed(p);
  },
  "g": function(x2, p) {
    return x2.toPrecision(p);
  },
  "o": function(x2) {
    return Math.round(x2).toString(8);
  },
  "p": function(x2, p) {
    return formatRounded(x2 * 100, p);
  },
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": function(x2) {
    return Math.round(x2).toString(16).toUpperCase();
  },
  "x": function(x2) {
    return Math.round(x2).toString(16);
  }
};
function identity$6(x2) {
  return x2;
}
var map$1 = Array.prototype.map, prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function formatLocale$1(locale2) {
  var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity$6 : formatGroup(map$1.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity$6 : formatNumerals(map$1.call(locale2.numerals, String)), percent2 = locale2.percent === void 0 ? "%" : locale2.percent + "", minus2 = locale2.minus === void 0 ? "-" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign2 = specifier.sign, symbol2 = specifier.symbol, zero2 = specifier.zero, width2 = specifier.width, comma = specifier.comma, precision = specifier.precision, trim2 = specifier.trim, type2 = specifier.type;
    if (type2 === "n")
      comma = true, type2 = "g";
    else if (!formatTypes[type2])
      precision === void 0 && (precision = 12), trim2 = true, type2 = "g";
    if (zero2 || fill === "0" && align === "=")
      zero2 = true, fill = "0", align = "=";
    var prefix2 = symbol2 === "$" ? currencyPrefix : symbol2 === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol2 === "$" ? currencySuffix : /[%p]/.test(type2) ? percent2 : "";
    var formatType = formatTypes[type2], maybeSuffix = /[defgprs%]/.test(type2);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix2, valueSuffix = suffix, i, n, c2;
      if (type2 === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim2)
          value = formatTrim(value);
        if (valueNegative && +value === 0 && sign2 !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign2 === "(" ? sign2 : minus2 : sign2 === "-" || sign2 === "(" ? "" : sign2) + valuePrefix;
        valueSuffix = (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign2 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c2 = value.charCodeAt(i), 48 > c2 || c2 > 57) {
              valueSuffix = (c2 === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero2)
        value = group(value, Infinity);
      var length2 = valuePrefix.length + value.length + valueSuffix.length, padding2 = length2 < width2 ? new Array(width2 - length2 + 1).join(fill) : "";
      if (comma && zero2)
        value = group(padding2 + value, padding2.length ? width2 - valueSuffix.length : Infinity), padding2 = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding2;
          break;
        case "=":
          value = valuePrefix + padding2 + value + valueSuffix;
          break;
        case "^":
          value = padding2.slice(0, length2 = padding2.length >> 1) + valuePrefix + value + valueSuffix + padding2.slice(length2);
          break;
        default:
          value = padding2 + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var f2 = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3, k2 = Math.pow(10, -e), prefix2 = prefixes[8 + e / 3];
    return function(value2) {
      return f2(k2 * value2) + prefix2;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}
var locale$1;
var format$1;
var formatPrefix;
defaultLocale$1({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""],
  minus: "-"
});
function defaultLocale$1(definition) {
  locale$1 = formatLocale$1(definition);
  format$1 = locale$1.format;
  formatPrefix = locale$1.formatPrefix;
  return locale$1;
}
function precisionFixed(step2) {
  return Math.max(0, -exponent(Math.abs(step2)));
}
function precisionPrefix(step2, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step2)));
}
function precisionRound(step2, max2) {
  step2 = Math.abs(step2), max2 = Math.abs(max2) - step2;
  return Math.max(0, exponent(max2) - exponent(step2)) + 1;
}
function adder() {
  return new Adder();
}
function Adder() {
  this.reset();
}
Adder.prototype = {
  constructor: Adder,
  reset: function() {
    this.s = this.t = 0;
  },
  add: function(y2) {
    add(temp, y2, this.t);
    add(this, temp.s, this.s);
    if (this.s)
      this.t += temp.t;
    else
      this.s = temp.t;
  },
  valueOf: function() {
    return this.s;
  }
};
var temp = new Adder();
function add(adder2, a2, b) {
  var x2 = adder2.s = a2 + b, bv = x2 - a2, av = x2 - bv;
  adder2.t = a2 - av + (b - bv);
}
var epsilon$2 = 1e-6;
var epsilon2$1 = 1e-12;
var pi$1 = Math.PI;
var halfPi$1 = pi$1 / 2;
var quarterPi = pi$1 / 4;
var tau$1 = pi$1 * 2;
var degrees = 180 / pi$1;
var radians = pi$1 / 180;
var abs$1 = Math.abs;
var atan = Math.atan;
var atan2$1 = Math.atan2;
var cos$1 = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var log$3 = Math.log;
var pow$1 = Math.pow;
var sin$1 = Math.sin;
var sign$1 = Math.sign || function(x2) {
  return x2 > 0 ? 1 : x2 < 0 ? -1 : 0;
};
var sqrt$2 = Math.sqrt;
var tan = Math.tan;
function acos$1(x2) {
  return x2 > 1 ? 0 : x2 < -1 ? pi$1 : Math.acos(x2);
}
function asin$1(x2) {
  return x2 > 1 ? halfPi$1 : x2 < -1 ? -halfPi$1 : Math.asin(x2);
}
function haversin(x2) {
  return (x2 = sin$1(x2 / 2)) * x2;
}
function noop$1() {
}
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}
var streamObjectType = {
  Feature: function(object2, stream) {
    streamGeometry(object2.geometry, stream);
  },
  FeatureCollection: function(object2, stream) {
    var features = object2.features, i = -1, n = features.length;
    while (++i < n)
      streamGeometry(features[i].geometry, stream);
  }
};
var streamGeometryType = {
  Sphere: function(object2, stream) {
    stream.sphere();
  },
  Point: function(object2, stream) {
    object2 = object2.coordinates;
    stream.point(object2[0], object2[1], object2[2]);
  },
  MultiPoint: function(object2, stream) {
    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
    while (++i < n)
      object2 = coordinates2[i], stream.point(object2[0], object2[1], object2[2]);
  },
  LineString: function(object2, stream) {
    streamLine(object2.coordinates, stream, 0);
  },
  MultiLineString: function(object2, stream) {
    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
    while (++i < n)
      streamLine(coordinates2[i], stream, 0);
  },
  Polygon: function(object2, stream) {
    streamPolygon(object2.coordinates, stream);
  },
  MultiPolygon: function(object2, stream) {
    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
    while (++i < n)
      streamPolygon(coordinates2[i], stream);
  },
  GeometryCollection: function(object2, stream) {
    var geometries = object2.geometries, i = -1, n = geometries.length;
    while (++i < n)
      streamGeometry(geometries[i], stream);
  }
};
function streamLine(coordinates2, stream, closed) {
  var i = -1, n = coordinates2.length - closed, coordinate;
  stream.lineStart();
  while (++i < n)
    coordinate = coordinates2[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}
function streamPolygon(coordinates2, stream) {
  var i = -1, n = coordinates2.length;
  stream.polygonStart();
  while (++i < n)
    streamLine(coordinates2[i], stream, 1);
  stream.polygonEnd();
}
function geoStream(object2, stream) {
  if (object2 && streamObjectType.hasOwnProperty(object2.type)) {
    streamObjectType[object2.type](object2, stream);
  } else {
    streamGeometry(object2, stream);
  }
}
var areaRingSum$1 = adder();
var areaSum$1 = adder(), lambda00$2, phi00$2, lambda0$2, cosPhi0$1, sinPhi0$1;
var areaStream$1 = {
  point: noop$1,
  lineStart: noop$1,
  lineEnd: noop$1,
  polygonStart: function() {
    areaRingSum$1.reset();
    areaStream$1.lineStart = areaRingStart$1;
    areaStream$1.lineEnd = areaRingEnd$1;
  },
  polygonEnd: function() {
    var areaRing = +areaRingSum$1;
    areaSum$1.add(areaRing < 0 ? tau$1 + areaRing : areaRing);
    this.lineStart = this.lineEnd = this.point = noop$1;
  },
  sphere: function() {
    areaSum$1.add(tau$1);
  }
};
function areaRingStart$1() {
  areaStream$1.point = areaPointFirst$1;
}
function areaRingEnd$1() {
  areaPoint$1(lambda00$2, phi00$2);
}
function areaPointFirst$1(lambda, phi2) {
  areaStream$1.point = areaPoint$1;
  lambda00$2 = lambda, phi00$2 = phi2;
  lambda *= radians, phi2 *= radians;
  lambda0$2 = lambda, cosPhi0$1 = cos$1(phi2 = phi2 / 2 + quarterPi), sinPhi0$1 = sin$1(phi2);
}
function areaPoint$1(lambda, phi2) {
  lambda *= radians, phi2 *= radians;
  phi2 = phi2 / 2 + quarterPi;
  var dLambda = lambda - lambda0$2, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos$1(phi2), sinPhi = sin$1(phi2), k2 = sinPhi0$1 * sinPhi, u = cosPhi0$1 * cosPhi + k2 * cos$1(adLambda), v = k2 * sdLambda * sin$1(adLambda);
  areaRingSum$1.add(atan2$1(v, u));
  lambda0$2 = lambda, cosPhi0$1 = cosPhi, sinPhi0$1 = sinPhi;
}
function area$2(object2) {
  areaSum$1.reset();
  geoStream(object2, areaStream$1);
  return areaSum$1 * 2;
}
function spherical(cartesian2) {
  return [atan2$1(cartesian2[1], cartesian2[0]), asin$1(cartesian2[2])];
}
function cartesian(spherical2) {
  var lambda = spherical2[0], phi2 = spherical2[1], cosPhi = cos$1(phi2);
  return [cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi2)];
}
function cartesianDot(a2, b) {
  return a2[0] * b[0] + a2[1] * b[1] + a2[2] * b[2];
}
function cartesianCross(a2, b) {
  return [a2[1] * b[2] - a2[2] * b[1], a2[2] * b[0] - a2[0] * b[2], a2[0] * b[1] - a2[1] * b[0]];
}
function cartesianAddInPlace(a2, b) {
  a2[0] += b[0], a2[1] += b[1], a2[2] += b[2];
}
function cartesianScale(vector, k2) {
  return [vector[0] * k2, vector[1] * k2, vector[2] * k2];
}
function cartesianNormalizeInPlace(d) {
  var l2 = sqrt$2(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l2, d[1] /= l2, d[2] /= l2;
}
var lambda0$1, phi0, lambda1, phi1, lambda2, lambda00$1, phi00$1, p0, deltaSum = adder(), ranges, range;
var boundsStream$2 = {
  point: boundsPoint$1,
  lineStart: boundsLineStart,
  lineEnd: boundsLineEnd,
  polygonStart: function() {
    boundsStream$2.point = boundsRingPoint;
    boundsStream$2.lineStart = boundsRingStart;
    boundsStream$2.lineEnd = boundsRingEnd;
    deltaSum.reset();
    areaStream$1.polygonStart();
  },
  polygonEnd: function() {
    areaStream$1.polygonEnd();
    boundsStream$2.point = boundsPoint$1;
    boundsStream$2.lineStart = boundsLineStart;
    boundsStream$2.lineEnd = boundsLineEnd;
    if (areaRingSum$1 < 0)
      lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
    else if (deltaSum > epsilon$2)
      phi1 = 90;
    else if (deltaSum < -epsilon$2)
      phi0 = -90;
    range[0] = lambda0$1, range[1] = lambda1;
  },
  sphere: function() {
    lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
  }
};
function boundsPoint$1(lambda, phi2) {
  ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
  if (phi2 < phi0)
    phi0 = phi2;
  if (phi2 > phi1)
    phi1 = phi2;
}
function linePoint(lambda, phi2) {
  var p = cartesian([lambda * radians, phi2 * radians]);
  if (p0) {
    var normal2 = cartesianCross(p0, p), equatorial = [normal2[1], -normal2[0], 0], inflection = cartesianCross(equatorial, normal2);
    cartesianNormalizeInPlace(inflection);
    inflection = spherical(inflection);
    var delta = lambda - lambda2, sign2 = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees * sign2, phii, antimeridian = abs$1(delta) > 180;
    if (antimeridian ^ (sign2 * lambda2 < lambdai && lambdai < sign2 * lambda)) {
      phii = inflection[1] * degrees;
      if (phii > phi1)
        phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign2 * lambda2 < lambdai && lambdai < sign2 * lambda)) {
      phii = -inflection[1] * degrees;
      if (phii < phi0)
        phi0 = phii;
    } else {
      if (phi2 < phi0)
        phi0 = phi2;
      if (phi2 > phi1)
        phi1 = phi2;
    }
    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1))
          lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(lambda0$1, lambda1))
          lambda0$1 = lambda;
      }
    } else {
      if (lambda1 >= lambda0$1) {
        if (lambda < lambda0$1)
          lambda0$1 = lambda;
        if (lambda > lambda1)
          lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1))
            lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda0$1, lambda1))
            lambda0$1 = lambda;
        }
      }
    }
  } else {
    ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
  }
  if (phi2 < phi0)
    phi0 = phi2;
  if (phi2 > phi1)
    phi1 = phi2;
  p0 = p, lambda2 = lambda;
}
function boundsLineStart() {
  boundsStream$2.point = linePoint;
}
function boundsLineEnd() {
  range[0] = lambda0$1, range[1] = lambda1;
  boundsStream$2.point = boundsPoint$1;
  p0 = null;
}
function boundsRingPoint(lambda, phi2) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add(abs$1(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda00$1 = lambda, phi00$1 = phi2;
  }
  areaStream$1.point(lambda, phi2);
  linePoint(lambda, phi2);
}
function boundsRingStart() {
  areaStream$1.lineStart();
}
function boundsRingEnd() {
  boundsRingPoint(lambda00$1, phi00$1);
  areaStream$1.lineEnd();
  if (abs$1(deltaSum) > epsilon$2)
    lambda0$1 = -(lambda1 = 180);
  range[0] = lambda0$1, range[1] = lambda1;
  p0 = null;
}
function angle(lambda02, lambda12) {
  return (lambda12 -= lambda02) < 0 ? lambda12 + 360 : lambda12;
}
function rangeCompare(a2, b) {
  return a2[0] - b[0];
}
function rangeContains(range2, x2) {
  return range2[0] <= range2[1] ? range2[0] <= x2 && x2 <= range2[1] : x2 < range2[0] || range2[1] < x2;
}
function bounds$2(feature) {
  var i, n, a2, b, merged, deltaMax, delta;
  phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
  ranges = [];
  geoStream(feature, boundsStream$2);
  if (n = ranges.length) {
    ranges.sort(rangeCompare);
    for (i = 1, a2 = ranges[0], merged = [a2]; i < n; ++i) {
      b = ranges[i];
      if (rangeContains(a2, b[0]) || rangeContains(a2, b[1])) {
        if (angle(a2[0], b[1]) > angle(a2[0], a2[1]))
          a2[1] = b[1];
        if (angle(b[0], a2[1]) > angle(a2[0], a2[1]))
          a2[0] = b[0];
      } else {
        merged.push(a2 = b);
      }
    }
    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a2 = merged[n]; i <= n; a2 = b, ++i) {
      b = merged[i];
      if ((delta = angle(a2[1], b[0])) > deltaMax)
        deltaMax = delta, lambda0$1 = b[0], lambda1 = a2[1];
    }
  }
  ranges = range = null;
  return lambda0$1 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda0$1, phi0], [lambda1, phi1]];
}
var W0, W1, X0$1, Y0$1, Z0$1, X1$1, Y1$1, Z1$1, X2$1, Y2$1, Z2$1, lambda00, phi00, x0$4, y0$4, z0;
var centroidStream$1 = {
  sphere: noop$1,
  point: centroidPoint$1,
  lineStart: centroidLineStart$1,
  lineEnd: centroidLineEnd$1,
  polygonStart: function() {
    centroidStream$1.lineStart = centroidRingStart$1;
    centroidStream$1.lineEnd = centroidRingEnd$1;
  },
  polygonEnd: function() {
    centroidStream$1.lineStart = centroidLineStart$1;
    centroidStream$1.lineEnd = centroidLineEnd$1;
  }
};
function centroidPoint$1(lambda, phi2) {
  lambda *= radians, phi2 *= radians;
  var cosPhi = cos$1(phi2);
  centroidPointCartesian(cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi2));
}
function centroidPointCartesian(x2, y2, z) {
  ++W0;
  X0$1 += (x2 - X0$1) / W0;
  Y0$1 += (y2 - Y0$1) / W0;
  Z0$1 += (z - Z0$1) / W0;
}
function centroidLineStart$1() {
  centroidStream$1.point = centroidLinePointFirst;
}
function centroidLinePointFirst(lambda, phi2) {
  lambda *= radians, phi2 *= radians;
  var cosPhi = cos$1(phi2);
  x0$4 = cosPhi * cos$1(lambda);
  y0$4 = cosPhi * sin$1(lambda);
  z0 = sin$1(phi2);
  centroidStream$1.point = centroidLinePoint;
  centroidPointCartesian(x0$4, y0$4, z0);
}
function centroidLinePoint(lambda, phi2) {
  lambda *= radians, phi2 *= radians;
  var cosPhi = cos$1(phi2), x2 = cosPhi * cos$1(lambda), y2 = cosPhi * sin$1(lambda), z = sin$1(phi2), w2 = atan2$1(sqrt$2((w2 = y0$4 * z - z0 * y2) * w2 + (w2 = z0 * x2 - x0$4 * z) * w2 + (w2 = x0$4 * y2 - y0$4 * x2) * w2), x0$4 * x2 + y0$4 * y2 + z0 * z);
  W1 += w2;
  X1$1 += w2 * (x0$4 + (x0$4 = x2));
  Y1$1 += w2 * (y0$4 + (y0$4 = y2));
  Z1$1 += w2 * (z0 + (z0 = z));
  centroidPointCartesian(x0$4, y0$4, z0);
}
function centroidLineEnd$1() {
  centroidStream$1.point = centroidPoint$1;
}
function centroidRingStart$1() {
  centroidStream$1.point = centroidRingPointFirst;
}
function centroidRingEnd$1() {
  centroidRingPoint(lambda00, phi00);
  centroidStream$1.point = centroidPoint$1;
}
function centroidRingPointFirst(lambda, phi2) {
  lambda00 = lambda, phi00 = phi2;
  lambda *= radians, phi2 *= radians;
  centroidStream$1.point = centroidRingPoint;
  var cosPhi = cos$1(phi2);
  x0$4 = cosPhi * cos$1(lambda);
  y0$4 = cosPhi * sin$1(lambda);
  z0 = sin$1(phi2);
  centroidPointCartesian(x0$4, y0$4, z0);
}
function centroidRingPoint(lambda, phi2) {
  lambda *= radians, phi2 *= radians;
  var cosPhi = cos$1(phi2), x2 = cosPhi * cos$1(lambda), y2 = cosPhi * sin$1(lambda), z = sin$1(phi2), cx = y0$4 * z - z0 * y2, cy = z0 * x2 - x0$4 * z, cz = x0$4 * y2 - y0$4 * x2, m = sqrt$2(cx * cx + cy * cy + cz * cz), w2 = asin$1(m), v = m && -w2 / m;
  X2$1 += v * cx;
  Y2$1 += v * cy;
  Z2$1 += v * cz;
  W1 += w2;
  X1$1 += w2 * (x0$4 + (x0$4 = x2));
  Y1$1 += w2 * (y0$4 + (y0$4 = y2));
  Z1$1 += w2 * (z0 + (z0 = z));
  centroidPointCartesian(x0$4, y0$4, z0);
}
function centroid$1(object2) {
  W0 = W1 = X0$1 = Y0$1 = Z0$1 = X1$1 = Y1$1 = Z1$1 = X2$1 = Y2$1 = Z2$1 = 0;
  geoStream(object2, centroidStream$1);
  var x2 = X2$1, y2 = Y2$1, z = Z2$1, m = x2 * x2 + y2 * y2 + z * z;
  if (m < epsilon2$1) {
    x2 = X1$1, y2 = Y1$1, z = Z1$1;
    if (W1 < epsilon$2)
      x2 = X0$1, y2 = Y0$1, z = Z0$1;
    m = x2 * x2 + y2 * y2 + z * z;
    if (m < epsilon2$1)
      return [NaN, NaN];
  }
  return [atan2$1(y2, x2) * degrees, asin$1(z / sqrt$2(m)) * degrees];
}
function constant$5(x2) {
  return function() {
    return x2;
  };
}
function compose(a2, b) {
  function compose2(x2, y2) {
    return x2 = a2(x2, y2), b(x2[0], x2[1]);
  }
  if (a2.invert && b.invert)
    compose2.invert = function(x2, y2) {
      return x2 = b.invert(x2, y2), x2 && a2.invert(x2[0], x2[1]);
    };
  return compose2;
}
function rotationIdentity(lambda, phi2) {
  return [abs$1(lambda) > pi$1 ? lambda + Math.round(-lambda / tau$1) * tau$1 : lambda, phi2];
}
rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau$1) ? deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}
function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi2) {
    return lambda += deltaLambda, [lambda > pi$1 ? lambda - tau$1 : lambda < -pi$1 ? lambda + tau$1 : lambda, phi2];
  };
}
function rotationLambda(deltaLambda) {
  var rotation2 = forwardRotationLambda(deltaLambda);
  rotation2.invert = forwardRotationLambda(-deltaLambda);
  return rotation2;
}
function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos$1(deltaPhi), sinDeltaPhi = sin$1(deltaPhi), cosDeltaGamma = cos$1(deltaGamma), sinDeltaGamma = sin$1(deltaGamma);
  function rotation2(lambda, phi2) {
    var cosPhi = cos$1(phi2), x2 = cos$1(lambda) * cosPhi, y2 = sin$1(lambda) * cosPhi, z = sin$1(phi2), k2 = z * cosDeltaPhi + x2 * sinDeltaPhi;
    return [
      atan2$1(y2 * cosDeltaGamma - k2 * sinDeltaGamma, x2 * cosDeltaPhi - z * sinDeltaPhi),
      asin$1(k2 * cosDeltaGamma + y2 * sinDeltaGamma)
    ];
  }
  rotation2.invert = function(lambda, phi2) {
    var cosPhi = cos$1(phi2), x2 = cos$1(lambda) * cosPhi, y2 = sin$1(lambda) * cosPhi, z = sin$1(phi2), k2 = z * cosDeltaGamma - y2 * sinDeltaGamma;
    return [
      atan2$1(y2 * cosDeltaGamma + z * sinDeltaGamma, x2 * cosDeltaPhi + k2 * sinDeltaPhi),
      asin$1(k2 * cosDeltaPhi - x2 * sinDeltaPhi)
    ];
  };
  return rotation2;
}
function rotation(rotate) {
  rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);
  function forward(coordinates2) {
    coordinates2 = rotate(coordinates2[0] * radians, coordinates2[1] * radians);
    return coordinates2[0] *= degrees, coordinates2[1] *= degrees, coordinates2;
  }
  forward.invert = function(coordinates2) {
    coordinates2 = rotate.invert(coordinates2[0] * radians, coordinates2[1] * radians);
    return coordinates2[0] *= degrees, coordinates2[1] *= degrees, coordinates2;
  };
  return forward;
}
function circleStream(stream, radius, delta, direction2, t02, t12) {
  if (!delta)
    return;
  var cosRadius = cos$1(radius), sinRadius = sin$1(radius), step2 = direction2 * delta;
  if (t02 == null) {
    t02 = radius + direction2 * tau$1;
    t12 = radius - step2 / 2;
  } else {
    t02 = circleRadius(cosRadius, t02);
    t12 = circleRadius(cosRadius, t12);
    if (direction2 > 0 ? t02 < t12 : t02 > t12)
      t02 += direction2 * tau$1;
  }
  for (var point2, t4 = t02; direction2 > 0 ? t4 > t12 : t4 < t12; t4 -= step2) {
    point2 = spherical([cosRadius, -sinRadius * cos$1(t4), -sinRadius * sin$1(t4)]);
    stream.point(point2[0], point2[1]);
  }
}
function circleRadius(cosRadius, point2) {
  point2 = cartesian(point2), point2[0] -= cosRadius;
  cartesianNormalizeInPlace(point2);
  var radius = acos$1(-point2[1]);
  return ((-point2[2] < 0 ? -radius : radius) + tau$1 - epsilon$2) % tau$1;
}
function circle$4() {
  var center2 = constant$5([0, 0]), radius = constant$5(90), precision = constant$5(6), ring, rotate, stream = { point: point2 };
  function point2(x2, y2) {
    ring.push(x2 = rotate(x2, y2));
    x2[0] *= degrees, x2[1] *= degrees;
  }
  function circle2() {
    var c2 = center2.apply(this, arguments), r = radius.apply(this, arguments) * radians, p = precision.apply(this, arguments) * radians;
    ring = [];
    rotate = rotateRadians(-c2[0] * radians, -c2[1] * radians, 0).invert;
    circleStream(stream, r, p, 1);
    c2 = { type: "Polygon", coordinates: [ring] };
    ring = rotate = null;
    return c2;
  }
  circle2.center = function(_2) {
    return arguments.length ? (center2 = typeof _2 === "function" ? _2 : constant$5([+_2[0], +_2[1]]), circle2) : center2;
  };
  circle2.radius = function(_2) {
    return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant$5(+_2), circle2) : radius;
  };
  circle2.precision = function(_2) {
    return arguments.length ? (precision = typeof _2 === "function" ? _2 : constant$5(+_2), circle2) : precision;
  };
  return circle2;
}
function clipBuffer() {
  var lines = [], line2;
  return {
    point: function(x2, y2, m) {
      line2.push([x2, y2, m]);
    },
    lineStart: function() {
      lines.push(line2 = []);
    },
    lineEnd: noop$1,
    rejoin: function() {
      if (lines.length > 1)
        lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line2 = null;
      return result;
    }
  };
}
function pointEqual(a2, b) {
  return abs$1(a2[0] - b[0]) < epsilon$2 && abs$1(a2[1] - b[1]) < epsilon$2;
}
function Intersection(point2, points, other, entry) {
  this.x = point2;
  this.z = points;
  this.o = other;
  this.e = entry;
  this.v = false;
  this.n = this.p = null;
}
function clipRejoin(segments, compareIntersection2, startInside, interpolate2, stream) {
  var subject = [], clip2 = [], i, n;
  segments.forEach(function(segment) {
    if ((n2 = segment.length - 1) <= 0)
      return;
    var n2, p02 = segment[0], p1 = segment[n2], x2;
    if (pointEqual(p02, p1)) {
      if (!p02[2] && !p1[2]) {
        stream.lineStart();
        for (i = 0; i < n2; ++i)
          stream.point((p02 = segment[i])[0], p02[1]);
        stream.lineEnd();
        return;
      }
      p1[0] += 2 * epsilon$2;
    }
    subject.push(x2 = new Intersection(p02, segment, null, true));
    clip2.push(x2.o = new Intersection(p02, null, x2, false));
    subject.push(x2 = new Intersection(p1, segment, null, false));
    clip2.push(x2.o = new Intersection(p1, null, x2, true));
  });
  if (!subject.length)
    return;
  clip2.sort(compareIntersection2);
  link$1(subject);
  link$1(clip2);
  for (i = 0, n = clip2.length; i < n; ++i) {
    clip2[i].e = startInside = !startInside;
  }
  var start2 = subject[0], points, point2;
  while (1) {
    var current = start2, isSubject = true;
    while (current.v)
      if ((current = current.n) === start2)
        return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i)
            stream.point((point2 = points[i])[0], point2[1]);
        } else {
          interpolate2(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i)
            stream.point((point2 = points[i])[0], point2[1]);
        } else {
          interpolate2(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}
function link$1(array2) {
  if (!(n = array2.length))
    return;
  var n, i = 0, a2 = array2[0], b;
  while (++i < n) {
    a2.n = b = array2[i];
    b.p = a2;
    a2 = b;
  }
  a2.n = b = array2[0];
  b.p = a2;
}
var sum$1 = adder();
function longitude(point2) {
  if (abs$1(point2[0]) <= pi$1)
    return point2[0];
  else
    return sign$1(point2[0]) * ((abs$1(point2[0]) + pi$1) % tau$1 - pi$1);
}
function polygonContains(polygon, point2) {
  var lambda = longitude(point2), phi2 = point2[1], sinPhi = sin$1(phi2), normal2 = [sin$1(lambda), -cos$1(lambda), 0], angle2 = 0, winding = 0;
  sum$1.reset();
  if (sinPhi === 1)
    phi2 = halfPi$1 + epsilon$2;
  else if (sinPhi === -1)
    phi2 = -halfPi$1 - epsilon$2;
  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length))
      continue;
    var ring, m, point0 = ring[m - 1], lambda02 = longitude(point0), phi02 = point0[1] / 2 + quarterPi, sinPhi02 = sin$1(phi02), cosPhi02 = cos$1(phi02);
    for (var j2 = 0; j2 < m; ++j2, lambda02 = lambda12, sinPhi02 = sinPhi1, cosPhi02 = cosPhi1, point0 = point1) {
      var point1 = ring[j2], lambda12 = longitude(point1), phi12 = point1[1] / 2 + quarterPi, sinPhi1 = sin$1(phi12), cosPhi1 = cos$1(phi12), delta = lambda12 - lambda02, sign2 = delta >= 0 ? 1 : -1, absDelta = sign2 * delta, antimeridian = absDelta > pi$1, k2 = sinPhi02 * sinPhi1;
      sum$1.add(atan2$1(k2 * sign2 * sin$1(absDelta), cosPhi02 * cosPhi1 + k2 * cos$1(absDelta)));
      angle2 += antimeridian ? delta + sign2 * tau$1 : delta;
      if (antimeridian ^ lambda02 >= lambda ^ lambda12 >= lambda) {
        var arc2 = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc2);
        var intersection2 = cartesianCross(normal2, arc2);
        cartesianNormalizeInPlace(intersection2);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin$1(intersection2[2]);
        if (phi2 > phiArc || phi2 === phiArc && (arc2[0] || arc2[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle2 < -epsilon$2 || angle2 < epsilon$2 && sum$1 < -epsilon$2) ^ winding & 1;
}
function clip(pointVisible, clipLine2, interpolate2, start2) {
  return function(sink) {
    var line2 = clipLine2(sink), ringBuffer = clipBuffer(), ringSink = clipLine2(ringBuffer), polygonStarted = false, polygon, segments, ring;
    var clip2 = {
      point: point2,
      lineStart,
      lineEnd: lineEnd2,
      polygonStart: function() {
        clip2.point = pointRing;
        clip2.lineStart = ringStart;
        clip2.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip2.point = point2;
        clip2.lineStart = lineStart;
        clip2.lineEnd = lineEnd2;
        segments = merge$1(segments);
        var startInside = polygonContains(polygon, start2);
        if (segments.length) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          clipRejoin(segments, compareIntersection, startInside, interpolate2, sink);
        } else if (startInside) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate2(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted)
          sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate2(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point2(lambda, phi2) {
      if (pointVisible(lambda, phi2))
        sink.point(lambda, phi2);
    }
    function pointLine(lambda, phi2) {
      line2.point(lambda, phi2);
    }
    function lineStart() {
      clip2.point = pointLine;
      line2.lineStart();
    }
    function lineEnd2() {
      clip2.point = point2;
      line2.lineEnd();
    }
    function pointRing(lambda, phi2) {
      ring.push([lambda, phi2]);
      ringSink.point(lambda, phi2);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m, segment, point3;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n)
        return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m; ++i)
            sink.point((point3 = segment[i])[0], point3[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n > 1 && clean & 2)
        ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }
    return clip2;
  };
}
function validSegment(segment) {
  return segment.length > 1;
}
function compareIntersection(a2, b) {
  return ((a2 = a2.x)[0] < 0 ? a2[1] - halfPi$1 - epsilon$2 : halfPi$1 - a2[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi$1 - epsilon$2 : halfPi$1 - b[1]);
}
const clipAntimeridian = clip(
  function() {
    return true;
  },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi$1, -halfPi$1]
);
function clipAntimeridianLine(stream) {
  var lambda02 = NaN, phi02 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda12, phi12) {
      var sign1 = lambda12 > 0 ? pi$1 : -pi$1, delta = abs$1(lambda12 - lambda02);
      if (abs$1(delta - pi$1) < epsilon$2) {
        stream.point(lambda02, phi02 = (phi02 + phi12) / 2 > 0 ? halfPi$1 : -halfPi$1);
        stream.point(sign0, phi02);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi02);
        stream.point(lambda12, phi02);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi$1) {
        if (abs$1(lambda02 - sign0) < epsilon$2)
          lambda02 -= sign0 * epsilon$2;
        if (abs$1(lambda12 - sign1) < epsilon$2)
          lambda12 -= sign1 * epsilon$2;
        phi02 = clipAntimeridianIntersect(lambda02, phi02, lambda12, phi12);
        stream.point(sign0, phi02);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi02);
        clean = 0;
      }
      stream.point(lambda02 = lambda12, phi02 = phi12);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda02 = phi02 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect(lambda02, phi02, lambda12, phi12) {
  var cosPhi02, cosPhi1, sinLambda0Lambda1 = sin$1(lambda02 - lambda12);
  return abs$1(sinLambda0Lambda1) > epsilon$2 ? atan((sin$1(phi02) * (cosPhi1 = cos$1(phi12)) * sin$1(lambda12) - sin$1(phi12) * (cosPhi02 = cos$1(phi02)) * sin$1(lambda02)) / (cosPhi02 * cosPhi1 * sinLambda0Lambda1)) : (phi02 + phi12) / 2;
}
function clipAntimeridianInterpolate(from2, to2, direction2, stream) {
  var phi2;
  if (from2 == null) {
    phi2 = direction2 * halfPi$1;
    stream.point(-pi$1, phi2);
    stream.point(0, phi2);
    stream.point(pi$1, phi2);
    stream.point(pi$1, 0);
    stream.point(pi$1, -phi2);
    stream.point(0, -phi2);
    stream.point(-pi$1, -phi2);
    stream.point(-pi$1, 0);
    stream.point(-pi$1, phi2);
  } else if (abs$1(from2[0] - to2[0]) > epsilon$2) {
    var lambda = from2[0] < to2[0] ? pi$1 : -pi$1;
    phi2 = direction2 * lambda / 2;
    stream.point(-lambda, phi2);
    stream.point(0, phi2);
    stream.point(lambda, phi2);
  } else {
    stream.point(to2[0], to2[1]);
  }
}
function clipCircle(radius) {
  var cr = cos$1(radius), delta = 6 * radians, smallRadius = cr > 0, notHemisphere = abs$1(cr) > epsilon$2;
  function interpolate2(from2, to2, direction2, stream) {
    circleStream(stream, radius, delta, direction2, from2, to2);
  }
  function visible(lambda, phi2) {
    return cos$1(lambda) * cos$1(phi2) > cr;
  }
  function clipLine2(stream) {
    var point0, c0, v0, v00, clean;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi2) {
        var point1 = [lambda, phi2], point2, v = visible(lambda, phi2), c2 = smallRadius ? v ? 0 : code(lambda, phi2) : v ? code(lambda + (lambda < 0 ? pi$1 : -pi$1), phi2) : 0;
        if (!point0 && (v00 = v0 = v))
          stream.lineStart();
        if (v !== v0) {
          point2 = intersect2(point0, point1);
          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2))
            point1[2] = 1;
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            stream.lineStart();
            point2 = intersect2(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            point2 = intersect2(point0, point1);
            stream.point(point2[0], point2[1], 2);
            stream.lineEnd();
          }
          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t4;
          if (!(c2 & c0) && (t4 = intersect2(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t4[0][0], t4[0][1]);
              stream.point(t4[1][0], t4[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t4[1][0], t4[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t4[0][0], t4[0][1], 3);
            }
          }
        }
        if (v && (!point0 || !pointEqual(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c2;
      },
      lineEnd: function() {
        if (v0)
          stream.lineEnd();
        point0 = null;
      },
      clean: function() {
        return clean | (v00 && v0) << 1;
      }
    };
  }
  function intersect2(a2, b, two) {
    var pa = cartesian(a2), pb = cartesian(b);
    var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
    if (!determinant)
      return !two && a2;
    var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A5 = cartesianScale(n1, c1), B2 = cartesianScale(n2, c2);
    cartesianAddInPlace(A5, B2);
    var u = n1xn2, w2 = cartesianDot(A5, u), uu = cartesianDot(u, u), t22 = w2 * w2 - uu * (cartesianDot(A5, A5) - 1);
    if (t22 < 0)
      return;
    var t4 = sqrt$2(t22), q = cartesianScale(u, (-w2 - t4) / uu);
    cartesianAddInPlace(q, A5);
    q = spherical(q);
    if (!two)
      return q;
    var lambda02 = a2[0], lambda12 = b[0], phi02 = a2[1], phi12 = b[1], z;
    if (lambda12 < lambda02)
      z = lambda02, lambda02 = lambda12, lambda12 = z;
    var delta2 = lambda12 - lambda02, polar = abs$1(delta2 - pi$1) < epsilon$2, meridian = polar || delta2 < epsilon$2;
    if (!polar && phi12 < phi02)
      z = phi02, phi02 = phi12, phi12 = z;
    if (meridian ? polar ? phi02 + phi12 > 0 ^ q[1] < (abs$1(q[0] - lambda02) < epsilon$2 ? phi02 : phi12) : phi02 <= q[1] && q[1] <= phi12 : delta2 > pi$1 ^ (lambda02 <= q[0] && q[0] <= lambda12)) {
      var q1 = cartesianScale(u, (-w2 + t4) / uu);
      cartesianAddInPlace(q1, A5);
      return [q, spherical(q1)];
    }
  }
  function code(lambda, phi2) {
    var r = smallRadius ? radius : pi$1 - radius, code2 = 0;
    if (lambda < -r)
      code2 |= 1;
    else if (lambda > r)
      code2 |= 2;
    if (phi2 < -r)
      code2 |= 4;
    else if (phi2 > r)
      code2 |= 8;
    return code2;
  }
  return clip(visible, clipLine2, interpolate2, smallRadius ? [0, -radius] : [-pi$1, radius - pi$1]);
}
function clipLine(a2, b, x02, y02, x12, y12) {
  var ax = a2[0], ay = a2[1], bx = b[0], by = b[1], t02 = 0, t12 = 1, dx = bx - ax, dy = by - ay, r;
  r = x02 - ax;
  if (!dx && r > 0)
    return;
  r /= dx;
  if (dx < 0) {
    if (r < t02)
      return;
    if (r < t12)
      t12 = r;
  } else if (dx > 0) {
    if (r > t12)
      return;
    if (r > t02)
      t02 = r;
  }
  r = x12 - ax;
  if (!dx && r < 0)
    return;
  r /= dx;
  if (dx < 0) {
    if (r > t12)
      return;
    if (r > t02)
      t02 = r;
  } else if (dx > 0) {
    if (r < t02)
      return;
    if (r < t12)
      t12 = r;
  }
  r = y02 - ay;
  if (!dy && r > 0)
    return;
  r /= dy;
  if (dy < 0) {
    if (r < t02)
      return;
    if (r < t12)
      t12 = r;
  } else if (dy > 0) {
    if (r > t12)
      return;
    if (r > t02)
      t02 = r;
  }
  r = y12 - ay;
  if (!dy && r < 0)
    return;
  r /= dy;
  if (dy < 0) {
    if (r > t12)
      return;
    if (r > t02)
      t02 = r;
  } else if (dy > 0) {
    if (r < t02)
      return;
    if (r < t12)
      t12 = r;
  }
  if (t02 > 0)
    a2[0] = ax + t02 * dx, a2[1] = ay + t02 * dy;
  if (t12 < 1)
    b[0] = ax + t12 * dx, b[1] = ay + t12 * dy;
  return true;
}
var clipMax = 1e9, clipMin = -clipMax;
function clipRectangle(x02, y02, x12, y12) {
  function visible(x2, y2) {
    return x02 <= x2 && x2 <= x12 && y02 <= y2 && y2 <= y12;
  }
  function interpolate2(from2, to2, direction2, stream) {
    var a2 = 0, a1 = 0;
    if (from2 == null || (a2 = corner(from2, direction2)) !== (a1 = corner(to2, direction2)) || comparePoint(from2, to2) < 0 ^ direction2 > 0) {
      do
        stream.point(a2 === 0 || a2 === 3 ? x02 : x12, a2 > 1 ? y12 : y02);
      while ((a2 = (a2 + direction2 + 4) % 4) !== a1);
    } else {
      stream.point(to2[0], to2[1]);
    }
  }
  function corner(p, direction2) {
    return abs$1(p[0] - x02) < epsilon$2 ? direction2 > 0 ? 0 : 3 : abs$1(p[0] - x12) < epsilon$2 ? direction2 > 0 ? 2 : 1 : abs$1(p[1] - y02) < epsilon$2 ? direction2 > 0 ? 1 : 0 : direction2 > 0 ? 3 : 2;
  }
  function compareIntersection2(a2, b) {
    return comparePoint(a2.x, b.x);
  }
  function comparePoint(a2, b) {
    var ca = corner(a2, 1), cb = corner(b, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b[1] - a2[1] : ca === 1 ? a2[0] - b[0] : ca === 2 ? a2[1] - b[1] : b[0] - a2[0];
  }
  return function(stream) {
    var activeStream = stream, bufferStream = clipBuffer(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean;
    var clipStream = {
      point: point2,
      lineStart,
      lineEnd: lineEnd2,
      polygonStart,
      polygonEnd
    };
    function point2(x2, y2) {
      if (visible(x2, y2))
        activeStream.point(x2, y2);
    }
    function polygonInside() {
      var winding = 0;
      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring2 = polygon[i], j2 = 1, m = ring2.length, point3 = ring2[0], a0, a1, b02 = point3[0], b12 = point3[1]; j2 < m; ++j2) {
          a0 = b02, a1 = b12, point3 = ring2[j2], b02 = point3[0], b12 = point3[1];
          if (a1 <= y12) {
            if (b12 > y12 && (b02 - a0) * (y12 - a1) > (b12 - a1) * (x02 - a0))
              ++winding;
          } else {
            if (b12 <= y12 && (b02 - a0) * (y12 - a1) < (b12 - a1) * (x02 - a0))
              --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge$1(segments)).length;
      if (cleanInside || visible2) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate2(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible2) {
          clipRejoin(segments, compareIntersection2, startInside, interpolate2, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint2;
      if (polygon)
        polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd2() {
      if (segments) {
        linePoint2(x__, y__);
        if (v__ && v_)
          bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point2;
      if (v_)
        activeStream.lineEnd();
    }
    function linePoint2(x2, y2) {
      var v = visible(x2, y2);
      if (polygon)
        ring.push([x2, y2]);
      if (first) {
        x__ = x2, y__ = y2, v__ = v;
        first = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x2, y2);
        }
      } else {
        if (v && v_)
          activeStream.point(x2, y2);
        else {
          var a2 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x2 = Math.max(clipMin, Math.min(clipMax, x2)), y2 = Math.max(clipMin, Math.min(clipMax, y2))];
          if (clipLine(a2, b, x02, y02, x12, y12)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a2[0], a2[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v)
              activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x2, y2);
            clean = false;
          }
        }
      }
      x_ = x2, y_ = y2, v_ = v;
    }
    return clipStream;
  };
}
function extent() {
  var x02 = 0, y02 = 0, x12 = 960, y12 = 500, cache2, cacheStream, clip2;
  return clip2 = {
    stream: function(stream) {
      return cache2 && cacheStream === stream ? cache2 : cache2 = clipRectangle(x02, y02, x12, y12)(cacheStream = stream);
    },
    extent: function(_2) {
      return arguments.length ? (x02 = +_2[0][0], y02 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1], cache2 = cacheStream = null, clip2) : [[x02, y02], [x12, y12]];
    }
  };
}
var lengthSum$1 = adder(), lambda0, sinPhi0, cosPhi0;
var lengthStream$1 = {
  sphere: noop$1,
  point: noop$1,
  lineStart: lengthLineStart,
  lineEnd: noop$1,
  polygonStart: noop$1,
  polygonEnd: noop$1
};
function lengthLineStart() {
  lengthStream$1.point = lengthPointFirst$1;
  lengthStream$1.lineEnd = lengthLineEnd;
}
function lengthLineEnd() {
  lengthStream$1.point = lengthStream$1.lineEnd = noop$1;
}
function lengthPointFirst$1(lambda, phi2) {
  lambda *= radians, phi2 *= radians;
  lambda0 = lambda, sinPhi0 = sin$1(phi2), cosPhi0 = cos$1(phi2);
  lengthStream$1.point = lengthPoint$1;
}
function lengthPoint$1(lambda, phi2) {
  lambda *= radians, phi2 *= radians;
  var sinPhi = sin$1(phi2), cosPhi = cos$1(phi2), delta = abs$1(lambda - lambda0), cosDelta = cos$1(delta), sinDelta = sin$1(delta), x2 = cosPhi * sinDelta, y2 = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosDelta, z = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosDelta;
  lengthSum$1.add(atan2$1(sqrt$2(x2 * x2 + y2 * y2), z));
  lambda0 = lambda, sinPhi0 = sinPhi, cosPhi0 = cosPhi;
}
function length$1(object2) {
  lengthSum$1.reset();
  geoStream(object2, lengthStream$1);
  return +lengthSum$1;
}
var coordinates = [null, null], object = { type: "LineString", coordinates };
function distance$1(a2, b) {
  coordinates[0] = a2;
  coordinates[1] = b;
  return length$1(object);
}
var containsObjectType = {
  Feature: function(object2, point2) {
    return containsGeometry(object2.geometry, point2);
  },
  FeatureCollection: function(object2, point2) {
    var features = object2.features, i = -1, n = features.length;
    while (++i < n)
      if (containsGeometry(features[i].geometry, point2))
        return true;
    return false;
  }
};
var containsGeometryType = {
  Sphere: function() {
    return true;
  },
  Point: function(object2, point2) {
    return containsPoint(object2.coordinates, point2);
  },
  MultiPoint: function(object2, point2) {
    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
    while (++i < n)
      if (containsPoint(coordinates2[i], point2))
        return true;
    return false;
  },
  LineString: function(object2, point2) {
    return containsLine(object2.coordinates, point2);
  },
  MultiLineString: function(object2, point2) {
    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
    while (++i < n)
      if (containsLine(coordinates2[i], point2))
        return true;
    return false;
  },
  Polygon: function(object2, point2) {
    return containsPolygon(object2.coordinates, point2);
  },
  MultiPolygon: function(object2, point2) {
    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
    while (++i < n)
      if (containsPolygon(coordinates2[i], point2))
        return true;
    return false;
  },
  GeometryCollection: function(object2, point2) {
    var geometries = object2.geometries, i = -1, n = geometries.length;
    while (++i < n)
      if (containsGeometry(geometries[i], point2))
        return true;
    return false;
  }
};
function containsGeometry(geometry, point2) {
  return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point2) : false;
}
function containsPoint(coordinates2, point2) {
  return distance$1(coordinates2, point2) === 0;
}
function containsLine(coordinates2, point2) {
  var ao, bo, ab;
  for (var i = 0, n = coordinates2.length; i < n; i++) {
    bo = distance$1(coordinates2[i], point2);
    if (bo === 0)
      return true;
    if (i > 0) {
      ab = distance$1(coordinates2[i], coordinates2[i - 1]);
      if (ab > 0 && ao <= ab && bo <= ab && (ao + bo - ab) * (1 - Math.pow((ao - bo) / ab, 2)) < epsilon2$1 * ab)
        return true;
    }
    ao = bo;
  }
  return false;
}
function containsPolygon(coordinates2, point2) {
  return !!polygonContains(coordinates2.map(ringRadians), pointRadians(point2));
}
function ringRadians(ring) {
  return ring = ring.map(pointRadians), ring.pop(), ring;
}
function pointRadians(point2) {
  return [point2[0] * radians, point2[1] * radians];
}
function contains$1(object2, point2) {
  return (object2 && containsObjectType.hasOwnProperty(object2.type) ? containsObjectType[object2.type] : containsGeometry)(object2, point2);
}
function graticuleX(y02, y12, dy) {
  var y2 = sequence(y02, y12 - epsilon$2, dy).concat(y12);
  return function(x2) {
    return y2.map(function(y3) {
      return [x2, y3];
    });
  };
}
function graticuleY(x02, x12, dx) {
  var x2 = sequence(x02, x12 - epsilon$2, dx).concat(x12);
  return function(y2) {
    return x2.map(function(x3) {
      return [x3, y2];
    });
  };
}
function graticule() {
  var x12, x02, X12, X02, y12, y02, Y12, Y02, dx = 10, dy = dx, DX = 90, DY = 360, x2, y2, X3, Y3, precision = 2.5;
  function graticule2() {
    return { type: "MultiLineString", coordinates: lines() };
  }
  function lines() {
    return sequence(ceil(X02 / DX) * DX, X12, DX).map(X3).concat(sequence(ceil(Y02 / DY) * DY, Y12, DY).map(Y3)).concat(sequence(ceil(x02 / dx) * dx, x12, dx).filter(function(x3) {
      return abs$1(x3 % DX) > epsilon$2;
    }).map(x2)).concat(sequence(ceil(y02 / dy) * dy, y12, dy).filter(function(y3) {
      return abs$1(y3 % DY) > epsilon$2;
    }).map(y2));
  }
  graticule2.lines = function() {
    return lines().map(function(coordinates2) {
      return { type: "LineString", coordinates: coordinates2 };
    });
  };
  graticule2.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X3(X02).concat(
          Y3(Y12).slice(1),
          X3(X12).reverse().slice(1),
          Y3(Y02).reverse().slice(1)
        )
      ]
    };
  };
  graticule2.extent = function(_2) {
    if (!arguments.length)
      return graticule2.extentMinor();
    return graticule2.extentMajor(_2).extentMinor(_2);
  };
  graticule2.extentMajor = function(_2) {
    if (!arguments.length)
      return [[X02, Y02], [X12, Y12]];
    X02 = +_2[0][0], X12 = +_2[1][0];
    Y02 = +_2[0][1], Y12 = +_2[1][1];
    if (X02 > X12)
      _2 = X02, X02 = X12, X12 = _2;
    if (Y02 > Y12)
      _2 = Y02, Y02 = Y12, Y12 = _2;
    return graticule2.precision(precision);
  };
  graticule2.extentMinor = function(_2) {
    if (!arguments.length)
      return [[x02, y02], [x12, y12]];
    x02 = +_2[0][0], x12 = +_2[1][0];
    y02 = +_2[0][1], y12 = +_2[1][1];
    if (x02 > x12)
      _2 = x02, x02 = x12, x12 = _2;
    if (y02 > y12)
      _2 = y02, y02 = y12, y12 = _2;
    return graticule2.precision(precision);
  };
  graticule2.step = function(_2) {
    if (!arguments.length)
      return graticule2.stepMinor();
    return graticule2.stepMajor(_2).stepMinor(_2);
  };
  graticule2.stepMajor = function(_2) {
    if (!arguments.length)
      return [DX, DY];
    DX = +_2[0], DY = +_2[1];
    return graticule2;
  };
  graticule2.stepMinor = function(_2) {
    if (!arguments.length)
      return [dx, dy];
    dx = +_2[0], dy = +_2[1];
    return graticule2;
  };
  graticule2.precision = function(_2) {
    if (!arguments.length)
      return precision;
    precision = +_2;
    x2 = graticuleX(y02, y12, 90);
    y2 = graticuleY(x02, x12, precision);
    X3 = graticuleX(Y02, Y12, 90);
    Y3 = graticuleY(X02, X12, precision);
    return graticule2;
  };
  return graticule2.extentMajor([[-180, -90 + epsilon$2], [180, 90 - epsilon$2]]).extentMinor([[-180, -80 - epsilon$2], [180, 80 + epsilon$2]]);
}
function graticule10() {
  return graticule()();
}
function interpolate(a2, b) {
  var x02 = a2[0] * radians, y02 = a2[1] * radians, x12 = b[0] * radians, y12 = b[1] * radians, cy0 = cos$1(y02), sy0 = sin$1(y02), cy1 = cos$1(y12), sy1 = sin$1(y12), kx0 = cy0 * cos$1(x02), ky0 = cy0 * sin$1(x02), kx1 = cy1 * cos$1(x12), ky1 = cy1 * sin$1(x12), d = 2 * asin$1(sqrt$2(haversin(y12 - y02) + cy0 * cy1 * haversin(x12 - x02))), k2 = sin$1(d);
  var interpolate2 = d ? function(t4) {
    var B2 = sin$1(t4 *= d) / k2, A5 = sin$1(d - t4) / k2, x2 = A5 * kx0 + B2 * kx1, y2 = A5 * ky0 + B2 * ky1, z = A5 * sy0 + B2 * sy1;
    return [
      atan2$1(y2, x2) * degrees,
      atan2$1(z, sqrt$2(x2 * x2 + y2 * y2)) * degrees
    ];
  } : function() {
    return [x02 * degrees, y02 * degrees];
  };
  interpolate2.distance = d;
  return interpolate2;
}
function identity$5(x2) {
  return x2;
}
var areaSum = adder(), areaRingSum = adder(), x00$2, y00$2, x0$3, y0$3;
var areaStream = {
  point: noop$1,
  lineStart: noop$1,
  lineEnd: noop$1,
  polygonStart: function() {
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop$1;
    areaSum.add(abs$1(areaRingSum));
    areaRingSum.reset();
  },
  result: function() {
    var area2 = areaSum / 2;
    areaSum.reset();
    return area2;
  }
};
function areaRingStart() {
  areaStream.point = areaPointFirst;
}
function areaPointFirst(x2, y2) {
  areaStream.point = areaPoint;
  x00$2 = x0$3 = x2, y00$2 = y0$3 = y2;
}
function areaPoint(x2, y2) {
  areaRingSum.add(y0$3 * x2 - x0$3 * y2);
  x0$3 = x2, y0$3 = y2;
}
function areaRingEnd() {
  areaPoint(x00$2, y00$2);
}
const pathArea = areaStream;
var x0$2 = Infinity, y0$2 = x0$2, x1 = -x0$2, y1 = x1;
var boundsStream = {
  point: boundsPoint,
  lineStart: noop$1,
  lineEnd: noop$1,
  polygonStart: noop$1,
  polygonEnd: noop$1,
  result: function() {
    var bounds2 = [[x0$2, y0$2], [x1, y1]];
    x1 = y1 = -(y0$2 = x0$2 = Infinity);
    return bounds2;
  }
};
function boundsPoint(x2, y2) {
  if (x2 < x0$2)
    x0$2 = x2;
  if (x2 > x1)
    x1 = x2;
  if (y2 < y0$2)
    y0$2 = y2;
  if (y2 > y1)
    y1 = y2;
}
const boundsStream$1 = boundsStream;
var X0 = 0, Y0 = 0, Z0 = 0, X1 = 0, Y1 = 0, Z1 = 0, X2 = 0, Y2 = 0, Z2 = 0, x00$1, y00$1, x0$1, y0$1;
var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function() {
    var centroid2 = Z2 ? [X2 / Z2, Y2 / Z2] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN];
    X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
    return centroid2;
  }
};
function centroidPoint(x2, y2) {
  X0 += x2;
  Y0 += y2;
  ++Z0;
}
function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}
function centroidPointFirstLine(x2, y2) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x0$1 = x2, y0$1 = y2);
}
function centroidPointLine(x2, y2) {
  var dx = x2 - x0$1, dy = y2 - y0$1, z = sqrt$2(dx * dx + dy * dy);
  X1 += z * (x0$1 + x2) / 2;
  Y1 += z * (y0$1 + y2) / 2;
  Z1 += z;
  centroidPoint(x0$1 = x2, y0$1 = y2);
}
function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}
function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}
function centroidRingEnd() {
  centroidPointRing(x00$1, y00$1);
}
function centroidPointFirstRing(x2, y2) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x00$1 = x0$1 = x2, y00$1 = y0$1 = y2);
}
function centroidPointRing(x2, y2) {
  var dx = x2 - x0$1, dy = y2 - y0$1, z = sqrt$2(dx * dx + dy * dy);
  X1 += z * (x0$1 + x2) / 2;
  Y1 += z * (y0$1 + y2) / 2;
  Z1 += z;
  z = y0$1 * x2 - x0$1 * y2;
  X2 += z * (x0$1 + x2);
  Y2 += z * (y0$1 + y2);
  Z2 += z * 3;
  centroidPoint(x0$1 = x2, y0$1 = y2);
}
const pathCentroid = centroidStream;
function PathContext(context) {
  this._context = context;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_2) {
    return this._radius = _2, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0)
      this._context.closePath();
    this._point = NaN;
  },
  point: function(x2, y2) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x2, y2);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x2, y2);
        break;
      }
      default: {
        this._context.moveTo(x2 + this._radius, y2);
        this._context.arc(x2, y2, this._radius, 0, tau$1);
        break;
      }
    }
  },
  result: noop$1
};
var lengthSum = adder(), lengthRing, x00, y00, x0, y0;
var lengthStream = {
  point: noop$1,
  lineStart: function() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing)
      lengthPoint(x00, y00);
    lengthStream.point = noop$1;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length2 = +lengthSum;
    lengthSum.reset();
    return length2;
  }
};
function lengthPointFirst(x2, y2) {
  lengthStream.point = lengthPoint;
  x00 = x0 = x2, y00 = y0 = y2;
}
function lengthPoint(x2, y2) {
  x0 -= x2, y0 -= y2;
  lengthSum.add(sqrt$2(x0 * x0 + y0 * y0));
  x0 = x2, y0 = y2;
}
const pathMeasure = lengthStream;
function PathString() {
  this._string = [];
}
PathString.prototype = {
  _radius: 4.5,
  _circle: circle$3(4.5),
  pointRadius: function(_2) {
    if ((_2 = +_2) !== this._radius)
      this._radius = _2, this._circle = null;
    return this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0)
      this._string.push("Z");
    this._point = NaN;
  },
  point: function(x2, y2) {
    switch (this._point) {
      case 0: {
        this._string.push("M", x2, ",", y2);
        this._point = 1;
        break;
      }
      case 1: {
        this._string.push("L", x2, ",", y2);
        break;
      }
      default: {
        if (this._circle == null)
          this._circle = circle$3(this._radius);
        this._string.push("M", x2, ",", y2, this._circle);
        break;
      }
    }
  },
  result: function() {
    if (this._string.length) {
      var result = this._string.join("");
      this._string = [];
      return result;
    } else {
      return null;
    }
  }
};
function circle$3(radius) {
  return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
}
function index$2(projection2, context) {
  var pointRadius = 4.5, projectionStream, contextStream;
  function path2(object2) {
    if (object2) {
      if (typeof pointRadius === "function")
        contextStream.pointRadius(+pointRadius.apply(this, arguments));
      geoStream(object2, projectionStream(contextStream));
    }
    return contextStream.result();
  }
  path2.area = function(object2) {
    geoStream(object2, projectionStream(pathArea));
    return pathArea.result();
  };
  path2.measure = function(object2) {
    geoStream(object2, projectionStream(pathMeasure));
    return pathMeasure.result();
  };
  path2.bounds = function(object2) {
    geoStream(object2, projectionStream(boundsStream$1));
    return boundsStream$1.result();
  };
  path2.centroid = function(object2) {
    geoStream(object2, projectionStream(pathCentroid));
    return pathCentroid.result();
  };
  path2.projection = function(_2) {
    return arguments.length ? (projectionStream = _2 == null ? (projection2 = null, identity$5) : (projection2 = _2).stream, path2) : projection2;
  };
  path2.context = function(_2) {
    if (!arguments.length)
      return context;
    contextStream = _2 == null ? (context = null, new PathString()) : new PathContext(context = _2);
    if (typeof pointRadius !== "function")
      contextStream.pointRadius(pointRadius);
    return path2;
  };
  path2.pointRadius = function(_2) {
    if (!arguments.length)
      return pointRadius;
    pointRadius = typeof _2 === "function" ? _2 : (contextStream.pointRadius(+_2), +_2);
    return path2;
  };
  return path2.projection(projection2).context(context);
}
function transform$1(methods) {
  return {
    stream: transformer$3(methods)
  };
}
function transformer$3(methods) {
  return function(stream) {
    var s2 = new TransformStream();
    for (var key in methods)
      s2[key] = methods[key];
    s2.stream = stream;
    return s2;
  };
}
function TransformStream() {
}
TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x2, y2) {
    this.stream.point(x2, y2);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};
function fit(projection2, fitBounds, object2) {
  var clip2 = projection2.clipExtent && projection2.clipExtent();
  projection2.scale(150).translate([0, 0]);
  if (clip2 != null)
    projection2.clipExtent(null);
  geoStream(object2, projection2.stream(boundsStream$1));
  fitBounds(boundsStream$1.result());
  if (clip2 != null)
    projection2.clipExtent(clip2);
  return projection2;
}
function fitExtent(projection2, extent2, object2) {
  return fit(projection2, function(b) {
    var w2 = extent2[1][0] - extent2[0][0], h2 = extent2[1][1] - extent2[0][1], k2 = Math.min(w2 / (b[1][0] - b[0][0]), h2 / (b[1][1] - b[0][1])), x2 = +extent2[0][0] + (w2 - k2 * (b[1][0] + b[0][0])) / 2, y2 = +extent2[0][1] + (h2 - k2 * (b[1][1] + b[0][1])) / 2;
    projection2.scale(150 * k2).translate([x2, y2]);
  }, object2);
}
function fitSize(projection2, size, object2) {
  return fitExtent(projection2, [[0, 0], size], object2);
}
function fitWidth(projection2, width2, object2) {
  return fit(projection2, function(b) {
    var w2 = +width2, k2 = w2 / (b[1][0] - b[0][0]), x2 = (w2 - k2 * (b[1][0] + b[0][0])) / 2, y2 = -k2 * b[0][1];
    projection2.scale(150 * k2).translate([x2, y2]);
  }, object2);
}
function fitHeight(projection2, height2, object2) {
  return fit(projection2, function(b) {
    var h2 = +height2, k2 = h2 / (b[1][1] - b[0][1]), x2 = -k2 * b[0][0], y2 = (h2 - k2 * (b[1][1] + b[0][1])) / 2;
    projection2.scale(150 * k2).translate([x2, y2]);
  }, object2);
}
var maxDepth = 16, cosMinDistance = cos$1(30 * radians);
function resample(project, delta2) {
  return +delta2 ? resample$1(project, delta2) : resampleNone(project);
}
function resampleNone(project) {
  return transformer$3({
    point: function(x2, y2) {
      x2 = project(x2, y2);
      this.stream.point(x2[0], x2[1]);
    }
  });
}
function resample$1(project, delta2) {
  function resampleLineTo(x02, y02, lambda02, a0, b02, c0, x12, y12, lambda12, a1, b12, c1, depth, stream) {
    var dx = x12 - x02, dy = y12 - y02, d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a2 = a0 + a1, b = b02 + b12, c2 = c0 + c1, m = sqrt$2(a2 * a2 + b * b + c2 * c2), phi2 = asin$1(c2 /= m), lambda22 = abs$1(abs$1(c2) - 1) < epsilon$2 || abs$1(lambda02 - lambda12) < epsilon$2 ? (lambda02 + lambda12) / 2 : atan2$1(b, a2), p = project(lambda22, phi2), x2 = p[0], y2 = p[1], dx2 = x2 - x02, dy2 = y2 - y02, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 || abs$1((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b02 * b12 + c0 * c1 < cosMinDistance) {
        resampleLineTo(x02, y02, lambda02, a0, b02, c0, x2, y2, lambda22, a2 /= m, b /= m, c2, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda22, a2, b, c2, x12, y12, lambda12, a1, b12, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda002, x002, y002, a00, b00, c00, lambda02, x02, y02, a0, b02, c0;
    var resampleStream = {
      point: point2,
      lineStart,
      lineEnd: lineEnd2,
      polygonStart: function() {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point2(x2, y2) {
      x2 = project(x2, y2);
      stream.point(x2[0], x2[1]);
    }
    function lineStart() {
      x02 = NaN;
      resampleStream.point = linePoint2;
      stream.lineStart();
    }
    function linePoint2(lambda, phi2) {
      var c2 = cartesian([lambda, phi2]), p = project(lambda, phi2);
      resampleLineTo(x02, y02, lambda02, a0, b02, c0, x02 = p[0], y02 = p[1], lambda02 = lambda, a0 = c2[0], b02 = c2[1], c0 = c2[2], maxDepth, stream);
      stream.point(x02, y02);
    }
    function lineEnd2() {
      resampleStream.point = point2;
      stream.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi2) {
      linePoint2(lambda002 = lambda, phi2), x002 = x02, y002 = y02, a00 = a0, b00 = b02, c00 = c0;
      resampleStream.point = linePoint2;
    }
    function ringEnd() {
      resampleLineTo(x02, y02, lambda02, a0, b02, c0, x002, y002, lambda002, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd2;
      lineEnd2();
    }
    return resampleStream;
  };
}
var transformRadians = transformer$3({
  point: function(x2, y2) {
    this.stream.point(x2 * radians, y2 * radians);
  }
});
function transformRotate(rotate) {
  return transformer$3({
    point: function(x2, y2) {
      var r = rotate(x2, y2);
      return this.stream.point(r[0], r[1]);
    }
  });
}
function scaleTranslate(k2, dx, dy, sx, sy) {
  function transform2(x2, y2) {
    x2 *= sx;
    y2 *= sy;
    return [dx + k2 * x2, dy - k2 * y2];
  }
  transform2.invert = function(x2, y2) {
    return [(x2 - dx) / k2 * sx, (dy - y2) / k2 * sy];
  };
  return transform2;
}
function scaleTranslateRotate(k2, dx, dy, sx, sy, alpha2) {
  var cosAlpha = cos$1(alpha2), sinAlpha = sin$1(alpha2), a2 = cosAlpha * k2, b = sinAlpha * k2, ai = cosAlpha / k2, bi = sinAlpha / k2, ci = (sinAlpha * dy - cosAlpha * dx) / k2, fi = (sinAlpha * dx + cosAlpha * dy) / k2;
  function transform2(x2, y2) {
    x2 *= sx;
    y2 *= sy;
    return [a2 * x2 - b * y2 + dx, dy - b * x2 - a2 * y2];
  }
  transform2.invert = function(x2, y2) {
    return [sx * (ai * x2 - bi * y2 + ci), sy * (fi - bi * x2 - ai * y2)];
  };
  return transform2;
}
function projection(project) {
  return projectionMutator(function() {
    return project;
  })();
}
function projectionMutator(projectAt) {
  var project, k2 = 150, x2 = 480, y2 = 250, lambda = 0, phi2 = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, alpha2 = 0, sx = 1, sy = 1, theta = null, preclip = clipAntimeridian, x02 = null, y02, x12, y12, postclip = identity$5, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache2, cacheStream;
  function projection2(point2) {
    return projectRotateTransform(point2[0] * radians, point2[1] * radians);
  }
  function invert2(point2) {
    point2 = projectRotateTransform.invert(point2[0], point2[1]);
    return point2 && [point2[0] * degrees, point2[1] * degrees];
  }
  projection2.stream = function(stream) {
    return cache2 && cacheStream === stream ? cache2 : cache2 = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };
  projection2.preclip = function(_2) {
    return arguments.length ? (preclip = _2, theta = void 0, reset2()) : preclip;
  };
  projection2.postclip = function(_2) {
    return arguments.length ? (postclip = _2, x02 = y02 = x12 = y12 = null, reset2()) : postclip;
  };
  projection2.clipAngle = function(_2) {
    return arguments.length ? (preclip = +_2 ? clipCircle(theta = _2 * radians) : (theta = null, clipAntimeridian), reset2()) : theta * degrees;
  };
  projection2.clipExtent = function(_2) {
    return arguments.length ? (postclip = _2 == null ? (x02 = y02 = x12 = y12 = null, identity$5) : clipRectangle(x02 = +_2[0][0], y02 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reset2()) : x02 == null ? null : [[x02, y02], [x12, y12]];
  };
  projection2.scale = function(_2) {
    return arguments.length ? (k2 = +_2, recenter()) : k2;
  };
  projection2.translate = function(_2) {
    return arguments.length ? (x2 = +_2[0], y2 = +_2[1], recenter()) : [x2, y2];
  };
  projection2.center = function(_2) {
    return arguments.length ? (lambda = _2[0] % 360 * radians, phi2 = _2[1] % 360 * radians, recenter()) : [lambda * degrees, phi2 * degrees];
  };
  projection2.rotate = function(_2) {
    return arguments.length ? (deltaLambda = _2[0] % 360 * radians, deltaPhi = _2[1] % 360 * radians, deltaGamma = _2.length > 2 ? _2[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
  };
  projection2.angle = function(_2) {
    return arguments.length ? (alpha2 = _2 % 360 * radians, recenter()) : alpha2 * degrees;
  };
  projection2.reflectX = function(_2) {
    return arguments.length ? (sx = _2 ? -1 : 1, recenter()) : sx < 0;
  };
  projection2.reflectY = function(_2) {
    return arguments.length ? (sy = _2 ? -1 : 1, recenter()) : sy < 0;
  };
  projection2.precision = function(_2) {
    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _2 * _2), reset2()) : sqrt$2(delta2);
  };
  projection2.fitExtent = function(extent2, object2) {
    return fitExtent(projection2, extent2, object2);
  };
  projection2.fitSize = function(size, object2) {
    return fitSize(projection2, size, object2);
  };
  projection2.fitWidth = function(width2, object2) {
    return fitWidth(projection2, width2, object2);
  };
  projection2.fitHeight = function(height2, object2) {
    return fitHeight(projection2, height2, object2);
  };
  function recenter() {
    var center2 = scaleTranslateRotate(k2, 0, 0, sx, sy, alpha2).apply(null, project(lambda, phi2)), transform2 = (alpha2 ? scaleTranslateRotate : scaleTranslate)(k2, x2 - center2[0], y2 - center2[1], sx, sy, alpha2);
    rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose(project, transform2);
    projectRotateTransform = compose(rotate, projectTransform);
    projectResample = resample(projectTransform, delta2);
    return reset2();
  }
  function reset2() {
    cache2 = cacheStream = null;
    return projection2;
  }
  return function() {
    project = projectAt.apply(this, arguments);
    projection2.invert = project.invert && invert2;
    return recenter();
  };
}
function conicProjection(projectAt) {
  var phi02 = 0, phi12 = pi$1 / 3, m = projectionMutator(projectAt), p = m(phi02, phi12);
  p.parallels = function(_2) {
    return arguments.length ? m(phi02 = _2[0] * radians, phi12 = _2[1] * radians) : [phi02 * degrees, phi12 * degrees];
  };
  return p;
}
function cylindricalEqualAreaRaw(phi02) {
  var cosPhi02 = cos$1(phi02);
  function forward(lambda, phi2) {
    return [lambda * cosPhi02, sin$1(phi2) / cosPhi02];
  }
  forward.invert = function(x2, y2) {
    return [x2 / cosPhi02, asin$1(y2 * cosPhi02)];
  };
  return forward;
}
function conicEqualAreaRaw(y02, y12) {
  var sy0 = sin$1(y02), n = (sy0 + sin$1(y12)) / 2;
  if (abs$1(n) < epsilon$2)
    return cylindricalEqualAreaRaw(y02);
  var c2 = 1 + sy0 * (2 * n - sy0), r0 = sqrt$2(c2) / n;
  function project(x2, y2) {
    var r = sqrt$2(c2 - 2 * n * sin$1(y2)) / n;
    return [r * sin$1(x2 *= n), r0 - r * cos$1(x2)];
  }
  project.invert = function(x2, y2) {
    var r0y = r0 - y2, l2 = atan2$1(x2, abs$1(r0y)) * sign$1(r0y);
    if (r0y * n < 0)
      l2 -= pi$1 * sign$1(x2) * sign$1(r0y);
    return [l2 / n, asin$1((c2 - (x2 * x2 + r0y * r0y) * n * n) / (2 * n))];
  };
  return project;
}
function conicEqualArea() {
  return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
}
function albers() {
  return conicEqualArea().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function(x2, y2) {
      var i = -1;
      while (++i < n)
        streams[i].point(x2, y2);
    },
    sphere: function() {
      var i = -1;
      while (++i < n)
        streams[i].sphere();
    },
    lineStart: function() {
      var i = -1;
      while (++i < n)
        streams[i].lineStart();
    },
    lineEnd: function() {
      var i = -1;
      while (++i < n)
        streams[i].lineEnd();
    },
    polygonStart: function() {
      var i = -1;
      while (++i < n)
        streams[i].polygonStart();
    },
    polygonEnd: function() {
      var i = -1;
      while (++i < n)
        streams[i].polygonEnd();
    }
  };
}
function albersUsa() {
  var cache2, cacheStream, lower48 = albers(), lower48Point, alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point2, pointStream = { point: function(x2, y2) {
    point2 = [x2, y2];
  } };
  function albersUsa2(coordinates2) {
    var x2 = coordinates2[0], y2 = coordinates2[1];
    return point2 = null, (lower48Point.point(x2, y2), point2) || (alaskaPoint.point(x2, y2), point2) || (hawaiiPoint.point(x2, y2), point2);
  }
  albersUsa2.invert = function(coordinates2) {
    var k2 = lower48.scale(), t4 = lower48.translate(), x2 = (coordinates2[0] - t4[0]) / k2, y2 = (coordinates2[1] - t4[1]) / k2;
    return (y2 >= 0.12 && y2 < 0.234 && x2 >= -0.425 && x2 < -0.214 ? alaska : y2 >= 0.166 && y2 < 0.234 && x2 >= -0.214 && x2 < -0.115 ? hawaii : lower48).invert(coordinates2);
  };
  albersUsa2.stream = function(stream) {
    return cache2 && cacheStream === stream ? cache2 : cache2 = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };
  albersUsa2.precision = function(_2) {
    if (!arguments.length)
      return lower48.precision();
    lower48.precision(_2), alaska.precision(_2), hawaii.precision(_2);
    return reset2();
  };
  albersUsa2.scale = function(_2) {
    if (!arguments.length)
      return lower48.scale();
    lower48.scale(_2), alaska.scale(_2 * 0.35), hawaii.scale(_2);
    return albersUsa2.translate(lower48.translate());
  };
  albersUsa2.translate = function(_2) {
    if (!arguments.length)
      return lower48.translate();
    var k2 = lower48.scale(), x2 = +_2[0], y2 = +_2[1];
    lower48Point = lower48.translate(_2).clipExtent([[x2 - 0.455 * k2, y2 - 0.238 * k2], [x2 + 0.455 * k2, y2 + 0.238 * k2]]).stream(pointStream);
    alaskaPoint = alaska.translate([x2 - 0.307 * k2, y2 + 0.201 * k2]).clipExtent([[x2 - 0.425 * k2 + epsilon$2, y2 + 0.12 * k2 + epsilon$2], [x2 - 0.214 * k2 - epsilon$2, y2 + 0.234 * k2 - epsilon$2]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x2 - 0.205 * k2, y2 + 0.212 * k2]).clipExtent([[x2 - 0.214 * k2 + epsilon$2, y2 + 0.166 * k2 + epsilon$2], [x2 - 0.115 * k2 - epsilon$2, y2 + 0.234 * k2 - epsilon$2]]).stream(pointStream);
    return reset2();
  };
  albersUsa2.fitExtent = function(extent2, object2) {
    return fitExtent(albersUsa2, extent2, object2);
  };
  albersUsa2.fitSize = function(size, object2) {
    return fitSize(albersUsa2, size, object2);
  };
  albersUsa2.fitWidth = function(width2, object2) {
    return fitWidth(albersUsa2, width2, object2);
  };
  albersUsa2.fitHeight = function(height2, object2) {
    return fitHeight(albersUsa2, height2, object2);
  };
  function reset2() {
    cache2 = cacheStream = null;
    return albersUsa2;
  }
  return albersUsa2.scale(1070);
}
function azimuthalRaw(scale) {
  return function(x2, y2) {
    var cx = cos$1(x2), cy = cos$1(y2), k2 = scale(cx * cy);
    return [
      k2 * cy * sin$1(x2),
      k2 * sin$1(y2)
    ];
  };
}
function azimuthalInvert(angle2) {
  return function(x2, y2) {
    var z = sqrt$2(x2 * x2 + y2 * y2), c2 = angle2(z), sc = sin$1(c2), cc = cos$1(c2);
    return [
      atan2$1(x2 * sc, z * cc),
      asin$1(z && y2 * sc / z)
    ];
  };
}
var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt$2(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
  return 2 * asin$1(z / 2);
});
function azimuthalEqualArea() {
  return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
}
var azimuthalEquidistantRaw = azimuthalRaw(function(c2) {
  return (c2 = acos$1(c2)) && c2 / sin$1(c2);
});
azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
  return z;
});
function azimuthalEquidistant() {
  return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}
function mercatorRaw(lambda, phi2) {
  return [lambda, log$3(tan((halfPi$1 + phi2) / 2))];
}
mercatorRaw.invert = function(x2, y2) {
  return [x2, 2 * atan(exp(y2)) - halfPi$1];
};
function mercator() {
  return mercatorProjection(mercatorRaw).scale(961 / tau$1);
}
function mercatorProjection(project) {
  var m = projection(project), center2 = m.center, scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, x02 = null, y02, x12, y12;
  m.scale = function(_2) {
    return arguments.length ? (scale(_2), reclip()) : scale();
  };
  m.translate = function(_2) {
    return arguments.length ? (translate(_2), reclip()) : translate();
  };
  m.center = function(_2) {
    return arguments.length ? (center2(_2), reclip()) : center2();
  };
  m.clipExtent = function(_2) {
    return arguments.length ? (_2 == null ? x02 = y02 = x12 = y12 = null : (x02 = +_2[0][0], y02 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reclip()) : x02 == null ? null : [[x02, y02], [x12, y12]];
  };
  function reclip() {
    var k2 = pi$1 * scale(), t4 = m(rotation(m.rotate()).invert([0, 0]));
    return clipExtent(x02 == null ? [[t4[0] - k2, t4[1] - k2], [t4[0] + k2, t4[1] + k2]] : project === mercatorRaw ? [[Math.max(t4[0] - k2, x02), y02], [Math.min(t4[0] + k2, x12), y12]] : [[x02, Math.max(t4[1] - k2, y02)], [x12, Math.min(t4[1] + k2, y12)]]);
  }
  return reclip();
}
function tany(y2) {
  return tan((halfPi$1 + y2) / 2);
}
function conicConformalRaw(y02, y12) {
  var cy0 = cos$1(y02), n = y02 === y12 ? sin$1(y02) : log$3(cy0 / cos$1(y12)) / log$3(tany(y12) / tany(y02)), f2 = cy0 * pow$1(tany(y02), n) / n;
  if (!n)
    return mercatorRaw;
  function project(x2, y2) {
    if (f2 > 0) {
      if (y2 < -halfPi$1 + epsilon$2)
        y2 = -halfPi$1 + epsilon$2;
    } else {
      if (y2 > halfPi$1 - epsilon$2)
        y2 = halfPi$1 - epsilon$2;
    }
    var r = f2 / pow$1(tany(y2), n);
    return [r * sin$1(n * x2), f2 - r * cos$1(n * x2)];
  }
  project.invert = function(x2, y2) {
    var fy = f2 - y2, r = sign$1(n) * sqrt$2(x2 * x2 + fy * fy), l2 = atan2$1(x2, abs$1(fy)) * sign$1(fy);
    if (fy * n < 0)
      l2 -= pi$1 * sign$1(x2) * sign$1(fy);
    return [l2 / n, 2 * atan(pow$1(f2 / r, 1 / n)) - halfPi$1];
  };
  return project;
}
function conicConformal() {
  return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
}
function equirectangularRaw(lambda, phi2) {
  return [lambda, phi2];
}
equirectangularRaw.invert = equirectangularRaw;
function equirectangular() {
  return projection(equirectangularRaw).scale(152.63);
}
function conicEquidistantRaw(y02, y12) {
  var cy0 = cos$1(y02), n = y02 === y12 ? sin$1(y02) : (cy0 - cos$1(y12)) / (y12 - y02), g2 = cy0 / n + y02;
  if (abs$1(n) < epsilon$2)
    return equirectangularRaw;
  function project(x2, y2) {
    var gy = g2 - y2, nx = n * x2;
    return [gy * sin$1(nx), g2 - gy * cos$1(nx)];
  }
  project.invert = function(x2, y2) {
    var gy = g2 - y2, l2 = atan2$1(x2, abs$1(gy)) * sign$1(gy);
    if (gy * n < 0)
      l2 -= pi$1 * sign$1(x2) * sign$1(gy);
    return [l2 / n, g2 - sign$1(n) * sqrt$2(x2 * x2 + gy * gy)];
  };
  return project;
}
function conicEquidistant() {
  return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
}
var A1 = 1.340264, A2 = -0.081106, A3 = 893e-6, A4 = 3796e-6, M = sqrt$2(3) / 2, iterations = 12;
function equalEarthRaw(lambda, phi2) {
  var l2 = asin$1(M * sin$1(phi2)), l22 = l2 * l2, l6 = l22 * l22 * l22;
  return [
    lambda * cos$1(l2) / (M * (A1 + 3 * A2 * l22 + l6 * (7 * A3 + 9 * A4 * l22))),
    l2 * (A1 + A2 * l22 + l6 * (A3 + A4 * l22))
  ];
}
equalEarthRaw.invert = function(x2, y2) {
  var l2 = y2, l22 = l2 * l2, l6 = l22 * l22 * l22;
  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
    fy = l2 * (A1 + A2 * l22 + l6 * (A3 + A4 * l22)) - y2;
    fpy = A1 + 3 * A2 * l22 + l6 * (7 * A3 + 9 * A4 * l22);
    l2 -= delta = fy / fpy, l22 = l2 * l2, l6 = l22 * l22 * l22;
    if (abs$1(delta) < epsilon2$1)
      break;
  }
  return [
    M * x2 * (A1 + 3 * A2 * l22 + l6 * (7 * A3 + 9 * A4 * l22)) / cos$1(l2),
    asin$1(sin$1(l2) / M)
  ];
};
function equalEarth() {
  return projection(equalEarthRaw).scale(177.158);
}
function gnomonicRaw(x2, y2) {
  var cy = cos$1(y2), k2 = cos$1(x2) * cy;
  return [cy * sin$1(x2) / k2, sin$1(y2) / k2];
}
gnomonicRaw.invert = azimuthalInvert(atan);
function gnomonic() {
  return projection(gnomonicRaw).scale(144.049).clipAngle(60);
}
function identity$4() {
  var k2 = 1, tx = 0, ty = 0, sx = 1, sy = 1, alpha2 = 0, ca, sa, x02 = null, y02, x12, y12, kx2 = 1, ky2 = 1, transform2 = transformer$3({
    point: function(x2, y2) {
      var p = projection2([x2, y2]);
      this.stream.point(p[0], p[1]);
    }
  }), postclip = identity$5, cache2, cacheStream;
  function reset2() {
    kx2 = k2 * sx;
    ky2 = k2 * sy;
    cache2 = cacheStream = null;
    return projection2;
  }
  function projection2(p) {
    var x2 = p[0] * kx2, y2 = p[1] * ky2;
    if (alpha2) {
      var t4 = y2 * ca - x2 * sa;
      x2 = x2 * ca + y2 * sa;
      y2 = t4;
    }
    return [x2 + tx, y2 + ty];
  }
  projection2.invert = function(p) {
    var x2 = p[0] - tx, y2 = p[1] - ty;
    if (alpha2) {
      var t4 = y2 * ca + x2 * sa;
      x2 = x2 * ca - y2 * sa;
      y2 = t4;
    }
    return [x2 / kx2, y2 / ky2];
  };
  projection2.stream = function(stream) {
    return cache2 && cacheStream === stream ? cache2 : cache2 = transform2(postclip(cacheStream = stream));
  };
  projection2.postclip = function(_2) {
    return arguments.length ? (postclip = _2, x02 = y02 = x12 = y12 = null, reset2()) : postclip;
  };
  projection2.clipExtent = function(_2) {
    return arguments.length ? (postclip = _2 == null ? (x02 = y02 = x12 = y12 = null, identity$5) : clipRectangle(x02 = +_2[0][0], y02 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reset2()) : x02 == null ? null : [[x02, y02], [x12, y12]];
  };
  projection2.scale = function(_2) {
    return arguments.length ? (k2 = +_2, reset2()) : k2;
  };
  projection2.translate = function(_2) {
    return arguments.length ? (tx = +_2[0], ty = +_2[1], reset2()) : [tx, ty];
  };
  projection2.angle = function(_2) {
    return arguments.length ? (alpha2 = _2 % 360 * radians, sa = sin$1(alpha2), ca = cos$1(alpha2), reset2()) : alpha2 * degrees;
  };
  projection2.reflectX = function(_2) {
    return arguments.length ? (sx = _2 ? -1 : 1, reset2()) : sx < 0;
  };
  projection2.reflectY = function(_2) {
    return arguments.length ? (sy = _2 ? -1 : 1, reset2()) : sy < 0;
  };
  projection2.fitExtent = function(extent2, object2) {
    return fitExtent(projection2, extent2, object2);
  };
  projection2.fitSize = function(size, object2) {
    return fitSize(projection2, size, object2);
  };
  projection2.fitWidth = function(width2, object2) {
    return fitWidth(projection2, width2, object2);
  };
  projection2.fitHeight = function(height2, object2) {
    return fitHeight(projection2, height2, object2);
  };
  return projection2;
}
function naturalEarth1Raw(lambda, phi2) {
  var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
  return [
    lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),
    phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))
  ];
}
naturalEarth1Raw.invert = function(x2, y2) {
  var phi2 = y2, i = 25, delta;
  do {
    var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
    phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y2) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));
  } while (abs$1(delta) > epsilon$2 && --i > 0);
  return [
    x2 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),
    phi2
  ];
};
function naturalEarth1() {
  return projection(naturalEarth1Raw).scale(175.295);
}
function orthographicRaw(x2, y2) {
  return [cos$1(y2) * sin$1(x2), sin$1(y2)];
}
orthographicRaw.invert = azimuthalInvert(asin$1);
function orthographic() {
  return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon$2);
}
function stereographicRaw(x2, y2) {
  var cy = cos$1(y2), k2 = 1 + cos$1(x2) * cy;
  return [cy * sin$1(x2) / k2, sin$1(y2) / k2];
}
stereographicRaw.invert = azimuthalInvert(function(z) {
  return 2 * atan(z);
});
function stereographic() {
  return projection(stereographicRaw).scale(250).clipAngle(142);
}
function transverseMercatorRaw(lambda, phi2) {
  return [log$3(tan((halfPi$1 + phi2) / 2)), -lambda];
}
transverseMercatorRaw.invert = function(x2, y2) {
  return [-y2, 2 * atan(exp(x2)) - halfPi$1];
};
function transverseMercator() {
  var m = mercatorProjection(transverseMercatorRaw), center2 = m.center, rotate = m.rotate;
  m.center = function(_2) {
    return arguments.length ? center2([-_2[1], _2[0]]) : (_2 = center2(), [_2[1], -_2[0]]);
  };
  m.rotate = function(_2) {
    return arguments.length ? rotate([_2[0], _2[1], _2.length > 2 ? _2[2] + 90 : 90]) : (_2 = rotate(), [_2[0], _2[1], _2[2] - 90]);
  };
  return rotate([0, 0, 90]).scale(159.155);
}
function defaultSeparation$1(a2, b) {
  return a2.parent === b.parent ? 1 : 2;
}
function meanX(children2) {
  return children2.reduce(meanXReduce, 0) / children2.length;
}
function meanXReduce(x2, c2) {
  return x2 + c2.x;
}
function maxY(children2) {
  return 1 + children2.reduce(maxYReduce, 0);
}
function maxYReduce(y2, c2) {
  return Math.max(y2, c2.y);
}
function leafLeft(node2) {
  var children2;
  while (children2 = node2.children)
    node2 = children2[0];
  return node2;
}
function leafRight(node2) {
  var children2;
  while (children2 = node2.children)
    node2 = children2[children2.length - 1];
  return node2;
}
function cluster() {
  var separation = defaultSeparation$1, dx = 1, dy = 1, nodeSize2 = false;
  function cluster2(root2) {
    var previousNode, x2 = 0;
    root2.eachAfter(function(node2) {
      var children2 = node2.children;
      if (children2) {
        node2.x = meanX(children2);
        node2.y = maxY(children2);
      } else {
        node2.x = previousNode ? x2 += separation(node2, previousNode) : 0;
        node2.y = 0;
        previousNode = node2;
      }
    });
    var left2 = leafLeft(root2), right2 = leafRight(root2), x02 = left2.x - separation(left2, right2) / 2, x12 = right2.x + separation(right2, left2) / 2;
    return root2.eachAfter(nodeSize2 ? function(node2) {
      node2.x = (node2.x - root2.x) * dx;
      node2.y = (root2.y - node2.y) * dy;
    } : function(node2) {
      node2.x = (node2.x - x02) / (x12 - x02) * dx;
      node2.y = (1 - (root2.y ? node2.y / root2.y : 1)) * dy;
    });
  }
  cluster2.separation = function(x2) {
    return arguments.length ? (separation = x2, cluster2) : separation;
  };
  cluster2.size = function(x2) {
    return arguments.length ? (nodeSize2 = false, dx = +x2[0], dy = +x2[1], cluster2) : nodeSize2 ? null : [dx, dy];
  };
  cluster2.nodeSize = function(x2) {
    return arguments.length ? (nodeSize2 = true, dx = +x2[0], dy = +x2[1], cluster2) : nodeSize2 ? [dx, dy] : null;
  };
  return cluster2;
}
function count(node2) {
  var sum2 = 0, children2 = node2.children, i = children2 && children2.length;
  if (!i)
    sum2 = 1;
  else
    while (--i >= 0)
      sum2 += children2[i].value;
  node2.value = sum2;
}
function node_count() {
  return this.eachAfter(count);
}
function node_each(callback) {
  var node2 = this, current, next2 = [node2], children2, i, n;
  do {
    current = next2.reverse(), next2 = [];
    while (node2 = current.pop()) {
      callback(node2), children2 = node2.children;
      if (children2)
        for (i = 0, n = children2.length; i < n; ++i) {
          next2.push(children2[i]);
        }
    }
  } while (next2.length);
  return this;
}
function node_eachBefore(callback) {
  var node2 = this, nodes = [node2], children2, i;
  while (node2 = nodes.pop()) {
    callback(node2), children2 = node2.children;
    if (children2)
      for (i = children2.length - 1; i >= 0; --i) {
        nodes.push(children2[i]);
      }
  }
  return this;
}
function node_eachAfter(callback) {
  var node2 = this, nodes = [node2], next2 = [], children2, i, n;
  while (node2 = nodes.pop()) {
    next2.push(node2), children2 = node2.children;
    if (children2)
      for (i = 0, n = children2.length; i < n; ++i) {
        nodes.push(children2[i]);
      }
  }
  while (node2 = next2.pop()) {
    callback(node2);
  }
  return this;
}
function node_sum(value) {
  return this.eachAfter(function(node2) {
    var sum2 = +value(node2.data) || 0, children2 = node2.children, i = children2 && children2.length;
    while (--i >= 0)
      sum2 += children2[i].value;
    node2.value = sum2;
  });
}
function node_sort(compare2) {
  return this.eachBefore(function(node2) {
    if (node2.children) {
      node2.children.sort(compare2);
    }
  });
}
function node_path(end2) {
  var start2 = this, ancestor = leastCommonAncestor(start2, end2), nodes = [start2];
  while (start2 !== ancestor) {
    start2 = start2.parent;
    nodes.push(start2);
  }
  var k2 = nodes.length;
  while (end2 !== ancestor) {
    nodes.splice(k2, 0, end2);
    end2 = end2.parent;
  }
  return nodes;
}
function leastCommonAncestor(a2, b) {
  if (a2 === b)
    return a2;
  var aNodes = a2.ancestors(), bNodes = b.ancestors(), c2 = null;
  a2 = aNodes.pop();
  b = bNodes.pop();
  while (a2 === b) {
    c2 = a2;
    a2 = aNodes.pop();
    b = bNodes.pop();
  }
  return c2;
}
function node_ancestors() {
  var node2 = this, nodes = [node2];
  while (node2 = node2.parent) {
    nodes.push(node2);
  }
  return nodes;
}
function node_descendants() {
  var nodes = [];
  this.each(function(node2) {
    nodes.push(node2);
  });
  return nodes;
}
function node_leaves() {
  var leaves = [];
  this.eachBefore(function(node2) {
    if (!node2.children) {
      leaves.push(node2);
    }
  });
  return leaves;
}
function node_links() {
  var root2 = this, links2 = [];
  root2.each(function(node2) {
    if (node2 !== root2) {
      links2.push({ source: node2.parent, target: node2 });
    }
  });
  return links2;
}
function hierarchy(data2, children2) {
  var root2 = new Node$2(data2), valued = +data2.value && (root2.value = data2.value), node2, nodes = [root2], child, childs, i, n;
  if (children2 == null)
    children2 = defaultChildren;
  while (node2 = nodes.pop()) {
    if (valued)
      node2.value = +node2.data.value;
    if ((childs = children2(node2.data)) && (n = childs.length)) {
      node2.children = new Array(n);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node2.children[i] = new Node$2(childs[i]));
        child.parent = node2;
        child.depth = node2.depth + 1;
      }
    }
  }
  return root2.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function defaultChildren(d) {
  return d.children;
}
function copyData(node2) {
  node2.data = node2.data.data;
}
function computeHeight(node2) {
  var height2 = 0;
  do
    node2.height = height2;
  while ((node2 = node2.parent) && node2.height < ++height2);
}
function Node$2(data2) {
  this.data = data2;
  this.depth = this.height = 0;
  this.parent = null;
}
Node$2.prototype = hierarchy.prototype = {
  constructor: Node$2,
  count: node_count,
  each: node_each,
  eachAfter: node_eachAfter,
  eachBefore: node_eachBefore,
  sum: node_sum,
  sort: node_sort,
  path: node_path,
  ancestors: node_ancestors,
  descendants: node_descendants,
  leaves: node_leaves,
  links: node_links,
  copy: node_copy
};
var slice$2 = Array.prototype.slice;
function shuffle(array2) {
  var m = array2.length, t4, i;
  while (m) {
    i = Math.random() * m-- | 0;
    t4 = array2[m];
    array2[m] = array2[i];
    array2[i] = t4;
  }
  return array2;
}
function enclose(circles2) {
  var i = 0, n = (circles2 = shuffle(slice$2.call(circles2))).length, B2 = [], p, e;
  while (i < n) {
    p = circles2[i];
    if (e && enclosesWeak(e, p))
      ++i;
    else
      e = encloseBasis(B2 = extendBasis(B2, p)), i = 0;
  }
  return e;
}
function extendBasis(B2, p) {
  var i, j2;
  if (enclosesWeakAll(p, B2))
    return [p];
  for (i = 0; i < B2.length; ++i) {
    if (enclosesNot(p, B2[i]) && enclosesWeakAll(encloseBasis2(B2[i], p), B2)) {
      return [B2[i], p];
    }
  }
  for (i = 0; i < B2.length - 1; ++i) {
    for (j2 = i + 1; j2 < B2.length; ++j2) {
      if (enclosesNot(encloseBasis2(B2[i], B2[j2]), p) && enclosesNot(encloseBasis2(B2[i], p), B2[j2]) && enclosesNot(encloseBasis2(B2[j2], p), B2[i]) && enclosesWeakAll(encloseBasis3(B2[i], B2[j2], p), B2)) {
        return [B2[i], B2[j2], p];
      }
    }
  }
  throw new Error();
}
function enclosesNot(a2, b) {
  var dr = a2.r - b.r, dx = b.x - a2.x, dy = b.y - a2.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}
function enclosesWeak(a2, b) {
  var dr = a2.r - b.r + 1e-6, dx = b.x - a2.x, dy = b.y - a2.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function enclosesWeakAll(a2, B2) {
  for (var i = 0; i < B2.length; ++i) {
    if (!enclosesWeak(a2, B2[i])) {
      return false;
    }
  }
  return true;
}
function encloseBasis(B2) {
  switch (B2.length) {
    case 1:
      return encloseBasis1(B2[0]);
    case 2:
      return encloseBasis2(B2[0], B2[1]);
    case 3:
      return encloseBasis3(B2[0], B2[1], B2[2]);
  }
}
function encloseBasis1(a2) {
  return {
    x: a2.x,
    y: a2.y,
    r: a2.r
  };
}
function encloseBasis2(a2, b) {
  var x12 = a2.x, y12 = a2.y, r1 = a2.r, x2 = b.x, y2 = b.y, r2 = b.r, x21 = x2 - x12, y21 = y2 - y12, r21 = r2 - r1, l2 = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x12 + x2 + x21 / l2 * r21) / 2,
    y: (y12 + y2 + y21 / l2 * r21) / 2,
    r: (l2 + r1 + r2) / 2
  };
}
function encloseBasis3(a2, b, c2) {
  var x12 = a2.x, y12 = a2.y, r1 = a2.r, x2 = b.x, y2 = b.y, r2 = b.r, x3 = c2.x, y3 = c2.y, r3 = c2.r, a22 = x12 - x2, a3 = x12 - x3, b22 = y12 - y2, b32 = y12 - y3, c22 = r2 - r1, c3 = r3 - r1, d1 = x12 * x12 + y12 * y12 - r1 * r1, d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2, d32 = d1 - x3 * x3 - y3 * y3 + r3 * r3, ab = a3 * b22 - a22 * b32, xa = (b22 * d32 - b32 * d2) / (ab * 2) - x12, xb = (b32 * c22 - b22 * c3) / ab, ya = (a3 * d2 - a22 * d32) / (ab * 2) - y12, yb = (a22 * c3 - a3 * c22) / ab, A5 = xb * xb + yb * yb - 1, B2 = 2 * (r1 + xa * xb + ya * yb), C2 = xa * xa + ya * ya - r1 * r1, r = -(A5 ? (B2 + Math.sqrt(B2 * B2 - 4 * A5 * C2)) / (2 * A5) : C2 / B2);
  return {
    x: x12 + xa + xb * r,
    y: y12 + ya + yb * r,
    r
  };
}
function place(b, a2, c2) {
  var dx = b.x - a2.x, x2, a22, dy = b.y - a2.y, y2, b22, d2 = dx * dx + dy * dy;
  if (d2) {
    a22 = a2.r + c2.r, a22 *= a22;
    b22 = b.r + c2.r, b22 *= b22;
    if (a22 > b22) {
      x2 = (d2 + b22 - a22) / (2 * d2);
      y2 = Math.sqrt(Math.max(0, b22 / d2 - x2 * x2));
      c2.x = b.x - x2 * dx - y2 * dy;
      c2.y = b.y - x2 * dy + y2 * dx;
    } else {
      x2 = (d2 + a22 - b22) / (2 * d2);
      y2 = Math.sqrt(Math.max(0, a22 / d2 - x2 * x2));
      c2.x = a2.x + x2 * dx - y2 * dy;
      c2.y = a2.y + x2 * dy + y2 * dx;
    }
  } else {
    c2.x = a2.x + c2.r;
    c2.y = a2.y;
  }
}
function intersects(a2, b) {
  var dr = a2.r + b.r - 1e-6, dx = b.x - a2.x, dy = b.y - a2.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function score(node2) {
  var a2 = node2._, b = node2.next._, ab = a2.r + b.r, dx = (a2.x * b.r + b.x * a2.r) / ab, dy = (a2.y * b.r + b.y * a2.r) / ab;
  return dx * dx + dy * dy;
}
function Node$1(circle2) {
  this._ = circle2;
  this.next = null;
  this.previous = null;
}
function packEnclose(circles2) {
  if (!(n = circles2.length))
    return 0;
  var a2, b, c2, n, aa, ca, i, j2, k2, sj, sk;
  a2 = circles2[0], a2.x = 0, a2.y = 0;
  if (!(n > 1))
    return a2.r;
  b = circles2[1], a2.x = -b.r, b.x = a2.r, b.y = 0;
  if (!(n > 2))
    return a2.r + b.r;
  place(b, a2, c2 = circles2[2]);
  a2 = new Node$1(a2), b = new Node$1(b), c2 = new Node$1(c2);
  a2.next = c2.previous = b;
  b.next = a2.previous = c2;
  c2.next = b.previous = a2;
  pack:
    for (i = 3; i < n; ++i) {
      place(a2._, b._, c2 = circles2[i]), c2 = new Node$1(c2);
      j2 = b.next, k2 = a2.previous, sj = b._.r, sk = a2._.r;
      do {
        if (sj <= sk) {
          if (intersects(j2._, c2._)) {
            b = j2, a2.next = b, b.previous = a2, --i;
            continue pack;
          }
          sj += j2._.r, j2 = j2.next;
        } else {
          if (intersects(k2._, c2._)) {
            a2 = k2, a2.next = b, b.previous = a2, --i;
            continue pack;
          }
          sk += k2._.r, k2 = k2.previous;
        }
      } while (j2 !== k2.next);
      c2.previous = a2, c2.next = b, a2.next = b.previous = b = c2;
      aa = score(a2);
      while ((c2 = c2.next) !== b) {
        if ((ca = score(c2)) < aa) {
          a2 = c2, aa = ca;
        }
      }
      b = a2.next;
    }
  a2 = [b._], c2 = b;
  while ((c2 = c2.next) !== b)
    a2.push(c2._);
  c2 = enclose(a2);
  for (i = 0; i < n; ++i)
    a2 = circles2[i], a2.x -= c2.x, a2.y -= c2.y;
  return c2.r;
}
function siblings(circles2) {
  packEnclose(circles2);
  return circles2;
}
function optional(f2) {
  return f2 == null ? null : required(f2);
}
function required(f2) {
  if (typeof f2 !== "function")
    throw new Error();
  return f2;
}
function constantZero() {
  return 0;
}
function constant$4(x2) {
  return function() {
    return x2;
  };
}
function defaultRadius(d) {
  return Math.sqrt(d.value);
}
function index$1() {
  var radius = null, dx = 1, dy = 1, padding2 = constantZero;
  function pack(root2) {
    root2.x = dx / 2, root2.y = dy / 2;
    if (radius) {
      root2.eachBefore(radiusLeaf(radius)).eachAfter(packChildren(padding2, 0.5)).eachBefore(translateChild(1));
    } else {
      root2.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildren(constantZero, 1)).eachAfter(packChildren(padding2, root2.r / Math.min(dx, dy))).eachBefore(translateChild(Math.min(dx, dy) / (2 * root2.r)));
    }
    return root2;
  }
  pack.radius = function(x2) {
    return arguments.length ? (radius = optional(x2), pack) : radius;
  };
  pack.size = function(x2) {
    return arguments.length ? (dx = +x2[0], dy = +x2[1], pack) : [dx, dy];
  };
  pack.padding = function(x2) {
    return arguments.length ? (padding2 = typeof x2 === "function" ? x2 : constant$4(+x2), pack) : padding2;
  };
  return pack;
}
function radiusLeaf(radius) {
  return function(node2) {
    if (!node2.children) {
      node2.r = Math.max(0, +radius(node2) || 0);
    }
  };
}
function packChildren(padding2, k2) {
  return function(node2) {
    if (children2 = node2.children) {
      var children2, i, n = children2.length, r = padding2(node2) * k2 || 0, e;
      if (r)
        for (i = 0; i < n; ++i)
          children2[i].r += r;
      e = packEnclose(children2);
      if (r)
        for (i = 0; i < n; ++i)
          children2[i].r -= r;
      node2.r = e + r;
    }
  };
}
function translateChild(k2) {
  return function(node2) {
    var parent = node2.parent;
    node2.r *= k2;
    if (parent) {
      node2.x = parent.x + k2 * node2.x;
      node2.y = parent.y + k2 * node2.y;
    }
  };
}
function roundNode(node2) {
  node2.x0 = Math.round(node2.x0);
  node2.y0 = Math.round(node2.y0);
  node2.x1 = Math.round(node2.x1);
  node2.y1 = Math.round(node2.y1);
}
function treemapDice(parent, x02, y02, x12, y12) {
  var nodes = parent.children, node2, i = -1, n = nodes.length, k2 = parent.value && (x12 - x02) / parent.value;
  while (++i < n) {
    node2 = nodes[i], node2.y0 = y02, node2.y1 = y12;
    node2.x0 = x02, node2.x1 = x02 += node2.value * k2;
  }
}
function partition() {
  var dx = 1, dy = 1, padding2 = 0, round = false;
  function partition2(root2) {
    var n = root2.height + 1;
    root2.x0 = root2.y0 = padding2;
    root2.x1 = dx;
    root2.y1 = dy / n;
    root2.eachBefore(positionNode2(dy, n));
    if (round)
      root2.eachBefore(roundNode);
    return root2;
  }
  function positionNode2(dy2, n) {
    return function(node2) {
      if (node2.children) {
        treemapDice(node2, node2.x0, dy2 * (node2.depth + 1) / n, node2.x1, dy2 * (node2.depth + 2) / n);
      }
      var x02 = node2.x0, y02 = node2.y0, x12 = node2.x1 - padding2, y12 = node2.y1 - padding2;
      if (x12 < x02)
        x02 = x12 = (x02 + x12) / 2;
      if (y12 < y02)
        y02 = y12 = (y02 + y12) / 2;
      node2.x0 = x02;
      node2.y0 = y02;
      node2.x1 = x12;
      node2.y1 = y12;
    };
  }
  partition2.round = function(x2) {
    return arguments.length ? (round = !!x2, partition2) : round;
  };
  partition2.size = function(x2) {
    return arguments.length ? (dx = +x2[0], dy = +x2[1], partition2) : [dx, dy];
  };
  partition2.padding = function(x2) {
    return arguments.length ? (padding2 = +x2, partition2) : padding2;
  };
  return partition2;
}
var keyPrefix = "$", preroot = { depth: -1 }, ambiguous = {};
function defaultId(d) {
  return d.id;
}
function defaultParentId(d) {
  return d.parentId;
}
function stratify() {
  var id2 = defaultId, parentId = defaultParentId;
  function stratify2(data2) {
    var d, i, n = data2.length, root2, parent, node2, nodes = new Array(n), nodeId, nodeKey, nodeByKey = {};
    for (i = 0; i < n; ++i) {
      d = data2[i], node2 = nodes[i] = new Node$2(d);
      if ((nodeId = id2(d, i, data2)) != null && (nodeId += "")) {
        nodeKey = keyPrefix + (node2.id = nodeId);
        nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node2;
      }
    }
    for (i = 0; i < n; ++i) {
      node2 = nodes[i], nodeId = parentId(data2[i], i, data2);
      if (nodeId == null || !(nodeId += "")) {
        if (root2)
          throw new Error("multiple roots");
        root2 = node2;
      } else {
        parent = nodeByKey[keyPrefix + nodeId];
        if (!parent)
          throw new Error("missing: " + nodeId);
        if (parent === ambiguous)
          throw new Error("ambiguous: " + nodeId);
        if (parent.children)
          parent.children.push(node2);
        else
          parent.children = [node2];
        node2.parent = parent;
      }
    }
    if (!root2)
      throw new Error("no root");
    root2.parent = preroot;
    root2.eachBefore(function(node3) {
      node3.depth = node3.parent.depth + 1;
      --n;
    }).eachBefore(computeHeight);
    root2.parent = null;
    if (n > 0)
      throw new Error("cycle");
    return root2;
  }
  stratify2.id = function(x2) {
    return arguments.length ? (id2 = required(x2), stratify2) : id2;
  };
  stratify2.parentId = function(x2) {
    return arguments.length ? (parentId = required(x2), stratify2) : parentId;
  };
  return stratify2;
}
function defaultSeparation(a2, b) {
  return a2.parent === b.parent ? 1 : 2;
}
function nextLeft(v) {
  var children2 = v.children;
  return children2 ? children2[0] : v.t;
}
function nextRight(v) {
  var children2 = v.children;
  return children2 ? children2[children2.length - 1] : v.t;
}
function moveSubtree(wm, wp, shift2) {
  var change2 = shift2 / (wp.i - wm.i);
  wp.c -= change2;
  wp.s += shift2;
  wm.c += change2;
  wp.z += shift2;
  wp.m += shift2;
}
function executeShifts(v) {
  var shift2 = 0, change2 = 0, children2 = v.children, i = children2.length, w2;
  while (--i >= 0) {
    w2 = children2[i];
    w2.z += shift2;
    w2.m += shift2;
    shift2 += w2.s + (change2 += w2.c);
  }
}
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}
function TreeNode(node2, i) {
  this._ = node2;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i;
}
TreeNode.prototype = Object.create(Node$2.prototype);
function treeRoot(root2) {
  var tree2 = new TreeNode(root2, 0), node2, nodes = [tree2], child, children2, i, n;
  while (node2 = nodes.pop()) {
    if (children2 = node2._.children) {
      node2.children = new Array(n = children2.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node2.children[i] = new TreeNode(children2[i], i));
        child.parent = node2;
      }
    }
  }
  (tree2.parent = new TreeNode(null, 0)).children = [tree2];
  return tree2;
}
function tree() {
  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize2 = null;
  function tree2(root2) {
    var t4 = treeRoot(root2);
    t4.eachAfter(firstWalk), t4.parent.m = -t4.z;
    t4.eachBefore(secondWalk);
    if (nodeSize2)
      root2.eachBefore(sizeNode);
    else {
      var left2 = root2, right2 = root2, bottom2 = root2;
      root2.eachBefore(function(node2) {
        if (node2.x < left2.x)
          left2 = node2;
        if (node2.x > right2.x)
          right2 = node2;
        if (node2.depth > bottom2.depth)
          bottom2 = node2;
      });
      var s2 = left2 === right2 ? 1 : separation(left2, right2) / 2, tx = s2 - left2.x, kx2 = dx / (right2.x + s2 + tx), ky2 = dy / (bottom2.depth || 1);
      root2.eachBefore(function(node2) {
        node2.x = (node2.x + tx) * kx2;
        node2.y = node2.depth * ky2;
      });
    }
    return root2;
  }
  function firstWalk(v) {
    var children2 = v.children, siblings2 = v.parent.children, w2 = v.i ? siblings2[v.i - 1] : null;
    if (children2) {
      executeShifts(v);
      var midpoint = (children2[0].z + children2[children2.length - 1].z) / 2;
      if (w2) {
        v.z = w2.z + separation(v._, w2._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w2) {
      v.z = w2.z + separation(v._, w2._);
    }
    v.parent.A = apportion(v, w2, v.parent.A || siblings2[0]);
  }
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }
  function apportion(v, w2, ancestor) {
    if (w2) {
      var vip = v, vop = v, vim = w2, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift2;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift2 = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift2 > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift2);
          sip += shift2;
          sop += shift2;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }
  function sizeNode(node2) {
    node2.x *= dx;
    node2.y = node2.depth * dy;
  }
  tree2.separation = function(x2) {
    return arguments.length ? (separation = x2, tree2) : separation;
  };
  tree2.size = function(x2) {
    return arguments.length ? (nodeSize2 = false, dx = +x2[0], dy = +x2[1], tree2) : nodeSize2 ? null : [dx, dy];
  };
  tree2.nodeSize = function(x2) {
    return arguments.length ? (nodeSize2 = true, dx = +x2[0], dy = +x2[1], tree2) : nodeSize2 ? [dx, dy] : null;
  };
  return tree2;
}
function treemapSlice(parent, x02, y02, x12, y12) {
  var nodes = parent.children, node2, i = -1, n = nodes.length, k2 = parent.value && (y12 - y02) / parent.value;
  while (++i < n) {
    node2 = nodes[i], node2.x0 = x02, node2.x1 = x12;
    node2.y0 = y02, node2.y1 = y02 += node2.value * k2;
  }
}
var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent, x02, y02, x12, y12) {
  var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha2, beta;
  while (i0 < n) {
    dx = x12 - x02, dy = y12 - y02;
    do
      sumValue = nodes[i1++].value;
    while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha2 = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha2;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue)
        minValue = nodeValue;
      if (nodeValue > maxValue)
        maxValue = nodeValue;
      beta = sumValue * sumValue * alpha2;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
    if (row.dice)
      treemapDice(row, x02, y02, x12, value ? y02 += dy * sumValue / value : y12);
    else
      treemapSlice(row, x02, y02, value ? x02 += dx * sumValue / value : x12, y12);
    value -= sumValue, i0 = i1;
  }
  return rows;
}
const squarify = function custom10(ratio) {
  function squarify2(parent, x02, y02, x12, y12) {
    squarifyRatio(ratio, parent, x02, y02, x12, y12);
  }
  squarify2.ratio = function(x2) {
    return custom10((x2 = +x2) > 1 ? x2 : 1);
  };
  return squarify2;
}(phi);
function index() {
  var tile = squarify, round = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
  function treemap(root2) {
    root2.x0 = root2.y0 = 0;
    root2.x1 = dx;
    root2.y1 = dy;
    root2.eachBefore(positionNode2);
    paddingStack = [0];
    if (round)
      root2.eachBefore(roundNode);
    return root2;
  }
  function positionNode2(node2) {
    var p = paddingStack[node2.depth], x02 = node2.x0 + p, y02 = node2.y0 + p, x12 = node2.x1 - p, y12 = node2.y1 - p;
    if (x12 < x02)
      x02 = x12 = (x02 + x12) / 2;
    if (y12 < y02)
      y02 = y12 = (y02 + y12) / 2;
    node2.x0 = x02;
    node2.y0 = y02;
    node2.x1 = x12;
    node2.y1 = y12;
    if (node2.children) {
      p = paddingStack[node2.depth + 1] = paddingInner(node2) / 2;
      x02 += paddingLeft(node2) - p;
      y02 += paddingTop(node2) - p;
      x12 -= paddingRight(node2) - p;
      y12 -= paddingBottom(node2) - p;
      if (x12 < x02)
        x02 = x12 = (x02 + x12) / 2;
      if (y12 < y02)
        y02 = y12 = (y02 + y12) / 2;
      tile(node2, x02, y02, x12, y12);
    }
  }
  treemap.round = function(x2) {
    return arguments.length ? (round = !!x2, treemap) : round;
  };
  treemap.size = function(x2) {
    return arguments.length ? (dx = +x2[0], dy = +x2[1], treemap) : [dx, dy];
  };
  treemap.tile = function(x2) {
    return arguments.length ? (tile = required(x2), treemap) : tile;
  };
  treemap.padding = function(x2) {
    return arguments.length ? treemap.paddingInner(x2).paddingOuter(x2) : treemap.paddingInner();
  };
  treemap.paddingInner = function(x2) {
    return arguments.length ? (paddingInner = typeof x2 === "function" ? x2 : constant$4(+x2), treemap) : paddingInner;
  };
  treemap.paddingOuter = function(x2) {
    return arguments.length ? treemap.paddingTop(x2).paddingRight(x2).paddingBottom(x2).paddingLeft(x2) : treemap.paddingTop();
  };
  treemap.paddingTop = function(x2) {
    return arguments.length ? (paddingTop = typeof x2 === "function" ? x2 : constant$4(+x2), treemap) : paddingTop;
  };
  treemap.paddingRight = function(x2) {
    return arguments.length ? (paddingRight = typeof x2 === "function" ? x2 : constant$4(+x2), treemap) : paddingRight;
  };
  treemap.paddingBottom = function(x2) {
    return arguments.length ? (paddingBottom = typeof x2 === "function" ? x2 : constant$4(+x2), treemap) : paddingBottom;
  };
  treemap.paddingLeft = function(x2) {
    return arguments.length ? (paddingLeft = typeof x2 === "function" ? x2 : constant$4(+x2), treemap) : paddingLeft;
  };
  return treemap;
}
function binary(parent, x02, y02, x12, y12) {
  var nodes = parent.children, i, n = nodes.length, sum2, sums = new Array(n + 1);
  for (sums[0] = sum2 = i = 0; i < n; ++i) {
    sums[i + 1] = sum2 += nodes[i].value;
  }
  partition2(0, n, parent.value, x02, y02, x12, y12);
  function partition2(i2, j2, value, x03, y03, x13, y13) {
    if (i2 >= j2 - 1) {
      var node2 = nodes[i2];
      node2.x0 = x03, node2.y0 = y03;
      node2.x1 = x13, node2.y1 = y13;
      return;
    }
    var valueOffset = sums[i2], valueTarget = value / 2 + valueOffset, k2 = i2 + 1, hi = j2 - 1;
    while (k2 < hi) {
      var mid = k2 + hi >>> 1;
      if (sums[mid] < valueTarget)
        k2 = mid + 1;
      else
        hi = mid;
    }
    if (valueTarget - sums[k2 - 1] < sums[k2] - valueTarget && i2 + 1 < k2)
      --k2;
    var valueLeft = sums[k2] - valueOffset, valueRight = value - valueLeft;
    if (x13 - x03 > y13 - y03) {
      var xk = (x03 * valueRight + x13 * valueLeft) / value;
      partition2(i2, k2, valueLeft, x03, y03, xk, y13);
      partition2(k2, j2, valueRight, xk, y03, x13, y13);
    } else {
      var yk = (y03 * valueRight + y13 * valueLeft) / value;
      partition2(i2, k2, valueLeft, x03, y03, x13, yk);
      partition2(k2, j2, valueRight, x03, yk, x13, y13);
    }
  }
}
function sliceDice(parent, x02, y02, x12, y12) {
  (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x02, y02, x12, y12);
}
const resquarify = function custom11(ratio) {
  function resquarify2(parent, x02, y02, x12, y12) {
    if ((rows = parent._squarify) && rows.ratio === ratio) {
      var rows, row, nodes, i, j2 = -1, n, m = rows.length, value = parent.value;
      while (++j2 < m) {
        row = rows[j2], nodes = row.children;
        for (i = row.value = 0, n = nodes.length; i < n; ++i)
          row.value += nodes[i].value;
        if (row.dice)
          treemapDice(row, x02, y02, x12, y02 += (y12 - y02) * row.value / value);
        else
          treemapSlice(row, x02, y02, x02 += (x12 - x02) * row.value / value, y12);
        value -= row.value;
      }
    } else {
      parent._squarify = rows = squarifyRatio(ratio, parent, x02, y02, x12, y12);
      rows.ratio = ratio;
    }
  }
  resquarify2.ratio = function(x2) {
    return custom11((x2 = +x2) > 1 ? x2 : 1);
  };
  return resquarify2;
}(phi);
function area$1(polygon) {
  var i = -1, n = polygon.length, a2, b = polygon[n - 1], area2 = 0;
  while (++i < n) {
    a2 = b;
    b = polygon[i];
    area2 += a2[1] * b[0] - a2[0] * b[1];
  }
  return area2 / 2;
}
function centroid(polygon) {
  var i = -1, n = polygon.length, x2 = 0, y2 = 0, a2, b = polygon[n - 1], c2, k2 = 0;
  while (++i < n) {
    a2 = b;
    b = polygon[i];
    k2 += c2 = a2[0] * b[1] - b[0] * a2[1];
    x2 += (a2[0] + b[0]) * c2;
    y2 += (a2[1] + b[1]) * c2;
  }
  return k2 *= 3, [x2 / k2, y2 / k2];
}
function cross$2(a2, b, c2) {
  return (b[0] - a2[0]) * (c2[1] - a2[1]) - (b[1] - a2[1]) * (c2[0] - a2[0]);
}
function lexicographicOrder(a2, b) {
  return a2[0] - b[0] || a2[1] - b[1];
}
function computeUpperHullIndexes(points) {
  var n = points.length, indexes = [0, 1], size = 2;
  for (var i = 2; i < n; ++i) {
    while (size > 1 && cross$2(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0)
      --size;
    indexes[size++] = i;
  }
  return indexes.slice(0, size);
}
function hull(points) {
  if ((n = points.length) < 3)
    return null;
  var i, n, sortedPoints = new Array(n), flippedPoints = new Array(n);
  for (i = 0; i < n; ++i)
    sortedPoints[i] = [+points[i][0], +points[i][1], i];
  sortedPoints.sort(lexicographicOrder);
  for (i = 0; i < n; ++i)
    flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];
  var upperIndexes = computeUpperHullIndexes(sortedPoints), lowerIndexes = computeUpperHullIndexes(flippedPoints);
  var skipLeft = lowerIndexes[0] === upperIndexes[0], skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1], hull2 = [];
  for (i = upperIndexes.length - 1; i >= 0; --i)
    hull2.push(points[sortedPoints[upperIndexes[i]][2]]);
  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i)
    hull2.push(points[sortedPoints[lowerIndexes[i]][2]]);
  return hull2;
}
function contains(polygon, point2) {
  var n = polygon.length, p = polygon[n - 1], x2 = point2[0], y2 = point2[1], x02 = p[0], y02 = p[1], x12, y12, inside2 = false;
  for (var i = 0; i < n; ++i) {
    p = polygon[i], x12 = p[0], y12 = p[1];
    if (y12 > y2 !== y02 > y2 && x2 < (x02 - x12) * (y2 - y12) / (y02 - y12) + x12)
      inside2 = !inside2;
    x02 = x12, y02 = y12;
  }
  return inside2;
}
function length(polygon) {
  var i = -1, n = polygon.length, b = polygon[n - 1], xa, ya, xb = b[0], yb = b[1], perimeter = 0;
  while (++i < n) {
    xa = xb;
    ya = yb;
    b = polygon[i];
    xb = b[0];
    yb = b[1];
    xa -= xb;
    ya -= yb;
    perimeter += Math.sqrt(xa * xa + ya * ya);
  }
  return perimeter;
}
function defaultSource() {
  return Math.random();
}
const uniform = function sourceRandomUniform(source) {
  function randomUniform(min2, max2) {
    min2 = min2 == null ? 0 : +min2;
    max2 = max2 == null ? 1 : +max2;
    if (arguments.length === 1)
      max2 = min2, min2 = 0;
    else
      max2 -= min2;
    return function() {
      return source() * max2 + min2;
    };
  }
  randomUniform.source = sourceRandomUniform;
  return randomUniform;
}(defaultSource);
const normal = function sourceRandomNormal(source) {
  function randomNormal(mu, sigma) {
    var x2, r;
    mu = mu == null ? 0 : +mu;
    sigma = sigma == null ? 1 : +sigma;
    return function() {
      var y2;
      if (x2 != null)
        y2 = x2, x2 = null;
      else
        do {
          x2 = source() * 2 - 1;
          y2 = source() * 2 - 1;
          r = x2 * x2 + y2 * y2;
        } while (!r || r > 1);
      return mu + sigma * y2 * Math.sqrt(-2 * Math.log(r) / r);
    };
  }
  randomNormal.source = sourceRandomNormal;
  return randomNormal;
}(defaultSource);
const logNormal = function sourceRandomLogNormal(source) {
  function randomLogNormal() {
    var randomNormal = normal.source(source).apply(this, arguments);
    return function() {
      return Math.exp(randomNormal());
    };
  }
  randomLogNormal.source = sourceRandomLogNormal;
  return randomLogNormal;
}(defaultSource);
const irwinHall = function sourceRandomIrwinHall(source) {
  function randomIrwinHall(n) {
    return function() {
      for (var sum2 = 0, i = 0; i < n; ++i)
        sum2 += source();
      return sum2;
    };
  }
  randomIrwinHall.source = sourceRandomIrwinHall;
  return randomIrwinHall;
}(defaultSource);
const bates = function sourceRandomBates(source) {
  function randomBates(n) {
    var randomIrwinHall = irwinHall.source(source)(n);
    return function() {
      return randomIrwinHall() / n;
    };
  }
  randomBates.source = sourceRandomBates;
  return randomBates;
}(defaultSource);
const exponential = function sourceRandomExponential(source) {
  function randomExponential(lambda) {
    return function() {
      return -Math.log(1 - source()) / lambda;
    };
  }
  randomExponential.source = sourceRandomExponential;
  return randomExponential;
}(defaultSource);
function initRange(domain, range2) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range2).domain(domain);
      break;
  }
  return this;
}
function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.interpolator(domain);
      break;
    default:
      this.interpolator(interpolator).domain(domain);
      break;
  }
  return this;
}
var array = Array.prototype;
var map = array.map;
var slice$1 = array.slice;
var implicit = { name: "implicit" };
function ordinal() {
  var index2 = map$2(), domain = [], range2 = [], unknown = implicit;
  function scale(d) {
    var key = d + "", i = index2.get(key);
    if (!i) {
      if (unknown !== implicit)
        return unknown;
      index2.set(key, i = domain.push(d));
    }
    return range2[(i - 1) % range2.length];
  }
  scale.domain = function(_2) {
    if (!arguments.length)
      return domain.slice();
    domain = [], index2 = map$2();
    var i = -1, n = _2.length, d, key;
    while (++i < n)
      if (!index2.has(key = (d = _2[i]) + ""))
        index2.set(key, domain.push(d));
    return scale;
  };
  scale.range = function(_2) {
    return arguments.length ? (range2 = slice$1.call(_2), scale) : range2.slice();
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  scale.copy = function() {
    return ordinal(domain, range2).unknown(unknown);
  };
  initRange.apply(scale, arguments);
  return scale;
}
function band() {
  var scale = ordinal().unknown(void 0), domain = scale.domain, ordinalRange = scale.range, range2 = [0, 1], step2, bandwidth, round = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
  delete scale.unknown;
  function rescale() {
    var n = domain().length, reverse2 = range2[1] < range2[0], start2 = range2[reverse2 - 0], stop = range2[1 - reverse2];
    step2 = (stop - start2) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round)
      step2 = Math.floor(step2);
    start2 += (stop - start2 - step2 * (n - paddingInner)) * align;
    bandwidth = step2 * (1 - paddingInner);
    if (round)
      start2 = Math.round(start2), bandwidth = Math.round(bandwidth);
    var values2 = sequence(n).map(function(i) {
      return start2 + step2 * i;
    });
    return ordinalRange(reverse2 ? values2.reverse() : values2);
  }
  scale.domain = function(_2) {
    return arguments.length ? (domain(_2), rescale()) : domain();
  };
  scale.range = function(_2) {
    return arguments.length ? (range2 = [+_2[0], +_2[1]], rescale()) : range2.slice();
  };
  scale.rangeRound = function(_2) {
    return range2 = [+_2[0], +_2[1]], round = true, rescale();
  };
  scale.bandwidth = function() {
    return bandwidth;
  };
  scale.step = function() {
    return step2;
  };
  scale.round = function(_2) {
    return arguments.length ? (round = !!_2, rescale()) : round;
  };
  scale.padding = function(_2) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_2), rescale()) : paddingInner;
  };
  scale.paddingInner = function(_2) {
    return arguments.length ? (paddingInner = Math.min(1, _2), rescale()) : paddingInner;
  };
  scale.paddingOuter = function(_2) {
    return arguments.length ? (paddingOuter = +_2, rescale()) : paddingOuter;
  };
  scale.align = function(_2) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _2)), rescale()) : align;
  };
  scale.copy = function() {
    return band(domain(), range2).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };
  return initRange.apply(rescale(), arguments);
}
function pointish(scale) {
  var copy2 = scale.copy;
  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;
  scale.copy = function() {
    return pointish(copy2());
  };
  return scale;
}
function point$5() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}
function constant$3(x2) {
  return function() {
    return x2;
  };
}
function number$1(x2) {
  return +x2;
}
var unit = [0, 1];
function identity$3(x2) {
  return x2;
}
function normalize(a2, b) {
  return (b -= a2 = +a2) ? function(x2) {
    return (x2 - a2) / b;
  } : constant$3(isNaN(b) ? NaN : 0.5);
}
function clamper(domain) {
  var a2 = domain[0], b = domain[domain.length - 1], t4;
  if (a2 > b)
    t4 = a2, a2 = b, b = t4;
  return function(x2) {
    return Math.max(a2, Math.min(b, x2));
  };
}
function bimap(domain, range2, interpolate2) {
  var d0 = domain[0], d1 = domain[1], r0 = range2[0], r1 = range2[1];
  if (d1 < d0)
    d0 = normalize(d1, d0), r0 = interpolate2(r1, r0);
  else
    d0 = normalize(d0, d1), r0 = interpolate2(r0, r1);
  return function(x2) {
    return r0(d0(x2));
  };
}
function polymap(domain, range2, interpolate2) {
  var j2 = Math.min(domain.length, range2.length) - 1, d = new Array(j2), r = new Array(j2), i = -1;
  if (domain[j2] < domain[0]) {
    domain = domain.slice().reverse();
    range2 = range2.slice().reverse();
  }
  while (++i < j2) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate2(range2[i], range2[i + 1]);
  }
  return function(x2) {
    var i2 = bisectRight(domain, x2, 1, j2) - 1;
    return r[i2](d[i2](x2));
  };
}
function copy$2(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer$2() {
  var domain = unit, range2 = unit, interpolate2 = interpolateValue, transform2, untransform, unknown, clamp = identity$3, piecewise2, output, input;
  function rescale() {
    piecewise2 = Math.min(domain.length, range2.length) > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }
  function scale(x2) {
    return isNaN(x2 = +x2) ? unknown : (output || (output = piecewise2(domain.map(transform2), range2, interpolate2)))(transform2(clamp(x2)));
  }
  scale.invert = function(y2) {
    return clamp(untransform((input || (input = piecewise2(range2, domain.map(transform2), interpolateNumber)))(y2)));
  };
  scale.domain = function(_2) {
    return arguments.length ? (domain = map.call(_2, number$1), clamp === identity$3 || (clamp = clamper(domain)), rescale()) : domain.slice();
  };
  scale.range = function(_2) {
    return arguments.length ? (range2 = slice$1.call(_2), rescale()) : range2.slice();
  };
  scale.rangeRound = function(_2) {
    return range2 = slice$1.call(_2), interpolate2 = interpolateRound, rescale();
  };
  scale.clamp = function(_2) {
    return arguments.length ? (clamp = _2 ? clamper(domain) : identity$3, scale) : clamp !== identity$3;
  };
  scale.interpolate = function(_2) {
    return arguments.length ? (interpolate2 = _2, rescale()) : interpolate2;
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  return function(t4, u) {
    transform2 = t4, untransform = u;
    return rescale();
  };
}
function continuous(transform2, untransform) {
  return transformer$2()(transform2, untransform);
}
function tickFormat(start2, stop, count2, specifier) {
  var step2 = tickStep(start2, stop, count2), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start2), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step2, value)))
        specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound(step2, Math.max(Math.abs(start2), Math.abs(stop)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed(step2)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format$1(specifier);
}
function linearish(scale) {
  var domain = scale.domain;
  scale.ticks = function(count2) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count2 == null ? 10 : count2);
  };
  scale.tickFormat = function(count2, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count2 == null ? 10 : count2, specifier);
  };
  scale.nice = function(count2) {
    if (count2 == null)
      count2 = 10;
    var d = domain(), i0 = 0, i1 = d.length - 1, start2 = d[i0], stop = d[i1], step2;
    if (stop < start2) {
      step2 = start2, start2 = stop, stop = step2;
      step2 = i0, i0 = i1, i1 = step2;
    }
    step2 = tickIncrement(start2, stop, count2);
    if (step2 > 0) {
      start2 = Math.floor(start2 / step2) * step2;
      stop = Math.ceil(stop / step2) * step2;
      step2 = tickIncrement(start2, stop, count2);
    } else if (step2 < 0) {
      start2 = Math.ceil(start2 * step2) / step2;
      stop = Math.floor(stop * step2) / step2;
      step2 = tickIncrement(start2, stop, count2);
    }
    if (step2 > 0) {
      d[i0] = Math.floor(start2 / step2) * step2;
      d[i1] = Math.ceil(stop / step2) * step2;
      domain(d);
    } else if (step2 < 0) {
      d[i0] = Math.ceil(start2 * step2) / step2;
      d[i1] = Math.floor(stop * step2) / step2;
      domain(d);
    }
    return scale;
  };
  return scale;
}
function linear() {
  var scale = continuous(identity$3, identity$3);
  scale.copy = function() {
    return copy$2(scale, linear());
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}
function identity$2(domain) {
  var unknown;
  function scale(x2) {
    return isNaN(x2 = +x2) ? unknown : x2;
  }
  scale.invert = scale;
  scale.domain = scale.range = function(_2) {
    return arguments.length ? (domain = map.call(_2, number$1), scale) : domain.slice();
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  scale.copy = function() {
    return identity$2(domain).unknown(unknown);
  };
  domain = arguments.length ? map.call(domain, number$1) : [0, 1];
  return linearish(scale);
}
function nice(domain, interval2) {
  domain = domain.slice();
  var i0 = 0, i1 = domain.length - 1, x02 = domain[i0], x12 = domain[i1], t4;
  if (x12 < x02) {
    t4 = i0, i0 = i1, i1 = t4;
    t4 = x02, x02 = x12, x12 = t4;
  }
  domain[i0] = interval2.floor(x02);
  domain[i1] = interval2.ceil(x12);
  return domain;
}
function transformLog(x2) {
  return Math.log(x2);
}
function transformExp(x2) {
  return Math.exp(x2);
}
function transformLogn(x2) {
  return -Math.log(-x2);
}
function transformExpn(x2) {
  return -Math.exp(-x2);
}
function pow10(x2) {
  return isFinite(x2) ? +("1e" + x2) : x2 < 0 ? 0 : x2;
}
function powp(base2) {
  return base2 === 10 ? pow10 : base2 === Math.E ? Math.exp : function(x2) {
    return Math.pow(base2, x2);
  };
}
function logp(base2) {
  return base2 === Math.E ? Math.log : base2 === 10 && Math.log10 || base2 === 2 && Math.log2 || (base2 = Math.log(base2), function(x2) {
    return Math.log(x2) / base2;
  });
}
function reflect(f2) {
  return function(x2) {
    return -f2(-x2);
  };
}
function loggish(transform2) {
  var scale = transform2(transformLog, transformExp), domain = scale.domain, base2 = 10, logs, pows;
  function rescale() {
    logs = logp(base2), pows = powp(base2);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform2(transformLogn, transformExpn);
    } else {
      transform2(transformLog, transformExp);
    }
    return scale;
  }
  scale.base = function(_2) {
    return arguments.length ? (base2 = +_2, rescale()) : base2;
  };
  scale.domain = function(_2) {
    return arguments.length ? (domain(_2), rescale()) : domain();
  };
  scale.ticks = function(count2) {
    var d = domain(), u = d[0], v = d[d.length - 1], r;
    if (r = v < u)
      i = u, u = v, v = i;
    var i = logs(u), j2 = logs(v), p, k2, t4, n = count2 == null ? 10 : +count2, z = [];
    if (!(base2 % 1) && j2 - i < n) {
      i = Math.round(i) - 1, j2 = Math.round(j2) + 1;
      if (u > 0)
        for (; i < j2; ++i) {
          for (k2 = 1, p = pows(i); k2 < base2; ++k2) {
            t4 = p * k2;
            if (t4 < u)
              continue;
            if (t4 > v)
              break;
            z.push(t4);
          }
        }
      else
        for (; i < j2; ++i) {
          for (k2 = base2 - 1, p = pows(i); k2 >= 1; --k2) {
            t4 = p * k2;
            if (t4 < u)
              continue;
            if (t4 > v)
              break;
            z.push(t4);
          }
        }
    } else {
      z = ticks(i, j2, Math.min(j2 - i, n)).map(pows);
    }
    return r ? z.reverse() : z;
  };
  scale.tickFormat = function(count2, specifier) {
    if (specifier == null)
      specifier = base2 === 10 ? ".0e" : ",";
    if (typeof specifier !== "function")
      specifier = format$1(specifier);
    if (count2 === Infinity)
      return specifier;
    if (count2 == null)
      count2 = 10;
    var k2 = Math.max(1, base2 * count2 / scale.ticks().length);
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base2 < base2 - 0.5)
        i *= base2;
      return i <= k2 ? specifier(d) : "";
    };
  };
  scale.nice = function() {
    return domain(nice(domain(), {
      floor: function(x2) {
        return pows(Math.floor(logs(x2)));
      },
      ceil: function(x2) {
        return pows(Math.ceil(logs(x2)));
      }
    }));
  };
  return scale;
}
function log$2() {
  var scale = loggish(transformer$2()).domain([1, 10]);
  scale.copy = function() {
    return copy$2(scale, log$2()).base(scale.base());
  };
  initRange.apply(scale, arguments);
  return scale;
}
function transformSymlog(c2) {
  return function(x2) {
    return Math.sign(x2) * Math.log1p(Math.abs(x2 / c2));
  };
}
function transformSymexp(c2) {
  return function(x2) {
    return Math.sign(x2) * Math.expm1(Math.abs(x2)) * c2;
  };
}
function symlogish(transform2) {
  var c2 = 1, scale = transform2(transformSymlog(c2), transformSymexp(c2));
  scale.constant = function(_2) {
    return arguments.length ? transform2(transformSymlog(c2 = +_2), transformSymexp(c2)) : c2;
  };
  return linearish(scale);
}
function symlog() {
  var scale = symlogish(transformer$2());
  scale.copy = function() {
    return copy$2(scale, symlog()).constant(scale.constant());
  };
  return initRange.apply(scale, arguments);
}
function transformPow(exponent2) {
  return function(x2) {
    return x2 < 0 ? -Math.pow(-x2, exponent2) : Math.pow(x2, exponent2);
  };
}
function transformSqrt(x2) {
  return x2 < 0 ? -Math.sqrt(-x2) : Math.sqrt(x2);
}
function transformSquare(x2) {
  return x2 < 0 ? -x2 * x2 : x2 * x2;
}
function powish(transform2) {
  var scale = transform2(identity$3, identity$3), exponent2 = 1;
  function rescale() {
    return exponent2 === 1 ? transform2(identity$3, identity$3) : exponent2 === 0.5 ? transform2(transformSqrt, transformSquare) : transform2(transformPow(exponent2), transformPow(1 / exponent2));
  }
  scale.exponent = function(_2) {
    return arguments.length ? (exponent2 = +_2, rescale()) : exponent2;
  };
  return linearish(scale);
}
function pow() {
  var scale = powish(transformer$2());
  scale.copy = function() {
    return copy$2(scale, pow()).exponent(scale.exponent());
  };
  initRange.apply(scale, arguments);
  return scale;
}
function sqrt$1() {
  return pow.apply(null, arguments).exponent(0.5);
}
function quantile() {
  var domain = [], range2 = [], thresholds = [], unknown;
  function rescale() {
    var i = 0, n = Math.max(1, range2.length);
    thresholds = new Array(n - 1);
    while (++i < n)
      thresholds[i - 1] = threshold$1(domain, i / n);
    return scale;
  }
  function scale(x2) {
    return isNaN(x2 = +x2) ? unknown : range2[bisectRight(thresholds, x2)];
  }
  scale.invertExtent = function(y2) {
    var i = range2.indexOf(y2);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };
  scale.domain = function(_2) {
    if (!arguments.length)
      return domain.slice();
    domain = [];
    for (var i = 0, n = _2.length, d; i < n; ++i)
      if (d = _2[i], d != null && !isNaN(d = +d))
        domain.push(d);
    domain.sort(ascending$3);
    return rescale();
  };
  scale.range = function(_2) {
    return arguments.length ? (range2 = slice$1.call(_2), rescale()) : range2.slice();
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  scale.quantiles = function() {
    return thresholds.slice();
  };
  scale.copy = function() {
    return quantile().domain(domain).range(range2).unknown(unknown);
  };
  return initRange.apply(scale, arguments);
}
function quantize() {
  var x02 = 0, x12 = 1, n = 1, domain = [0.5], range2 = [0, 1], unknown;
  function scale(x2) {
    return x2 <= x2 ? range2[bisectRight(domain, x2, 0, n)] : unknown;
  }
  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n)
      domain[i] = ((i + 1) * x12 - (i - n) * x02) / (n + 1);
    return scale;
  }
  scale.domain = function(_2) {
    return arguments.length ? (x02 = +_2[0], x12 = +_2[1], rescale()) : [x02, x12];
  };
  scale.range = function(_2) {
    return arguments.length ? (n = (range2 = slice$1.call(_2)).length - 1, rescale()) : range2.slice();
  };
  scale.invertExtent = function(y2) {
    var i = range2.indexOf(y2);
    return i < 0 ? [NaN, NaN] : i < 1 ? [x02, domain[0]] : i >= n ? [domain[n - 1], x12] : [domain[i - 1], domain[i]];
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : scale;
  };
  scale.thresholds = function() {
    return domain.slice();
  };
  scale.copy = function() {
    return quantize().domain([x02, x12]).range(range2).unknown(unknown);
  };
  return initRange.apply(linearish(scale), arguments);
}
function threshold() {
  var domain = [0.5], range2 = [0, 1], unknown, n = 1;
  function scale(x2) {
    return x2 <= x2 ? range2[bisectRight(domain, x2, 0, n)] : unknown;
  }
  scale.domain = function(_2) {
    return arguments.length ? (domain = slice$1.call(_2), n = Math.min(domain.length, range2.length - 1), scale) : domain.slice();
  };
  scale.range = function(_2) {
    return arguments.length ? (range2 = slice$1.call(_2), n = Math.min(domain.length, range2.length - 1), scale) : range2.slice();
  };
  scale.invertExtent = function(y2) {
    var i = range2.indexOf(y2);
    return [domain[i - 1], domain[i]];
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  scale.copy = function() {
    return threshold().domain(domain).range(range2).unknown(unknown);
  };
  return initRange.apply(scale, arguments);
}
var t0 = new Date(), t1 = new Date();
function newInterval(floori, offseti, count2, field) {
  function interval2(date2) {
    return floori(date2 = arguments.length === 0 ? new Date() : new Date(+date2)), date2;
  }
  interval2.floor = function(date2) {
    return floori(date2 = new Date(+date2)), date2;
  };
  interval2.ceil = function(date2) {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval2.round = function(date2) {
    var d0 = interval2(date2), d1 = interval2.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval2.offset = function(date2, step2) {
    return offseti(date2 = new Date(+date2), step2 == null ? 1 : Math.floor(step2)), date2;
  };
  interval2.range = function(start2, stop, step2) {
    var range2 = [], previous;
    start2 = interval2.ceil(start2);
    step2 = step2 == null ? 1 : Math.floor(step2);
    if (!(start2 < stop) || !(step2 > 0))
      return range2;
    do
      range2.push(previous = new Date(+start2)), offseti(start2, step2), floori(start2);
    while (previous < start2 && start2 < stop);
    return range2;
  };
  interval2.filter = function(test) {
    return newInterval(function(date2) {
      if (date2 >= date2)
        while (floori(date2), !test(date2))
          date2.setTime(date2 - 1);
    }, function(date2, step2) {
      if (date2 >= date2) {
        if (step2 < 0)
          while (++step2 <= 0) {
            while (offseti(date2, -1), !test(date2)) {
            }
          }
        else
          while (--step2 >= 0) {
            while (offseti(date2, 1), !test(date2)) {
            }
          }
      }
    });
  };
  if (count2) {
    interval2.count = function(start2, end2) {
      t0.setTime(+start2), t1.setTime(+end2);
      floori(t0), floori(t1);
      return Math.floor(count2(t0, t1));
    };
    interval2.every = function(step2) {
      step2 = Math.floor(step2);
      return !isFinite(step2) || !(step2 > 0) ? null : !(step2 > 1) ? interval2 : interval2.filter(field ? function(d) {
        return field(d) % step2 === 0;
      } : function(d) {
        return interval2.count(0, d) % step2 === 0;
      });
    };
  }
  return interval2;
}
var millisecond = newInterval(function() {
}, function(date2, step2) {
  date2.setTime(+date2 + step2);
}, function(start2, end2) {
  return end2 - start2;
});
millisecond.every = function(k2) {
  k2 = Math.floor(k2);
  if (!isFinite(k2) || !(k2 > 0))
    return null;
  if (!(k2 > 1))
    return millisecond;
  return newInterval(function(date2) {
    date2.setTime(Math.floor(date2 / k2) * k2);
  }, function(date2, step2) {
    date2.setTime(+date2 + step2 * k2);
  }, function(start2, end2) {
    return (end2 - start2) / k2;
  });
};
const utcMillisecond = millisecond;
var milliseconds = millisecond.range;
var durationSecond$1 = 1e3;
var durationMinute$1 = 6e4;
var durationHour$1 = 36e5;
var durationDay$1 = 864e5;
var durationWeek$1 = 6048e5;
var second = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds());
}, function(date2, step2) {
  date2.setTime(+date2 + step2 * durationSecond$1);
}, function(start2, end2) {
  return (end2 - start2) / durationSecond$1;
}, function(date2) {
  return date2.getUTCSeconds();
});
const utcSecond = second;
var seconds = second.range;
var minute = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond$1);
}, function(date2, step2) {
  date2.setTime(+date2 + step2 * durationMinute$1);
}, function(start2, end2) {
  return (end2 - start2) / durationMinute$1;
}, function(date2) {
  return date2.getMinutes();
});
const timeMinute = minute;
var minutes = minute.range;
var hour = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond$1 - date2.getMinutes() * durationMinute$1);
}, function(date2, step2) {
  date2.setTime(+date2 + step2 * durationHour$1);
}, function(start2, end2) {
  return (end2 - start2) / durationHour$1;
}, function(date2) {
  return date2.getHours();
});
const timeHour = hour;
var hours = hour.range;
var day = newInterval(function(date2) {
  date2.setHours(0, 0, 0, 0);
}, function(date2, step2) {
  date2.setDate(date2.getDate() + step2);
}, function(start2, end2) {
  return (end2 - start2 - (end2.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute$1) / durationDay$1;
}, function(date2) {
  return date2.getDate() - 1;
});
const timeDay = day;
var days = day.range;
function weekday(i) {
  return newInterval(function(date2) {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
    date2.setHours(0, 0, 0, 0);
  }, function(date2, step2) {
    date2.setDate(date2.getDate() + step2 * 7);
  }, function(start2, end2) {
    return (end2 - start2 - (end2.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute$1) / durationWeek$1;
  });
}
var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);
var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;
var month = newInterval(function(date2) {
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
}, function(date2, step2) {
  date2.setMonth(date2.getMonth() + step2);
}, function(start2, end2) {
  return end2.getMonth() - start2.getMonth() + (end2.getFullYear() - start2.getFullYear()) * 12;
}, function(date2) {
  return date2.getMonth();
});
const timeMonth = month;
var months = month.range;
var year = newInterval(function(date2) {
  date2.setMonth(0, 1);
  date2.setHours(0, 0, 0, 0);
}, function(date2, step2) {
  date2.setFullYear(date2.getFullYear() + step2);
}, function(start2, end2) {
  return end2.getFullYear() - start2.getFullYear();
}, function(date2) {
  return date2.getFullYear();
});
year.every = function(k2) {
  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : newInterval(function(date2) {
    date2.setFullYear(Math.floor(date2.getFullYear() / k2) * k2);
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, function(date2, step2) {
    date2.setFullYear(date2.getFullYear() + step2 * k2);
  });
};
const timeYear = year;
var years = year.range;
var utcMinute = newInterval(function(date2) {
  date2.setUTCSeconds(0, 0);
}, function(date2, step2) {
  date2.setTime(+date2 + step2 * durationMinute$1);
}, function(start2, end2) {
  return (end2 - start2) / durationMinute$1;
}, function(date2) {
  return date2.getUTCMinutes();
});
const utcMinute$1 = utcMinute;
var utcMinutes = utcMinute.range;
var utcHour = newInterval(function(date2) {
  date2.setUTCMinutes(0, 0, 0);
}, function(date2, step2) {
  date2.setTime(+date2 + step2 * durationHour$1);
}, function(start2, end2) {
  return (end2 - start2) / durationHour$1;
}, function(date2) {
  return date2.getUTCHours();
});
const utcHour$1 = utcHour;
var utcHours = utcHour.range;
var utcDay = newInterval(function(date2) {
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step2) {
  date2.setUTCDate(date2.getUTCDate() + step2);
}, function(start2, end2) {
  return (end2 - start2) / durationDay$1;
}, function(date2) {
  return date2.getUTCDate() - 1;
});
const utcDay$1 = utcDay;
var utcDays = utcDay.range;
function utcWeekday(i) {
  return newInterval(function(date2) {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step2) {
    date2.setUTCDate(date2.getUTCDate() + step2 * 7);
  }, function(start2, end2) {
    return (end2 - start2) / durationWeek$1;
  });
}
var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;
var utcMonth = newInterval(function(date2) {
  date2.setUTCDate(1);
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step2) {
  date2.setUTCMonth(date2.getUTCMonth() + step2);
}, function(start2, end2) {
  return end2.getUTCMonth() - start2.getUTCMonth() + (end2.getUTCFullYear() - start2.getUTCFullYear()) * 12;
}, function(date2) {
  return date2.getUTCMonth();
});
const utcMonth$1 = utcMonth;
var utcMonths = utcMonth.range;
var utcYear = newInterval(function(date2) {
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step2) {
  date2.setUTCFullYear(date2.getUTCFullYear() + step2);
}, function(start2, end2) {
  return end2.getUTCFullYear() - start2.getUTCFullYear();
}, function(date2) {
  return date2.getUTCFullYear();
});
utcYear.every = function(k2) {
  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : newInterval(function(date2) {
    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k2) * k2);
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step2) {
    date2.setUTCFullYear(date2.getUTCFullYear() + step2 * k2);
  });
};
const utcYear$1 = utcYear;
var utcYears = utcYear.range;
function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date2.setFullYear(d.y);
    return date2;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date2.setUTCFullYear(d.y);
    return date2;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y2, m, d) {
  return { y: y2, m, d, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale2) {
  var locale_dateTime = locale2.dateTime, locale_date = locale2.date, locale_time = locale2.time, locale_periods = locale2.periods, locale_weekdays = locale2.days, locale_shortWeekdays = locale2.shortDays, locale_months = locale2.months, locale_shortMonths = locale2.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date2) {
      var string2 = [], i = -1, j2 = 0, n = specifier.length, c2, pad2, format2;
      if (!(date2 instanceof Date))
        date2 = new Date(+date2);
      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string2.push(specifier.slice(j2, i));
          if ((pad2 = pads[c2 = specifier.charAt(++i)]) != null)
            c2 = specifier.charAt(++i);
          else
            pad2 = c2 === "e" ? " " : "0";
          if (format2 = formats2[c2])
            c2 = format2(date2, pad2);
          string2.push(c2);
          j2 = i + 1;
        }
      }
      string2.push(specifier.slice(j2, i));
      return string2.join("");
    };
  }
  function newParse(specifier, Z3) {
    return function(string2) {
      var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string2 += "", 0), week, day2;
      if (i != string2.length)
        return null;
      if ("Q" in d)
        return new Date(d.Q);
      if ("s" in d)
        return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z3 && !("Z" in d))
        d.Z = 0;
      if ("p" in d)
        d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0)
        d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53)
          return null;
        if (!("w" in d))
          d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day2 = week.getUTCDay();
          week = day2 > 4 || day2 === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay$1.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day2 = week.getDay();
          week = day2 > 4 || day2 === 0 ? monday.ceil(week) : monday(week);
          week = timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d))
          d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day2 = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day2 + 5) % 7 : d.w + d.U * 7 - (day2 + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }
      return localDate(d);
    };
  }
  function parseSpecifier(d, specifier, string2, j2) {
    var i = 0, n = specifier.length, m = string2.length, c2, parse2;
    while (i < n) {
      if (j2 >= m)
        return -1;
      c2 = specifier.charCodeAt(i++);
      if (c2 === 37) {
        c2 = specifier.charAt(i++);
        parse2 = parses[c2 in pads ? specifier.charAt(i++) : c2];
        if (!parse2 || (j2 = parse2(d, string2, j2)) < 0)
          return -1;
      } else if (c2 != string2.charCodeAt(j2++)) {
        return -1;
      }
    }
    return j2;
  }
  function parsePeriod(d, string2, i) {
    var n = periodRe.exec(string2.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }
  function parseShortWeekday(d, string2, i) {
    var n = shortWeekdayRe.exec(string2.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }
  function parseWeekday(d, string2, i) {
    var n = weekdayRe.exec(string2.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }
  function parseShortMonth(d, string2, i) {
    var n = shortMonthRe.exec(string2.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }
  function parseMonth(d, string2, i) {
    var n = monthRe.exec(string2.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string2, i) {
    return parseSpecifier(d, locale_dateTime, string2, i);
  }
  function parseLocaleDate(d, string2, i) {
    return parseSpecifier(d, locale_date, string2, i);
  }
  function parseLocaleTime(d, string2, i) {
    return parseSpecifier(d, locale_time, string2, i);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f2 = newFormat(specifier += "", formats);
      f2.toString = function() {
        return specifier;
      };
      return f2;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() {
        return specifier;
      };
      return p;
    },
    utcFormat: function(specifier) {
      var f2 = newFormat(specifier += "", utcFormats);
      f2.toString = function() {
        return specifier;
      };
      return f2;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() {
        return specifier;
      };
      return p;
    }
  };
}
var pads = { "-": "", "_": " ", "0": "0" }, numberRe = /^\s*\d+/, percentRe = /^%/, requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad(value, fill, width2) {
  var sign2 = value < 0 ? "-" : "", string2 = (sign2 ? -value : value) + "", length2 = string2.length;
  return sign2 + (length2 < width2 ? new Array(width2 - length2 + 1).join(fill) + string2 : string2);
}
function requote(s2) {
  return s2.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  var map2 = {}, i = -1, n = names.length;
  while (++i < n)
    map2[names[i].toLowerCase()] = i;
  return map2;
}
function parseWeekdayNumberSunday(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
}
function parseZone(d, string2, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string2.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour24(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds(d, string2, i) {
  var n = numberRe.exec(string2.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
}
function parseLiteralPercent(d, string2, i) {
  var n = percentRe.exec(string2.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}
function parseUnixTimestamp(d, string2, i) {
  var n = numberRe.exec(string2.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string2, i) {
  var n = numberRe.exec(string2.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}
function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}
function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear(d, p) {
  return pad(1 + timeDay.count(timeYear(d), d), p, 3);
}
function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}
function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}
function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}
function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}
function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday(d) {
  var day2 = d.getDay();
  return day2 === 0 ? 7 : day2;
}
function formatWeekNumberSunday(d, p) {
  return pad(sunday.count(timeYear(d) - 1, d), p, 2);
}
function dISO(d) {
  var day2 = d.getDay();
  return day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
}
function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad(thursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday(d) {
  return d.getDay();
}
function formatWeekNumberMonday(d, p) {
  return pad(monday.count(timeYear(d) - 1, d), p, 2);
}
function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}
function formatYearISO(d, p) {
  d = dISO(d);
  return pad(d.getFullYear() % 100, p, 2);
}
function formatFullYear(d, p) {
  return pad(d.getFullYear() % 1e4, p, 4);
}
function formatFullYearISO(d, p) {
  var day2 = d.getDay();
  d = day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
  return pad(d.getFullYear() % 1e4, p, 4);
}
function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}
function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}
function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear(d, p) {
  return pad(1 + utcDay$1.count(utcYear$1(d), d), p, 3);
}
function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}
function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p) {
  return pad(utcSunday.count(utcYear$1(d) - 1, d), p, 2);
}
function UTCdISO(d) {
  var day2 = d.getUTCDay();
  return day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad(utcThursday.count(utcYear$1(d), d) + (utcYear$1(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p) {
  return pad(utcMonday.count(utcYear$1(d) - 1, d), p, 2);
}
function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCFullYearISO(d, p) {
  var day2 = d.getUTCDay();
  d = day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
  return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d) {
  return +d;
}
function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1e3);
}
var locale;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;
defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale(definition) {
  locale = formatLocale(definition);
  timeFormat = locale.format;
  timeParse = locale.parse;
  utcFormat = locale.utcFormat;
  utcParse = locale.utcParse;
  return locale;
}
var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
function formatIsoNative(date2) {
  return date2.toISOString();
}
var formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);
const formatIso$1 = formatIso;
function parseIsoNative(string2) {
  var date2 = new Date(string2);
  return isNaN(date2) ? null : date2;
}
var parseIso = +new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : utcParse(isoSpecifier);
const parseIso$1 = parseIso;
var durationSecond = 1e3, durationMinute = durationSecond * 60, durationHour = durationMinute * 60, durationDay = durationHour * 24, durationWeek = durationDay * 7, durationMonth = durationDay * 30, durationYear = durationDay * 365;
function date(t4) {
  return new Date(t4);
}
function number(t4) {
  return t4 instanceof Date ? +t4 : +new Date(+t4);
}
function calendar(year2, month2, week, day2, hour2, minute2, second2, millisecond2, format2) {
  var scale = continuous(identity$3, identity$3), invert2 = scale.invert, domain = scale.domain;
  var formatMillisecond = format2(".%L"), formatSecond = format2(":%S"), formatMinute = format2("%I:%M"), formatHour = format2("%I %p"), formatDay = format2("%a %d"), formatWeek = format2("%b %d"), formatMonth = format2("%B"), formatYear2 = format2("%Y");
  var tickIntervals = [
    [second2, 1, durationSecond],
    [second2, 5, 5 * durationSecond],
    [second2, 15, 15 * durationSecond],
    [second2, 30, 30 * durationSecond],
    [minute2, 1, durationMinute],
    [minute2, 5, 5 * durationMinute],
    [minute2, 15, 15 * durationMinute],
    [minute2, 30, 30 * durationMinute],
    [hour2, 1, durationHour],
    [hour2, 3, 3 * durationHour],
    [hour2, 6, 6 * durationHour],
    [hour2, 12, 12 * durationHour],
    [day2, 1, durationDay],
    [day2, 2, 2 * durationDay],
    [week, 1, durationWeek],
    [month2, 1, durationMonth],
    [month2, 3, 3 * durationMonth],
    [year2, 1, durationYear]
  ];
  function tickFormat2(date2) {
    return (second2(date2) < date2 ? formatMillisecond : minute2(date2) < date2 ? formatSecond : hour2(date2) < date2 ? formatMinute : day2(date2) < date2 ? formatHour : month2(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year2(date2) < date2 ? formatMonth : formatYear2)(date2);
  }
  function tickInterval(interval2, start2, stop, step2) {
    if (interval2 == null)
      interval2 = 10;
    if (typeof interval2 === "number") {
      var target = Math.abs(stop - start2) / interval2, i = bisector(function(i2) {
        return i2[2];
      }).right(tickIntervals, target);
      if (i === tickIntervals.length) {
        step2 = tickStep(start2 / durationYear, stop / durationYear, interval2);
        interval2 = year2;
      } else if (i) {
        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        step2 = i[1];
        interval2 = i[0];
      } else {
        step2 = Math.max(tickStep(start2, stop, interval2), 1);
        interval2 = millisecond2;
      }
    }
    return step2 == null ? interval2 : interval2.every(step2);
  }
  scale.invert = function(y2) {
    return new Date(invert2(y2));
  };
  scale.domain = function(_2) {
    return arguments.length ? domain(map.call(_2, number)) : domain().map(date);
  };
  scale.ticks = function(interval2, step2) {
    var d = domain(), t02 = d[0], t12 = d[d.length - 1], r = t12 < t02, t4;
    if (r)
      t4 = t02, t02 = t12, t12 = t4;
    t4 = tickInterval(interval2, t02, t12, step2);
    t4 = t4 ? t4.range(t02, t12 + 1) : [];
    return r ? t4.reverse() : t4;
  };
  scale.tickFormat = function(count2, specifier) {
    return specifier == null ? tickFormat2 : format2(specifier);
  };
  scale.nice = function(interval2, step2) {
    var d = domain();
    return (interval2 = tickInterval(interval2, d[0], d[d.length - 1], step2)) ? domain(nice(d, interval2)) : scale;
  };
  scale.copy = function() {
    return copy$2(scale, calendar(year2, month2, week, day2, hour2, minute2, second2, millisecond2, format2));
  };
  return scale;
}
function time() {
  return initRange.apply(calendar(timeYear, timeMonth, sunday, timeDay, timeHour, timeMinute, utcSecond, utcMillisecond, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function utcTime() {
  return initRange.apply(calendar(utcYear$1, utcMonth$1, utcSunday, utcDay$1, utcHour$1, utcMinute$1, utcSecond, utcMillisecond, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
function transformer$1() {
  var x02 = 0, x12 = 1, t02, t12, k10, transform2, interpolator = identity$3, clamp = false, unknown;
  function scale(x2) {
    return isNaN(x2 = +x2) ? unknown : interpolator(k10 === 0 ? 0.5 : (x2 = (transform2(x2) - t02) * k10, clamp ? Math.max(0, Math.min(1, x2)) : x2));
  }
  scale.domain = function(_2) {
    return arguments.length ? (t02 = transform2(x02 = +_2[0]), t12 = transform2(x12 = +_2[1]), k10 = t02 === t12 ? 0 : 1 / (t12 - t02), scale) : [x02, x12];
  };
  scale.clamp = function(_2) {
    return arguments.length ? (clamp = !!_2, scale) : clamp;
  };
  scale.interpolator = function(_2) {
    return arguments.length ? (interpolator = _2, scale) : interpolator;
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  return function(t4) {
    transform2 = t4, t02 = t4(x02), t12 = t4(x12), k10 = t02 === t12 ? 0 : 1 / (t12 - t02);
    return scale;
  };
}
function copy$1(source, target) {
  return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
}
function sequential() {
  var scale = linearish(transformer$1()(identity$3));
  scale.copy = function() {
    return copy$1(scale, sequential());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialLog() {
  var scale = loggish(transformer$1()).domain([1, 10]);
  scale.copy = function() {
    return copy$1(scale, sequentialLog()).base(scale.base());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialSymlog() {
  var scale = symlogish(transformer$1());
  scale.copy = function() {
    return copy$1(scale, sequentialSymlog()).constant(scale.constant());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialPow() {
  var scale = powish(transformer$1());
  scale.copy = function() {
    return copy$1(scale, sequentialPow()).exponent(scale.exponent());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}
function sequentialQuantile() {
  var domain = [], interpolator = identity$3;
  function scale(x2) {
    if (!isNaN(x2 = +x2))
      return interpolator((bisectRight(domain, x2) - 1) / (domain.length - 1));
  }
  scale.domain = function(_2) {
    if (!arguments.length)
      return domain.slice();
    domain = [];
    for (var i = 0, n = _2.length, d; i < n; ++i)
      if (d = _2[i], d != null && !isNaN(d = +d))
        domain.push(d);
    domain.sort(ascending$3);
    return scale;
  };
  scale.interpolator = function(_2) {
    return arguments.length ? (interpolator = _2, scale) : interpolator;
  };
  scale.copy = function() {
    return sequentialQuantile(interpolator).domain(domain);
  };
  return initInterpolator.apply(scale, arguments);
}
function transformer() {
  var x02 = 0, x12 = 0.5, x2 = 1, t02, t12, t22, k10, k21, interpolator = identity$3, transform2, clamp = false, unknown;
  function scale(x3) {
    return isNaN(x3 = +x3) ? unknown : (x3 = 0.5 + ((x3 = +transform2(x3)) - t12) * (x3 < t12 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x3)) : x3));
  }
  scale.domain = function(_2) {
    return arguments.length ? (t02 = transform2(x02 = +_2[0]), t12 = transform2(x12 = +_2[1]), t22 = transform2(x2 = +_2[2]), k10 = t02 === t12 ? 0 : 0.5 / (t12 - t02), k21 = t12 === t22 ? 0 : 0.5 / (t22 - t12), scale) : [x02, x12, x2];
  };
  scale.clamp = function(_2) {
    return arguments.length ? (clamp = !!_2, scale) : clamp;
  };
  scale.interpolator = function(_2) {
    return arguments.length ? (interpolator = _2, scale) : interpolator;
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  return function(t4) {
    transform2 = t4, t02 = t4(x02), t12 = t4(x12), t22 = t4(x2), k10 = t02 === t12 ? 0 : 0.5 / (t12 - t02), k21 = t12 === t22 ? 0 : 0.5 / (t22 - t12);
    return scale;
  };
}
function diverging$1() {
  var scale = linearish(transformer()(identity$3));
  scale.copy = function() {
    return copy$1(scale, diverging$1());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingLog() {
  var scale = loggish(transformer()).domain([0.1, 1, 10]);
  scale.copy = function() {
    return copy$1(scale, divergingLog()).base(scale.base());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingSymlog() {
  var scale = symlogish(transformer());
  scale.copy = function() {
    return copy$1(scale, divergingSymlog()).constant(scale.constant());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingPow() {
  var scale = powish(transformer());
  scale.copy = function() {
    return copy$1(scale, divergingPow()).exponent(scale.exponent());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}
function colors$1(specifier) {
  var n = specifier.length / 6 | 0, colors2 = new Array(n), i = 0;
  while (i < n)
    colors2[i] = "#" + specifier.slice(i * 6, ++i * 6);
  return colors2;
}
const category10 = colors$1("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");
const Accent = colors$1("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");
const Dark2 = colors$1("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");
const Paired = colors$1("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");
const Pastel1 = colors$1("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");
const Pastel2 = colors$1("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");
const Set1 = colors$1("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");
const Set2 = colors$1("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");
const Set3 = colors$1("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");
const Tableau10 = colors$1("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");
function ramp$1(scheme2) {
  return rgbBasis(scheme2[scheme2.length - 1]);
}
var scheme$q = new Array(3).concat(
  "d8b365f5f5f55ab4ac",
  "a6611adfc27d80cdc1018571",
  "a6611adfc27df5f5f580cdc1018571",
  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(colors$1);
const BrBG = ramp$1(scheme$q);
var scheme$p = new Array(3).concat(
  "af8dc3f7f7f77fbf7b",
  "7b3294c2a5cfa6dba0008837",
  "7b3294c2a5cff7f7f7a6dba0008837",
  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(colors$1);
const PRGn = ramp$1(scheme$p);
var scheme$o = new Array(3).concat(
  "e9a3c9f7f7f7a1d76a",
  "d01c8bf1b6dab8e1864dac26",
  "d01c8bf1b6daf7f7f7b8e1864dac26",
  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(colors$1);
const PiYG = ramp$1(scheme$o);
var scheme$n = new Array(3).concat(
  "998ec3f7f7f7f1a340",
  "5e3c99b2abd2fdb863e66101",
  "5e3c99b2abd2f7f7f7fdb863e66101",
  "542788998ec3d8daebfee0b6f1a340b35806",
  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(colors$1);
const PuOr = ramp$1(scheme$n);
var scheme$m = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(colors$1);
const RdBu = ramp$1(scheme$m);
var scheme$l = new Array(3).concat(
  "ef8a62ffffff999999",
  "ca0020f4a582bababa404040",
  "ca0020f4a582ffffffbababa404040",
  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(colors$1);
const RdGy = ramp$1(scheme$l);
var scheme$k = new Array(3).concat(
  "fc8d59ffffbf91bfdb",
  "d7191cfdae61abd9e92c7bb6",
  "d7191cfdae61ffffbfabd9e92c7bb6",
  "d73027fc8d59fee090e0f3f891bfdb4575b4",
  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(colors$1);
const RdYlBu = ramp$1(scheme$k);
var scheme$j = new Array(3).concat(
  "fc8d59ffffbf91cf60",
  "d7191cfdae61a6d96a1a9641",
  "d7191cfdae61ffffbfa6d96a1a9641",
  "d73027fc8d59fee08bd9ef8b91cf601a9850",
  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(colors$1);
const RdYlGn = ramp$1(scheme$j);
var scheme$i = new Array(3).concat(
  "fc8d59ffffbf99d594",
  "d7191cfdae61abdda42b83ba",
  "d7191cfdae61ffffbfabdda42b83ba",
  "d53e4ffc8d59fee08be6f59899d5943288bd",
  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(colors$1);
const Spectral = ramp$1(scheme$i);
var scheme$h = new Array(3).concat(
  "e5f5f999d8c92ca25f",
  "edf8fbb2e2e266c2a4238b45",
  "edf8fbb2e2e266c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(colors$1);
const BuGn = ramp$1(scheme$h);
var scheme$g = new Array(3).concat(
  "e0ecf49ebcda8856a7",
  "edf8fbb3cde38c96c688419d",
  "edf8fbb3cde38c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(colors$1);
const BuPu = ramp$1(scheme$g);
var scheme$f = new Array(3).concat(
  "e0f3dba8ddb543a2ca",
  "f0f9e8bae4bc7bccc42b8cbe",
  "f0f9e8bae4bc7bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(colors$1);
const GnBu = ramp$1(scheme$f);
var scheme$e = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(colors$1);
const OrRd = ramp$1(scheme$e);
var scheme$d = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(colors$1);
const PuBuGn = ramp$1(scheme$d);
var scheme$c = new Array(3).concat(
  "ece7f2a6bddb2b8cbe",
  "f1eef6bdc9e174a9cf0570b0",
  "f1eef6bdc9e174a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(colors$1);
const PuBu = ramp$1(scheme$c);
var scheme$b = new Array(3).concat(
  "e7e1efc994c7dd1c77",
  "f1eef6d7b5d8df65b0ce1256",
  "f1eef6d7b5d8df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(colors$1);
const PuRd = ramp$1(scheme$b);
var scheme$a = new Array(3).concat(
  "fde0ddfa9fb5c51b8a",
  "feebe2fbb4b9f768a1ae017e",
  "feebe2fbb4b9f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(colors$1);
const RdPu = ramp$1(scheme$a);
var scheme$9 = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(colors$1);
const YlGnBu = ramp$1(scheme$9);
var scheme$8 = new Array(3).concat(
  "f7fcb9addd8e31a354",
  "ffffccc2e69978c679238443",
  "ffffccc2e69978c67931a354006837",
  "ffffccd9f0a3addd8e78c67931a354006837",
  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(colors$1);
const YlGn = ramp$1(scheme$8);
var scheme$7 = new Array(3).concat(
  "fff7bcfec44fd95f0e",
  "ffffd4fed98efe9929cc4c02",
  "ffffd4fed98efe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(colors$1);
const YlOrBr = ramp$1(scheme$7);
var scheme$6 = new Array(3).concat(
  "ffeda0feb24cf03b20",
  "ffffb2fecc5cfd8d3ce31a1c",
  "ffffb2fecc5cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(colors$1);
const YlOrRd = ramp$1(scheme$6);
var scheme$5 = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(colors$1);
const Blues = ramp$1(scheme$5);
var scheme$4 = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(colors$1);
const Greens = ramp$1(scheme$4);
var scheme$3 = new Array(3).concat(
  "f0f0f0bdbdbd636363",
  "f7f7f7cccccc969696525252",
  "f7f7f7cccccc969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(colors$1);
const Greys = ramp$1(scheme$3);
var scheme$2 = new Array(3).concat(
  "efedf5bcbddc756bb1",
  "f2f0f7cbc9e29e9ac86a51a3",
  "f2f0f7cbc9e29e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(colors$1);
const Purples = ramp$1(scheme$2);
var scheme$1 = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(colors$1);
const Reds = ramp$1(scheme$1);
var scheme = new Array(3).concat(
  "fee6cefdae6be6550d",
  "feeddefdbe85fd8d3cd94701",
  "feeddefdbe85fd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(colors$1);
const Oranges = ramp$1(scheme);
function cividis(t4) {
  t4 = Math.max(0, Math.min(1, t4));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - t4 * (35.34 - t4 * (2381.73 - t4 * (6402.7 - t4 * (7024.72 - t4 * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + t4 * (170.73 + t4 * (52.82 - t4 * (131.46 - t4 * (176.58 - t4 * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + t4 * (442.36 - t4 * (2482.43 - t4 * (6167.24 - t4 * (6614.94 - t4 * 2475.67))))))) + ")";
}
const cubehelix = cubehelixLong(cubehelix$3(300, 0.5, 0), cubehelix$3(-240, 0.5, 1));
var warm = cubehelixLong(cubehelix$3(-100, 0.75, 0.35), cubehelix$3(80, 1.5, 0.8));
var cool = cubehelixLong(cubehelix$3(260, 0.75, 0.35), cubehelix$3(80, 1.5, 0.8));
var c$3 = cubehelix$3();
function rainbow(t4) {
  if (t4 < 0 || t4 > 1)
    t4 -= Math.floor(t4);
  var ts = Math.abs(t4 - 0.5);
  c$3.h = 360 * t4 - 100;
  c$3.s = 1.5 - 1.5 * ts;
  c$3.l = 0.8 - 0.9 * ts;
  return c$3 + "";
}
var c$2 = rgb(), pi_1_3 = Math.PI / 3, pi_2_3 = Math.PI * 2 / 3;
function sinebow(t4) {
  var x2;
  t4 = (0.5 - t4) * Math.PI;
  c$2.r = 255 * (x2 = Math.sin(t4)) * x2;
  c$2.g = 255 * (x2 = Math.sin(t4 + pi_1_3)) * x2;
  c$2.b = 255 * (x2 = Math.sin(t4 + pi_2_3)) * x2;
  return c$2 + "";
}
function turbo(t4) {
  t4 = Math.max(0, Math.min(1, t4));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t4 * (1172.33 - t4 * (10793.56 - t4 * (33300.12 - t4 * (38394.49 - t4 * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t4 * (557.33 + t4 * (1225.33 - t4 * (3574.96 - t4 * (1073.77 + t4 * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t4 * (3211.1 - t4 * (15327.97 - t4 * (27814 - t4 * (22569.18 - t4 * 6838.66))))))) + ")";
}
function ramp(range2) {
  var n = range2.length;
  return function(t4) {
    return range2[Math.max(0, Math.min(n - 1, Math.floor(t4 * n)))];
  };
}
const viridis = ramp(colors$1("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
var magma = ramp(colors$1("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
var inferno = ramp(colors$1("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
var plasma = ramp(colors$1("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
function constant$2(x2) {
  return function constant2() {
    return x2;
  };
}
var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max = Math.max;
var min = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;
var epsilon$1 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;
function acos(x2) {
  return x2 > 1 ? 0 : x2 < -1 ? pi : Math.acos(x2);
}
function asin(x2) {
  return x2 >= 1 ? halfPi : x2 <= -1 ? -halfPi : Math.asin(x2);
}
function arcInnerRadius(d) {
  return d.innerRadius;
}
function arcOuterRadius(d) {
  return d.outerRadius;
}
function arcStartAngle(d) {
  return d.startAngle;
}
function arcEndAngle(d) {
  return d.endAngle;
}
function arcPadAngle(d) {
  return d && d.padAngle;
}
function intersect$1(x02, y02, x12, y12, x2, y2, x3, y3) {
  var x10 = x12 - x02, y10 = y12 - y02, x32 = x3 - x2, y32 = y3 - y2, t4 = y32 * x10 - x32 * y10;
  if (t4 * t4 < epsilon$1)
    return;
  t4 = (x32 * (y02 - y2) - y32 * (x02 - x2)) / t4;
  return [x02 + t4 * x10, y02 + t4 * y10];
}
function cornerTangents(x02, y02, x12, y12, r1, rc, cw) {
  var x01 = x02 - x12, y01 = y02 - y12, lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x02 + ox, y11 = y02 + oy, x10 = x12 + ox, y10 = y12 + oy, x002 = (x11 + x10) / 2, y002 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D2 = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D2 * D2)), cx0 = (D2 * dy - dx * d) / d2, cy0 = (-D2 * dx - dy * d) / d2, cx1 = (D2 * dy + dx * d) / d2, cy1 = (-D2 * dx + dy * d) / d2, dx0 = cx0 - x002, dy0 = cy0 - y002, dx1 = cx1 - x002, dy1 = cy1 - y002;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
    cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}
function arc() {
  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant$2(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null;
  function arc2() {
    var buffer2, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs(a1 - a0), cw = a1 > a0;
    if (!context)
      context = buffer2 = path();
    if (r1 < r0)
      r = r1, r1 = r0, r0 = r;
    if (!(r1 > epsilon$1))
      context.moveTo(0, 0);
    else if (da > tau - epsilon$1) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon$1) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon$1 && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t02, t12;
      if (rp > epsilon$1) {
        var p02 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p02 * 2) > epsilon$1)
          p02 *= cw ? 1 : -1, a00 += p02, a10 -= p02;
        else
          da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon$1)
          p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
        else
          da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
      if (rc > epsilon$1) {
        var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x002 = r0 * cos(a00), y002 = r0 * sin(a00), oc;
        if (da < pi && (oc = intersect$1(x01, y01, x002, y002, x11, y11, x10, y10))) {
          var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = min(rc, (r0 - lc) / (kc - 1));
          rc1 = min(rc, (r1 - lc) / (kc + 1));
        }
      }
      if (!(da1 > epsilon$1))
        context.moveTo(x01, y01);
      else if (rc1 > epsilon$1) {
        t02 = cornerTangents(x002, y002, x01, y01, r1, rc1, cw);
        t12 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
        context.moveTo(t02.cx + t02.x01, t02.cy + t02.y01);
        if (rc1 < rc)
          context.arc(t02.cx, t02.cy, rc1, atan2(t02.y01, t02.x01), atan2(t12.y01, t12.x01), !cw);
        else {
          context.arc(t02.cx, t02.cy, rc1, atan2(t02.y01, t02.x01), atan2(t02.y11, t02.x11), !cw);
          context.arc(0, 0, r1, atan2(t02.cy + t02.y11, t02.cx + t02.x11), atan2(t12.cy + t12.y11, t12.cx + t12.x11), !cw);
          context.arc(t12.cx, t12.cy, rc1, atan2(t12.y11, t12.x11), atan2(t12.y01, t12.x01), !cw);
        }
      } else
        context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
      if (!(r0 > epsilon$1) || !(da0 > epsilon$1))
        context.lineTo(x10, y10);
      else if (rc0 > epsilon$1) {
        t02 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t12 = cornerTangents(x01, y01, x002, y002, r0, -rc0, cw);
        context.lineTo(t02.cx + t02.x01, t02.cy + t02.y01);
        if (rc0 < rc)
          context.arc(t02.cx, t02.cy, rc0, atan2(t02.y01, t02.x01), atan2(t12.y01, t12.x01), !cw);
        else {
          context.arc(t02.cx, t02.cy, rc0, atan2(t02.y01, t02.x01), atan2(t02.y11, t02.x11), !cw);
          context.arc(0, 0, r0, atan2(t02.cy + t02.y11, t02.cx + t02.x11), atan2(t12.cy + t12.y11, t12.cx + t12.x11), cw);
          context.arc(t12.cx, t12.cy, rc0, atan2(t12.y11, t12.x11), atan2(t12.y01, t12.x01), !cw);
        }
      } else
        context.arc(0, 0, r0, a10, a00, cw);
    }
    context.closePath();
    if (buffer2)
      return context = null, buffer2 + "" || null;
  }
  arc2.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a2 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
    return [cos(a2) * r, sin(a2) * r];
  };
  arc2.innerRadius = function(_2) {
    return arguments.length ? (innerRadius = typeof _2 === "function" ? _2 : constant$2(+_2), arc2) : innerRadius;
  };
  arc2.outerRadius = function(_2) {
    return arguments.length ? (outerRadius = typeof _2 === "function" ? _2 : constant$2(+_2), arc2) : outerRadius;
  };
  arc2.cornerRadius = function(_2) {
    return arguments.length ? (cornerRadius = typeof _2 === "function" ? _2 : constant$2(+_2), arc2) : cornerRadius;
  };
  arc2.padRadius = function(_2) {
    return arguments.length ? (padRadius = _2 == null ? null : typeof _2 === "function" ? _2 : constant$2(+_2), arc2) : padRadius;
  };
  arc2.startAngle = function(_2) {
    return arguments.length ? (startAngle = typeof _2 === "function" ? _2 : constant$2(+_2), arc2) : startAngle;
  };
  arc2.endAngle = function(_2) {
    return arguments.length ? (endAngle = typeof _2 === "function" ? _2 : constant$2(+_2), arc2) : endAngle;
  };
  arc2.padAngle = function(_2) {
    return arguments.length ? (padAngle = typeof _2 === "function" ? _2 : constant$2(+_2), arc2) : padAngle;
  };
  arc2.context = function(_2) {
    return arguments.length ? (context = _2 == null ? null : _2, arc2) : context;
  };
  return arc2;
}
function Linear(context) {
  this._context = context;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x2, y2);
        break;
    }
  }
};
function curveLinear(context) {
  return new Linear(context);
}
function x$1(p) {
  return p[0];
}
function y$1(p) {
  return p[1];
}
function line() {
  var x2 = x$1, y2 = y$1, defined = constant$2(true), context = null, curve = curveLinear, output = null;
  function line2(data2) {
    var i, n = data2.length, d, defined0 = false, buffer2;
    if (context == null)
      output = curve(buffer2 = path());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data2[i], i, data2)) === defined0) {
        if (defined0 = !defined0)
          output.lineStart();
        else
          output.lineEnd();
      }
      if (defined0)
        output.point(+x2(d, i, data2), +y2(d, i, data2));
    }
    if (buffer2)
      return output = null, buffer2 + "" || null;
  }
  line2.x = function(_2) {
    return arguments.length ? (x2 = typeof _2 === "function" ? _2 : constant$2(+_2), line2) : x2;
  };
  line2.y = function(_2) {
    return arguments.length ? (y2 = typeof _2 === "function" ? _2 : constant$2(+_2), line2) : y2;
  };
  line2.defined = function(_2) {
    return arguments.length ? (defined = typeof _2 === "function" ? _2 : constant$2(!!_2), line2) : defined;
  };
  line2.curve = function(_2) {
    return arguments.length ? (curve = _2, context != null && (output = curve(context)), line2) : curve;
  };
  line2.context = function(_2) {
    return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), line2) : context;
  };
  return line2;
}
function area() {
  var x02 = x$1, x12 = null, y02 = constant$2(0), y12 = y$1, defined = constant$2(true), context = null, curve = curveLinear, output = null;
  function area2(data2) {
    var i, j2, k2, n = data2.length, d, defined0 = false, buffer2, x0z = new Array(n), y0z = new Array(n);
    if (context == null)
      output = curve(buffer2 = path());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data2[i], i, data2)) === defined0) {
        if (defined0 = !defined0) {
          j2 = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k2 = i - 1; k2 >= j2; --k2) {
            output.point(x0z[k2], y0z[k2]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x02(d, i, data2), y0z[i] = +y02(d, i, data2);
        output.point(x12 ? +x12(d, i, data2) : x0z[i], y12 ? +y12(d, i, data2) : y0z[i]);
      }
    }
    if (buffer2)
      return output = null, buffer2 + "" || null;
  }
  function arealine() {
    return line().defined(defined).curve(curve).context(context);
  }
  area2.x = function(_2) {
    return arguments.length ? (x02 = typeof _2 === "function" ? _2 : constant$2(+_2), x12 = null, area2) : x02;
  };
  area2.x0 = function(_2) {
    return arguments.length ? (x02 = typeof _2 === "function" ? _2 : constant$2(+_2), area2) : x02;
  };
  area2.x1 = function(_2) {
    return arguments.length ? (x12 = _2 == null ? null : typeof _2 === "function" ? _2 : constant$2(+_2), area2) : x12;
  };
  area2.y = function(_2) {
    return arguments.length ? (y02 = typeof _2 === "function" ? _2 : constant$2(+_2), y12 = null, area2) : y02;
  };
  area2.y0 = function(_2) {
    return arguments.length ? (y02 = typeof _2 === "function" ? _2 : constant$2(+_2), area2) : y02;
  };
  area2.y1 = function(_2) {
    return arguments.length ? (y12 = _2 == null ? null : typeof _2 === "function" ? _2 : constant$2(+_2), area2) : y12;
  };
  area2.lineX0 = area2.lineY0 = function() {
    return arealine().x(x02).y(y02);
  };
  area2.lineY1 = function() {
    return arealine().x(x02).y(y12);
  };
  area2.lineX1 = function() {
    return arealine().x(x12).y(y02);
  };
  area2.defined = function(_2) {
    return arguments.length ? (defined = typeof _2 === "function" ? _2 : constant$2(!!_2), area2) : defined;
  };
  area2.curve = function(_2) {
    return arguments.length ? (curve = _2, context != null && (output = curve(context)), area2) : curve;
  };
  area2.context = function(_2) {
    return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), area2) : context;
  };
  return area2;
}
function descending$1(a2, b) {
  return b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
}
function identity$1(d) {
  return d;
}
function pie() {
  var value = identity$1, sortValues = descending$1, sort2 = null, startAngle = constant$2(0), endAngle = constant$2(tau), padAngle = constant$2(0);
  function pie2(data2) {
    var i, n = data2.length, j2, k2, sum2 = 0, index2 = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)), pa = p * (da < 0 ? -1 : 1), v;
    for (i = 0; i < n; ++i) {
      if ((v = arcs[index2[i] = i] = +value(data2[i], i, data2)) > 0) {
        sum2 += v;
      }
    }
    if (sortValues != null)
      index2.sort(function(i2, j3) {
        return sortValues(arcs[i2], arcs[j3]);
      });
    else if (sort2 != null)
      index2.sort(function(i2, j3) {
        return sort2(data2[i2], data2[j3]);
      });
    for (i = 0, k2 = sum2 ? (da - n * pa) / sum2 : 0; i < n; ++i, a0 = a1) {
      j2 = index2[i], v = arcs[j2], a1 = a0 + (v > 0 ? v * k2 : 0) + pa, arcs[j2] = {
        data: data2[j2],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }
    return arcs;
  }
  pie2.value = function(_2) {
    return arguments.length ? (value = typeof _2 === "function" ? _2 : constant$2(+_2), pie2) : value;
  };
  pie2.sortValues = function(_2) {
    return arguments.length ? (sortValues = _2, sort2 = null, pie2) : sortValues;
  };
  pie2.sort = function(_2) {
    return arguments.length ? (sort2 = _2, sortValues = null, pie2) : sort2;
  };
  pie2.startAngle = function(_2) {
    return arguments.length ? (startAngle = typeof _2 === "function" ? _2 : constant$2(+_2), pie2) : startAngle;
  };
  pie2.endAngle = function(_2) {
    return arguments.length ? (endAngle = typeof _2 === "function" ? _2 : constant$2(+_2), pie2) : endAngle;
  };
  pie2.padAngle = function(_2) {
    return arguments.length ? (padAngle = typeof _2 === "function" ? _2 : constant$2(+_2), pie2) : padAngle;
  };
  return pie2;
}
var curveRadialLinear = curveRadial$1(curveLinear);
function Radial(curve) {
  this._curve = curve;
}
Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a2, r) {
    this._curve.point(r * Math.sin(a2), r * -Math.cos(a2));
  }
};
function curveRadial$1(curve) {
  function radial2(context) {
    return new Radial(curve(context));
  }
  radial2._curve = curve;
  return radial2;
}
function lineRadial(l2) {
  var c2 = l2.curve;
  l2.angle = l2.x, delete l2.x;
  l2.radius = l2.y, delete l2.y;
  l2.curve = function(_2) {
    return arguments.length ? c2(curveRadial$1(_2)) : c2()._curve;
  };
  return l2;
}
function lineRadial$1() {
  return lineRadial(line().curve(curveRadialLinear));
}
function areaRadial() {
  var a2 = area().curve(curveRadialLinear), c2 = a2.curve, x02 = a2.lineX0, x12 = a2.lineX1, y02 = a2.lineY0, y12 = a2.lineY1;
  a2.angle = a2.x, delete a2.x;
  a2.startAngle = a2.x0, delete a2.x0;
  a2.endAngle = a2.x1, delete a2.x1;
  a2.radius = a2.y, delete a2.y;
  a2.innerRadius = a2.y0, delete a2.y0;
  a2.outerRadius = a2.y1, delete a2.y1;
  a2.lineStartAngle = function() {
    return lineRadial(x02());
  }, delete a2.lineX0;
  a2.lineEndAngle = function() {
    return lineRadial(x12());
  }, delete a2.lineX1;
  a2.lineInnerRadius = function() {
    return lineRadial(y02());
  }, delete a2.lineY0;
  a2.lineOuterRadius = function() {
    return lineRadial(y12());
  }, delete a2.lineY1;
  a2.curve = function(_2) {
    return arguments.length ? c2(curveRadial$1(_2)) : c2()._curve;
  };
  return a2;
}
function pointRadial(x2, y2) {
  return [(y2 = +y2) * Math.cos(x2 -= Math.PI / 2), y2 * Math.sin(x2)];
}
var slice = Array.prototype.slice;
function linkSource(d) {
  return d.source;
}
function linkTarget(d) {
  return d.target;
}
function link(curve) {
  var source = linkSource, target = linkTarget, x2 = x$1, y2 = y$1, context = null;
  function link2() {
    var buffer2, argv = slice.call(arguments), s2 = source.apply(this, argv), t4 = target.apply(this, argv);
    if (!context)
      context = buffer2 = path();
    curve(context, +x2.apply(this, (argv[0] = s2, argv)), +y2.apply(this, argv), +x2.apply(this, (argv[0] = t4, argv)), +y2.apply(this, argv));
    if (buffer2)
      return context = null, buffer2 + "" || null;
  }
  link2.source = function(_2) {
    return arguments.length ? (source = _2, link2) : source;
  };
  link2.target = function(_2) {
    return arguments.length ? (target = _2, link2) : target;
  };
  link2.x = function(_2) {
    return arguments.length ? (x2 = typeof _2 === "function" ? _2 : constant$2(+_2), link2) : x2;
  };
  link2.y = function(_2) {
    return arguments.length ? (y2 = typeof _2 === "function" ? _2 : constant$2(+_2), link2) : y2;
  };
  link2.context = function(_2) {
    return arguments.length ? (context = _2 == null ? null : _2, link2) : context;
  };
  return link2;
}
function curveHorizontal(context, x02, y02, x12, y12) {
  context.moveTo(x02, y02);
  context.bezierCurveTo(x02 = (x02 + x12) / 2, y02, x02, y12, x12, y12);
}
function curveVertical(context, x02, y02, x12, y12) {
  context.moveTo(x02, y02);
  context.bezierCurveTo(x02, y02 = (y02 + y12) / 2, x12, y02, x12, y12);
}
function curveRadial(context, x02, y02, x12, y12) {
  var p02 = pointRadial(x02, y02), p1 = pointRadial(x02, y02 = (y02 + y12) / 2), p2 = pointRadial(x12, y02), p3 = pointRadial(x12, y12);
  context.moveTo(p02[0], p02[1]);
  context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
}
function linkHorizontal() {
  return link(curveHorizontal);
}
function linkVertical() {
  return link(curveVertical);
}
function linkRadial() {
  var l2 = link(curveRadial);
  l2.angle = l2.x, delete l2.x;
  l2.radius = l2.y, delete l2.y;
  return l2;
}
const circle$2 = {
  draw: function(context, size) {
    var r = Math.sqrt(size / pi);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, tau);
  }
};
const cross$1 = {
  draw: function(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
};
var tan30 = Math.sqrt(1 / 3), tan30_2 = tan30 * 2;
const diamond = {
  draw: function(context, size) {
    var y2 = Math.sqrt(size / tan30_2), x2 = y2 * tan30;
    context.moveTo(0, -y2);
    context.lineTo(x2, 0);
    context.lineTo(0, y2);
    context.lineTo(-x2, 0);
    context.closePath();
  }
};
var ka = 0.8908130915292852, kr = Math.sin(pi / 10) / Math.sin(7 * pi / 10), kx = Math.sin(tau / 10) * kr, ky = -Math.cos(tau / 10) * kr;
const star = {
  draw: function(context, size) {
    var r = Math.sqrt(size * ka), x2 = kx * r, y2 = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x2, y2);
    for (var i = 1; i < 5; ++i) {
      var a2 = tau * i / 5, c2 = Math.cos(a2), s2 = Math.sin(a2);
      context.lineTo(s2 * r, -c2 * r);
      context.lineTo(c2 * x2 - s2 * y2, s2 * x2 + c2 * y2);
    }
    context.closePath();
  }
};
const square = {
  draw: function(context, size) {
    var w2 = Math.sqrt(size), x2 = -w2 / 2;
    context.rect(x2, x2, w2, w2);
  }
};
var sqrt3 = Math.sqrt(3);
const triangle = {
  draw: function(context, size) {
    var y2 = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y2 * 2);
    context.lineTo(-sqrt3 * y2, -y2);
    context.lineTo(sqrt3 * y2, -y2);
    context.closePath();
  }
};
var c$1 = -0.5, s = Math.sqrt(3) / 2, k = 1 / Math.sqrt(12), a = (k / 2 + 1) * 3;
const wye = {
  draw: function(context, size) {
    var r = Math.sqrt(size / a), x02 = r / 2, y02 = r * k, x12 = x02, y12 = r * k + r, x2 = -x12, y2 = y12;
    context.moveTo(x02, y02);
    context.lineTo(x12, y12);
    context.lineTo(x2, y2);
    context.lineTo(c$1 * x02 - s * y02, s * x02 + c$1 * y02);
    context.lineTo(c$1 * x12 - s * y12, s * x12 + c$1 * y12);
    context.lineTo(c$1 * x2 - s * y2, s * x2 + c$1 * y2);
    context.lineTo(c$1 * x02 + s * y02, c$1 * y02 - s * x02);
    context.lineTo(c$1 * x12 + s * y12, c$1 * y12 - s * x12);
    context.lineTo(c$1 * x2 + s * y2, c$1 * y2 - s * x2);
    context.closePath();
  }
};
var symbols = [
  circle$2,
  cross$1,
  diamond,
  square,
  star,
  triangle,
  wye
];
function symbol() {
  var type2 = constant$2(circle$2), size = constant$2(64), context = null;
  function symbol2() {
    var buffer2;
    if (!context)
      context = buffer2 = path();
    type2.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer2)
      return context = null, buffer2 + "" || null;
  }
  symbol2.type = function(_2) {
    return arguments.length ? (type2 = typeof _2 === "function" ? _2 : constant$2(_2), symbol2) : type2;
  };
  symbol2.size = function(_2) {
    return arguments.length ? (size = typeof _2 === "function" ? _2 : constant$2(+_2), symbol2) : size;
  };
  symbol2.context = function(_2) {
    return arguments.length ? (context = _2 == null ? null : _2, symbol2) : context;
  };
  return symbol2;
}
function noop() {
}
function point$4(that, x2, y2) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x2) / 6,
    (that._y0 + 4 * that._y1 + y2) / 6
  );
}
function Basis(context) {
  this._context = context;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point$4(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        point$4(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function basis(context) {
  return new Basis(context);
}
function BasisClosed(context) {
  this._context = context;
}
BasisClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x2, this._y2 = y2;
        break;
      case 1:
        this._point = 2;
        this._x3 = x2, this._y3 = y2;
        break;
      case 2:
        this._point = 3;
        this._x4 = x2, this._y4 = y2;
        this._context.moveTo((this._x0 + 4 * this._x1 + x2) / 6, (this._y0 + 4 * this._y1 + y2) / 6);
        break;
      default:
        point$4(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function basisClosed(context) {
  return new BasisClosed(context);
}
function BasisOpen(context) {
  this._context = context;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x02 = (this._x0 + 4 * this._x1 + x2) / 6, y02 = (this._y0 + 4 * this._y1 + y2) / 6;
        this._line ? this._context.lineTo(x02, y02) : this._context.moveTo(x02, y02);
        break;
      case 3:
        this._point = 4;
      default:
        point$4(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function basisOpen(context) {
  return new BasisOpen(context);
}
function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}
Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x2 = this._x, y2 = this._y, j2 = x2.length - 1;
    if (j2 > 0) {
      var x02 = x2[0], y02 = y2[0], dx = x2[j2] - x02, dy = y2[j2] - y02, i = -1, t4;
      while (++i <= j2) {
        t4 = i / j2;
        this._basis.point(
          this._beta * x2[i] + (1 - this._beta) * (x02 + t4 * dx),
          this._beta * y2[i] + (1 - this._beta) * (y02 + t4 * dy)
        );
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x2, y2) {
    this._x.push(+x2);
    this._y.push(+y2);
  }
};
const bundle = function custom12(beta) {
  function bundle2(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }
  bundle2.beta = function(beta2) {
    return custom12(+beta2);
  };
  return bundle2;
}(0.85);
function point$3(that, x2, y2) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x2),
    that._y2 + that._k * (that._y1 - y2),
    that._x2,
    that._y2
  );
}
function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point$3(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        this._x1 = x2, this._y1 = y2;
        break;
      case 2:
        this._point = 3;
      default:
        point$3(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
const cardinal = function custom13(tension) {
  function cardinal2(context) {
    return new Cardinal(context, tension);
  }
  cardinal2.tension = function(tension2) {
    return custom13(+tension2);
  };
  return cardinal2;
}(0);
function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x2, this._y3 = y2;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x2, this._y4 = y2);
        break;
      case 2:
        this._point = 3;
        this._x5 = x2, this._y5 = y2;
        break;
      default:
        point$3(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
const cardinalClosed = function custom14(tension) {
  function cardinal2(context) {
    return new CardinalClosed(context, tension);
  }
  cardinal2.tension = function(tension2) {
    return custom14(+tension2);
  };
  return cardinal2;
}(0);
function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point$3(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
const cardinalOpen = function custom15(tension) {
  function cardinal2(context) {
    return new CardinalOpen(context, tension);
  }
  cardinal2.tension = function(tension2) {
    return custom15(+tension2);
  };
  return cardinal2;
}(0);
function point$2(that, x2, y2) {
  var x12 = that._x1, y12 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon$1) {
    var a2 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x12 = (x12 * a2 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y12 = (y12 * a2 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }
  if (that._l23_a > epsilon$1) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b + that._x1 * that._l23_2a - x2 * that._l12_2a) / m;
    y22 = (y22 * b + that._y1 * that._l23_2a - y2 * that._l12_2a) / m;
  }
  that._context.bezierCurveTo(x12, y12, x22, y22, that._x2, that._y2);
}
function CatmullRom(context, alpha2) {
  this._context = context;
  this._alpha = alpha2;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        point$2(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
const catmullRom = function custom16(alpha2) {
  function catmullRom2(context) {
    return alpha2 ? new CatmullRom(context, alpha2) : new Cardinal(context, 0);
  }
  catmullRom2.alpha = function(alpha3) {
    return custom16(+alpha3);
  };
  return catmullRom2;
}(0.5);
function CatmullRomClosed(context, alpha2) {
  this._context = context;
  this._alpha = alpha2;
}
CatmullRomClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x2, this._y3 = y2;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x2, this._y4 = y2);
        break;
      case 2:
        this._point = 3;
        this._x5 = x2, this._y5 = y2;
        break;
      default:
        point$2(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
const catmullRomClosed = function custom17(alpha2) {
  function catmullRom2(context) {
    return alpha2 ? new CatmullRomClosed(context, alpha2) : new CardinalClosed(context, 0);
  }
  catmullRom2.alpha = function(alpha3) {
    return custom17(+alpha3);
  };
  return catmullRom2;
}(0.5);
function CatmullRomOpen(context, alpha2) {
  this._context = context;
  this._alpha = alpha2;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point$2(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
const catmullRomOpen = function custom18(alpha2) {
  function catmullRom2(context) {
    return alpha2 ? new CatmullRomOpen(context, alpha2) : new CardinalOpen(context, 0);
  }
  catmullRom2.alpha = function(alpha3) {
    return custom18(+alpha3);
  };
  return catmullRom2;
}(0.5);
function LinearClosed(context) {
  this._context = context;
}
LinearClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point)
      this._context.closePath();
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point)
      this._context.lineTo(x2, y2);
    else
      this._point = 1, this._context.moveTo(x2, y2);
  }
};
function linearClosed(context) {
  return new LinearClosed(context);
}
function sign(x2) {
  return x2 < 0 ? -1 : 1;
}
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope2(that, t4) {
  var h2 = that._x1 - that._x0;
  return h2 ? (3 * (that._y1 - that._y0) / h2 - t4) / 2 : t4;
}
function point$1(that, t02, t12) {
  var x02 = that._x0, y02 = that._y0, x12 = that._x1, y12 = that._y1, dx = (x12 - x02) / 3;
  that._context.bezierCurveTo(x02 + dx, y02 + dx * t02, x12 - dx, y12 - dx * t12, x12, y12);
}
function MonotoneX(context) {
  this._context = context;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point$1(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    var t12 = NaN;
    x2 = +x2, y2 = +y2;
    if (x2 === this._x1 && y2 === this._y1)
      return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point$1(this, slope2(this, t12 = slope3(this, x2, y2)), t12);
        break;
      default:
        point$1(this, this._t0, t12 = slope3(this, x2, y2));
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
    this._t0 = t12;
  }
};
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x2, y2) {
  MonotoneX.prototype.point.call(this, y2, x2);
};
function ReflectContext(context) {
  this._context = context;
}
ReflectContext.prototype = {
  moveTo: function(x2, y2) {
    this._context.moveTo(y2, x2);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x2, y2) {
    this._context.lineTo(y2, x2);
  },
  bezierCurveTo: function(x12, y12, x2, y2, x3, y3) {
    this._context.bezierCurveTo(y12, x12, y2, x2, y3, x3);
  }
};
function monotoneX(context) {
  return new MonotoneX(context);
}
function monotoneY(context) {
  return new MonotoneY(context);
}
function Natural(context) {
  this._context = context;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x2 = this._x, y2 = this._y, n = x2.length;
    if (n) {
      this._line ? this._context.lineTo(x2[0], y2[0]) : this._context.moveTo(x2[0], y2[0]);
      if (n === 2) {
        this._context.lineTo(x2[1], y2[1]);
      } else {
        var px = controlPoints(x2), py = controlPoints(y2);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x2[i1], y2[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n === 1)
      this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x2, y2) {
    this._x.push(+x2);
    this._y.push(+y2);
  }
};
function controlPoints(x2) {
  var i, n = x2.length - 1, m, a2 = new Array(n), b = new Array(n), r = new Array(n);
  a2[0] = 0, b[0] = 2, r[0] = x2[0] + 2 * x2[1];
  for (i = 1; i < n - 1; ++i)
    a2[i] = 1, b[i] = 4, r[i] = 4 * x2[i] + 2 * x2[i + 1];
  a2[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x2[n - 1] + x2[n];
  for (i = 1; i < n; ++i)
    m = a2[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a2[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i)
    a2[i] = (r[i] - a2[i + 1]) / b[i];
  b[n - 1] = (x2[n] + a2[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i)
    b[i] = 2 * x2[i + 1] - a2[i + 1];
  return [a2, b];
}
function natural(context) {
  return new Natural(context);
}
function Step(context, t4) {
  this._context = context;
  this._t = t4;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2)
      this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    if (this._line >= 0)
      this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y2);
          this._context.lineTo(x2, y2);
        } else {
          var x12 = this._x * (1 - this._t) + x2 * this._t;
          this._context.lineTo(x12, this._y);
          this._context.lineTo(x12, y2);
        }
        break;
      }
    }
    this._x = x2, this._y = y2;
  }
};
function step(context) {
  return new Step(context, 0.5);
}
function stepBefore(context) {
  return new Step(context, 0);
}
function stepAfter(context) {
  return new Step(context, 1);
}
function none$1(series, order2) {
  if (!((n = series.length) > 1))
    return;
  for (var i = 1, j2, s0, s1 = series[order2[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order2[i]];
    for (j2 = 0; j2 < m; ++j2) {
      s1[j2][1] += s1[j2][0] = isNaN(s0[j2][1]) ? s0[j2][0] : s0[j2][1];
    }
  }
}
function none(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0)
    o[n] = n;
  return o;
}
function stackValue(d, key) {
  return d[key];
}
function stack() {
  var keys2 = constant$2([]), order2 = none, offset = none$1, value = stackValue;
  function stack2(data2) {
    var kz = keys2.apply(this, arguments), i, m = data2.length, n = kz.length, sz = new Array(n), oz;
    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j2 = 0, sij; j2 < m; ++j2) {
        si[j2] = sij = [0, +value(data2[j2], ki, j2, data2)];
        sij.data = data2[j2];
      }
      si.key = ki;
    }
    for (i = 0, oz = order2(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }
    offset(sz, oz);
    return sz;
  }
  stack2.keys = function(_2) {
    return arguments.length ? (keys2 = typeof _2 === "function" ? _2 : constant$2(slice.call(_2)), stack2) : keys2;
  };
  stack2.value = function(_2) {
    return arguments.length ? (value = typeof _2 === "function" ? _2 : constant$2(+_2), stack2) : value;
  };
  stack2.order = function(_2) {
    return arguments.length ? (order2 = _2 == null ? none : typeof _2 === "function" ? _2 : constant$2(slice.call(_2)), stack2) : order2;
  };
  stack2.offset = function(_2) {
    return arguments.length ? (offset = _2 == null ? none$1 : _2, stack2) : offset;
  };
  return stack2;
}
function expand(series, order2) {
  if (!((n = series.length) > 0))
    return;
  for (var i, n, j2 = 0, m = series[0].length, y2; j2 < m; ++j2) {
    for (y2 = i = 0; i < n; ++i)
      y2 += series[i][j2][1] || 0;
    if (y2)
      for (i = 0; i < n; ++i)
        series[i][j2][1] /= y2;
  }
  none$1(series, order2);
}
function diverging(series, order2) {
  if (!((n = series.length) > 0))
    return;
  for (var i, j2 = 0, d, dy, yp, yn2, n, m = series[order2[0]].length; j2 < m; ++j2) {
    for (yp = yn2 = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order2[i]][j2])[1] - d[0]) > 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn2, d[0] = yn2 += dy;
      } else {
        d[0] = 0, d[1] = dy;
      }
    }
  }
}
function silhouette(series, order2) {
  if (!((n = series.length) > 0))
    return;
  for (var j2 = 0, s0 = series[order2[0]], n, m = s0.length; j2 < m; ++j2) {
    for (var i = 0, y2 = 0; i < n; ++i)
      y2 += series[i][j2][1] || 0;
    s0[j2][1] += s0[j2][0] = -y2 / 2;
  }
  none$1(series, order2);
}
function wiggle(series, order2) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order2[0]]).length) > 0))
    return;
  for (var y2 = 0, j2 = 1, s0, m, n; j2 < m; ++j2) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order2[i]], sij0 = si[j2][1] || 0, sij1 = si[j2 - 1][1] || 0, s3 = (sij0 - sij1) / 2;
      for (var k2 = 0; k2 < i; ++k2) {
        var sk = series[order2[k2]], skj0 = sk[j2][1] || 0, skj1 = sk[j2 - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j2 - 1][1] += s0[j2 - 1][0] = y2;
    if (s1)
      y2 -= s2 / s1;
  }
  s0[j2 - 1][1] += s0[j2 - 1][0] = y2;
  none$1(series, order2);
}
function appearance(series) {
  var peaks = series.map(peak);
  return none(series).sort(function(a2, b) {
    return peaks[a2] - peaks[b];
  });
}
function peak(series) {
  var i = -1, j2 = 0, n = series.length, vi, vj = -Infinity;
  while (++i < n)
    if ((vi = +series[i][1]) > vj)
      vj = vi, j2 = i;
  return j2;
}
function ascending(series) {
  var sums = series.map(sum);
  return none(series).sort(function(a2, b) {
    return sums[a2] - sums[b];
  });
}
function sum(series) {
  var s2 = 0, i = -1, n = series.length, v;
  while (++i < n)
    if (v = +series[i][1])
      s2 += v;
  return s2;
}
function descending(series) {
  return ascending(series).reverse();
}
function insideOut(series) {
  var n = series.length, i, j2, sums = series.map(sum), order2 = appearance(series), top2 = 0, bottom2 = 0, tops = [], bottoms = [];
  for (i = 0; i < n; ++i) {
    j2 = order2[i];
    if (top2 < bottom2) {
      top2 += sums[j2];
      tops.push(j2);
    } else {
      bottom2 += sums[j2];
      bottoms.push(j2);
    }
  }
  return bottoms.reverse().concat(tops);
}
function reverse(series) {
  return none(series).reverse();
}
function constant$1(x2) {
  return function() {
    return x2;
  };
}
function x(d) {
  return d[0];
}
function y(d) {
  return d[1];
}
function RedBlackTree() {
  this._ = null;
}
function RedBlackNode(node2) {
  node2.U = node2.C = node2.L = node2.R = node2.P = node2.N = null;
}
RedBlackTree.prototype = {
  constructor: RedBlackTree,
  insert: function(after, node2) {
    var parent, grandpa, uncle;
    if (after) {
      node2.P = after;
      node2.N = after.N;
      if (after.N)
        after.N.P = node2;
      after.N = node2;
      if (after.R) {
        after = after.R;
        while (after.L)
          after = after.L;
        after.L = node2;
      } else {
        after.R = node2;
      }
      parent = after;
    } else if (this._) {
      after = RedBlackFirst(this._);
      node2.P = null;
      node2.N = after;
      after.P = after.L = node2;
      parent = after;
    } else {
      node2.P = node2.N = null;
      this._ = node2;
      parent = null;
    }
    node2.L = node2.R = null;
    node2.U = parent;
    node2.C = true;
    after = node2;
    while (parent && parent.C) {
      grandpa = parent.U;
      if (parent === grandpa.L) {
        uncle = grandpa.R;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.R) {
            RedBlackRotateLeft(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateRight(this, grandpa);
        }
      } else {
        uncle = grandpa.L;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.L) {
            RedBlackRotateRight(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateLeft(this, grandpa);
        }
      }
      parent = after.U;
    }
    this._.C = false;
  },
  remove: function(node2) {
    if (node2.N)
      node2.N.P = node2.P;
    if (node2.P)
      node2.P.N = node2.N;
    node2.N = node2.P = null;
    var parent = node2.U, sibling, left2 = node2.L, right2 = node2.R, next2, red;
    if (!left2)
      next2 = right2;
    else if (!right2)
      next2 = left2;
    else
      next2 = RedBlackFirst(right2);
    if (parent) {
      if (parent.L === node2)
        parent.L = next2;
      else
        parent.R = next2;
    } else {
      this._ = next2;
    }
    if (left2 && right2) {
      red = next2.C;
      next2.C = node2.C;
      next2.L = left2;
      left2.U = next2;
      if (next2 !== right2) {
        parent = next2.U;
        next2.U = node2.U;
        node2 = next2.R;
        parent.L = node2;
        next2.R = right2;
        right2.U = next2;
      } else {
        next2.U = parent;
        parent = next2;
        node2 = next2.R;
      }
    } else {
      red = node2.C;
      node2 = next2;
    }
    if (node2)
      node2.U = parent;
    if (red)
      return;
    if (node2 && node2.C) {
      node2.C = false;
      return;
    }
    do {
      if (node2 === this._)
        break;
      if (node2 === parent.L) {
        sibling = parent.R;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateLeft(this, parent);
          sibling = parent.R;
        }
        if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
          if (!sibling.R || !sibling.R.C) {
            sibling.L.C = false;
            sibling.C = true;
            RedBlackRotateRight(this, sibling);
            sibling = parent.R;
          }
          sibling.C = parent.C;
          parent.C = sibling.R.C = false;
          RedBlackRotateLeft(this, parent);
          node2 = this._;
          break;
        }
      } else {
        sibling = parent.L;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateRight(this, parent);
          sibling = parent.L;
        }
        if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
          if (!sibling.L || !sibling.L.C) {
            sibling.R.C = false;
            sibling.C = true;
            RedBlackRotateLeft(this, sibling);
            sibling = parent.L;
          }
          sibling.C = parent.C;
          parent.C = sibling.L.C = false;
          RedBlackRotateRight(this, parent);
          node2 = this._;
          break;
        }
      }
      sibling.C = true;
      node2 = parent;
      parent = parent.U;
    } while (!node2.C);
    if (node2)
      node2.C = false;
  }
};
function RedBlackRotateLeft(tree2, node2) {
  var p = node2, q = node2.R, parent = p.U;
  if (parent) {
    if (parent.L === p)
      parent.L = q;
    else
      parent.R = q;
  } else {
    tree2._ = q;
  }
  q.U = parent;
  p.U = q;
  p.R = q.L;
  if (p.R)
    p.R.U = p;
  q.L = p;
}
function RedBlackRotateRight(tree2, node2) {
  var p = node2, q = node2.L, parent = p.U;
  if (parent) {
    if (parent.L === p)
      parent.L = q;
    else
      parent.R = q;
  } else {
    tree2._ = q;
  }
  q.U = parent;
  p.U = q;
  p.L = q.R;
  if (p.L)
    p.L.U = p;
  q.R = p;
}
function RedBlackFirst(node2) {
  while (node2.L)
    node2 = node2.L;
  return node2;
}
function createEdge(left2, right2, v0, v1) {
  var edge = [null, null], index2 = edges$1.push(edge) - 1;
  edge.left = left2;
  edge.right = right2;
  if (v0)
    setEdgeEnd(edge, left2, right2, v0);
  if (v1)
    setEdgeEnd(edge, right2, left2, v1);
  cells[left2.index].halfedges.push(index2);
  cells[right2.index].halfedges.push(index2);
  return edge;
}
function createBorderEdge(left2, v0, v1) {
  var edge = [v0, v1];
  edge.left = left2;
  return edge;
}
function setEdgeEnd(edge, left2, right2, vertex) {
  if (!edge[0] && !edge[1]) {
    edge[0] = vertex;
    edge.left = left2;
    edge.right = right2;
  } else if (edge.left === right2) {
    edge[1] = vertex;
  } else {
    edge[0] = vertex;
  }
}
function clipEdge(edge, x02, y02, x12, y12) {
  var a2 = edge[0], b = edge[1], ax = a2[0], ay = a2[1], bx = b[0], by = b[1], t02 = 0, t12 = 1, dx = bx - ax, dy = by - ay, r;
  r = x02 - ax;
  if (!dx && r > 0)
    return;
  r /= dx;
  if (dx < 0) {
    if (r < t02)
      return;
    if (r < t12)
      t12 = r;
  } else if (dx > 0) {
    if (r > t12)
      return;
    if (r > t02)
      t02 = r;
  }
  r = x12 - ax;
  if (!dx && r < 0)
    return;
  r /= dx;
  if (dx < 0) {
    if (r > t12)
      return;
    if (r > t02)
      t02 = r;
  } else if (dx > 0) {
    if (r < t02)
      return;
    if (r < t12)
      t12 = r;
  }
  r = y02 - ay;
  if (!dy && r > 0)
    return;
  r /= dy;
  if (dy < 0) {
    if (r < t02)
      return;
    if (r < t12)
      t12 = r;
  } else if (dy > 0) {
    if (r > t12)
      return;
    if (r > t02)
      t02 = r;
  }
  r = y12 - ay;
  if (!dy && r < 0)
    return;
  r /= dy;
  if (dy < 0) {
    if (r > t12)
      return;
    if (r > t02)
      t02 = r;
  } else if (dy > 0) {
    if (r < t02)
      return;
    if (r < t12)
      t12 = r;
  }
  if (!(t02 > 0) && !(t12 < 1))
    return true;
  if (t02 > 0)
    edge[0] = [ax + t02 * dx, ay + t02 * dy];
  if (t12 < 1)
    edge[1] = [ax + t12 * dx, ay + t12 * dy];
  return true;
}
function connectEdge(edge, x02, y02, x12, y12) {
  var v1 = edge[1];
  if (v1)
    return true;
  var v0 = edge[0], left2 = edge.left, right2 = edge.right, lx = left2[0], ly = left2[1], rx = right2[0], ry = right2[1], fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
  if (ry === ly) {
    if (fx < x02 || fx >= x12)
      return;
    if (lx > rx) {
      if (!v0)
        v0 = [fx, y02];
      else if (v0[1] >= y12)
        return;
      v1 = [fx, y12];
    } else {
      if (!v0)
        v0 = [fx, y12];
      else if (v0[1] < y02)
        return;
      v1 = [fx, y02];
    }
  } else {
    fm = (lx - rx) / (ry - ly);
    fb = fy - fm * fx;
    if (fm < -1 || fm > 1) {
      if (lx > rx) {
        if (!v0)
          v0 = [(y02 - fb) / fm, y02];
        else if (v0[1] >= y12)
          return;
        v1 = [(y12 - fb) / fm, y12];
      } else {
        if (!v0)
          v0 = [(y12 - fb) / fm, y12];
        else if (v0[1] < y02)
          return;
        v1 = [(y02 - fb) / fm, y02];
      }
    } else {
      if (ly < ry) {
        if (!v0)
          v0 = [x02, fm * x02 + fb];
        else if (v0[0] >= x12)
          return;
        v1 = [x12, fm * x12 + fb];
      } else {
        if (!v0)
          v0 = [x12, fm * x12 + fb];
        else if (v0[0] < x02)
          return;
        v1 = [x02, fm * x02 + fb];
      }
    }
  }
  edge[0] = v0;
  edge[1] = v1;
  return true;
}
function clipEdges(x02, y02, x12, y12) {
  var i = edges$1.length, edge;
  while (i--) {
    if (!connectEdge(edge = edges$1[i], x02, y02, x12, y12) || !clipEdge(edge, x02, y02, x12, y12) || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon || Math.abs(edge[0][1] - edge[1][1]) > epsilon)) {
      delete edges$1[i];
    }
  }
}
function createCell(site) {
  return cells[site.index] = {
    site,
    halfedges: []
  };
}
function cellHalfedgeAngle(cell, edge) {
  var site = cell.site, va = edge.left, vb = edge.right;
  if (site === vb)
    vb = va, va = site;
  if (vb)
    return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
  if (site === va)
    va = edge[1], vb = edge[0];
  else
    va = edge[0], vb = edge[1];
  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
}
function cellHalfedgeStart(cell, edge) {
  return edge[+(edge.left !== cell.site)];
}
function cellHalfedgeEnd(cell, edge) {
  return edge[+(edge.left === cell.site)];
}
function sortCellHalfedges() {
  for (var i = 0, n = cells.length, cell, halfedges, j2, m; i < n; ++i) {
    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
      var index2 = new Array(m), array2 = new Array(m);
      for (j2 = 0; j2 < m; ++j2)
        index2[j2] = j2, array2[j2] = cellHalfedgeAngle(cell, edges$1[halfedges[j2]]);
      index2.sort(function(i2, j3) {
        return array2[j3] - array2[i2];
      });
      for (j2 = 0; j2 < m; ++j2)
        array2[j2] = halfedges[index2[j2]];
      for (j2 = 0; j2 < m; ++j2)
        halfedges[j2] = array2[j2];
    }
  }
}
function clipCells(x02, y02, x12, y12) {
  var nCells = cells.length, iCell, cell, site, iHalfedge, halfedges, nHalfedges, start2, startX, startY, end2, endX, endY, cover = true;
  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      site = cell.site;
      halfedges = cell.halfedges;
      iHalfedge = halfedges.length;
      while (iHalfedge--) {
        if (!edges$1[halfedges[iHalfedge]]) {
          halfedges.splice(iHalfedge, 1);
        }
      }
      iHalfedge = 0, nHalfedges = halfedges.length;
      while (iHalfedge < nHalfedges) {
        end2 = cellHalfedgeEnd(cell, edges$1[halfedges[iHalfedge]]), endX = end2[0], endY = end2[1];
        start2 = cellHalfedgeStart(cell, edges$1[halfedges[++iHalfedge % nHalfedges]]), startX = start2[0], startY = start2[1];
        if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {
          halfedges.splice(iHalfedge, 0, edges$1.push(createBorderEdge(
            site,
            end2,
            Math.abs(endX - x02) < epsilon && y12 - endY > epsilon ? [x02, Math.abs(startX - x02) < epsilon ? startY : y12] : Math.abs(endY - y12) < epsilon && x12 - endX > epsilon ? [Math.abs(startY - y12) < epsilon ? startX : x12, y12] : Math.abs(endX - x12) < epsilon && endY - y02 > epsilon ? [x12, Math.abs(startX - x12) < epsilon ? startY : y02] : Math.abs(endY - y02) < epsilon && endX - x02 > epsilon ? [Math.abs(startY - y02) < epsilon ? startX : x02, y02] : null
          )) - 1);
          ++nHalfedges;
        }
      }
      if (nHalfedges)
        cover = false;
    }
  }
  if (cover) {
    var dx, dy, d2, dc = Infinity;
    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
      if (cell = cells[iCell]) {
        site = cell.site;
        dx = site[0] - x02;
        dy = site[1] - y02;
        d2 = dx * dx + dy * dy;
        if (d2 < dc)
          dc = d2, cover = cell;
      }
    }
    if (cover) {
      var v00 = [x02, y02], v01 = [x02, y12], v11 = [x12, y12], v10 = [x12, y02];
      cover.halfedges.push(
        edges$1.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
        edges$1.push(createBorderEdge(site, v01, v11)) - 1,
        edges$1.push(createBorderEdge(site, v11, v10)) - 1,
        edges$1.push(createBorderEdge(site, v10, v00)) - 1
      );
    }
  }
  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      if (!cell.halfedges.length) {
        delete cells[iCell];
      }
    }
  }
}
var circlePool = [];
var firstCircle;
function Circle() {
  RedBlackNode(this);
  this.x = this.y = this.arc = this.site = this.cy = null;
}
function attachCircle(arc2) {
  var lArc = arc2.P, rArc = arc2.N;
  if (!lArc || !rArc)
    return;
  var lSite = lArc.site, cSite = arc2.site, rSite = rArc.site;
  if (lSite === rSite)
    return;
  var bx = cSite[0], by = cSite[1], ax = lSite[0] - bx, ay = lSite[1] - by, cx = rSite[0] - bx, cy = rSite[1] - by;
  var d = 2 * (ax * cy - ay * cx);
  if (d >= -epsilon2)
    return;
  var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x2 = (cy * ha - ay * hc) / d, y2 = (ax * hc - cx * ha) / d;
  var circle2 = circlePool.pop() || new Circle();
  circle2.arc = arc2;
  circle2.site = cSite;
  circle2.x = x2 + bx;
  circle2.y = (circle2.cy = y2 + by) + Math.sqrt(x2 * x2 + y2 * y2);
  arc2.circle = circle2;
  var before = null, node2 = circles._;
  while (node2) {
    if (circle2.y < node2.y || circle2.y === node2.y && circle2.x <= node2.x) {
      if (node2.L)
        node2 = node2.L;
      else {
        before = node2.P;
        break;
      }
    } else {
      if (node2.R)
        node2 = node2.R;
      else {
        before = node2;
        break;
      }
    }
  }
  circles.insert(before, circle2);
  if (!before)
    firstCircle = circle2;
}
function detachCircle(arc2) {
  var circle2 = arc2.circle;
  if (circle2) {
    if (!circle2.P)
      firstCircle = circle2.N;
    circles.remove(circle2);
    circlePool.push(circle2);
    RedBlackNode(circle2);
    arc2.circle = null;
  }
}
var beachPool = [];
function Beach() {
  RedBlackNode(this);
  this.edge = this.site = this.circle = null;
}
function createBeach(site) {
  var beach = beachPool.pop() || new Beach();
  beach.site = site;
  return beach;
}
function detachBeach(beach) {
  detachCircle(beach);
  beaches.remove(beach);
  beachPool.push(beach);
  RedBlackNode(beach);
}
function removeBeach(beach) {
  var circle2 = beach.circle, x2 = circle2.x, y2 = circle2.cy, vertex = [x2, y2], previous = beach.P, next2 = beach.N, disappearing = [beach];
  detachBeach(beach);
  var lArc = previous;
  while (lArc.circle && Math.abs(x2 - lArc.circle.x) < epsilon && Math.abs(y2 - lArc.circle.cy) < epsilon) {
    previous = lArc.P;
    disappearing.unshift(lArc);
    detachBeach(lArc);
    lArc = previous;
  }
  disappearing.unshift(lArc);
  detachCircle(lArc);
  var rArc = next2;
  while (rArc.circle && Math.abs(x2 - rArc.circle.x) < epsilon && Math.abs(y2 - rArc.circle.cy) < epsilon) {
    next2 = rArc.N;
    disappearing.push(rArc);
    detachBeach(rArc);
    rArc = next2;
  }
  disappearing.push(rArc);
  detachCircle(rArc);
  var nArcs = disappearing.length, iArc;
  for (iArc = 1; iArc < nArcs; ++iArc) {
    rArc = disappearing[iArc];
    lArc = disappearing[iArc - 1];
    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
  }
  lArc = disappearing[0];
  rArc = disappearing[nArcs - 1];
  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);
  attachCircle(lArc);
  attachCircle(rArc);
}
function addBeach(site) {
  var x2 = site[0], directrix = site[1], lArc, rArc, dxl, dxr, node2 = beaches._;
  while (node2) {
    dxl = leftBreakPoint(node2, directrix) - x2;
    if (dxl > epsilon)
      node2 = node2.L;
    else {
      dxr = x2 - rightBreakPoint(node2, directrix);
      if (dxr > epsilon) {
        if (!node2.R) {
          lArc = node2;
          break;
        }
        node2 = node2.R;
      } else {
        if (dxl > -epsilon) {
          lArc = node2.P;
          rArc = node2;
        } else if (dxr > -epsilon) {
          lArc = node2;
          rArc = node2.N;
        } else {
          lArc = rArc = node2;
        }
        break;
      }
    }
  }
  createCell(site);
  var newArc = createBeach(site);
  beaches.insert(lArc, newArc);
  if (!lArc && !rArc)
    return;
  if (lArc === rArc) {
    detachCircle(lArc);
    rArc = createBeach(lArc.site);
    beaches.insert(newArc, rArc);
    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
    attachCircle(lArc);
    attachCircle(rArc);
    return;
  }
  if (!rArc) {
    newArc.edge = createEdge(lArc.site, newArc.site);
    return;
  }
  detachCircle(lArc);
  detachCircle(rArc);
  var lSite = lArc.site, ax = lSite[0], ay = lSite[1], bx = site[0] - ax, by = site[1] - ay, rSite = rArc.site, cx = rSite[0] - ax, cy = rSite[1] - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];
  setEdgeEnd(rArc.edge, lSite, rSite, vertex);
  newArc.edge = createEdge(lSite, site, null, vertex);
  rArc.edge = createEdge(site, rSite, null, vertex);
  attachCircle(lArc);
  attachCircle(rArc);
}
function leftBreakPoint(arc2, directrix) {
  var site = arc2.site, rfocx = site[0], rfocy = site[1], pby2 = rfocy - directrix;
  if (!pby2)
    return rfocx;
  var lArc = arc2.P;
  if (!lArc)
    return -Infinity;
  site = lArc.site;
  var lfocx = site[0], lfocy = site[1], plby2 = lfocy - directrix;
  if (!plby2)
    return lfocx;
  var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
  if (aby2)
    return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
  return (rfocx + lfocx) / 2;
}
function rightBreakPoint(arc2, directrix) {
  var rArc = arc2.N;
  if (rArc)
    return leftBreakPoint(rArc, directrix);
  var site = arc2.site;
  return site[1] === directrix ? site[0] : Infinity;
}
var epsilon = 1e-6;
var epsilon2 = 1e-12;
var beaches;
var cells;
var circles;
var edges$1;
function triangleArea(a2, b, c2) {
  return (a2[0] - c2[0]) * (b[1] - a2[1]) - (a2[0] - b[0]) * (c2[1] - a2[1]);
}
function lexicographic(a2, b) {
  return b[1] - a2[1] || b[0] - a2[0];
}
function Diagram$1(sites, extent2) {
  var site = sites.sort(lexicographic).pop(), x2, y2, circle2;
  edges$1 = [];
  cells = new Array(sites.length);
  beaches = new RedBlackTree();
  circles = new RedBlackTree();
  while (true) {
    circle2 = firstCircle;
    if (site && (!circle2 || site[1] < circle2.y || site[1] === circle2.y && site[0] < circle2.x)) {
      if (site[0] !== x2 || site[1] !== y2) {
        addBeach(site);
        x2 = site[0], y2 = site[1];
      }
      site = sites.pop();
    } else if (circle2) {
      removeBeach(circle2.arc);
    } else {
      break;
    }
  }
  sortCellHalfedges();
  if (extent2) {
    var x02 = +extent2[0][0], y02 = +extent2[0][1], x12 = +extent2[1][0], y12 = +extent2[1][1];
    clipEdges(x02, y02, x12, y12);
    clipCells(x02, y02, x12, y12);
  }
  this.edges = edges$1;
  this.cells = cells;
  beaches = circles = edges$1 = cells = null;
}
Diagram$1.prototype = {
  constructor: Diagram$1,
  polygons: function() {
    var edges2 = this.edges;
    return this.cells.map(function(cell) {
      var polygon = cell.halfedges.map(function(i) {
        return cellHalfedgeStart(cell, edges2[i]);
      });
      polygon.data = cell.site.data;
      return polygon;
    });
  },
  triangles: function() {
    var triangles = [], edges2 = this.edges;
    this.cells.forEach(function(cell, i) {
      if (!(m = (halfedges = cell.halfedges).length))
        return;
      var site = cell.site, halfedges, j2 = -1, m, s0, e1 = edges2[halfedges[m - 1]], s1 = e1.left === site ? e1.right : e1.left;
      while (++j2 < m) {
        s0 = s1;
        e1 = edges2[halfedges[j2]];
        s1 = e1.left === site ? e1.right : e1.left;
        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
          triangles.push([site.data, s0.data, s1.data]);
        }
      }
    });
    return triangles;
  },
  links: function() {
    return this.edges.filter(function(edge) {
      return edge.right;
    }).map(function(edge) {
      return {
        source: edge.left.data,
        target: edge.right.data
      };
    });
  },
  find: function(x2, y2, radius) {
    var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;
    while (!(cell = that.cells[i1]))
      if (++i1 >= n)
        return null;
    var dx = x2 - cell.site[0], dy = y2 - cell.site[1], d2 = dx * dx + dy * dy;
    do {
      cell = that.cells[i0 = i1], i1 = null;
      cell.halfedges.forEach(function(e) {
        var edge = that.edges[e], v = edge.left;
        if ((v === cell.site || !v) && !(v = edge.right))
          return;
        var vx = x2 - v[0], vy = y2 - v[1], v2 = vx * vx + vy * vy;
        if (v2 < d2)
          d2 = v2, i1 = v.index;
      });
    } while (i1 !== null);
    that._found = i0;
    return radius == null || d2 <= radius * radius ? cell.site : null;
  }
};
function voronoi() {
  var x$12 = x, y$12 = y, extent2 = null;
  function voronoi2(data2) {
    return new Diagram$1(data2.map(function(d, i) {
      var s2 = [Math.round(x$12(d, i, data2) / epsilon) * epsilon, Math.round(y$12(d, i, data2) / epsilon) * epsilon];
      s2.index = i;
      s2.data = d;
      return s2;
    }), extent2);
  }
  voronoi2.polygons = function(data2) {
    return voronoi2(data2).polygons();
  };
  voronoi2.links = function(data2) {
    return voronoi2(data2).links();
  };
  voronoi2.triangles = function(data2) {
    return voronoi2(data2).triangles();
  };
  voronoi2.x = function(_2) {
    return arguments.length ? (x$12 = typeof _2 === "function" ? _2 : constant$1(+_2), voronoi2) : x$12;
  };
  voronoi2.y = function(_2) {
    return arguments.length ? (y$12 = typeof _2 === "function" ? _2 : constant$1(+_2), voronoi2) : y$12;
  };
  voronoi2.extent = function(_2) {
    return arguments.length ? (extent2 = _2 == null ? null : [[+_2[0][0], +_2[0][1]], [+_2[1][0], +_2[1][1]]], voronoi2) : extent2 && [[extent2[0][0], extent2[0][1]], [extent2[1][0], extent2[1][1]]];
  };
  voronoi2.size = function(_2) {
    return arguments.length ? (extent2 = _2 == null ? null : [[0, 0], [+_2[0], +_2[1]]], voronoi2) : extent2 && [extent2[1][0] - extent2[0][0], extent2[1][1] - extent2[0][1]];
  };
  return voronoi2;
}
function constant(x2) {
  return function() {
    return x2;
  };
}
function ZoomEvent(target, type2, transform2) {
  this.target = target;
  this.type = type2;
  this.transform = transform2;
}
function Transform(k2, x2, y2) {
  this.k = k2;
  this.x = x2;
  this.y = y2;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k2) {
    return k2 === 1 ? this : new Transform(this.k * k2, this.x, this.y);
  },
  translate: function(x2, y2) {
    return x2 === 0 & y2 === 0 ? this : new Transform(this.k, this.x + this.k * x2, this.y + this.k * y2);
  },
  apply: function(point2) {
    return [point2[0] * this.k + this.x, point2[1] * this.k + this.y];
  },
  applyX: function(x2) {
    return x2 * this.k + this.x;
  },
  applyY: function(y2) {
    return y2 * this.k + this.y;
  },
  invert: function(location2) {
    return [(location2[0] - this.x) / this.k, (location2[1] - this.y) / this.k];
  },
  invertX: function(x2) {
    return (x2 - this.x) / this.k;
  },
  invertY: function(y2) {
    return (y2 - this.y) / this.k;
  },
  rescaleX: function(x2) {
    return x2.copy().domain(x2.range().map(this.invertX, this).map(x2.invert, x2));
  },
  rescaleY: function(y2) {
    return y2.copy().domain(y2.range().map(this.invertY, this).map(y2.invert, y2));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node2) {
  while (!node2.__zoom)
    if (!(node2 = node2.parentNode))
      return identity;
  return node2.__zoom;
}
function nopropagation() {
  event.stopImmediatePropagation();
}
function noevent() {
  event.preventDefault();
  event.stopImmediatePropagation();
}
function defaultFilter() {
  return !event.ctrlKey && !event.button;
}
function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}
function defaultTransform() {
  return this.__zoom || identity;
}
function defaultWheelDelta() {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3);
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(transform2, extent2, translateExtent) {
  var dx0 = transform2.invertX(extent2[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent2[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent2[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent2[1][1]) - translateExtent[1][1];
  return transform2.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}
function zoom() {
  var filter = defaultFilter, extent2 = defaultExtent, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate2 = interpolateZoom, listeners = dispatch("start", "zoom", "end"), touchstarting, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0;
  function zoom2(selection2) {
    selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  zoom2.transform = function(collection, transform2, point2) {
    var selection2 = collection.selection ? collection.selection() : collection;
    selection2.property("__zoom", defaultTransform);
    if (collection !== selection2) {
      schedule2(collection, transform2, point2);
    } else {
      selection2.interrupt().each(function() {
        gesture(this, arguments).start().zoom(null, typeof transform2 === "function" ? transform2.apply(this, arguments) : transform2).end();
      });
    }
  };
  zoom2.scaleBy = function(selection2, k2, p) {
    zoom2.scaleTo(selection2, function() {
      var k0 = this.__zoom.k, k1 = typeof k2 === "function" ? k2.apply(this, arguments) : k2;
      return k0 * k1;
    }, p);
  };
  zoom2.scaleTo = function(selection2, k2, p) {
    zoom2.transform(selection2, function() {
      var e = extent2.apply(this, arguments), t02 = this.__zoom, p02 = p == null ? centroid2(e) : typeof p === "function" ? p.apply(this, arguments) : p, p1 = t02.invert(p02), k1 = typeof k2 === "function" ? k2.apply(this, arguments) : k2;
      return constrain(translate(scale(t02, k1), p02, p1), e, translateExtent);
    }, p);
  };
  zoom2.translateBy = function(selection2, x2, y2) {
    zoom2.transform(selection2, function() {
      return constrain(this.__zoom.translate(
        typeof x2 === "function" ? x2.apply(this, arguments) : x2,
        typeof y2 === "function" ? y2.apply(this, arguments) : y2
      ), extent2.apply(this, arguments), translateExtent);
    });
  };
  zoom2.translateTo = function(selection2, x2, y2, p) {
    zoom2.transform(selection2, function() {
      var e = extent2.apply(this, arguments), t4 = this.__zoom, p02 = p == null ? centroid2(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(identity.translate(p02[0], p02[1]).scale(t4.k).translate(
        typeof x2 === "function" ? -x2.apply(this, arguments) : -x2,
        typeof y2 === "function" ? -y2.apply(this, arguments) : -y2
      ), e, translateExtent);
    }, p);
  };
  function scale(transform2, k2) {
    k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k2));
    return k2 === transform2.k ? transform2 : new Transform(k2, transform2.x, transform2.y);
  }
  function translate(transform2, p02, p1) {
    var x2 = p02[0] - p1[0] * transform2.k, y2 = p02[1] - p1[1] * transform2.k;
    return x2 === transform2.x && y2 === transform2.y ? transform2 : new Transform(transform2.k, x2, y2);
  }
  function centroid2(extent3) {
    return [(+extent3[0][0] + +extent3[1][0]) / 2, (+extent3[0][1] + +extent3[1][1]) / 2];
  }
  function schedule2(transition2, transform2, point2) {
    transition2.on("start.zoom", function() {
      gesture(this, arguments).start();
    }).on("interrupt.zoom end.zoom", function() {
      gesture(this, arguments).end();
    }).tween("zoom", function() {
      var that = this, args = arguments, g2 = gesture(that, args), e = extent2.apply(that, args), p = point2 == null ? centroid2(e) : typeof point2 === "function" ? point2.apply(that, args) : point2, w2 = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]), a2 = that.__zoom, b = typeof transform2 === "function" ? transform2.apply(that, args) : transform2, i = interpolate2(a2.invert(p).concat(w2 / a2.k), b.invert(p).concat(w2 / b.k));
      return function(t4) {
        if (t4 === 1)
          t4 = b;
        else {
          var l2 = i(t4), k2 = w2 / l2[2];
          t4 = new Transform(k2, p[0] - l2[0] * k2, p[1] - l2[1] * k2);
        }
        g2.zoom(null, t4);
      };
    });
  }
  function gesture(that, args, clean) {
    return !clean && that.__zooming || new Gesture(that, args);
  }
  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.extent = extent2.apply(that, args);
    this.taps = 0;
  }
  Gesture.prototype = {
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform2) {
      if (this.mouse && key !== "mouse")
        this.mouse[1] = transform2.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch")
        this.touch0[1] = transform2.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch")
        this.touch1[1] = transform2.invert(this.touch1[0]);
      this.that.__zoom = transform2;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type2) {
      customEvent(new ZoomEvent(zoom2, type2, this.that.__zoom), listeners.apply, listeners, [type2, this.that, this.args]);
    }
  };
  function wheeled() {
    if (!filter.apply(this, arguments))
      return;
    var g2 = gesture(this, arguments), t4 = this.__zoom, k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t4.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p = mouse(this);
    if (g2.wheel) {
      if (g2.mouse[0][0] !== p[0] || g2.mouse[0][1] !== p[1]) {
        g2.mouse[1] = t4.invert(g2.mouse[0] = p);
      }
      clearTimeout(g2.wheel);
    } else if (t4.k === k2)
      return;
    else {
      g2.mouse = [p, t4.invert(p)];
      interrupt(this);
      g2.start();
    }
    noevent();
    g2.wheel = setTimeout(wheelidled, wheelDelay);
    g2.zoom("mouse", constrain(translate(scale(t4, k2), g2.mouse[0], g2.mouse[1]), g2.extent, translateExtent));
    function wheelidled() {
      g2.wheel = null;
      g2.end();
    }
  }
  function mousedowned() {
    if (touchending || !filter.apply(this, arguments))
      return;
    var g2 = gesture(this, arguments, true), v = select(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p = mouse(this), x02 = event.clientX, y02 = event.clientY;
    dragDisable(event.view);
    nopropagation();
    g2.mouse = [p, this.__zoom.invert(p)];
    interrupt(this);
    g2.start();
    function mousemoved() {
      noevent();
      if (!g2.moved) {
        var dx = event.clientX - x02, dy = event.clientY - y02;
        g2.moved = dx * dx + dy * dy > clickDistance2;
      }
      g2.zoom("mouse", constrain(translate(g2.that.__zoom, g2.mouse[0] = mouse(g2.that), g2.mouse[1]), g2.extent, translateExtent));
    }
    function mouseupped() {
      v.on("mousemove.zoom mouseup.zoom", null);
      yesdrag(event.view, g2.moved);
      noevent();
      g2.end();
    }
  }
  function dblclicked() {
    if (!filter.apply(this, arguments))
      return;
    var t02 = this.__zoom, p02 = mouse(this), p1 = t02.invert(p02), k1 = t02.k * (event.shiftKey ? 0.5 : 2), t12 = constrain(translate(scale(t02, k1), p02, p1), extent2.apply(this, arguments), translateExtent);
    noevent();
    if (duration > 0)
      select(this).transition().duration(duration).call(schedule2, t12, p02);
    else
      select(this).call(zoom2.transform, t12);
  }
  function touchstarted() {
    if (!filter.apply(this, arguments))
      return;
    var touches2 = event.touches, n = touches2.length, g2 = gesture(this, arguments, event.changedTouches.length === n), started, i, t4, p;
    nopropagation();
    for (i = 0; i < n; ++i) {
      t4 = touches2[i], p = touch(this, touches2, t4.identifier);
      p = [p, this.__zoom.invert(p), t4.identifier];
      if (!g2.touch0)
        g2.touch0 = p, started = true, g2.taps = 1 + !!touchstarting;
      else if (!g2.touch1 && g2.touch0[2] !== p[2])
        g2.touch1 = p, g2.taps = 0;
    }
    if (touchstarting)
      touchstarting = clearTimeout(touchstarting);
    if (started) {
      if (g2.taps < 2)
        touchstarting = setTimeout(function() {
          touchstarting = null;
        }, touchDelay);
      interrupt(this);
      g2.start();
    }
  }
  function touchmoved() {
    if (!this.__zooming)
      return;
    var g2 = gesture(this, arguments), touches2 = event.changedTouches, n = touches2.length, i, t4, p, l2;
    noevent();
    if (touchstarting)
      touchstarting = clearTimeout(touchstarting);
    g2.taps = 0;
    for (i = 0; i < n; ++i) {
      t4 = touches2[i], p = touch(this, touches2, t4.identifier);
      if (g2.touch0 && g2.touch0[2] === t4.identifier)
        g2.touch0[0] = p;
      else if (g2.touch1 && g2.touch1[2] === t4.identifier)
        g2.touch1[0] = p;
    }
    t4 = g2.that.__zoom;
    if (g2.touch1) {
      var p02 = g2.touch0[0], l0 = g2.touch0[1], p1 = g2.touch1[0], l1 = g2.touch1[1], dp = (dp = p1[0] - p02[0]) * dp + (dp = p1[1] - p02[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t4 = scale(t4, Math.sqrt(dp / dl));
      p = [(p02[0] + p1[0]) / 2, (p02[1] + p1[1]) / 2];
      l2 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    } else if (g2.touch0)
      p = g2.touch0[0], l2 = g2.touch0[1];
    else
      return;
    g2.zoom("touch", constrain(translate(t4, p, l2), g2.extent, translateExtent));
  }
  function touchended() {
    if (!this.__zooming)
      return;
    var g2 = gesture(this, arguments), touches2 = event.changedTouches, n = touches2.length, i, t4;
    nopropagation();
    if (touchending)
      clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, touchDelay);
    for (i = 0; i < n; ++i) {
      t4 = touches2[i];
      if (g2.touch0 && g2.touch0[2] === t4.identifier)
        delete g2.touch0;
      else if (g2.touch1 && g2.touch1[2] === t4.identifier)
        delete g2.touch1;
    }
    if (g2.touch1 && !g2.touch0)
      g2.touch0 = g2.touch1, delete g2.touch1;
    if (g2.touch0)
      g2.touch0[1] = this.__zoom.invert(g2.touch0[0]);
    else {
      g2.end();
      if (g2.taps === 2) {
        var p = select(this).on("dblclick.zoom");
        if (p)
          p.apply(this, arguments);
      }
    }
  }
  zoom2.wheelDelta = function(_2) {
    return arguments.length ? (wheelDelta = typeof _2 === "function" ? _2 : constant(+_2), zoom2) : wheelDelta;
  };
  zoom2.filter = function(_2) {
    return arguments.length ? (filter = typeof _2 === "function" ? _2 : constant(!!_2), zoom2) : filter;
  };
  zoom2.touchable = function(_2) {
    return arguments.length ? (touchable = typeof _2 === "function" ? _2 : constant(!!_2), zoom2) : touchable;
  };
  zoom2.extent = function(_2) {
    return arguments.length ? (extent2 = typeof _2 === "function" ? _2 : constant([[+_2[0][0], +_2[0][1]], [+_2[1][0], +_2[1][1]]]), zoom2) : extent2;
  };
  zoom2.scaleExtent = function(_2) {
    return arguments.length ? (scaleExtent[0] = +_2[0], scaleExtent[1] = +_2[1], zoom2) : [scaleExtent[0], scaleExtent[1]];
  };
  zoom2.translateExtent = function(_2) {
    return arguments.length ? (translateExtent[0][0] = +_2[0][0], translateExtent[1][0] = +_2[1][0], translateExtent[0][1] = +_2[0][1], translateExtent[1][1] = +_2[1][1], zoom2) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };
  zoom2.constrain = function(_2) {
    return arguments.length ? (constrain = _2, zoom2) : constrain;
  };
  zoom2.duration = function(_2) {
    return arguments.length ? (duration = +_2, zoom2) : duration;
  };
  zoom2.interpolate = function(_2) {
    return arguments.length ? (interpolate2 = _2, zoom2) : interpolate2;
  };
  zoom2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom2 : value;
  };
  zoom2.clickDistance = function(_2) {
    return arguments.length ? (clickDistance2 = (_2 = +_2) * _2, zoom2) : Math.sqrt(clickDistance2);
  };
  return zoom2;
}
const d3$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  version: version$3,
  bisect: bisectRight,
  bisectRight,
  bisectLeft,
  ascending: ascending$3,
  bisector,
  cross: cross$3,
  descending: descending$2,
  deviation,
  extent: extent$1,
  histogram,
  thresholdFreedmanDiaconis: freedmanDiaconis,
  thresholdScott: scott,
  thresholdSturges,
  max: max$2,
  mean,
  median,
  merge: merge$1,
  min: min$1,
  pairs,
  permute,
  quantile: threshold$1,
  range: sequence,
  scan,
  shuffle: shuffle$1,
  sum: sum$2,
  ticks,
  tickIncrement,
  tickStep,
  transpose,
  variance,
  zip,
  axisTop,
  axisRight,
  axisBottom,
  axisLeft,
  brush,
  brushX,
  brushY,
  brushSelection,
  chord,
  ribbon,
  nest,
  set,
  map: map$2,
  keys,
  values,
  entries,
  color,
  rgb,
  hsl: hsl$2,
  lab: lab$1,
  hcl: hcl$2,
  lch,
  gray,
  cubehelix: cubehelix$3,
  contours,
  contourDensity: density,
  dispatch,
  drag,
  dragDisable,
  dragEnable: yesdrag,
  dsvFormat,
  csvParse,
  csvParseRows,
  csvFormat,
  csvFormatBody,
  csvFormatRows,
  csvFormatRow,
  csvFormatValue,
  tsvParse,
  tsvParseRows,
  tsvFormat,
  tsvFormatBody,
  tsvFormatRows,
  tsvFormatRow,
  tsvFormatValue,
  autoType,
  easeLinear: linear$1,
  easeQuad: quadInOut,
  easeQuadIn: quadIn,
  easeQuadOut: quadOut,
  easeQuadInOut: quadInOut,
  easeCubic: cubicInOut,
  easeCubicIn: cubicIn,
  easeCubicOut: cubicOut,
  easeCubicInOut: cubicInOut,
  easePoly: polyInOut,
  easePolyIn: polyIn,
  easePolyOut: polyOut,
  easePolyInOut: polyInOut,
  easeSin: sinInOut,
  easeSinIn: sinIn,
  easeSinOut: sinOut,
  easeSinInOut: sinInOut,
  easeExp: expInOut,
  easeExpIn: expIn,
  easeExpOut: expOut,
  easeExpInOut: expInOut,
  easeCircle: circleInOut,
  easeCircleIn: circleIn,
  easeCircleOut: circleOut,
  easeCircleInOut: circleInOut,
  easeBounce: bounceOut,
  easeBounceIn: bounceIn,
  easeBounceOut: bounceOut,
  easeBounceInOut: bounceInOut,
  easeBack: backInOut,
  easeBackIn: backIn,
  easeBackOut: backOut,
  easeBackInOut: backInOut,
  easeElastic: elasticOut,
  easeElasticIn: elasticIn,
  easeElasticOut: elasticOut,
  easeElasticInOut: elasticInOut,
  blob,
  buffer,
  dsv,
  csv,
  tsv,
  image,
  json,
  text,
  xml,
  html,
  svg,
  forceCenter: center,
  forceCollide: collide,
  forceLink: link$2,
  forceManyBody: manyBody,
  forceRadial: radial,
  forceSimulation: simulation,
  forceX: x$2,
  forceY: y$2,
  formatDefaultLocale: defaultLocale$1,
  get format() {
    return format$1;
  },
  get formatPrefix() {
    return formatPrefix;
  },
  formatLocale: formatLocale$1,
  formatSpecifier,
  FormatSpecifier,
  precisionFixed,
  precisionPrefix,
  precisionRound,
  geoArea: area$2,
  geoBounds: bounds$2,
  geoCentroid: centroid$1,
  geoCircle: circle$4,
  geoClipAntimeridian: clipAntimeridian,
  geoClipCircle: clipCircle,
  geoClipExtent: extent,
  geoClipRectangle: clipRectangle,
  geoContains: contains$1,
  geoDistance: distance$1,
  geoGraticule: graticule,
  geoGraticule10: graticule10,
  geoInterpolate: interpolate,
  geoLength: length$1,
  geoPath: index$2,
  geoAlbers: albers,
  geoAlbersUsa: albersUsa,
  geoAzimuthalEqualArea: azimuthalEqualArea,
  geoAzimuthalEqualAreaRaw: azimuthalEqualAreaRaw,
  geoAzimuthalEquidistant: azimuthalEquidistant,
  geoAzimuthalEquidistantRaw: azimuthalEquidistantRaw,
  geoConicConformal: conicConformal,
  geoConicConformalRaw: conicConformalRaw,
  geoConicEqualArea: conicEqualArea,
  geoConicEqualAreaRaw: conicEqualAreaRaw,
  geoConicEquidistant: conicEquidistant,
  geoConicEquidistantRaw: conicEquidistantRaw,
  geoEqualEarth: equalEarth,
  geoEqualEarthRaw: equalEarthRaw,
  geoEquirectangular: equirectangular,
  geoEquirectangularRaw: equirectangularRaw,
  geoGnomonic: gnomonic,
  geoGnomonicRaw: gnomonicRaw,
  geoIdentity: identity$4,
  geoProjection: projection,
  geoProjectionMutator: projectionMutator,
  geoMercator: mercator,
  geoMercatorRaw: mercatorRaw,
  geoNaturalEarth1: naturalEarth1,
  geoNaturalEarth1Raw: naturalEarth1Raw,
  geoOrthographic: orthographic,
  geoOrthographicRaw: orthographicRaw,
  geoStereographic: stereographic,
  geoStereographicRaw: stereographicRaw,
  geoTransverseMercator: transverseMercator,
  geoTransverseMercatorRaw: transverseMercatorRaw,
  geoRotation: rotation,
  geoStream,
  geoTransform: transform$1,
  cluster,
  hierarchy,
  pack: index$1,
  packSiblings: siblings,
  packEnclose: enclose,
  partition,
  stratify,
  tree,
  treemap: index,
  treemapBinary: binary,
  treemapDice,
  treemapSlice,
  treemapSliceDice: sliceDice,
  treemapSquarify: squarify,
  treemapResquarify: resquarify,
  interpolate: interpolateValue,
  interpolateArray: array$2,
  interpolateBasis: basis$2,
  interpolateBasisClosed: basisClosed$1,
  interpolateDate: date$1,
  interpolateDiscrete: discrete,
  interpolateHue: hue,
  interpolateNumber,
  interpolateNumberArray: numberArray,
  interpolateObject: object$1,
  interpolateRound,
  interpolateString,
  interpolateTransformCss,
  interpolateTransformSvg,
  interpolateZoom,
  interpolateRgb,
  interpolateRgbBasis: rgbBasis,
  interpolateRgbBasisClosed: rgbBasisClosed,
  interpolateHsl: hsl$1,
  interpolateHslLong: hslLong,
  interpolateLab: lab,
  interpolateHcl: hcl$1,
  interpolateHclLong: hclLong,
  interpolateCubehelix: cubehelix$2,
  interpolateCubehelixLong: cubehelixLong,
  piecewise,
  quantize: quantize$1,
  path,
  polygonArea: area$1,
  polygonCentroid: centroid,
  polygonHull: hull,
  polygonContains: contains,
  polygonLength: length,
  quadtree,
  randomUniform: uniform,
  randomNormal: normal,
  randomLogNormal: logNormal,
  randomBates: bates,
  randomIrwinHall: irwinHall,
  randomExponential: exponential,
  scaleBand: band,
  scalePoint: point$5,
  scaleIdentity: identity$2,
  scaleLinear: linear,
  scaleLog: log$2,
  scaleSymlog: symlog,
  scaleOrdinal: ordinal,
  scaleImplicit: implicit,
  scalePow: pow,
  scaleSqrt: sqrt$1,
  scaleQuantile: quantile,
  scaleQuantize: quantize,
  scaleThreshold: threshold,
  scaleTime: time,
  scaleUtc: utcTime,
  scaleSequential: sequential,
  scaleSequentialLog: sequentialLog,
  scaleSequentialPow: sequentialPow,
  scaleSequentialSqrt: sequentialSqrt,
  scaleSequentialSymlog: sequentialSymlog,
  scaleSequentialQuantile: sequentialQuantile,
  scaleDiverging: diverging$1,
  scaleDivergingLog: divergingLog,
  scaleDivergingPow: divergingPow,
  scaleDivergingSqrt: divergingSqrt,
  scaleDivergingSymlog: divergingSymlog,
  tickFormat,
  schemeCategory10: category10,
  schemeAccent: Accent,
  schemeDark2: Dark2,
  schemePaired: Paired,
  schemePastel1: Pastel1,
  schemePastel2: Pastel2,
  schemeSet1: Set1,
  schemeSet2: Set2,
  schemeSet3: Set3,
  schemeTableau10: Tableau10,
  interpolateBrBG: BrBG,
  schemeBrBG: scheme$q,
  interpolatePRGn: PRGn,
  schemePRGn: scheme$p,
  interpolatePiYG: PiYG,
  schemePiYG: scheme$o,
  interpolatePuOr: PuOr,
  schemePuOr: scheme$n,
  interpolateRdBu: RdBu,
  schemeRdBu: scheme$m,
  interpolateRdGy: RdGy,
  schemeRdGy: scheme$l,
  interpolateRdYlBu: RdYlBu,
  schemeRdYlBu: scheme$k,
  interpolateRdYlGn: RdYlGn,
  schemeRdYlGn: scheme$j,
  interpolateSpectral: Spectral,
  schemeSpectral: scheme$i,
  interpolateBuGn: BuGn,
  schemeBuGn: scheme$h,
  interpolateBuPu: BuPu,
  schemeBuPu: scheme$g,
  interpolateGnBu: GnBu,
  schemeGnBu: scheme$f,
  interpolateOrRd: OrRd,
  schemeOrRd: scheme$e,
  interpolatePuBuGn: PuBuGn,
  schemePuBuGn: scheme$d,
  interpolatePuBu: PuBu,
  schemePuBu: scheme$c,
  interpolatePuRd: PuRd,
  schemePuRd: scheme$b,
  interpolateRdPu: RdPu,
  schemeRdPu: scheme$a,
  interpolateYlGnBu: YlGnBu,
  schemeYlGnBu: scheme$9,
  interpolateYlGn: YlGn,
  schemeYlGn: scheme$8,
  interpolateYlOrBr: YlOrBr,
  schemeYlOrBr: scheme$7,
  interpolateYlOrRd: YlOrRd,
  schemeYlOrRd: scheme$6,
  interpolateBlues: Blues,
  schemeBlues: scheme$5,
  interpolateGreens: Greens,
  schemeGreens: scheme$4,
  interpolateGreys: Greys,
  schemeGreys: scheme$3,
  interpolatePurples: Purples,
  schemePurples: scheme$2,
  interpolateReds: Reds,
  schemeReds: scheme$1,
  interpolateOranges: Oranges,
  schemeOranges: scheme,
  interpolateCividis: cividis,
  interpolateCubehelixDefault: cubehelix,
  interpolateRainbow: rainbow,
  interpolateWarm: warm,
  interpolateCool: cool,
  interpolateSinebow: sinebow,
  interpolateTurbo: turbo,
  interpolateViridis: viridis,
  interpolateMagma: magma,
  interpolateInferno: inferno,
  interpolatePlasma: plasma,
  create: create$1,
  creator,
  local: local$1,
  matcher,
  mouse,
  namespace,
  namespaces,
  clientPoint: point$6,
  select,
  selectAll,
  selection,
  selector,
  selectorAll,
  style: styleValue,
  touch,
  touches,
  window: defaultView,
  get event() {
    return event;
  },
  customEvent,
  arc,
  area,
  line,
  pie,
  areaRadial,
  radialArea: areaRadial,
  lineRadial: lineRadial$1,
  radialLine: lineRadial$1,
  pointRadial,
  linkHorizontal,
  linkVertical,
  linkRadial,
  symbol,
  symbols,
  symbolCircle: circle$2,
  symbolCross: cross$1,
  symbolDiamond: diamond,
  symbolSquare: square,
  symbolStar: star,
  symbolTriangle: triangle,
  symbolWye: wye,
  curveBasisClosed: basisClosed,
  curveBasisOpen: basisOpen,
  curveBasis: basis,
  curveBundle: bundle,
  curveCardinalClosed: cardinalClosed,
  curveCardinalOpen: cardinalOpen,
  curveCardinal: cardinal,
  curveCatmullRomClosed: catmullRomClosed,
  curveCatmullRomOpen: catmullRomOpen,
  curveCatmullRom: catmullRom,
  curveLinearClosed: linearClosed,
  curveLinear,
  curveMonotoneX: monotoneX,
  curveMonotoneY: monotoneY,
  curveNatural: natural,
  curveStep: step,
  curveStepAfter: stepAfter,
  curveStepBefore: stepBefore,
  stack,
  stackOffsetExpand: expand,
  stackOffsetDiverging: diverging,
  stackOffsetNone: none$1,
  stackOffsetSilhouette: silhouette,
  stackOffsetWiggle: wiggle,
  stackOrderAppearance: appearance,
  stackOrderAscending: ascending,
  stackOrderDescending: descending,
  stackOrderInsideOut: insideOut,
  stackOrderNone: none,
  stackOrderReverse: reverse,
  timeInterval: newInterval,
  timeMillisecond: utcMillisecond,
  timeMilliseconds: milliseconds,
  utcMillisecond,
  utcMilliseconds: milliseconds,
  timeSecond: utcSecond,
  timeSeconds: seconds,
  utcSecond,
  utcSeconds: seconds,
  timeMinute,
  timeMinutes: minutes,
  timeHour,
  timeHours: hours,
  timeDay,
  timeDays: days,
  timeWeek: sunday,
  timeWeeks: sundays,
  timeSunday: sunday,
  timeSundays: sundays,
  timeMonday: monday,
  timeMondays: mondays,
  timeTuesday: tuesday,
  timeTuesdays: tuesdays,
  timeWednesday: wednesday,
  timeWednesdays: wednesdays,
  timeThursday: thursday,
  timeThursdays: thursdays,
  timeFriday: friday,
  timeFridays: fridays,
  timeSaturday: saturday,
  timeSaturdays: saturdays,
  timeMonth,
  timeMonths: months,
  timeYear,
  timeYears: years,
  utcMinute: utcMinute$1,
  utcMinutes,
  utcHour: utcHour$1,
  utcHours,
  utcDay: utcDay$1,
  utcDays,
  utcWeek: utcSunday,
  utcWeeks: utcSundays,
  utcSunday,
  utcSundays,
  utcMonday,
  utcMondays,
  utcTuesday,
  utcTuesdays,
  utcWednesday,
  utcWednesdays,
  utcThursday,
  utcThursdays,
  utcFriday,
  utcFridays,
  utcSaturday,
  utcSaturdays,
  utcMonth: utcMonth$1,
  utcMonths,
  utcYear: utcYear$1,
  utcYears,
  timeFormatDefaultLocale: defaultLocale,
  get timeFormat() {
    return timeFormat;
  },
  get timeParse() {
    return timeParse;
  },
  get utcFormat() {
    return utcFormat;
  },
  get utcParse() {
    return utcParse;
  },
  timeFormatLocale: formatLocale,
  isoFormat: formatIso$1,
  isoParse: parseIso$1,
  now,
  timer,
  timerFlush,
  timeout,
  interval,
  transition,
  active,
  interrupt,
  voronoi,
  zoom,
  zoomTransform: transform,
  zoomIdentity: identity
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(d3$2);
var d3$1;
if (!d3$1) {
  if (typeof commonjsRequire$1 === "function") {
    try {
      d3$1 = require$$0;
    } catch (e) {
    }
  }
}
if (!d3$1) {
  d3$1 = window.d3;
}
var d3_1 = d3$1;
var _$2 = lodash_1$1;
var util$2 = {
  isSubgraph: isSubgraph$1,
  edgeToId: edgeToId$1,
  applyStyle: applyStyle$2,
  applyClass: applyClass$1,
  applyTransition: applyTransition$1
};
function isSubgraph$1(g2, v) {
  return !!g2.children(v).length;
}
function edgeToId$1(e) {
  return escapeId$1(e.v) + ":" + escapeId$1(e.w) + ":" + escapeId$1(e.name);
}
var ID_DELIM$1 = /:/g;
function escapeId$1(str) {
  return str ? String(str).replace(ID_DELIM$1, "\\:") : "";
}
function applyStyle$2(dom, styleFn) {
  if (styleFn) {
    dom.attr("style", styleFn);
  }
}
function applyClass$1(dom, classFn, otherClasses) {
  if (classFn) {
    dom.attr("class", classFn).attr("class", otherClasses + " " + dom.attr("class"));
  }
}
function applyTransition$1(selection2, g2) {
  var graph2 = g2.graph();
  if (_$2.isPlainObject(graph2)) {
    var transition2 = graph2.transition;
    if (_$2.isFunction(transition2)) {
      return transition2(selection2);
    }
  }
  return selection2;
}
var addTextLabel_1;
var hasRequiredAddTextLabel;
function requireAddTextLabel() {
  if (hasRequiredAddTextLabel)
    return addTextLabel_1;
  hasRequiredAddTextLabel = 1;
  var util2 = util$2;
  addTextLabel_1 = addTextLabel;
  function addTextLabel(root2, node2) {
    var domNode = root2.append("text");
    var lines = processEscapeSequences(node2.label).split("\n");
    for (var i = 0; i < lines.length; i++) {
      domNode.append("tspan").attr("xml:space", "preserve").attr("dy", "1em").attr("x", "1").text(lines[i]);
    }
    util2.applyStyle(domNode, node2.labelStyle);
    return domNode;
  }
  function processEscapeSequences(text2) {
    var newText = "";
    var escaped = false;
    var ch;
    for (var i = 0; i < text2.length; ++i) {
      ch = text2[i];
      if (escaped) {
        switch (ch) {
          case "n":
            newText += "\n";
            break;
          default:
            newText += ch;
        }
        escaped = false;
      } else if (ch === "\\") {
        escaped = true;
      } else {
        newText += ch;
      }
    }
    return newText;
  }
  return addTextLabel_1;
}
var addHtmlLabel_1$1;
var hasRequiredAddHtmlLabel;
function requireAddHtmlLabel() {
  if (hasRequiredAddHtmlLabel)
    return addHtmlLabel_1$1;
  hasRequiredAddHtmlLabel = 1;
  var util2 = util$2;
  addHtmlLabel_1$1 = addHtmlLabel2;
  function addHtmlLabel2(root2, node2) {
    var fo = root2.append("foreignObject").attr("width", "100000");
    var div = fo.append("xhtml:div");
    div.attr("xmlns", "http://www.w3.org/1999/xhtml");
    var label = node2.label;
    switch (typeof label) {
      case "function":
        div.insert(label);
        break;
      case "object":
        div.insert(function() {
          return label;
        });
        break;
      default:
        div.html(label);
    }
    util2.applyStyle(div, node2.labelStyle);
    div.style("display", "inline-block");
    div.style("white-space", "nowrap");
    var client = div.node().getBoundingClientRect();
    fo.attr("width", client.width).attr("height", client.height);
    return fo;
  }
  return addHtmlLabel_1$1;
}
var addSvgLabel;
var hasRequiredAddSvgLabel;
function requireAddSvgLabel() {
  if (hasRequiredAddSvgLabel)
    return addSvgLabel;
  hasRequiredAddSvgLabel = 1;
  var util2 = util$2;
  addSvgLabel = addSVGLabel;
  function addSVGLabel(root2, node2) {
    var domNode = root2;
    domNode.node().appendChild(node2.label);
    util2.applyStyle(domNode, node2.labelStyle);
    return domNode;
  }
  return addSvgLabel;
}
var addLabel_1;
var hasRequiredAddLabel;
function requireAddLabel() {
  if (hasRequiredAddLabel)
    return addLabel_1;
  hasRequiredAddLabel = 1;
  var addTextLabel = requireAddTextLabel();
  var addHtmlLabel2 = requireAddHtmlLabel();
  var addSVGLabel = requireAddSvgLabel();
  addLabel_1 = addLabel;
  function addLabel(root2, node2, location2) {
    var label = node2.label;
    var labelSvg = root2.append("g");
    if (node2.labelType === "svg") {
      addSVGLabel(labelSvg, node2);
    } else if (typeof label !== "string" || node2.labelType === "html") {
      addHtmlLabel2(labelSvg, node2);
    } else {
      addTextLabel(labelSvg, node2);
    }
    var labelBBox = labelSvg.node().getBBox();
    var y2;
    switch (location2) {
      case "top":
        y2 = -node2.height / 2;
        break;
      case "bottom":
        y2 = node2.height / 2 - labelBBox.height;
        break;
      default:
        y2 = -labelBBox.height / 2;
    }
    labelSvg.attr(
      "transform",
      "translate(" + -labelBBox.width / 2 + "," + y2 + ")"
    );
    return labelSvg;
  }
  return addLabel_1;
}
var createNodes_1;
var hasRequiredCreateNodes;
function requireCreateNodes() {
  if (hasRequiredCreateNodes)
    return createNodes_1;
  hasRequiredCreateNodes = 1;
  var _2 = lodash_1$1;
  var addLabel = requireAddLabel();
  var util2 = util$2;
  var d32 = d3_1;
  createNodes_1 = createNodes;
  function createNodes(selection2, g2, shapes2) {
    var simpleNodes = g2.nodes().filter(function(v) {
      return !util2.isSubgraph(g2, v);
    });
    var svgNodes = selection2.selectAll("g.node").data(simpleNodes, function(v) {
      return v;
    }).classed("update", true);
    svgNodes.exit().remove();
    svgNodes.enter().append("g").attr("class", "node").style("opacity", 0);
    svgNodes = selection2.selectAll("g.node");
    svgNodes.each(function(v) {
      var node2 = g2.node(v);
      var thisGroup = d32.select(this);
      util2.applyClass(
        thisGroup,
        node2["class"],
        (thisGroup.classed("update") ? "update " : "") + "node"
      );
      thisGroup.select("g.label").remove();
      var labelGroup = thisGroup.append("g").attr("class", "label");
      var labelDom = addLabel(labelGroup, node2);
      var shape = shapes2[node2.shape];
      var bbox = _2.pick(labelDom.node().getBBox(), "width", "height");
      node2.elem = this;
      if (node2.id) {
        thisGroup.attr("id", node2.id);
      }
      if (node2.labelId) {
        labelGroup.attr("id", node2.labelId);
      }
      if (_2.has(node2, "width")) {
        bbox.width = node2.width;
      }
      if (_2.has(node2, "height")) {
        bbox.height = node2.height;
      }
      bbox.width += node2.paddingLeft + node2.paddingRight;
      bbox.height += node2.paddingTop + node2.paddingBottom;
      labelGroup.attr("transform", "translate(" + (node2.paddingLeft - node2.paddingRight) / 2 + "," + (node2.paddingTop - node2.paddingBottom) / 2 + ")");
      var root2 = d32.select(this);
      root2.select(".label-container").remove();
      var shapeSvg = shape(root2, bbox, node2).classed("label-container", true);
      util2.applyStyle(shapeSvg, node2.style);
      var shapeBBox = shapeSvg.node().getBBox();
      node2.width = shapeBBox.width;
      node2.height = shapeBBox.height;
    });
    var exitSelection;
    if (svgNodes.exit) {
      exitSelection = svgNodes.exit();
    } else {
      exitSelection = svgNodes.selectAll(null);
    }
    util2.applyTransition(exitSelection, g2).style("opacity", 0).remove();
    return svgNodes;
  }
  return createNodes_1;
}
var createClusters_1;
var hasRequiredCreateClusters;
function requireCreateClusters() {
  if (hasRequiredCreateClusters)
    return createClusters_1;
  hasRequiredCreateClusters = 1;
  var util2 = util$2;
  var d32 = d3_1;
  var addLabel = requireAddLabel();
  createClusters_1 = createClusters;
  function createClusters(selection2, g2) {
    var clusters = g2.nodes().filter(function(v) {
      return util2.isSubgraph(g2, v);
    });
    var svgClusters = selection2.selectAll("g.cluster").data(clusters, function(v) {
      return v;
    });
    svgClusters.selectAll("*").remove();
    svgClusters.enter().append("g").attr("class", "cluster").attr("id", function(v) {
      var node2 = g2.node(v);
      return node2.id;
    }).style("opacity", 0);
    svgClusters = selection2.selectAll("g.cluster");
    util2.applyTransition(svgClusters, g2).style("opacity", 1);
    svgClusters.each(function(v) {
      var node2 = g2.node(v);
      var thisGroup = d32.select(this);
      d32.select(this).append("rect");
      var labelGroup = thisGroup.append("g").attr("class", "label");
      addLabel(labelGroup, node2, node2.clusterLabelPos);
    });
    svgClusters.selectAll("rect").each(function(c2) {
      var node2 = g2.node(c2);
      var domCluster = d32.select(this);
      util2.applyStyle(domCluster, node2.style);
    });
    var exitSelection;
    if (svgClusters.exit) {
      exitSelection = svgClusters.exit();
    } else {
      exitSelection = svgClusters.selectAll(null);
    }
    util2.applyTransition(exitSelection, g2).style("opacity", 0).remove();
    return svgClusters;
  }
  return createClusters_1;
}
var createEdgeLabels_1;
var hasRequiredCreateEdgeLabels;
function requireCreateEdgeLabels() {
  if (hasRequiredCreateEdgeLabels)
    return createEdgeLabels_1;
  hasRequiredCreateEdgeLabels = 1;
  var _2 = lodash_1$1;
  var addLabel = requireAddLabel();
  var util2 = util$2;
  var d32 = d3_1;
  createEdgeLabels_1 = createEdgeLabels;
  function createEdgeLabels(selection2, g2) {
    var svgEdgeLabels = selection2.selectAll("g.edgeLabel").data(g2.edges(), function(e) {
      return util2.edgeToId(e);
    }).classed("update", true);
    svgEdgeLabels.exit().remove();
    svgEdgeLabels.enter().append("g").classed("edgeLabel", true).style("opacity", 0);
    svgEdgeLabels = selection2.selectAll("g.edgeLabel");
    svgEdgeLabels.each(function(e) {
      var root2 = d32.select(this);
      root2.select(".label").remove();
      var edge = g2.edge(e);
      var label = addLabel(root2, g2.edge(e), 0, 0).classed("label", true);
      var bbox = label.node().getBBox();
      if (edge.labelId) {
        label.attr("id", edge.labelId);
      }
      if (!_2.has(edge, "width")) {
        edge.width = bbox.width;
      }
      if (!_2.has(edge, "height")) {
        edge.height = bbox.height;
      }
    });
    var exitSelection;
    if (svgEdgeLabels.exit) {
      exitSelection = svgEdgeLabels.exit();
    } else {
      exitSelection = svgEdgeLabels.selectAll(null);
    }
    util2.applyTransition(exitSelection, g2).style("opacity", 0).remove();
    return svgEdgeLabels;
  }
  return createEdgeLabels_1;
}
var createEdgePaths_1;
var hasRequiredCreateEdgePaths;
function requireCreateEdgePaths() {
  if (hasRequiredCreateEdgePaths)
    return createEdgePaths_1;
  hasRequiredCreateEdgePaths = 1;
  var _2 = lodash_1$1;
  var intersectNode2 = intersectNode_1;
  var util2 = util$2;
  var d32 = d3_1;
  createEdgePaths_1 = createEdgePaths;
  function createEdgePaths(selection2, g2, arrows2) {
    var previousPaths = selection2.selectAll("g.edgePath").data(g2.edges(), function(e) {
      return util2.edgeToId(e);
    }).classed("update", true);
    var newPaths = enter(previousPaths, g2);
    exit(previousPaths, g2);
    var svgPaths = previousPaths.merge !== void 0 ? previousPaths.merge(newPaths) : previousPaths;
    util2.applyTransition(svgPaths, g2).style("opacity", 1);
    svgPaths.each(function(e) {
      var domEdge = d32.select(this);
      var edge = g2.edge(e);
      edge.elem = this;
      if (edge.id) {
        domEdge.attr("id", edge.id);
      }
      util2.applyClass(
        domEdge,
        edge["class"],
        (domEdge.classed("update") ? "update " : "") + "edgePath"
      );
    });
    svgPaths.selectAll("path.path").each(function(e) {
      var edge = g2.edge(e);
      edge.arrowheadId = _2.uniqueId("arrowhead");
      var domEdge = d32.select(this).attr("marker-end", function() {
        return "url(" + makeFragmentRef(location.href, edge.arrowheadId) + ")";
      }).style("fill", "none");
      util2.applyTransition(domEdge, g2).attr("d", function(e3) {
        return calcPoints(g2, e3);
      });
      util2.applyStyle(domEdge, edge.style);
    });
    svgPaths.selectAll("defs *").remove();
    svgPaths.selectAll("defs").each(function(e) {
      var edge = g2.edge(e);
      var arrowhead = arrows2[edge.arrowhead];
      arrowhead(d32.select(this), edge.arrowheadId, edge, "arrowhead");
    });
    return svgPaths;
  }
  function makeFragmentRef(url, fragmentId) {
    var baseUrl = url.split("#")[0];
    return baseUrl + "#" + fragmentId;
  }
  function calcPoints(g2, e) {
    var edge = g2.edge(e);
    var tail = g2.node(e.v);
    var head2 = g2.node(e.w);
    var points = edge.points.slice(1, edge.points.length - 1);
    points.unshift(intersectNode2(tail, points[0]));
    points.push(intersectNode2(head2, points[points.length - 1]));
    return createLine(edge, points);
  }
  function createLine(edge, points) {
    var line2 = (d32.line || d32.svg.line)().x(function(d) {
      return d.x;
    }).y(function(d) {
      return d.y;
    });
    (line2.curve || line2.interpolate)(edge.curve);
    return line2(points);
  }
  function getCoords(elem) {
    var bbox = elem.getBBox();
    var matrix = elem.ownerSVGElement.getScreenCTM().inverse().multiply(elem.getScreenCTM()).translate(bbox.width / 2, bbox.height / 2);
    return { x: matrix.e, y: matrix.f };
  }
  function enter(svgPaths, g2) {
    var svgPathsEnter = svgPaths.enter().append("g").attr("class", "edgePath").style("opacity", 0);
    svgPathsEnter.append("path").attr("class", "path").attr("d", function(e) {
      var edge = g2.edge(e);
      var sourceElem = g2.node(e.v).elem;
      var points = _2.range(edge.points.length).map(function() {
        return getCoords(sourceElem);
      });
      return createLine(edge, points);
    });
    svgPathsEnter.append("defs");
    return svgPathsEnter;
  }
  function exit(svgPaths, g2) {
    var svgPathExit = svgPaths.exit();
    util2.applyTransition(svgPathExit, g2).style("opacity", 0).remove();
  }
  return createEdgePaths_1;
}
var positionNodes_1;
var hasRequiredPositionNodes;
function requirePositionNodes() {
  if (hasRequiredPositionNodes)
    return positionNodes_1;
  hasRequiredPositionNodes = 1;
  var util2 = util$2;
  var d32 = d3_1;
  positionNodes_1 = positionNodes;
  function positionNodes(selection2, g2) {
    var created = selection2.filter(function() {
      return !d32.select(this).classed("update");
    });
    function translate(v) {
      var node2 = g2.node(v);
      return "translate(" + node2.x + "," + node2.y + ")";
    }
    created.attr("transform", translate);
    util2.applyTransition(selection2, g2).style("opacity", 1).attr("transform", translate);
  }
  return positionNodes_1;
}
var positionEdgeLabels_1;
var hasRequiredPositionEdgeLabels;
function requirePositionEdgeLabels() {
  if (hasRequiredPositionEdgeLabels)
    return positionEdgeLabels_1;
  hasRequiredPositionEdgeLabels = 1;
  var util2 = util$2;
  var d32 = d3_1;
  var _2 = lodash_1$1;
  positionEdgeLabels_1 = positionEdgeLabels;
  function positionEdgeLabels(selection2, g2) {
    var created = selection2.filter(function() {
      return !d32.select(this).classed("update");
    });
    function translate(e) {
      var edge = g2.edge(e);
      return _2.has(edge, "x") ? "translate(" + edge.x + "," + edge.y + ")" : "";
    }
    created.attr("transform", translate);
    util2.applyTransition(selection2, g2).style("opacity", 1).attr("transform", translate);
  }
  return positionEdgeLabels_1;
}
var positionClusters_1;
var hasRequiredPositionClusters;
function requirePositionClusters() {
  if (hasRequiredPositionClusters)
    return positionClusters_1;
  hasRequiredPositionClusters = 1;
  var util2 = util$2;
  var d32 = d3_1;
  positionClusters_1 = positionClusters;
  function positionClusters(selection2, g2) {
    var created = selection2.filter(function() {
      return !d32.select(this).classed("update");
    });
    function translate(v) {
      var node2 = g2.node(v);
      return "translate(" + node2.x + "," + node2.y + ")";
    }
    created.attr("transform", translate);
    util2.applyTransition(selection2, g2).style("opacity", 1).attr("transform", translate);
    util2.applyTransition(created.selectAll("rect"), g2).attr("width", function(v) {
      return g2.node(v).width;
    }).attr("height", function(v) {
      return g2.node(v).height;
    }).attr("x", function(v) {
      var node2 = g2.node(v);
      return -node2.width / 2;
    }).attr("y", function(v) {
      var node2 = g2.node(v);
      return -node2.height / 2;
    });
  }
  return positionClusters_1;
}
var shapes$2;
var hasRequiredShapes;
function requireShapes() {
  if (hasRequiredShapes)
    return shapes$2;
  hasRequiredShapes = 1;
  var intersectRect2 = intersectRect_1;
  var intersectEllipse2 = intersectEllipse_1;
  var intersectCircle2 = intersectCircle_1;
  var intersectPolygon2 = intersectPolygon_1;
  shapes$2 = {
    rect: rect2,
    ellipse,
    circle: circle2,
    diamond: diamond2
  };
  function rect2(parent, bbox, node2) {
    var shapeSvg = parent.insert("rect", ":first-child").attr("rx", node2.rx).attr("ry", node2.ry).attr("x", -bbox.width / 2).attr("y", -bbox.height / 2).attr("width", bbox.width).attr("height", bbox.height);
    node2.intersect = function(point2) {
      return intersectRect2(node2, point2);
    };
    return shapeSvg;
  }
  function ellipse(parent, bbox, node2) {
    var rx = bbox.width / 2;
    var ry = bbox.height / 2;
    var shapeSvg = parent.insert("ellipse", ":first-child").attr("x", -bbox.width / 2).attr("y", -bbox.height / 2).attr("rx", rx).attr("ry", ry);
    node2.intersect = function(point2) {
      return intersectEllipse2(node2, rx, ry, point2);
    };
    return shapeSvg;
  }
  function circle2(parent, bbox, node2) {
    var r = Math.max(bbox.width, bbox.height) / 2;
    var shapeSvg = parent.insert("circle", ":first-child").attr("x", -bbox.width / 2).attr("y", -bbox.height / 2).attr("r", r);
    node2.intersect = function(point2) {
      return intersectCircle2(node2, r, point2);
    };
    return shapeSvg;
  }
  function diamond2(parent, bbox, node2) {
    var w2 = bbox.width * Math.SQRT2 / 2;
    var h2 = bbox.height * Math.SQRT2 / 2;
    var points = [
      { x: 0, y: -h2 },
      { x: -w2, y: 0 },
      { x: 0, y: h2 },
      { x: w2, y: 0 }
    ];
    var shapeSvg = parent.insert("polygon", ":first-child").attr("points", points.map(function(p) {
      return p.x + "," + p.y;
    }).join(" "));
    node2.intersect = function(p) {
      return intersectPolygon2(node2, points, p);
    };
    return shapeSvg;
  }
  return shapes$2;
}
var arrows;
var hasRequiredArrows;
function requireArrows() {
  if (hasRequiredArrows)
    return arrows;
  hasRequiredArrows = 1;
  var util2 = util$2;
  arrows = {
    "default": normal2,
    "normal": normal2,
    "vee": vee,
    "undirected": undirected
  };
  function normal2(parent, id2, edge, type2) {
    var marker = parent.append("marker").attr("id", id2).attr("viewBox", "0 0 10 10").attr("refX", 9).attr("refY", 5).attr("markerUnits", "strokeWidth").attr("markerWidth", 8).attr("markerHeight", 6).attr("orient", "auto");
    var path2 = marker.append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").style("stroke-width", 1).style("stroke-dasharray", "1,0");
    util2.applyStyle(path2, edge[type2 + "Style"]);
    if (edge[type2 + "Class"]) {
      path2.attr("class", edge[type2 + "Class"]);
    }
  }
  function vee(parent, id2, edge, type2) {
    var marker = parent.append("marker").attr("id", id2).attr("viewBox", "0 0 10 10").attr("refX", 9).attr("refY", 5).attr("markerUnits", "strokeWidth").attr("markerWidth", 8).attr("markerHeight", 6).attr("orient", "auto");
    var path2 = marker.append("path").attr("d", "M 0 0 L 10 5 L 0 10 L 4 5 z").style("stroke-width", 1).style("stroke-dasharray", "1,0");
    util2.applyStyle(path2, edge[type2 + "Style"]);
    if (edge[type2 + "Class"]) {
      path2.attr("class", edge[type2 + "Class"]);
    }
  }
  function undirected(parent, id2, edge, type2) {
    var marker = parent.append("marker").attr("id", id2).attr("viewBox", "0 0 10 10").attr("refX", 9).attr("refY", 5).attr("markerUnits", "strokeWidth").attr("markerWidth", 8).attr("markerHeight", 6).attr("orient", "auto");
    var path2 = marker.append("path").attr("d", "M 0 5 L 10 5").style("stroke-width", 1).style("stroke-dasharray", "1,0");
    util2.applyStyle(path2, edge[type2 + "Style"]);
    if (edge[type2 + "Class"]) {
      path2.attr("class", edge[type2 + "Class"]);
    }
  }
  return arrows;
}
var _$1 = lodash_1$1;
var d3 = d3_1;
var layout = dagre_1.layout;
var render_1 = render$2;
function render$2() {
  var createNodes = requireCreateNodes();
  var createClusters = requireCreateClusters();
  var createEdgeLabels = requireCreateEdgeLabels();
  var createEdgePaths = requireCreateEdgePaths();
  var positionNodes = requirePositionNodes();
  var positionEdgeLabels = requirePositionEdgeLabels();
  var positionClusters = requirePositionClusters();
  var shapes2 = requireShapes();
  var arrows2 = requireArrows();
  var fn2 = function(svg2, g2) {
    preProcessGraph(g2);
    var outputGroup = createOrSelectGroup(svg2, "output");
    var clustersGroup = createOrSelectGroup(outputGroup, "clusters");
    var edgePathsGroup = createOrSelectGroup(outputGroup, "edgePaths");
    var edgeLabels2 = createEdgeLabels(createOrSelectGroup(outputGroup, "edgeLabels"), g2);
    var nodes = createNodes(createOrSelectGroup(outputGroup, "nodes"), g2, shapes2);
    layout(g2);
    positionNodes(nodes, g2);
    positionEdgeLabels(edgeLabels2, g2);
    createEdgePaths(edgePathsGroup, g2, arrows2);
    var clusters = createClusters(clustersGroup, g2);
    positionClusters(clusters, g2);
    postProcessGraph(g2);
  };
  fn2.createNodes = function(value) {
    if (!arguments.length)
      return createNodes;
    createNodes = value;
    return fn2;
  };
  fn2.createClusters = function(value) {
    if (!arguments.length)
      return createClusters;
    createClusters = value;
    return fn2;
  };
  fn2.createEdgeLabels = function(value) {
    if (!arguments.length)
      return createEdgeLabels;
    createEdgeLabels = value;
    return fn2;
  };
  fn2.createEdgePaths = function(value) {
    if (!arguments.length)
      return createEdgePaths;
    createEdgePaths = value;
    return fn2;
  };
  fn2.shapes = function(value) {
    if (!arguments.length)
      return shapes2;
    shapes2 = value;
    return fn2;
  };
  fn2.arrows = function(value) {
    if (!arguments.length)
      return arrows2;
    arrows2 = value;
    return fn2;
  };
  return fn2;
}
var NODE_DEFAULT_ATTRS = {
  paddingLeft: 10,
  paddingRight: 10,
  paddingTop: 10,
  paddingBottom: 10,
  rx: 0,
  ry: 0,
  shape: "rect"
};
var EDGE_DEFAULT_ATTRS = {
  arrowhead: "normal",
  curve: d3.curveLinear
};
function preProcessGraph(g2) {
  g2.nodes().forEach(function(v) {
    var node2 = g2.node(v);
    if (!_$1.has(node2, "label") && !g2.children(v).length) {
      node2.label = v;
    }
    if (_$1.has(node2, "paddingX")) {
      _$1.defaults(node2, {
        paddingLeft: node2.paddingX,
        paddingRight: node2.paddingX
      });
    }
    if (_$1.has(node2, "paddingY")) {
      _$1.defaults(node2, {
        paddingTop: node2.paddingY,
        paddingBottom: node2.paddingY
      });
    }
    if (_$1.has(node2, "padding")) {
      _$1.defaults(node2, {
        paddingLeft: node2.padding,
        paddingRight: node2.padding,
        paddingTop: node2.padding,
        paddingBottom: node2.padding
      });
    }
    _$1.defaults(node2, NODE_DEFAULT_ATTRS);
    _$1.each(["paddingLeft", "paddingRight", "paddingTop", "paddingBottom"], function(k2) {
      node2[k2] = Number(node2[k2]);
    });
    if (_$1.has(node2, "width")) {
      node2._prevWidth = node2.width;
    }
    if (_$1.has(node2, "height")) {
      node2._prevHeight = node2.height;
    }
  });
  g2.edges().forEach(function(e) {
    var edge = g2.edge(e);
    if (!_$1.has(edge, "label")) {
      edge.label = "";
    }
    _$1.defaults(edge, EDGE_DEFAULT_ATTRS);
  });
}
function postProcessGraph(g2) {
  _$1.each(g2.nodes(), function(v) {
    var node2 = g2.node(v);
    if (_$1.has(node2, "_prevWidth")) {
      node2.width = node2._prevWidth;
    } else {
      delete node2.width;
    }
    if (_$1.has(node2, "_prevHeight")) {
      node2.height = node2._prevHeight;
    } else {
      delete node2.height;
    }
    delete node2._prevWidth;
    delete node2._prevHeight;
  });
}
function createOrSelectGroup(root2, name2) {
  var selection2 = root2.select("g." + name2);
  if (selection2.empty()) {
    selection2 = root2.append("g").attr("class", name2);
  }
  return selection2;
}
var version$2 = "0.6.4";
/**
 * @license
 * Copyright (c) 2012-2013 Chris Pettitt
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var dagreD3 = {
  graphlib: graphlib_1,
  dagre: dagre_1,
  intersect: intersect$2,
  render: render_1,
  util: util$2,
  version: version$2
};
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const LEVELS = {
  trace: 0,
  debug: 1,
  info: 2,
  warn: 3,
  error: 4,
  fatal: 5
};
const log$1 = {
  trace: (..._args) => {
  },
  debug: (..._args) => {
  },
  info: (..._args) => {
  },
  warn: (..._args) => {
  },
  error: (..._args) => {
  },
  fatal: (..._args) => {
  }
};
const setLogLevel$1 = function(level = "fatal") {
  let numericLevel = LEVELS.fatal;
  if (typeof level === "string") {
    level = level.toLowerCase();
    if (level in LEVELS) {
      numericLevel = LEVELS[level];
    }
  } else if (typeof level === "number") {
    numericLevel = level;
  }
  log$1.trace = () => {
  };
  log$1.debug = () => {
  };
  log$1.info = () => {
  };
  log$1.warn = () => {
  };
  log$1.error = () => {
  };
  log$1.fatal = () => {
  };
  if (numericLevel <= LEVELS.fatal) {
    log$1.fatal = console.error ? console.error.bind(console, format("FATAL"), "color: orange") : console.log.bind(console, "\x1B[35m", format("FATAL"));
  }
  if (numericLevel <= LEVELS.error) {
    log$1.error = console.error ? console.error.bind(console, format("ERROR"), "color: orange") : console.log.bind(console, "\x1B[31m", format("ERROR"));
  }
  if (numericLevel <= LEVELS.warn) {
    log$1.warn = console.warn ? console.warn.bind(console, format("WARN"), "color: orange") : console.log.bind(console, `\x1B[33m`, format("WARN"));
  }
  if (numericLevel <= LEVELS.info) {
    log$1.info = console.info ? console.info.bind(console, format("INFO"), "color: lightblue") : console.log.bind(console, "\x1B[34m", format("INFO"));
  }
  if (numericLevel <= LEVELS.debug) {
    log$1.debug = console.debug ? console.debug.bind(console, format("DEBUG"), "color: lightgreen") : console.log.bind(console, "\x1B[32m", format("DEBUG"));
  }
  if (numericLevel <= LEVELS.trace) {
    log$1.trace = console.debug ? console.debug.bind(console, format("TRACE"), "color: lightgreen") : console.log.bind(console, "\x1B[32m", format("TRACE"));
  }
};
const format = (level) => {
  const time2 = moment().format("ss.SSS");
  return `%c${time2} : ${level} : `;
};
const getRows = (s2) => {
  if (!s2)
    return [""];
  const str = breakToPlaceholder(s2).replace(/\\n/g, "#br#");
  return str.split("#br#");
};
const removeScript = (txt) => {
  return purify.sanitize(txt);
};
const sanitizeMore = (text2, config2) => {
  var _a2;
  if (((_a2 = config2.flowchart) == null ? void 0 : _a2.htmlLabels) !== false) {
    const level = config2.securityLevel;
    if (level === "antiscript" || level === "strict") {
      text2 = removeScript(text2);
    } else if (level !== "loose") {
      text2 = breakToPlaceholder(text2);
      text2 = text2.replace(/</g, "&lt;").replace(/>/g, "&gt;");
      text2 = text2.replace(/=/g, "&equals;");
      text2 = placeholderToBreak(text2);
    }
  }
  return text2;
};
const sanitizeText$5 = (text2, config2) => {
  if (!text2)
    return text2;
  if (config2.dompurifyConfig) {
    text2 = purify.sanitize(sanitizeMore(text2, config2), config2.dompurifyConfig).toString();
  } else {
    text2 = purify.sanitize(sanitizeMore(text2, config2));
  }
  return text2;
};
const sanitizeTextOrArray = (a2, config2) => {
  if (typeof a2 === "string")
    return sanitizeText$5(a2, config2);
  return a2.flat().map((x2) => sanitizeText$5(x2, config2));
};
const lineBreakRegex = /<br\s*\/?>/gi;
const hasBreaks = (text2) => {
  return lineBreakRegex.test(text2);
};
const splitBreaks = (text2) => {
  return text2.split(lineBreakRegex);
};
const placeholderToBreak = (s2) => {
  return s2.replace(/#br#/g, "<br/>");
};
const breakToPlaceholder = (s2) => {
  return s2.replace(lineBreakRegex, "#br#");
};
const getUrl = (useAbsolute) => {
  let url = "";
  if (useAbsolute) {
    url = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search;
    url = url.replaceAll(/\(/g, "\\(");
    url = url.replaceAll(/\)/g, "\\)");
  }
  return url;
};
const evaluate = (val) => val === false || ["false", "null", "0"].includes(String(val).trim().toLowerCase()) ? false : true;
const parseGenericTypes = function(text2) {
  let cleanedText = text2;
  if (text2.indexOf("~") !== -1) {
    cleanedText = cleanedText.replace(/~([^~].*)/, "<$1");
    cleanedText = cleanedText.replace(/~([^~]*)$/, ">$1");
    return parseGenericTypes(cleanedText);
  } else {
    return cleanedText;
  }
};
const common = {
  getRows,
  sanitizeText: sanitizeText$5,
  sanitizeTextOrArray,
  hasBreaks,
  splitBreaks,
  lineBreakRegex,
  removeScript,
  getUrl,
  evaluate
};
const mkBorder = (col, darkMode) => darkMode ? adjust$2(col, { s: -40, l: 10 }) : adjust$2(col, { s: -40, l: -10 });
const oldAttributeBackgroundColorOdd = "#ffffff";
const oldAttributeBackgroundColorEven = "#f2f2f2";
class Theme$4 {
  constructor() {
    this.background = "#f4f4f4";
    this.darkMode = false;
    this.primaryColor = "#fff4dd";
    this.noteBkgColor = "#fff5ad";
    this.noteTextColor = "#333";
    this.THEME_COLOR_LIMIT = 12;
    this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif';
    this.fontSize = "16px";
  }
  updateColors() {
    this.primaryTextColor = this.primaryTextColor || (this.darkMode ? "#eee" : "#333");
    this.secondaryColor = this.secondaryColor || adjust$2(this.primaryColor, { h: -120 });
    this.tertiaryColor = this.tertiaryColor || adjust$2(this.primaryColor, { h: 180, l: 5 });
    this.primaryBorderColor = this.primaryBorderColor || mkBorder(this.primaryColor, this.darkMode);
    this.secondaryBorderColor = this.secondaryBorderColor || mkBorder(this.secondaryColor, this.darkMode);
    this.tertiaryBorderColor = this.tertiaryBorderColor || mkBorder(this.tertiaryColor, this.darkMode);
    this.noteBorderColor = this.noteBorderColor || mkBorder(this.noteBkgColor, this.darkMode);
    this.noteBkgColor = this.noteBkgColor || "#fff5ad";
    this.noteTextColor = this.noteTextColor || "#333";
    this.secondaryTextColor = this.secondaryTextColor || invert$1(this.secondaryColor);
    this.tertiaryTextColor = this.tertiaryTextColor || invert$1(this.tertiaryColor);
    this.lineColor = this.lineColor || invert$1(this.background);
    this.textColor = this.textColor || this.primaryTextColor;
    this.nodeBkg = this.nodeBkg || this.primaryColor;
    this.mainBkg = this.mainBkg || this.primaryColor;
    this.nodeBorder = this.nodeBorder || this.primaryBorderColor;
    this.clusterBkg = this.clusterBkg || this.tertiaryColor;
    this.clusterBorder = this.clusterBorder || this.tertiaryBorderColor;
    this.defaultLinkColor = this.defaultLinkColor || this.lineColor;
    this.titleColor = this.titleColor || this.tertiaryTextColor;
    this.edgeLabelBackground = this.edgeLabelBackground || (this.darkMode ? darken$1(this.secondaryColor, 30) : this.secondaryColor);
    this.nodeTextColor = this.nodeTextColor || this.primaryTextColor;
    this.actorBorder = this.actorBorder || this.primaryBorderColor;
    this.actorBkg = this.actorBkg || this.mainBkg;
    this.actorTextColor = this.actorTextColor || this.primaryTextColor;
    this.actorLineColor = this.actorLineColor || "grey";
    this.labelBoxBkgColor = this.labelBoxBkgColor || this.actorBkg;
    this.signalColor = this.signalColor || this.textColor;
    this.signalTextColor = this.signalTextColor || this.textColor;
    this.labelBoxBorderColor = this.labelBoxBorderColor || this.actorBorder;
    this.labelTextColor = this.labelTextColor || this.actorTextColor;
    this.loopTextColor = this.loopTextColor || this.actorTextColor;
    this.activationBorderColor = this.activationBorderColor || darken$1(this.secondaryColor, 10);
    this.activationBkgColor = this.activationBkgColor || this.secondaryColor;
    this.sequenceNumberColor = this.sequenceNumberColor || invert$1(this.lineColor);
    this.sectionBkgColor = this.sectionBkgColor || this.tertiaryColor;
    this.altSectionBkgColor = this.altSectionBkgColor || "white";
    this.sectionBkgColor = this.sectionBkgColor || this.secondaryColor;
    this.sectionBkgColor2 = this.sectionBkgColor2 || this.primaryColor;
    this.excludeBkgColor = this.excludeBkgColor || "#eeeeee";
    this.taskBorderColor = this.taskBorderColor || this.primaryBorderColor;
    this.taskBkgColor = this.taskBkgColor || this.primaryColor;
    this.activeTaskBorderColor = this.activeTaskBorderColor || this.primaryColor;
    this.activeTaskBkgColor = this.activeTaskBkgColor || lighten$1(this.primaryColor, 23);
    this.gridColor = this.gridColor || "lightgrey";
    this.doneTaskBkgColor = this.doneTaskBkgColor || "lightgrey";
    this.doneTaskBorderColor = this.doneTaskBorderColor || "grey";
    this.critBorderColor = this.critBorderColor || "#ff8888";
    this.critBkgColor = this.critBkgColor || "red";
    this.todayLineColor = this.todayLineColor || "red";
    this.taskTextColor = this.taskTextColor || this.textColor;
    this.taskTextOutsideColor = this.taskTextOutsideColor || this.textColor;
    this.taskTextLightColor = this.taskTextLightColor || this.textColor;
    this.taskTextColor = this.taskTextColor || this.primaryTextColor;
    this.taskTextDarkColor = this.taskTextDarkColor || this.textColor;
    this.taskTextClickableColor = this.taskTextClickableColor || "#003163";
    this.personBorder = this.personBorder || this.primaryBorderColor;
    this.personBkg = this.personBkg || this.mainBkg;
    this.transitionColor = this.transitionColor || this.lineColor;
    this.transitionLabelColor = this.transitionLabelColor || this.textColor;
    this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor;
    this.stateBkg = this.stateBkg || this.mainBkg;
    this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg;
    this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor;
    this.altBackground = this.altBackground || this.tertiaryColor;
    this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg;
    this.compositeBorder = this.compositeBorder || this.nodeBorder;
    this.innerEndBackground = this.nodeBorder;
    this.errorBkgColor = this.errorBkgColor || this.tertiaryColor;
    this.errorTextColor = this.errorTextColor || this.tertiaryTextColor;
    this.transitionColor = this.transitionColor || this.lineColor;
    this.specialStateColor = this.lineColor;
    this.cScale0 = this.cScale0 || this.primaryColor;
    this.cScale1 = this.cScale1 || this.secondaryColor;
    this.cScale2 = this.cScale2 || this.tertiaryColor;
    this.cScale3 = this.cScale3 || adjust$2(this.primaryColor, { h: 30 });
    this.cScale4 = this.cScale4 || adjust$2(this.primaryColor, { h: 60 });
    this.cScale5 = this.cScale5 || adjust$2(this.primaryColor, { h: 90 });
    this.cScale6 = this.cScale6 || adjust$2(this.primaryColor, { h: 120 });
    this.cScale7 = this.cScale7 || adjust$2(this.primaryColor, { h: 150 });
    this.cScale8 = this.cScale8 || adjust$2(this.primaryColor, { h: 210, l: 150 });
    this.cScale9 = this.cScale9 || adjust$2(this.primaryColor, { h: 270 });
    this.cScale10 = this.cScale10 || adjust$2(this.primaryColor, { h: 300 });
    this.cScale11 = this.cScale11 || adjust$2(this.primaryColor, { h: 330 });
    if (this.darkMode) {
      for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
        this["cScale" + i] = darken$1(this["cScale" + i], 75);
      }
    } else {
      for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
        this["cScale" + i] = darken$1(this["cScale" + i], 25);
      }
    }
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScaleInv" + i] = this["cScaleInv" + i] || invert$1(this["cScale" + i]);
    }
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      if (this.darkMode) {
        this["cScalePeer" + i] = this["cScalePeer" + i] || lighten$1(this["cScale" + i], 10);
      } else {
        this["cScalePeer" + i] = this["cScalePeer" + i] || darken$1(this["cScale" + i], 10);
      }
    }
    this.scaleLabelColor = this.scaleLabelColor || this.labelTextColor;
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScaleLabel" + i] = this["cScaleLabel" + i] || this.scaleLabelColor;
    }
    this.classText = this.classText || this.textColor;
    this.fillType0 = this.fillType0 || this.primaryColor;
    this.fillType1 = this.fillType1 || this.secondaryColor;
    this.fillType2 = this.fillType2 || adjust$2(this.primaryColor, { h: 64 });
    this.fillType3 = this.fillType3 || adjust$2(this.secondaryColor, { h: 64 });
    this.fillType4 = this.fillType4 || adjust$2(this.primaryColor, { h: -64 });
    this.fillType5 = this.fillType5 || adjust$2(this.secondaryColor, { h: -64 });
    this.fillType6 = this.fillType6 || adjust$2(this.primaryColor, { h: 128 });
    this.fillType7 = this.fillType7 || adjust$2(this.secondaryColor, { h: 128 });
    this.pie1 = this.pie1 || this.primaryColor;
    this.pie2 = this.pie2 || this.secondaryColor;
    this.pie3 = this.pie3 || this.tertiaryColor;
    this.pie4 = this.pie4 || adjust$2(this.primaryColor, { l: -10 });
    this.pie5 = this.pie5 || adjust$2(this.secondaryColor, { l: -10 });
    this.pie6 = this.pie6 || adjust$2(this.tertiaryColor, { l: -10 });
    this.pie7 = this.pie7 || adjust$2(this.primaryColor, { h: 60, l: -10 });
    this.pie8 = this.pie8 || adjust$2(this.primaryColor, { h: -60, l: -10 });
    this.pie9 = this.pie9 || adjust$2(this.primaryColor, { h: 120, l: 0 });
    this.pie10 = this.pie10 || adjust$2(this.primaryColor, { h: 60, l: -20 });
    this.pie11 = this.pie11 || adjust$2(this.primaryColor, { h: -60, l: -20 });
    this.pie12 = this.pie12 || adjust$2(this.primaryColor, { h: 120, l: -10 });
    this.pieTitleTextSize = this.pieTitleTextSize || "25px";
    this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor;
    this.pieSectionTextSize = this.pieSectionTextSize || "17px";
    this.pieSectionTextColor = this.pieSectionTextColor || this.textColor;
    this.pieLegendTextSize = this.pieLegendTextSize || "17px";
    this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor;
    this.pieStrokeColor = this.pieStrokeColor || "black";
    this.pieStrokeWidth = this.pieStrokeWidth || "2px";
    this.pieOpacity = this.pieOpacity || "0.7";
    this.requirementBackground = this.requirementBackground || this.primaryColor;
    this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor;
    this.requirementBorderSize = this.requirementBorderSize || this.primaryBorderColor;
    this.requirementTextColor = this.requirementTextColor || this.primaryTextColor;
    this.relationColor = this.relationColor || this.lineColor;
    this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? darken$1(this.secondaryColor, 30) : this.secondaryColor);
    this.relationLabelColor = this.relationLabelColor || this.actorTextColor;
    this.git0 = this.git0 || this.primaryColor;
    this.git1 = this.git1 || this.secondaryColor;
    this.git2 = this.git2 || this.tertiaryColor;
    this.git3 = this.git3 || adjust$2(this.primaryColor, { h: -30 });
    this.git4 = this.git4 || adjust$2(this.primaryColor, { h: -60 });
    this.git5 = this.git5 || adjust$2(this.primaryColor, { h: -90 });
    this.git6 = this.git6 || adjust$2(this.primaryColor, { h: 60 });
    this.git7 = this.git7 || adjust$2(this.primaryColor, { h: 120 });
    if (this.darkMode) {
      this.git0 = lighten$1(this.git0, 25);
      this.git1 = lighten$1(this.git1, 25);
      this.git2 = lighten$1(this.git2, 25);
      this.git3 = lighten$1(this.git3, 25);
      this.git4 = lighten$1(this.git4, 25);
      this.git5 = lighten$1(this.git5, 25);
      this.git6 = lighten$1(this.git6, 25);
      this.git7 = lighten$1(this.git7, 25);
    } else {
      this.git0 = darken$1(this.git0, 25);
      this.git1 = darken$1(this.git1, 25);
      this.git2 = darken$1(this.git2, 25);
      this.git3 = darken$1(this.git3, 25);
      this.git4 = darken$1(this.git4, 25);
      this.git5 = darken$1(this.git5, 25);
      this.git6 = darken$1(this.git6, 25);
      this.git7 = darken$1(this.git7, 25);
    }
    this.gitInv0 = this.gitInv0 || invert$1(this.git0);
    this.gitInv1 = this.gitInv1 || invert$1(this.git1);
    this.gitInv2 = this.gitInv2 || invert$1(this.git2);
    this.gitInv3 = this.gitInv3 || invert$1(this.git3);
    this.gitInv4 = this.gitInv4 || invert$1(this.git4);
    this.gitInv5 = this.gitInv5 || invert$1(this.git5);
    this.gitInv6 = this.gitInv6 || invert$1(this.git6);
    this.gitInv7 = this.gitInv7 || invert$1(this.git7);
    this.branchLabelColor = this.branchLabelColor || (this.darkMode ? "black" : this.labelTextColor);
    this.gitBranchLabel0 = this.gitBranchLabel0 || this.branchLabelColor;
    this.gitBranchLabel1 = this.gitBranchLabel1 || this.branchLabelColor;
    this.gitBranchLabel2 = this.gitBranchLabel2 || this.branchLabelColor;
    this.gitBranchLabel3 = this.gitBranchLabel3 || this.branchLabelColor;
    this.gitBranchLabel4 = this.gitBranchLabel4 || this.branchLabelColor;
    this.gitBranchLabel5 = this.gitBranchLabel5 || this.branchLabelColor;
    this.gitBranchLabel6 = this.gitBranchLabel6 || this.branchLabelColor;
    this.gitBranchLabel7 = this.gitBranchLabel7 || this.branchLabelColor;
    this.tagLabelColor = this.tagLabelColor || this.primaryTextColor;
    this.tagLabelBackground = this.tagLabelBackground || this.primaryColor;
    this.tagLabelBorder = this.tagBorder || this.primaryBorderColor;
    this.tagLabelFontSize = this.tagLabelFontSize || "10px";
    this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor;
    this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor;
    this.commitLabelFontSize = this.commitLabelFontSize || "10px";
    this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || oldAttributeBackgroundColorOdd;
    this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || oldAttributeBackgroundColorEven;
  }
  calculate(overrides) {
    if (typeof overrides !== "object") {
      this.updateColors();
      return;
    }
    const keys2 = Object.keys(overrides);
    keys2.forEach((k2) => {
      this[k2] = overrides[k2];
    });
    this.updateColors();
    keys2.forEach((k2) => {
      this[k2] = overrides[k2];
    });
  }
}
const getThemeVariables$4 = (userOverrides) => {
  const theme2 = new Theme$4();
  theme2.calculate(userOverrides);
  return theme2;
};
class Theme$3 {
  constructor() {
    this.background = "#333";
    this.primaryColor = "#1f2020";
    this.secondaryColor = lighten$1(this.primaryColor, 16);
    this.tertiaryColor = adjust$2(this.primaryColor, { h: -160 });
    this.primaryBorderColor = invert$1(this.background);
    this.secondaryBorderColor = mkBorder(this.secondaryColor, this.darkMode);
    this.tertiaryBorderColor = mkBorder(this.tertiaryColor, this.darkMode);
    this.primaryTextColor = invert$1(this.primaryColor);
    this.secondaryTextColor = invert$1(this.secondaryColor);
    this.tertiaryTextColor = invert$1(this.tertiaryColor);
    this.lineColor = invert$1(this.background);
    this.textColor = invert$1(this.background);
    this.mainBkg = "#1f2020";
    this.secondBkg = "calculated";
    this.mainContrastColor = "lightgrey";
    this.darkTextColor = lighten$1(invert$1("#323D47"), 10);
    this.lineColor = "calculated";
    this.border1 = "#81B1DB";
    this.border2 = rgba$2(255, 255, 255, 0.25);
    this.arrowheadColor = "calculated";
    this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif';
    this.fontSize = "16px";
    this.labelBackground = "#181818";
    this.textColor = "#ccc";
    this.THEME_COLOR_LIMIT = 12;
    this.nodeBkg = "calculated";
    this.nodeBorder = "calculated";
    this.clusterBkg = "calculated";
    this.clusterBorder = "calculated";
    this.defaultLinkColor = "calculated";
    this.titleColor = "#F9FFFE";
    this.edgeLabelBackground = "calculated";
    this.actorBorder = "calculated";
    this.actorBkg = "calculated";
    this.actorTextColor = "calculated";
    this.actorLineColor = "calculated";
    this.signalColor = "calculated";
    this.signalTextColor = "calculated";
    this.labelBoxBkgColor = "calculated";
    this.labelBoxBorderColor = "calculated";
    this.labelTextColor = "calculated";
    this.loopTextColor = "calculated";
    this.noteBorderColor = "calculated";
    this.noteBkgColor = "#fff5ad";
    this.noteTextColor = "calculated";
    this.activationBorderColor = "calculated";
    this.activationBkgColor = "calculated";
    this.sequenceNumberColor = "black";
    this.sectionBkgColor = darken$1("#EAE8D9", 30);
    this.altSectionBkgColor = "calculated";
    this.sectionBkgColor2 = "#EAE8D9";
    this.taskBorderColor = rgba$2(255, 255, 255, 70);
    this.taskBkgColor = "calculated";
    this.taskTextColor = "calculated";
    this.taskTextLightColor = "calculated";
    this.taskTextOutsideColor = "calculated";
    this.taskTextClickableColor = "#003163";
    this.activeTaskBorderColor = rgba$2(255, 255, 255, 50);
    this.activeTaskBkgColor = "#81B1DB";
    this.gridColor = "calculated";
    this.doneTaskBkgColor = "calculated";
    this.doneTaskBorderColor = "grey";
    this.critBorderColor = "#E83737";
    this.critBkgColor = "#E83737";
    this.taskTextDarkColor = "calculated";
    this.todayLineColor = "#DB5757";
    this.personBorder = "calculated";
    this.personBkg = "calculated";
    this.labelColor = "calculated";
    this.errorBkgColor = "#a44141";
    this.errorTextColor = "#ddd";
  }
  updateColors() {
    this.secondBkg = lighten$1(this.mainBkg, 16);
    this.lineColor = this.mainContrastColor;
    this.arrowheadColor = this.mainContrastColor;
    this.nodeBkg = this.mainBkg;
    this.nodeBorder = this.border1;
    this.clusterBkg = this.secondBkg;
    this.clusterBorder = this.border2;
    this.defaultLinkColor = this.lineColor;
    this.edgeLabelBackground = lighten$1(this.labelBackground, 25);
    this.actorBorder = this.border1;
    this.actorBkg = this.mainBkg;
    this.actorTextColor = this.mainContrastColor;
    this.actorLineColor = this.mainContrastColor;
    this.signalColor = this.mainContrastColor;
    this.signalTextColor = this.mainContrastColor;
    this.labelBoxBkgColor = this.actorBkg;
    this.labelBoxBorderColor = this.actorBorder;
    this.labelTextColor = this.mainContrastColor;
    this.loopTextColor = this.mainContrastColor;
    this.noteBorderColor = this.secondaryBorderColor;
    this.noteBkgColor = this.secondBkg;
    this.noteTextColor = this.secondaryTextColor;
    this.activationBorderColor = this.border1;
    this.activationBkgColor = this.secondBkg;
    this.altSectionBkgColor = this.background;
    this.taskBkgColor = lighten$1(this.mainBkg, 23);
    this.taskTextColor = this.darkTextColor;
    this.taskTextLightColor = this.mainContrastColor;
    this.taskTextOutsideColor = this.taskTextLightColor;
    this.gridColor = this.mainContrastColor;
    this.doneTaskBkgColor = this.mainContrastColor;
    this.taskTextDarkColor = this.darkTextColor;
    this.transitionColor = this.transitionColor || this.lineColor;
    this.transitionLabelColor = this.transitionLabelColor || this.textColor;
    this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor;
    this.stateBkg = this.stateBkg || this.mainBkg;
    this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg;
    this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor;
    this.altBackground = this.altBackground || "#555";
    this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg;
    this.compositeBorder = this.compositeBorder || this.nodeBorder;
    this.innerEndBackground = this.primaryBorderColor;
    this.specialStateColor = "#f4f4f4";
    this.errorBkgColor = this.errorBkgColor || this.tertiaryColor;
    this.errorTextColor = this.errorTextColor || this.tertiaryTextColor;
    this.fillType0 = this.primaryColor;
    this.fillType1 = this.secondaryColor;
    this.fillType2 = adjust$2(this.primaryColor, { h: 64 });
    this.fillType3 = adjust$2(this.secondaryColor, { h: 64 });
    this.fillType4 = adjust$2(this.primaryColor, { h: -64 });
    this.fillType5 = adjust$2(this.secondaryColor, { h: -64 });
    this.fillType6 = adjust$2(this.primaryColor, { h: 128 });
    this.fillType7 = adjust$2(this.secondaryColor, { h: 128 });
    this.cScale1 = this.cScale1 || "#0b0000";
    this.cScale2 = this.cScale2 || "#4d1037";
    this.cScale3 = this.cScale3 || "#3f5258";
    this.cScale4 = this.cScale4 || "#4f2f1b";
    this.cScale5 = this.cScale5 || "#6e0a0a";
    this.cScale6 = this.cScale6 || "#3b0048";
    this.cScale7 = this.cScale7 || "#995a01";
    this.cScale8 = this.cScale8 || "#154706";
    this.cScale9 = this.cScale9 || "#161722";
    this.cScale10 = this.cScale10 || "#00296f";
    this.cScale11 = this.cScale11 || "#01629c";
    this.cScale12 = this.cScale12 || "#010029";
    this.cScale0 = this.cScale0 || this.primaryColor;
    this.cScale1 = this.cScale1 || this.secondaryColor;
    this.cScale2 = this.cScale2 || this.tertiaryColor;
    this.cScale3 = this.cScale3 || adjust$2(this.primaryColor, { h: 30 });
    this.cScale4 = this.cScale4 || adjust$2(this.primaryColor, { h: 60 });
    this.cScale5 = this.cScale5 || adjust$2(this.primaryColor, { h: 90 });
    this.cScale6 = this.cScale6 || adjust$2(this.primaryColor, { h: 120 });
    this.cScale7 = this.cScale7 || adjust$2(this.primaryColor, { h: 150 });
    this.cScale8 = this.cScale8 || adjust$2(this.primaryColor, { h: 210 });
    this.cScale9 = this.cScale9 || adjust$2(this.primaryColor, { h: 270 });
    this.cScale10 = this.cScale10 || adjust$2(this.primaryColor, { h: 300 });
    this.cScale11 = this.cScale11 || adjust$2(this.primaryColor, { h: 330 });
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScaleInv" + i] = this["cScaleInv" + i] || invert$1(this["cScale" + i]);
    }
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScalePeer" + i] = this["cScalePeer" + i] || lighten$1(this["cScale" + i], 10);
    }
    this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? "black" : this.labelTextColor);
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScaleLabel" + i] = this["cScaleLabel" + i] || this.scaleLabelColor;
    }
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["pie" + i] = this["cScale" + i];
    }
    this.pieTitleTextSize = this.pieTitleTextSize || "25px";
    this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor;
    this.pieSectionTextSize = this.pieSectionTextSize || "17px";
    this.pieSectionTextColor = this.pieSectionTextColor || this.textColor;
    this.pieLegendTextSize = this.pieLegendTextSize || "17px";
    this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor;
    this.pieStrokeColor = this.pieStrokeColor || "black";
    this.pieStrokeWidth = this.pieStrokeWidth || "2px";
    this.pieOpacity = this.pieOpacity || "0.7";
    this.classText = this.primaryTextColor;
    this.requirementBackground = this.requirementBackground || this.primaryColor;
    this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor;
    this.requirementBorderSize = this.requirementBorderSize || this.primaryBorderColor;
    this.requirementTextColor = this.requirementTextColor || this.primaryTextColor;
    this.relationColor = this.relationColor || this.lineColor;
    this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? darken$1(this.secondaryColor, 30) : this.secondaryColor);
    this.relationLabelColor = this.relationLabelColor || this.actorTextColor;
    this.git0 = lighten$1(this.secondaryColor, 20);
    this.git1 = lighten$1(this.pie2 || this.secondaryColor, 20);
    this.git2 = lighten$1(this.pie3 || this.tertiaryColor, 20);
    this.git3 = lighten$1(this.pie4 || adjust$2(this.primaryColor, { h: -30 }), 20);
    this.git4 = lighten$1(this.pie5 || adjust$2(this.primaryColor, { h: -60 }), 20);
    this.git5 = lighten$1(this.pie6 || adjust$2(this.primaryColor, { h: -90 }), 10);
    this.git6 = lighten$1(this.pie7 || adjust$2(this.primaryColor, { h: 60 }), 10);
    this.git7 = lighten$1(this.pie8 || adjust$2(this.primaryColor, { h: 120 }), 20);
    this.gitInv0 = this.gitInv0 || invert$1(this.git0);
    this.gitInv1 = this.gitInv1 || invert$1(this.git1);
    this.gitInv2 = this.gitInv2 || invert$1(this.git2);
    this.gitInv3 = this.gitInv3 || invert$1(this.git3);
    this.gitInv4 = this.gitInv4 || invert$1(this.git4);
    this.gitInv5 = this.gitInv5 || invert$1(this.git5);
    this.gitInv6 = this.gitInv6 || invert$1(this.git6);
    this.gitInv7 = this.gitInv7 || invert$1(this.git7);
    this.tagLabelColor = this.tagLabelColor || this.primaryTextColor;
    this.tagLabelBackground = this.tagLabelBackground || this.primaryColor;
    this.tagLabelBorder = this.tagBorder || this.primaryBorderColor;
    this.tagLabelFontSize = this.tagLabelFontSize || "10px";
    this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor;
    this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor;
    this.commitLabelFontSize = this.commitLabelFontSize || "10px";
    this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || lighten$1(this.background, 12);
    this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || lighten$1(this.background, 2);
  }
  calculate(overrides) {
    if (typeof overrides !== "object") {
      this.updateColors();
      return;
    }
    const keys2 = Object.keys(overrides);
    keys2.forEach((k2) => {
      this[k2] = overrides[k2];
    });
    this.updateColors();
    keys2.forEach((k2) => {
      this[k2] = overrides[k2];
    });
  }
}
const getThemeVariables$3 = (userOverrides) => {
  const theme2 = new Theme$3();
  theme2.calculate(userOverrides);
  return theme2;
};
class Theme$2 {
  constructor() {
    this.background = "#f4f4f4";
    this.primaryColor = "#ECECFF";
    this.secondaryColor = adjust$2(this.primaryColor, { h: 120 });
    this.secondaryColor = "#ffffde";
    this.tertiaryColor = adjust$2(this.primaryColor, { h: -160 });
    this.primaryBorderColor = mkBorder(this.primaryColor, this.darkMode);
    this.secondaryBorderColor = mkBorder(this.secondaryColor, this.darkMode);
    this.tertiaryBorderColor = mkBorder(this.tertiaryColor, this.darkMode);
    this.primaryTextColor = invert$1(this.primaryColor);
    this.secondaryTextColor = invert$1(this.secondaryColor);
    this.tertiaryTextColor = invert$1(this.tertiaryColor);
    this.lineColor = invert$1(this.background);
    this.textColor = invert$1(this.background);
    this.background = "white";
    this.mainBkg = "#ECECFF";
    this.secondBkg = "#ffffde";
    this.lineColor = "#333333";
    this.border1 = "#9370DB";
    this.border2 = "#aaaa33";
    this.arrowheadColor = "#333333";
    this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif';
    this.fontSize = "16px";
    this.labelBackground = "#e8e8e8";
    this.textColor = "#333";
    this.THEME_COLOR_LIMIT = 12;
    this.nodeBkg = "calculated";
    this.nodeBorder = "calculated";
    this.clusterBkg = "calculated";
    this.clusterBorder = "calculated";
    this.defaultLinkColor = "calculated";
    this.titleColor = "calculated";
    this.edgeLabelBackground = "calculated";
    this.actorBorder = "calculated";
    this.actorBkg = "calculated";
    this.actorTextColor = "black";
    this.actorLineColor = "grey";
    this.signalColor = "calculated";
    this.signalTextColor = "calculated";
    this.labelBoxBkgColor = "calculated";
    this.labelBoxBorderColor = "calculated";
    this.labelTextColor = "calculated";
    this.loopTextColor = "calculated";
    this.noteBorderColor = "calculated";
    this.noteBkgColor = "#fff5ad";
    this.noteTextColor = "calculated";
    this.activationBorderColor = "#666";
    this.activationBkgColor = "#f4f4f4";
    this.sequenceNumberColor = "white";
    this.sectionBkgColor = "calculated";
    this.altSectionBkgColor = "calculated";
    this.sectionBkgColor2 = "calculated";
    this.excludeBkgColor = "#eeeeee";
    this.taskBorderColor = "calculated";
    this.taskBkgColor = "calculated";
    this.taskTextLightColor = "calculated";
    this.taskTextColor = this.taskTextLightColor;
    this.taskTextDarkColor = "calculated";
    this.taskTextOutsideColor = this.taskTextDarkColor;
    this.taskTextClickableColor = "calculated";
    this.activeTaskBorderColor = "calculated";
    this.activeTaskBkgColor = "calculated";
    this.gridColor = "calculated";
    this.doneTaskBkgColor = "calculated";
    this.doneTaskBorderColor = "calculated";
    this.critBorderColor = "calculated";
    this.critBkgColor = "calculated";
    this.todayLineColor = "calculated";
    this.sectionBkgColor = rgba$2(102, 102, 255, 0.49);
    this.altSectionBkgColor = "white";
    this.sectionBkgColor2 = "#fff400";
    this.taskBorderColor = "#534fbc";
    this.taskBkgColor = "#8a90dd";
    this.taskTextLightColor = "white";
    this.taskTextColor = "calculated";
    this.taskTextDarkColor = "black";
    this.taskTextOutsideColor = "calculated";
    this.taskTextClickableColor = "#003163";
    this.activeTaskBorderColor = "#534fbc";
    this.activeTaskBkgColor = "#bfc7ff";
    this.gridColor = "lightgrey";
    this.doneTaskBkgColor = "lightgrey";
    this.doneTaskBorderColor = "grey";
    this.critBorderColor = "#ff8888";
    this.critBkgColor = "red";
    this.todayLineColor = "red";
    this.personBorder = "calculated";
    this.personBkg = "calculated";
    this.labelColor = "black";
    this.errorBkgColor = "#552222";
    this.errorTextColor = "#552222";
    this.updateColors();
  }
  updateColors() {
    this.cScale0 = this.cScale0 || this.primaryColor;
    this.cScale1 = this.cScale1 || this.secondaryColor;
    this.cScale2 = this.cScale2 || this.tertiaryColor;
    this.cScale3 = this.cScale3 || adjust$2(this.primaryColor, { h: 30 });
    this.cScale4 = this.cScale4 || adjust$2(this.primaryColor, { h: 60 });
    this.cScale5 = this.cScale5 || adjust$2(this.primaryColor, { h: 90 });
    this.cScale6 = this.cScale6 || adjust$2(this.primaryColor, { h: 120 });
    this.cScale7 = this.cScale7 || adjust$2(this.primaryColor, { h: 150 });
    this.cScale8 = this.cScale8 || adjust$2(this.primaryColor, { h: 210 });
    this.cScale9 = this.cScale9 || adjust$2(this.primaryColor, { h: 270 });
    this.cScale10 = this.cScale10 || adjust$2(this.primaryColor, { h: 300 });
    this.cScale11 = this.cScale11 || adjust$2(this.primaryColor, { h: 330 });
    this["cScalePeer" + 1] = this["cScalePeer" + 1] || darken$1(this.secondaryColor, 45);
    this["cScalePeer" + 2] = this["cScalePeer" + 2] || darken$1(this.tertiaryColor, 40);
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScale" + i] = darken$1(this["cScale" + i], 10);
      this["cScalePeer" + i] = this["cScalePeer" + i] || darken$1(this["cScale" + i], 25);
    }
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScaleInv" + i] = this["cScaleInv" + i] || adjust$2(this["cScale" + i], { h: 180 });
    }
    this.scaleLabelColor = this.scaleLabelColor !== "calculated" && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor;
    if (this.labelTextColor !== "calculated") {
      this.cScaleLabel0 = this.cScaleLabel0 || invert$1(this.labelTextColor);
      this.cScaleLabel3 = this.cScaleLabel3 || invert$1(this.labelTextColor);
      for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
        this["cScaleLabel" + i] = this["cScaleLabel" + i] || this.labelTextColor;
      }
    }
    this.nodeBkg = this.mainBkg;
    this.nodeBorder = this.border1;
    this.clusterBkg = this.secondBkg;
    this.clusterBorder = this.border2;
    this.defaultLinkColor = this.lineColor;
    this.titleColor = this.textColor;
    this.edgeLabelBackground = this.labelBackground;
    this.actorBorder = lighten$1(this.border1, 23);
    this.actorBkg = this.mainBkg;
    this.labelBoxBkgColor = this.actorBkg;
    this.signalColor = this.textColor;
    this.signalTextColor = this.textColor;
    this.labelBoxBorderColor = this.actorBorder;
    this.labelTextColor = this.actorTextColor;
    this.loopTextColor = this.actorTextColor;
    this.noteBorderColor = this.border2;
    this.noteTextColor = this.actorTextColor;
    this.taskTextColor = this.taskTextLightColor;
    this.taskTextOutsideColor = this.taskTextDarkColor;
    this.transitionColor = this.transitionColor || this.lineColor;
    this.transitionLabelColor = this.transitionLabelColor || this.textColor;
    this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor;
    this.stateBkg = this.stateBkg || this.mainBkg;
    this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg;
    this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor;
    this.altBackground = this.altBackground || "#f0f0f0";
    this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg;
    this.compositeBorder = this.compositeBorder || this.nodeBorder;
    this.innerEndBackground = this.nodeBorder;
    this.specialStateColor = this.lineColor;
    this.errorBkgColor = this.errorBkgColor || this.tertiaryColor;
    this.errorTextColor = this.errorTextColor || this.tertiaryTextColor;
    this.transitionColor = this.transitionColor || this.lineColor;
    this.classText = this.primaryTextColor;
    this.fillType0 = this.primaryColor;
    this.fillType1 = this.secondaryColor;
    this.fillType2 = adjust$2(this.primaryColor, { h: 64 });
    this.fillType3 = adjust$2(this.secondaryColor, { h: 64 });
    this.fillType4 = adjust$2(this.primaryColor, { h: -64 });
    this.fillType5 = adjust$2(this.secondaryColor, { h: -64 });
    this.fillType6 = adjust$2(this.primaryColor, { h: 128 });
    this.fillType7 = adjust$2(this.secondaryColor, { h: 128 });
    this.pie1 = this.pie1 || this.primaryColor;
    this.pie2 = this.pie2 || this.secondaryColor;
    this.pie3 = this.pie3 || adjust$2(this.tertiaryColor, { l: -40 });
    this.pie4 = this.pie4 || adjust$2(this.primaryColor, { l: -10 });
    this.pie5 = this.pie5 || adjust$2(this.secondaryColor, { l: -30 });
    this.pie6 = this.pie6 || adjust$2(this.tertiaryColor, { l: -20 });
    this.pie7 = this.pie7 || adjust$2(this.primaryColor, { h: 60, l: -20 });
    this.pie8 = this.pie8 || adjust$2(this.primaryColor, { h: -60, l: -40 });
    this.pie9 = this.pie9 || adjust$2(this.primaryColor, { h: 120, l: -40 });
    this.pie10 = this.pie10 || adjust$2(this.primaryColor, { h: 60, l: -40 });
    this.pie11 = this.pie11 || adjust$2(this.primaryColor, { h: -90, l: -40 });
    this.pie12 = this.pie12 || adjust$2(this.primaryColor, { h: 120, l: -30 });
    this.pieTitleTextSize = this.pieTitleTextSize || "25px";
    this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor;
    this.pieSectionTextSize = this.pieSectionTextSize || "17px";
    this.pieSectionTextColor = this.pieSectionTextColor || this.textColor;
    this.pieLegendTextSize = this.pieLegendTextSize || "17px";
    this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor;
    this.pieStrokeColor = this.pieStrokeColor || "black";
    this.pieStrokeWidth = this.pieStrokeWidth || "2px";
    this.pieOpacity = this.pieOpacity || "0.7";
    this.requirementBackground = this.requirementBackground || this.primaryColor;
    this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor;
    this.requirementBorderSize = this.requirementBorderSize || this.primaryBorderColor;
    this.requirementTextColor = this.requirementTextColor || this.primaryTextColor;
    this.relationColor = this.relationColor || this.lineColor;
    this.relationLabelBackground = this.relationLabelBackground || this.labelBackground;
    this.relationLabelColor = this.relationLabelColor || this.actorTextColor;
    this.git0 = this.git0 || this.primaryColor;
    this.git1 = this.git1 || this.secondaryColor;
    this.git2 = this.git2 || this.tertiaryColor;
    this.git3 = this.git3 || adjust$2(this.primaryColor, { h: -30 });
    this.git4 = this.git4 || adjust$2(this.primaryColor, { h: -60 });
    this.git5 = this.git5 || adjust$2(this.primaryColor, { h: -90 });
    this.git6 = this.git6 || adjust$2(this.primaryColor, { h: 60 });
    this.git7 = this.git7 || adjust$2(this.primaryColor, { h: 120 });
    if (this.darkMode) {
      this.git0 = lighten$1(this.git0, 25);
      this.git1 = lighten$1(this.git1, 25);
      this.git2 = lighten$1(this.git2, 25);
      this.git3 = lighten$1(this.git3, 25);
      this.git4 = lighten$1(this.git4, 25);
      this.git5 = lighten$1(this.git5, 25);
      this.git6 = lighten$1(this.git6, 25);
      this.git7 = lighten$1(this.git7, 25);
    } else {
      this.git0 = darken$1(this.git0, 25);
      this.git1 = darken$1(this.git1, 25);
      this.git2 = darken$1(this.git2, 25);
      this.git3 = darken$1(this.git3, 25);
      this.git4 = darken$1(this.git4, 25);
      this.git5 = darken$1(this.git5, 25);
      this.git6 = darken$1(this.git6, 25);
      this.git7 = darken$1(this.git7, 25);
    }
    this.gitInv0 = this.gitInv0 || darken$1(invert$1(this.git0), 25);
    this.gitInv1 = this.gitInv1 || invert$1(this.git1);
    this.gitInv2 = this.gitInv2 || invert$1(this.git2);
    this.gitInv3 = this.gitInv3 || invert$1(this.git3);
    this.gitInv4 = this.gitInv4 || invert$1(this.git4);
    this.gitInv5 = this.gitInv5 || invert$1(this.git5);
    this.gitInv6 = this.gitInv6 || invert$1(this.git6);
    this.gitInv7 = this.gitInv7 || invert$1(this.git7);
    this.gitBranchLabel0 = this.gitBranchLabel0 || invert$1(this.labelTextColor);
    this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor;
    this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor;
    this.gitBranchLabel3 = this.gitBranchLabel3 || invert$1(this.labelTextColor);
    this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor;
    this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor;
    this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor;
    this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor;
    this.tagLabelColor = this.tagLabelColor || this.primaryTextColor;
    this.tagLabelBackground = this.tagLabelBackground || this.primaryColor;
    this.tagLabelBorder = this.tagBorder || this.primaryBorderColor;
    this.tagLabelFontSize = this.tagLabelFontSize || "10px";
    this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor;
    this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor;
    this.commitLabelFontSize = this.commitLabelFontSize || "10px";
    this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || oldAttributeBackgroundColorOdd;
    this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || oldAttributeBackgroundColorEven;
  }
  calculate(overrides) {
    if (typeof overrides !== "object") {
      this.updateColors();
      return;
    }
    const keys2 = Object.keys(overrides);
    keys2.forEach((k2) => {
      this[k2] = overrides[k2];
    });
    this.updateColors();
    keys2.forEach((k2) => {
      this[k2] = overrides[k2];
    });
  }
}
const getThemeVariables$2 = (userOverrides) => {
  const theme2 = new Theme$2();
  theme2.calculate(userOverrides);
  return theme2;
};
class Theme$1 {
  constructor() {
    this.background = "#f4f4f4";
    this.primaryColor = "#cde498";
    this.secondaryColor = "#cdffb2";
    this.background = "white";
    this.mainBkg = "#cde498";
    this.secondBkg = "#cdffb2";
    this.lineColor = "green";
    this.border1 = "#13540c";
    this.border2 = "#6eaa49";
    this.arrowheadColor = "green";
    this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif';
    this.fontSize = "16px";
    this.tertiaryColor = lighten$1("#cde498", 10);
    this.primaryBorderColor = mkBorder(this.primaryColor, this.darkMode);
    this.secondaryBorderColor = mkBorder(this.secondaryColor, this.darkMode);
    this.tertiaryBorderColor = mkBorder(this.tertiaryColor, this.darkMode);
    this.primaryTextColor = invert$1(this.primaryColor);
    this.secondaryTextColor = invert$1(this.secondaryColor);
    this.tertiaryTextColor = invert$1(this.primaryColor);
    this.lineColor = invert$1(this.background);
    this.textColor = invert$1(this.background);
    this.THEME_COLOR_LIMIT = 12;
    this.nodeBkg = "calculated";
    this.nodeBorder = "calculated";
    this.clusterBkg = "calculated";
    this.clusterBorder = "calculated";
    this.defaultLinkColor = "calculated";
    this.titleColor = "#333";
    this.edgeLabelBackground = "#e8e8e8";
    this.actorBorder = "calculated";
    this.actorBkg = "calculated";
    this.actorTextColor = "black";
    this.actorLineColor = "grey";
    this.signalColor = "#333";
    this.signalTextColor = "#333";
    this.labelBoxBkgColor = "calculated";
    this.labelBoxBorderColor = "#326932";
    this.labelTextColor = "calculated";
    this.loopTextColor = "calculated";
    this.noteBorderColor = "calculated";
    this.noteBkgColor = "#fff5ad";
    this.noteTextColor = "calculated";
    this.activationBorderColor = "#666";
    this.activationBkgColor = "#f4f4f4";
    this.sequenceNumberColor = "white";
    this.sectionBkgColor = "#6eaa49";
    this.altSectionBkgColor = "white";
    this.sectionBkgColor2 = "#6eaa49";
    this.excludeBkgColor = "#eeeeee";
    this.taskBorderColor = "calculated";
    this.taskBkgColor = "#487e3a";
    this.taskTextLightColor = "white";
    this.taskTextColor = "calculated";
    this.taskTextDarkColor = "black";
    this.taskTextOutsideColor = "calculated";
    this.taskTextClickableColor = "#003163";
    this.activeTaskBorderColor = "calculated";
    this.activeTaskBkgColor = "calculated";
    this.gridColor = "lightgrey";
    this.doneTaskBkgColor = "lightgrey";
    this.doneTaskBorderColor = "grey";
    this.critBorderColor = "#ff8888";
    this.critBkgColor = "red";
    this.todayLineColor = "red";
    this.personBorder = "calculated";
    this.personBkg = "calculated";
    this.labelColor = "black";
    this.errorBkgColor = "#552222";
    this.errorTextColor = "#552222";
  }
  updateColors() {
    this.cScale0 = this.cScale0 || this.primaryColor;
    this.cScale1 = this.cScale1 || this.secondaryColor;
    this.cScale2 = this.cScale2 || this.tertiaryColor;
    this.cScale3 = this.cScale3 || adjust$2(this.primaryColor, { h: 30 });
    this.cScale4 = this.cScale4 || adjust$2(this.primaryColor, { h: 60 });
    this.cScale5 = this.cScale5 || adjust$2(this.primaryColor, { h: 90 });
    this.cScale6 = this.cScale6 || adjust$2(this.primaryColor, { h: 120 });
    this.cScale7 = this.cScale7 || adjust$2(this.primaryColor, { h: 150 });
    this.cScale8 = this.cScale8 || adjust$2(this.primaryColor, { h: 210 });
    this.cScale9 = this.cScale9 || adjust$2(this.primaryColor, { h: 270 });
    this.cScale10 = this.cScale10 || adjust$2(this.primaryColor, { h: 300 });
    this.cScale11 = this.cScale11 || adjust$2(this.primaryColor, { h: 330 });
    this["cScalePeer" + 1] = this["cScalePeer" + 1] || darken$1(this.secondaryColor, 45);
    this["cScalePeer" + 2] = this["cScalePeer" + 2] || darken$1(this.tertiaryColor, 40);
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScale" + i] = darken$1(this["cScale" + i], 10);
      this["cScalePeer" + i] = this["cScalePeer" + i] || darken$1(this["cScale" + i], 25);
    }
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScaleInv" + i] = this["cScaleInv" + i] || adjust$2(this["cScale" + i], { h: 180 });
    }
    this.scaleLabelColor = this.scaleLabelColor !== "calculated" && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor;
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScaleLabel" + i] = this["cScaleLabel" + i] || this.scaleLabelColor;
    }
    this.nodeBkg = this.mainBkg;
    this.nodeBorder = this.border1;
    this.clusterBkg = this.secondBkg;
    this.clusterBorder = this.border2;
    this.defaultLinkColor = this.lineColor;
    this.actorBorder = darken$1(this.mainBkg, 20);
    this.actorBkg = this.mainBkg;
    this.labelBoxBkgColor = this.actorBkg;
    this.labelTextColor = this.actorTextColor;
    this.loopTextColor = this.actorTextColor;
    this.noteBorderColor = this.border2;
    this.noteTextColor = this.actorTextColor;
    this.taskBorderColor = this.border1;
    this.taskTextColor = this.taskTextLightColor;
    this.taskTextOutsideColor = this.taskTextDarkColor;
    this.activeTaskBorderColor = this.taskBorderColor;
    this.activeTaskBkgColor = this.mainBkg;
    this.transitionColor = this.transitionColor || this.lineColor;
    this.transitionLabelColor = this.transitionLabelColor || this.textColor;
    this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor;
    this.stateBkg = this.stateBkg || this.mainBkg;
    this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg;
    this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor;
    this.altBackground = this.altBackground || "#f0f0f0";
    this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg;
    this.compositeBorder = this.compositeBorder || this.nodeBorder;
    this.innerEndBackground = this.primaryBorderColor;
    this.specialStateColor = this.lineColor;
    this.errorBkgColor = this.errorBkgColor || this.tertiaryColor;
    this.errorTextColor = this.errorTextColor || this.tertiaryTextColor;
    this.transitionColor = this.transitionColor || this.lineColor;
    this.classText = this.primaryTextColor;
    this.fillType0 = this.primaryColor;
    this.fillType1 = this.secondaryColor;
    this.fillType2 = adjust$2(this.primaryColor, { h: 64 });
    this.fillType3 = adjust$2(this.secondaryColor, { h: 64 });
    this.fillType4 = adjust$2(this.primaryColor, { h: -64 });
    this.fillType5 = adjust$2(this.secondaryColor, { h: -64 });
    this.fillType6 = adjust$2(this.primaryColor, { h: 128 });
    this.fillType7 = adjust$2(this.secondaryColor, { h: 128 });
    this.pie1 = this.pie1 || this.primaryColor;
    this.pie2 = this.pie2 || this.secondaryColor;
    this.pie3 = this.pie3 || this.tertiaryColor;
    this.pie4 = this.pie4 || adjust$2(this.primaryColor, { l: -30 });
    this.pie5 = this.pie5 || adjust$2(this.secondaryColor, { l: -30 });
    this.pie6 = this.pie6 || adjust$2(this.tertiaryColor, { h: 40, l: -40 });
    this.pie7 = this.pie7 || adjust$2(this.primaryColor, { h: 60, l: -10 });
    this.pie8 = this.pie8 || adjust$2(this.primaryColor, { h: -60, l: -10 });
    this.pie9 = this.pie9 || adjust$2(this.primaryColor, { h: 120, l: 0 });
    this.pie10 = this.pie10 || adjust$2(this.primaryColor, { h: 60, l: -50 });
    this.pie11 = this.pie11 || adjust$2(this.primaryColor, { h: -60, l: -50 });
    this.pie12 = this.pie12 || adjust$2(this.primaryColor, { h: 120, l: -50 });
    this.pieTitleTextSize = this.pieTitleTextSize || "25px";
    this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor;
    this.pieSectionTextSize = this.pieSectionTextSize || "17px";
    this.pieSectionTextColor = this.pieSectionTextColor || this.textColor;
    this.pieLegendTextSize = this.pieLegendTextSize || "17px";
    this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor;
    this.pieStrokeColor = this.pieStrokeColor || "black";
    this.pieStrokeWidth = this.pieStrokeWidth || "2px";
    this.pieOpacity = this.pieOpacity || "0.7";
    this.requirementBackground = this.requirementBackground || this.primaryColor;
    this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor;
    this.requirementBorderSize = this.requirementBorderSize || this.primaryBorderColor;
    this.requirementTextColor = this.requirementTextColor || this.primaryTextColor;
    this.relationColor = this.relationColor || this.lineColor;
    this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground;
    this.relationLabelColor = this.relationLabelColor || this.actorTextColor;
    this.git0 = this.git0 || this.primaryColor;
    this.git1 = this.git1 || this.secondaryColor;
    this.git2 = this.git2 || this.tertiaryColor;
    this.git3 = this.git3 || adjust$2(this.primaryColor, { h: -30 });
    this.git4 = this.git4 || adjust$2(this.primaryColor, { h: -60 });
    this.git5 = this.git5 || adjust$2(this.primaryColor, { h: -90 });
    this.git6 = this.git6 || adjust$2(this.primaryColor, { h: 60 });
    this.git7 = this.git7 || adjust$2(this.primaryColor, { h: 120 });
    if (this.darkMode) {
      this.git0 = lighten$1(this.git0, 25);
      this.git1 = lighten$1(this.git1, 25);
      this.git2 = lighten$1(this.git2, 25);
      this.git3 = lighten$1(this.git3, 25);
      this.git4 = lighten$1(this.git4, 25);
      this.git5 = lighten$1(this.git5, 25);
      this.git6 = lighten$1(this.git6, 25);
      this.git7 = lighten$1(this.git7, 25);
    } else {
      this.git0 = darken$1(this.git0, 25);
      this.git1 = darken$1(this.git1, 25);
      this.git2 = darken$1(this.git2, 25);
      this.git3 = darken$1(this.git3, 25);
      this.git4 = darken$1(this.git4, 25);
      this.git5 = darken$1(this.git5, 25);
      this.git6 = darken$1(this.git6, 25);
      this.git7 = darken$1(this.git7, 25);
    }
    this.gitInv0 = this.gitInv0 || invert$1(this.git0);
    this.gitInv1 = this.gitInv1 || invert$1(this.git1);
    this.gitInv2 = this.gitInv2 || invert$1(this.git2);
    this.gitInv3 = this.gitInv3 || invert$1(this.git3);
    this.gitInv4 = this.gitInv4 || invert$1(this.git4);
    this.gitInv5 = this.gitInv5 || invert$1(this.git5);
    this.gitInv6 = this.gitInv6 || invert$1(this.git6);
    this.gitInv7 = this.gitInv7 || invert$1(this.git7);
    this.tagLabelColor = this.tagLabelColor || this.primaryTextColor;
    this.tagLabelBackground = this.tagLabelBackground || this.primaryColor;
    this.tagLabelBorder = this.tagBorder || this.primaryBorderColor;
    this.tagLabelFontSize = this.tagLabelFontSize || "10px";
    this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor;
    this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor;
    this.commitLabelFontSize = this.commitLabelFontSize || "10px";
    this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || oldAttributeBackgroundColorOdd;
    this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || oldAttributeBackgroundColorEven;
  }
  calculate(overrides) {
    if (typeof overrides !== "object") {
      this.updateColors();
      return;
    }
    const keys2 = Object.keys(overrides);
    keys2.forEach((k2) => {
      this[k2] = overrides[k2];
    });
    this.updateColors();
    keys2.forEach((k2) => {
      this[k2] = overrides[k2];
    });
  }
}
const getThemeVariables$1 = (userOverrides) => {
  const theme2 = new Theme$1();
  theme2.calculate(userOverrides);
  return theme2;
};
class Theme {
  constructor() {
    this.primaryColor = "#eee";
    this.contrast = "#707070";
    this.secondaryColor = lighten$1(this.contrast, 55);
    this.background = "#ffffff";
    this.tertiaryColor = adjust$2(this.primaryColor, { h: -160 });
    this.primaryBorderColor = mkBorder(this.primaryColor, this.darkMode);
    this.secondaryBorderColor = mkBorder(this.secondaryColor, this.darkMode);
    this.tertiaryBorderColor = mkBorder(this.tertiaryColor, this.darkMode);
    this.primaryTextColor = invert$1(this.primaryColor);
    this.secondaryTextColor = invert$1(this.secondaryColor);
    this.tertiaryTextColor = invert$1(this.tertiaryColor);
    this.lineColor = invert$1(this.background);
    this.textColor = invert$1(this.background);
    this.mainBkg = "#eee";
    this.secondBkg = "calculated";
    this.lineColor = "#666";
    this.border1 = "#999";
    this.border2 = "calculated";
    this.note = "#ffa";
    this.text = "#333";
    this.critical = "#d42";
    this.done = "#bbb";
    this.arrowheadColor = "#333333";
    this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif';
    this.fontSize = "16px";
    this.THEME_COLOR_LIMIT = 12;
    this.nodeBkg = "calculated";
    this.nodeBorder = "calculated";
    this.clusterBkg = "calculated";
    this.clusterBorder = "calculated";
    this.defaultLinkColor = "calculated";
    this.titleColor = "calculated";
    this.edgeLabelBackground = "white";
    this.actorBorder = "calculated";
    this.actorBkg = "calculated";
    this.actorTextColor = "calculated";
    this.actorLineColor = "calculated";
    this.signalColor = "calculated";
    this.signalTextColor = "calculated";
    this.labelBoxBkgColor = "calculated";
    this.labelBoxBorderColor = "calculated";
    this.labelTextColor = "calculated";
    this.loopTextColor = "calculated";
    this.noteBorderColor = "calculated";
    this.noteBkgColor = "calculated";
    this.noteTextColor = "calculated";
    this.activationBorderColor = "#666";
    this.activationBkgColor = "#f4f4f4";
    this.sequenceNumberColor = "white";
    this.sectionBkgColor = "calculated";
    this.altSectionBkgColor = "white";
    this.sectionBkgColor2 = "calculated";
    this.excludeBkgColor = "#eeeeee";
    this.taskBorderColor = "calculated";
    this.taskBkgColor = "calculated";
    this.taskTextLightColor = "white";
    this.taskTextColor = "calculated";
    this.taskTextDarkColor = "calculated";
    this.taskTextOutsideColor = "calculated";
    this.taskTextClickableColor = "#003163";
    this.activeTaskBorderColor = "calculated";
    this.activeTaskBkgColor = "calculated";
    this.gridColor = "calculated";
    this.doneTaskBkgColor = "calculated";
    this.doneTaskBorderColor = "calculated";
    this.critBkgColor = "calculated";
    this.critBorderColor = "calculated";
    this.todayLineColor = "calculated";
    this.personBorder = "calculated";
    this.personBkg = "calculated";
    this.labelColor = "black";
    this.errorBkgColor = "#552222";
    this.errorTextColor = "#552222";
  }
  updateColors() {
    this.secondBkg = lighten$1(this.contrast, 55);
    this.border2 = this.contrast;
    this.cScale0 = this.cScale0 || "#555";
    this.cScale1 = this.cScale1 || "#F4F4F4";
    this.cScale2 = this.cScale2 || "#555";
    this.cScale3 = this.cScale3 || "#BBB";
    this.cScale4 = this.cScale4 || "#777";
    this.cScale5 = this.cScale5 || "#999";
    this.cScale6 = this.cScale6 || "#DDD";
    this.cScale7 = this.cScale7 || "#FFF";
    this.cScale8 = this.cScale8 || "#DDD";
    this.cScale9 = this.cScale9 || "#BBB";
    this.cScale10 = this.cScale10 || "#999";
    this.cScale11 = this.cScale11 || "#777";
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScaleInv" + i] = this["cScaleInv" + i] || invert$1(this["cScale" + i]);
    }
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      if (this.darkMode) {
        this["cScalePeer" + i] = this["cScalePeer" + i] || lighten$1(this["cScale" + i], 10);
      } else {
        this["cScalePeer" + i] = this["cScalePeer" + i] || darken$1(this["cScale" + i], 10);
      }
    }
    this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? "black" : this.labelTextColor);
    this["cScaleLabel0"] = this["cScaleLabel0"] || this.cScale1;
    this["cScaleLabel2"] = this["cScaleLabel2"] || this.cScale1;
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScaleLabel" + i] = this["cScaleLabel" + i] || this.scaleLabelColor;
    }
    this.nodeBkg = this.mainBkg;
    this.nodeBorder = this.border1;
    this.clusterBkg = this.secondBkg;
    this.clusterBorder = this.border2;
    this.defaultLinkColor = this.lineColor;
    this.titleColor = this.text;
    this.actorBorder = lighten$1(this.border1, 23);
    this.actorBkg = this.mainBkg;
    this.actorTextColor = this.text;
    this.actorLineColor = this.lineColor;
    this.signalColor = this.text;
    this.signalTextColor = this.text;
    this.labelBoxBkgColor = this.actorBkg;
    this.labelBoxBorderColor = this.actorBorder;
    this.labelTextColor = this.text;
    this.loopTextColor = this.text;
    this.noteBorderColor = "#999";
    this.noteBkgColor = "#666";
    this.noteTextColor = "#fff";
    this.sectionBkgColor = lighten$1(this.contrast, 30);
    this.sectionBkgColor2 = lighten$1(this.contrast, 30);
    this.taskBorderColor = darken$1(this.contrast, 10);
    this.taskBkgColor = this.contrast;
    this.taskTextColor = this.taskTextLightColor;
    this.taskTextDarkColor = this.text;
    this.taskTextOutsideColor = this.taskTextDarkColor;
    this.activeTaskBorderColor = this.taskBorderColor;
    this.activeTaskBkgColor = this.mainBkg;
    this.gridColor = lighten$1(this.border1, 30);
    this.doneTaskBkgColor = this.done;
    this.doneTaskBorderColor = this.lineColor;
    this.critBkgColor = this.critical;
    this.critBorderColor = darken$1(this.critBkgColor, 10);
    this.todayLineColor = this.critBkgColor;
    this.transitionColor = this.transitionColor || "#000";
    this.transitionLabelColor = this.transitionLabelColor || this.textColor;
    this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor;
    this.stateBkg = this.stateBkg || this.mainBkg;
    this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg;
    this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor;
    this.altBackground = this.altBackground || "#f4f4f4";
    this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg;
    this.stateBorder = this.stateBorder || "#000";
    this.innerEndBackground = this.primaryBorderColor;
    this.specialStateColor = "#222";
    this.errorBkgColor = this.errorBkgColor || this.tertiaryColor;
    this.errorTextColor = this.errorTextColor || this.tertiaryTextColor;
    this.classText = this.primaryTextColor;
    this.fillType0 = this.primaryColor;
    this.fillType1 = this.secondaryColor;
    this.fillType2 = adjust$2(this.primaryColor, { h: 64 });
    this.fillType3 = adjust$2(this.secondaryColor, { h: 64 });
    this.fillType4 = adjust$2(this.primaryColor, { h: -64 });
    this.fillType5 = adjust$2(this.secondaryColor, { h: -64 });
    this.fillType6 = adjust$2(this.primaryColor, { h: 128 });
    this.fillType7 = adjust$2(this.secondaryColor, { h: 128 });
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["pie" + i] = this["cScale" + i];
    }
    this.pie12 = this.pie0;
    this.pieTitleTextSize = this.pieTitleTextSize || "25px";
    this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor;
    this.pieSectionTextSize = this.pieSectionTextSize || "17px";
    this.pieSectionTextColor = this.pieSectionTextColor || this.textColor;
    this.pieLegendTextSize = this.pieLegendTextSize || "17px";
    this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor;
    this.pieStrokeColor = this.pieStrokeColor || "black";
    this.pieStrokeWidth = this.pieStrokeWidth || "2px";
    this.pieOpacity = this.pieOpacity || "0.7";
    this.requirementBackground = this.requirementBackground || this.primaryColor;
    this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor;
    this.requirementBorderSize = this.requirementBorderSize || this.primaryBorderColor;
    this.requirementTextColor = this.requirementTextColor || this.primaryTextColor;
    this.relationColor = this.relationColor || this.lineColor;
    this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground;
    this.relationLabelColor = this.relationLabelColor || this.actorTextColor;
    this.git0 = darken$1(this.pie1, 25) || this.primaryColor;
    this.git1 = this.pie2 || this.secondaryColor;
    this.git2 = this.pie3 || this.tertiaryColor;
    this.git3 = this.pie4 || adjust$2(this.primaryColor, { h: -30 });
    this.git4 = this.pie5 || adjust$2(this.primaryColor, { h: -60 });
    this.git5 = this.pie6 || adjust$2(this.primaryColor, { h: -90 });
    this.git6 = this.pie7 || adjust$2(this.primaryColor, { h: 60 });
    this.git7 = this.pie8 || adjust$2(this.primaryColor, { h: 120 });
    this.gitInv0 = this.gitInv0 || invert$1(this.git0);
    this.gitInv1 = this.gitInv1 || invert$1(this.git1);
    this.gitInv2 = this.gitInv2 || invert$1(this.git2);
    this.gitInv3 = this.gitInv3 || invert$1(this.git3);
    this.gitInv4 = this.gitInv4 || invert$1(this.git4);
    this.gitInv5 = this.gitInv5 || invert$1(this.git5);
    this.gitInv6 = this.gitInv6 || invert$1(this.git6);
    this.gitInv7 = this.gitInv7 || invert$1(this.git7);
    this.branchLabelColor = this.branchLabelColor || this.labelTextColor;
    this.gitBranchLabel0 = this.branchLabelColor;
    this.gitBranchLabel1 = "white";
    this.gitBranchLabel2 = this.branchLabelColor;
    this.gitBranchLabel3 = "white";
    this.gitBranchLabel4 = this.branchLabelColor;
    this.gitBranchLabel5 = this.branchLabelColor;
    this.gitBranchLabel6 = this.branchLabelColor;
    this.gitBranchLabel7 = this.branchLabelColor;
    this.tagLabelColor = this.tagLabelColor || this.primaryTextColor;
    this.tagLabelBackground = this.tagLabelBackground || this.primaryColor;
    this.tagLabelBorder = this.tagBorder || this.primaryBorderColor;
    this.tagLabelFontSize = this.tagLabelFontSize || "10px";
    this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor;
    this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor;
    this.commitLabelFontSize = this.commitLabelFontSize || "10px";
    this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || oldAttributeBackgroundColorOdd;
    this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || oldAttributeBackgroundColorEven;
  }
  calculate(overrides) {
    if (typeof overrides !== "object") {
      this.updateColors();
      return;
    }
    const keys2 = Object.keys(overrides);
    keys2.forEach((k2) => {
      this[k2] = overrides[k2];
    });
    this.updateColors();
    keys2.forEach((k2) => {
      this[k2] = overrides[k2];
    });
  }
}
const getThemeVariables = (userOverrides) => {
  const theme2 = new Theme();
  theme2.calculate(userOverrides);
  return theme2;
};
const theme$3 = {
  base: {
    getThemeVariables: getThemeVariables$4
  },
  dark: {
    getThemeVariables: getThemeVariables$3
  },
  default: {
    getThemeVariables: getThemeVariables$2
  },
  forest: {
    getThemeVariables: getThemeVariables$1
  },
  neutral: {
    getThemeVariables
  }
};
const config$1 = {
  theme: "default",
  themeVariables: theme$3["default"].getThemeVariables(),
  themeCSS: void 0,
  maxTextSize: 5e4,
  darkMode: false,
  fontFamily: '"trebuchet ms", verdana, arial, sans-serif;',
  logLevel: 5,
  securityLevel: "strict",
  startOnLoad: true,
  arrowMarkerAbsolute: false,
  secure: ["secure", "securityLevel", "startOnLoad", "maxTextSize"],
  lazyLoadedDiagrams: [],
  deterministicIds: false,
  deterministicIDSeed: void 0,
  flowchart: {
    diagramPadding: 8,
    htmlLabels: true,
    nodeSpacing: 50,
    rankSpacing: 50,
    curve: "basis",
    padding: 15,
    useMaxWidth: true,
    defaultRenderer: "dagre-wrapper"
  },
  sequence: {
    hideUnusedParticipants: false,
    activationWidth: 10,
    diagramMarginX: 50,
    diagramMarginY: 10,
    actorMargin: 50,
    width: 150,
    height: 65,
    boxMargin: 10,
    boxTextMargin: 5,
    noteMargin: 10,
    messageMargin: 35,
    messageAlign: "center",
    mirrorActors: true,
    forceMenus: false,
    bottomMarginAdj: 1,
    useMaxWidth: true,
    rightAngles: false,
    showSequenceNumbers: false,
    actorFontSize: 14,
    actorFontFamily: '"Open Sans", sans-serif',
    actorFontWeight: 400,
    noteFontSize: 14,
    noteFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
    noteFontWeight: 400,
    noteAlign: "center",
    messageFontSize: 16,
    messageFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
    messageFontWeight: 400,
    wrap: false,
    wrapPadding: 10,
    labelBoxWidth: 50,
    labelBoxHeight: 20,
    messageFont: function() {
      return {
        fontFamily: this.messageFontFamily,
        fontSize: this.messageFontSize,
        fontWeight: this.messageFontWeight
      };
    },
    noteFont: function() {
      return {
        fontFamily: this.noteFontFamily,
        fontSize: this.noteFontSize,
        fontWeight: this.noteFontWeight
      };
    },
    actorFont: function() {
      return {
        fontFamily: this.actorFontFamily,
        fontSize: this.actorFontSize,
        fontWeight: this.actorFontWeight
      };
    }
  },
  gantt: {
    titleTopMargin: 25,
    barHeight: 20,
    barGap: 4,
    topPadding: 50,
    rightPadding: 75,
    leftPadding: 75,
    gridLineStartPadding: 35,
    fontSize: 11,
    sectionFontSize: 11,
    numberSectionStyles: 4,
    axisFormat: "%Y-%m-%d",
    useMaxWidth: true,
    topAxis: false,
    useWidth: void 0
  },
  journey: {
    diagramMarginX: 50,
    diagramMarginY: 10,
    leftMargin: 150,
    width: 150,
    height: 50,
    boxMargin: 10,
    boxTextMargin: 5,
    noteMargin: 10,
    messageMargin: 35,
    messageAlign: "center",
    bottomMarginAdj: 1,
    useMaxWidth: true,
    rightAngles: false,
    taskFontSize: 14,
    taskFontFamily: '"Open Sans", sans-serif',
    taskMargin: 50,
    activationWidth: 10,
    textPlacement: "fo",
    actorColours: ["#8FBC8F", "#7CFC00", "#00FFFF", "#20B2AA", "#B0E0E6", "#FFFFE0"],
    sectionFills: ["#191970", "#8B008B", "#4B0082", "#2F4F4F", "#800000", "#8B4513", "#00008B"],
    sectionColours: ["#fff"]
  },
  class: {
    arrowMarkerAbsolute: false,
    dividerMargin: 10,
    padding: 5,
    textHeight: 10,
    useMaxWidth: true,
    defaultRenderer: "dagre-wrapper"
  },
  state: {
    dividerMargin: 10,
    sizeUnit: 5,
    padding: 8,
    textHeight: 10,
    titleShift: -15,
    noteMargin: 10,
    forkWidth: 70,
    forkHeight: 7,
    miniPadding: 2,
    fontSizeFactor: 5.02,
    fontSize: 24,
    labelHeight: 16,
    edgeLengthFactor: "20",
    compositTitleSize: 35,
    radius: 5,
    useMaxWidth: true,
    defaultRenderer: "dagre-wrapper"
  },
  er: {
    diagramPadding: 20,
    layoutDirection: "TB",
    minEntityWidth: 100,
    minEntityHeight: 75,
    entityPadding: 15,
    stroke: "gray",
    fill: "honeydew",
    fontSize: 12,
    useMaxWidth: true
  },
  pie: {
    useWidth: void 0,
    useMaxWidth: true
  },
  requirement: {
    useWidth: void 0,
    useMaxWidth: true,
    rect_fill: "#f9f9f9",
    text_color: "#333",
    rect_border_size: "0.5px",
    rect_border_color: "#bbb",
    rect_min_width: 200,
    rect_min_height: 200,
    fontSize: 14,
    rect_padding: 10,
    line_height: 20
  },
  gitGraph: {
    diagramPadding: 8,
    nodeLabel: {
      width: 75,
      height: 100,
      x: -25,
      y: 0
    },
    mainBranchName: "main",
    mainBranchOrder: 0,
    showCommitLabel: true,
    showBranches: true,
    rotateCommitLabel: true
  },
  c4: {
    useWidth: void 0,
    diagramMarginX: 50,
    diagramMarginY: 10,
    c4ShapeMargin: 50,
    c4ShapePadding: 20,
    width: 216,
    height: 60,
    boxMargin: 10,
    useMaxWidth: true,
    c4ShapeInRow: 4,
    nextLinePaddingX: 0,
    c4BoundaryInRow: 2,
    personFontSize: 14,
    personFontFamily: '"Open Sans", sans-serif',
    personFontWeight: "normal",
    external_personFontSize: 14,
    external_personFontFamily: '"Open Sans", sans-serif',
    external_personFontWeight: "normal",
    systemFontSize: 14,
    systemFontFamily: '"Open Sans", sans-serif',
    systemFontWeight: "normal",
    external_systemFontSize: 14,
    external_systemFontFamily: '"Open Sans", sans-serif',
    external_systemFontWeight: "normal",
    system_dbFontSize: 14,
    system_dbFontFamily: '"Open Sans", sans-serif',
    system_dbFontWeight: "normal",
    external_system_dbFontSize: 14,
    external_system_dbFontFamily: '"Open Sans", sans-serif',
    external_system_dbFontWeight: "normal",
    system_queueFontSize: 14,
    system_queueFontFamily: '"Open Sans", sans-serif',
    system_queueFontWeight: "normal",
    external_system_queueFontSize: 14,
    external_system_queueFontFamily: '"Open Sans", sans-serif',
    external_system_queueFontWeight: "normal",
    boundaryFontSize: 14,
    boundaryFontFamily: '"Open Sans", sans-serif',
    boundaryFontWeight: "normal",
    messageFontSize: 12,
    messageFontFamily: '"Open Sans", sans-serif',
    messageFontWeight: "normal",
    containerFontSize: 14,
    containerFontFamily: '"Open Sans", sans-serif',
    containerFontWeight: "normal",
    external_containerFontSize: 14,
    external_containerFontFamily: '"Open Sans", sans-serif',
    external_containerFontWeight: "normal",
    container_dbFontSize: 14,
    container_dbFontFamily: '"Open Sans", sans-serif',
    container_dbFontWeight: "normal",
    external_container_dbFontSize: 14,
    external_container_dbFontFamily: '"Open Sans", sans-serif',
    external_container_dbFontWeight: "normal",
    container_queueFontSize: 14,
    container_queueFontFamily: '"Open Sans", sans-serif',
    container_queueFontWeight: "normal",
    external_container_queueFontSize: 14,
    external_container_queueFontFamily: '"Open Sans", sans-serif',
    external_container_queueFontWeight: "normal",
    componentFontSize: 14,
    componentFontFamily: '"Open Sans", sans-serif',
    componentFontWeight: "normal",
    external_componentFontSize: 14,
    external_componentFontFamily: '"Open Sans", sans-serif',
    external_componentFontWeight: "normal",
    component_dbFontSize: 14,
    component_dbFontFamily: '"Open Sans", sans-serif',
    component_dbFontWeight: "normal",
    external_component_dbFontSize: 14,
    external_component_dbFontFamily: '"Open Sans", sans-serif',
    external_component_dbFontWeight: "normal",
    component_queueFontSize: 14,
    component_queueFontFamily: '"Open Sans", sans-serif',
    component_queueFontWeight: "normal",
    external_component_queueFontSize: 14,
    external_component_queueFontFamily: '"Open Sans", sans-serif',
    external_component_queueFontWeight: "normal",
    wrap: true,
    wrapPadding: 10,
    personFont: function() {
      return {
        fontFamily: this.personFontFamily,
        fontSize: this.personFontSize,
        fontWeight: this.personFontWeight
      };
    },
    external_personFont: function() {
      return {
        fontFamily: this.external_personFontFamily,
        fontSize: this.external_personFontSize,
        fontWeight: this.external_personFontWeight
      };
    },
    systemFont: function() {
      return {
        fontFamily: this.systemFontFamily,
        fontSize: this.systemFontSize,
        fontWeight: this.systemFontWeight
      };
    },
    external_systemFont: function() {
      return {
        fontFamily: this.external_systemFontFamily,
        fontSize: this.external_systemFontSize,
        fontWeight: this.external_systemFontWeight
      };
    },
    system_dbFont: function() {
      return {
        fontFamily: this.system_dbFontFamily,
        fontSize: this.system_dbFontSize,
        fontWeight: this.system_dbFontWeight
      };
    },
    external_system_dbFont: function() {
      return {
        fontFamily: this.external_system_dbFontFamily,
        fontSize: this.external_system_dbFontSize,
        fontWeight: this.external_system_dbFontWeight
      };
    },
    system_queueFont: function() {
      return {
        fontFamily: this.system_queueFontFamily,
        fontSize: this.system_queueFontSize,
        fontWeight: this.system_queueFontWeight
      };
    },
    external_system_queueFont: function() {
      return {
        fontFamily: this.external_system_queueFontFamily,
        fontSize: this.external_system_queueFontSize,
        fontWeight: this.external_system_queueFontWeight
      };
    },
    containerFont: function() {
      return {
        fontFamily: this.containerFontFamily,
        fontSize: this.containerFontSize,
        fontWeight: this.containerFontWeight
      };
    },
    external_containerFont: function() {
      return {
        fontFamily: this.external_containerFontFamily,
        fontSize: this.external_containerFontSize,
        fontWeight: this.external_containerFontWeight
      };
    },
    container_dbFont: function() {
      return {
        fontFamily: this.container_dbFontFamily,
        fontSize: this.container_dbFontSize,
        fontWeight: this.container_dbFontWeight
      };
    },
    external_container_dbFont: function() {
      return {
        fontFamily: this.external_container_dbFontFamily,
        fontSize: this.external_container_dbFontSize,
        fontWeight: this.external_container_dbFontWeight
      };
    },
    container_queueFont: function() {
      return {
        fontFamily: this.container_queueFontFamily,
        fontSize: this.container_queueFontSize,
        fontWeight: this.container_queueFontWeight
      };
    },
    external_container_queueFont: function() {
      return {
        fontFamily: this.external_container_queueFontFamily,
        fontSize: this.external_container_queueFontSize,
        fontWeight: this.external_container_queueFontWeight
      };
    },
    componentFont: function() {
      return {
        fontFamily: this.componentFontFamily,
        fontSize: this.componentFontSize,
        fontWeight: this.componentFontWeight
      };
    },
    external_componentFont: function() {
      return {
        fontFamily: this.external_componentFontFamily,
        fontSize: this.external_componentFontSize,
        fontWeight: this.external_componentFontWeight
      };
    },
    component_dbFont: function() {
      return {
        fontFamily: this.component_dbFontFamily,
        fontSize: this.component_dbFontSize,
        fontWeight: this.component_dbFontWeight
      };
    },
    external_component_dbFont: function() {
      return {
        fontFamily: this.external_component_dbFontFamily,
        fontSize: this.external_component_dbFontSize,
        fontWeight: this.external_component_dbFontWeight
      };
    },
    component_queueFont: function() {
      return {
        fontFamily: this.component_queueFontFamily,
        fontSize: this.component_queueFontSize,
        fontWeight: this.component_queueFontWeight
      };
    },
    external_component_queueFont: function() {
      return {
        fontFamily: this.external_component_queueFontFamily,
        fontSize: this.external_component_queueFontSize,
        fontWeight: this.external_component_queueFontWeight
      };
    },
    boundaryFont: function() {
      return {
        fontFamily: this.boundaryFontFamily,
        fontSize: this.boundaryFontSize,
        fontWeight: this.boundaryFontWeight
      };
    },
    messageFont: function() {
      return {
        fontFamily: this.messageFontFamily,
        fontSize: this.messageFontSize,
        fontWeight: this.messageFontWeight
      };
    },
    person_bg_color: "#08427B",
    person_border_color: "#073B6F",
    external_person_bg_color: "#686868",
    external_person_border_color: "#8A8A8A",
    system_bg_color: "#1168BD",
    system_border_color: "#3C7FC0",
    system_db_bg_color: "#1168BD",
    system_db_border_color: "#3C7FC0",
    system_queue_bg_color: "#1168BD",
    system_queue_border_color: "#3C7FC0",
    external_system_bg_color: "#999999",
    external_system_border_color: "#8A8A8A",
    external_system_db_bg_color: "#999999",
    external_system_db_border_color: "#8A8A8A",
    external_system_queue_bg_color: "#999999",
    external_system_queue_border_color: "#8A8A8A",
    container_bg_color: "#438DD5",
    container_border_color: "#3C7FC0",
    container_db_bg_color: "#438DD5",
    container_db_border_color: "#3C7FC0",
    container_queue_bg_color: "#438DD5",
    container_queue_border_color: "#3C7FC0",
    external_container_bg_color: "#B3B3B3",
    external_container_border_color: "#A6A6A6",
    external_container_db_bg_color: "#B3B3B3",
    external_container_db_border_color: "#A6A6A6",
    external_container_queue_bg_color: "#B3B3B3",
    external_container_queue_border_color: "#A6A6A6",
    component_bg_color: "#85BBF0",
    component_border_color: "#78A8D8",
    component_db_bg_color: "#85BBF0",
    component_db_border_color: "#78A8D8",
    component_queue_bg_color: "#85BBF0",
    component_queue_border_color: "#78A8D8",
    external_component_bg_color: "#CCCCCC",
    external_component_border_color: "#BFBFBF",
    external_component_db_bg_color: "#CCCCCC",
    external_component_db_border_color: "#BFBFBF",
    external_component_queue_bg_color: "#CCCCCC",
    external_component_queue_border_color: "#BFBFBF"
  },
  mindmap: {
    useMaxWidth: true,
    padding: 10,
    maxNodeWidth: 200
  },
  fontSize: 16
};
if (config$1.class)
  config$1.class.arrowMarkerAbsolute = config$1.arrowMarkerAbsolute;
if (config$1.gitGraph)
  config$1.gitGraph.arrowMarkerAbsolute = config$1.arrowMarkerAbsolute;
const keyify = (obj, prefix2 = "") => Object.keys(obj).reduce((res, el) => {
  if (Array.isArray(obj[el])) {
    return res;
  } else if (typeof obj[el] === "object" && obj[el] !== null) {
    return [...res, prefix2 + el, ...keyify(obj[el], "")];
  }
  return [...res, prefix2 + el];
}, []);
const configKeys = keyify(config$1, "");
const directive$1 = /[%]{2}[{]\s*(?:(?:(\w+)\s*:|(\w+))\s*(?:(?:(\w+))|((?:(?![}][%]{2}).|\r?\n)*))?\s*)(?:[}][%]{2})?/gi;
const anyComment = /\s*%%.*\n/gm;
const detectors = {};
const detectType = function(text2, config2) {
  text2 = text2.replace(directive$1, "").replace(anyComment, "\n");
  for (const [key, { detector }] of Object.entries(detectors)) {
    const diagram = detector(text2, config2);
    if (diagram) {
      return key;
    }
  }
  throw new Error(`No diagram type detected for text: ${text2}`);
};
const addDetector = (key, detector, loader) => {
  if (detectors[key]) {
    throw new Error(`Detector with key ${key} already exists`);
  }
  detectors[key] = { detector, loader };
  log$1.debug(`Detector with key ${key} added${loader ? " with loader" : ""}`);
};
const getDiagramLoader = (key) => detectors[key].loader;
const assignWithDepth = function(dst, src, config2) {
  const { depth, clobber } = Object.assign({ depth: 2, clobber: false }, config2);
  if (Array.isArray(src) && !Array.isArray(dst)) {
    src.forEach((s2) => assignWithDepth(dst, s2, config2));
    return dst;
  } else if (Array.isArray(src) && Array.isArray(dst)) {
    src.forEach((s2) => {
      if (dst.indexOf(s2) === -1) {
        dst.push(s2);
      }
    });
    return dst;
  }
  if (typeof dst === "undefined" || depth <= 0) {
    if (dst !== void 0 && dst !== null && typeof dst === "object" && typeof src === "object") {
      return Object.assign(dst, src);
    } else {
      return src;
    }
  }
  if (typeof src !== "undefined" && typeof dst === "object" && typeof src === "object") {
    Object.keys(src).forEach((key) => {
      if (typeof src[key] === "object" && (dst[key] === void 0 || typeof dst[key] === "object")) {
        if (dst[key] === void 0) {
          dst[key] = Array.isArray(src[key]) ? [] : {};
        }
        dst[key] = assignWithDepth(dst[key], src[key], { depth: depth - 1, clobber });
      } else if (clobber || typeof dst[key] !== "object" && typeof src[key] !== "object") {
        dst[key] = src[key];
      }
    });
  }
  return dst;
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$2 = freeGlobal || freeSelf || Function("return this")();
var _root = root$2;
var _Symbol;
var hasRequired_Symbol;
function require_Symbol() {
  if (hasRequired_Symbol)
    return _Symbol;
  hasRequired_Symbol = 1;
  var root2 = _root;
  var Symbol2 = root2.Symbol;
  _Symbol = Symbol2;
  return _Symbol;
}
var _getRawTag;
var hasRequired_getRawTag;
function require_getRawTag() {
  if (hasRequired_getRawTag)
    return _getRawTag;
  hasRequired_getRawTag = 1;
  var Symbol2 = require_Symbol();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var nativeObjectToString = objectProto2.toString;
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  function getRawTag(value) {
    var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  _getRawTag = getRawTag;
  return _getRawTag;
}
var _objectToString;
var hasRequired_objectToString;
function require_objectToString() {
  if (hasRequired_objectToString)
    return _objectToString;
  hasRequired_objectToString = 1;
  var objectProto2 = Object.prototype;
  var nativeObjectToString = objectProto2.toString;
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  _objectToString = objectToString;
  return _objectToString;
}
var _baseGetTag;
var hasRequired_baseGetTag;
function require_baseGetTag() {
  if (hasRequired_baseGetTag)
    return _baseGetTag;
  hasRequired_baseGetTag = 1;
  var Symbol2 = require_Symbol(), getRawTag = require_getRawTag(), objectToString = require_objectToString();
  var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  _baseGetTag = baseGetTag;
  return _baseGetTag;
}
var isObject_1;
var hasRequiredIsObject;
function requireIsObject() {
  if (hasRequiredIsObject)
    return isObject_1;
  hasRequiredIsObject = 1;
  function isObject2(value) {
    var type2 = typeof value;
    return value != null && (type2 == "object" || type2 == "function");
  }
  isObject_1 = isObject2;
  return isObject_1;
}
var isFunction_1;
var hasRequiredIsFunction;
function requireIsFunction() {
  if (hasRequiredIsFunction)
    return isFunction_1;
  hasRequiredIsFunction = 1;
  var baseGetTag = require_baseGetTag(), isObject2 = requireIsObject();
  var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
  function isFunction2(value) {
    if (!isObject2(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  isFunction_1 = isFunction2;
  return isFunction_1;
}
var root$1 = _root;
var coreJsData$1 = root$1["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource$1(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var _toSource = toSource$1;
var isFunction = requireIsFunction(), isMasked = _isMasked, isObject = requireIsObject(), toSource = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$2 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty$2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$1(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(object2, key) {
  return object2 == null ? void 0 : object2[key];
}
var _getValue = getValue$1;
var baseIsNative = _baseIsNative, getValue = _getValue;
function getNative$2(object2, key) {
  var value = getValue(object2, key);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$2;
var getNative$1 = _getNative;
var nativeCreate$4 = getNative$1(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function hashGet$1(key) {
  var data2 = this.__data__;
  if (nativeCreate$2) {
    var result = data2[key];
    return result === HASH_UNDEFINED$1 ? void 0 : result;
  }
  return hasOwnProperty$1.call(data2, key) ? data2[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function hashHas$1(key) {
  var data2 = this.__data__;
  return nativeCreate$1 ? data2[key] !== void 0 : hasOwnProperty.call(data2, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
  var data2 = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data2[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(entries2) {
  var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries2[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
var eq_1;
var hasRequiredEq;
function requireEq() {
  if (hasRequiredEq)
    return eq_1;
  hasRequiredEq = 1;
  function eq2(value, other) {
    return value === other || value !== value && other !== other;
  }
  eq_1 = eq2;
  return eq_1;
}
var eq = requireEq();
function assocIndexOf$4(array2, key) {
  var length2 = array2.length;
  while (length2--) {
    if (eq(array2[length2][0], key)) {
      return length2;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key) {
  var data2 = this.__data__, index2 = assocIndexOf$3(data2, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data2.length - 1;
  if (index2 == lastIndex) {
    data2.pop();
  } else {
    splice.call(data2, index2, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
  var data2 = this.__data__, index2 = assocIndexOf$2(data2, key);
  return index2 < 0 ? void 0 : data2[index2][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value) {
  var data2 = this.__data__, index2 = assocIndexOf(data2, key);
  if (index2 < 0) {
    ++this.size;
    data2.push([key, value]);
  } else {
    data2[index2][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$1(entries2) {
  var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries2[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache$1.prototype.clear = listCacheClear;
ListCache$1.prototype["delete"] = listCacheDelete;
ListCache$1.prototype.get = listCacheGet;
ListCache$1.prototype.has = listCacheHas;
ListCache$1.prototype.set = listCacheSet;
var _ListCache = ListCache$1;
var getNative = _getNative, root = _root;
var Map$2 = getNative(root, "Map");
var _Map = Map$2;
var Hash = _Hash, ListCache = _ListCache, Map$1 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$1 || ListCache)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type2 = typeof value;
  return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map2, key) {
  var data2 = map2.__data__;
  return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value) {
  var data2 = getMapData(this, key), size = data2.size;
  data2.set(key, value);
  this.size += data2.size == size ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$1(entries2) {
  var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries2[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache$1.prototype.clear = mapCacheClear;
MapCache$1.prototype["delete"] = mapCacheDelete;
MapCache$1.prototype.get = mapCacheGet;
MapCache$1.prototype.has = mapCacheHas;
MapCache$1.prototype.set = mapCacheSet;
var _MapCache = MapCache$1;
var MapCache = _MapCache;
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache2.set(key, result) || cache2;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
var memoize_1 = memoize;
const d3CurveTypes = {
  curveBasis,
  curveBasisClosed,
  curveBasisOpen,
  curveLinear: curveLinear$1,
  curveLinearClosed,
  curveMonotoneX: monotoneX$1,
  curveMonotoneY: monotoneY$1,
  curveNatural,
  curveStep,
  curveStepAfter: stepAfter$1,
  curveStepBefore: stepBefore$1
};
const directive = /[%]{2}[{]\s*(?:(?:(\w+)\s*:|(\w+))\s*(?:(?:(\w+))|((?:(?![}][%]{2}).|\r?\n)*))?\s*)(?:[}][%]{2})?/gi;
const directiveWithoutOpen = /\s*(?:(?:(\w+)(?=:):|(\w+))\s*(?:(?:(\w+))|((?:(?![}][%]{2}).|\r?\n)*))?\s*)(?:[}][%]{2})?/gi;
const detectInit = function(text2, config2) {
  const inits = detectDirective(text2, /(?:init\b)|(?:initialize\b)/);
  let results = {};
  if (Array.isArray(inits)) {
    const args = inits.map((init2) => init2.args);
    directiveSanitizer(args);
    results = assignWithDepth(results, [...args]);
  } else {
    results = inits.args;
  }
  if (results) {
    let type2 = detectType(text2, config2);
    ["config"].forEach((prop) => {
      if (typeof results[prop] !== "undefined") {
        if (type2 === "flowchart-v2") {
          type2 = "flowchart";
        }
        results[type2] = results[prop];
        delete results[prop];
      }
    });
  }
  return results;
};
const detectDirective = function(text2, type2 = null) {
  try {
    const commentWithoutDirectives = new RegExp(
      `[%]{2}(?![{]${directiveWithoutOpen.source})(?=[}][%]{2}).*
`,
      "ig"
    );
    text2 = text2.trim().replace(commentWithoutDirectives, "").replace(/'/gm, '"');
    log$1.debug(
      `Detecting diagram directive${type2 !== null ? " type:" + type2 : ""} based on the text:${text2}`
    );
    let match;
    const result = [];
    while ((match = directive.exec(text2)) !== null) {
      if (match.index === directive.lastIndex) {
        directive.lastIndex++;
      }
      if (match && !type2 || type2 && match[1] && match[1].match(type2) || type2 && match[2] && match[2].match(type2)) {
        const type22 = match[1] ? match[1] : match[2];
        const args = match[3] ? match[3].trim() : match[4] ? JSON.parse(match[4].trim()) : null;
        result.push({ type: type22, args });
      }
    }
    if (result.length === 0) {
      result.push({ type: text2, args: null });
    }
    return result.length === 1 ? result[0] : result;
  } catch (error) {
    log$1.error(
      `ERROR: ${error.message} - Unable to parse directive
      ${type2 !== null ? " type:" + type2 : ""} based on the text:${text2}`
    );
    return { type: null, args: null };
  }
};
const isSubstringInArray = function(str, arr) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i].match(str))
      return i;
  }
  return -1;
};
const interpolateToCurve = (interpolate2, defaultCurve) => {
  if (!interpolate2) {
    return defaultCurve;
  }
  const curveName = `curve${interpolate2.charAt(0).toUpperCase() + interpolate2.slice(1)}`;
  return d3CurveTypes[curveName] || defaultCurve;
};
const formatUrl = (linkStr, config2) => {
  const url = linkStr.trim();
  if (url) {
    if (config2.securityLevel !== "loose") {
      return sanitizeUrl_1(url);
    }
    return url;
  }
};
const runFunc = (functionName, ...params) => {
  const arrPaths = functionName.split(".");
  const len = arrPaths.length - 1;
  const fnName = arrPaths[len];
  let obj = window;
  for (let i = 0; i < len; i++) {
    obj = obj[arrPaths[i]];
    if (!obj)
      return;
  }
  obj[fnName](...params);
};
const distance = (p1, p2) => p1 && p2 ? Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2)) : 0;
const traverseEdge = (points) => {
  let prevPoint;
  let totalDistance2 = 0;
  points.forEach((point2) => {
    totalDistance2 += distance(point2, prevPoint);
    prevPoint = point2;
  });
  let remainingDistance = totalDistance2 / 2;
  let center2 = void 0;
  prevPoint = void 0;
  points.forEach((point2) => {
    if (prevPoint && !center2) {
      const vectorDistance = distance(point2, prevPoint);
      if (vectorDistance < remainingDistance) {
        remainingDistance -= vectorDistance;
      } else {
        const distanceRatio = remainingDistance / vectorDistance;
        if (distanceRatio <= 0)
          center2 = prevPoint;
        if (distanceRatio >= 1)
          center2 = { x: point2.x, y: point2.y };
        if (distanceRatio > 0 && distanceRatio < 1) {
          center2 = {
            x: (1 - distanceRatio) * prevPoint.x + distanceRatio * point2.x,
            y: (1 - distanceRatio) * prevPoint.y + distanceRatio * point2.y
          };
        }
      }
    }
    prevPoint = point2;
  });
  return center2;
};
const calcLabelPosition = (points) => {
  if (points.length === 1) {
    return points[0];
  }
  return traverseEdge(points);
};
const calcCardinalityPosition = (isRelationTypePresent, points, initialPosition) => {
  let prevPoint;
  log$1.info("our points", points);
  if (points[0] !== initialPosition) {
    points = points.reverse();
  }
  points.forEach((point2) => {
    totalDistance += distance(point2, prevPoint);
    prevPoint = point2;
  });
  const distanceToCardinalityPoint = 25;
  let remainingDistance = distanceToCardinalityPoint;
  let center2;
  prevPoint = void 0;
  points.forEach((point2) => {
    if (prevPoint && !center2) {
      const vectorDistance = distance(point2, prevPoint);
      if (vectorDistance < remainingDistance) {
        remainingDistance -= vectorDistance;
      } else {
        const distanceRatio = remainingDistance / vectorDistance;
        if (distanceRatio <= 0)
          center2 = prevPoint;
        if (distanceRatio >= 1)
          center2 = { x: point2.x, y: point2.y };
        if (distanceRatio > 0 && distanceRatio < 1) {
          center2 = {
            x: (1 - distanceRatio) * prevPoint.x + distanceRatio * point2.x,
            y: (1 - distanceRatio) * prevPoint.y + distanceRatio * point2.y
          };
        }
      }
    }
    prevPoint = point2;
  });
  const d = isRelationTypePresent ? 10 : 5;
  const angle2 = Math.atan2(points[0].y - center2.y, points[0].x - center2.x);
  const cardinalityPosition = { x: 0, y: 0 };
  cardinalityPosition.x = Math.sin(angle2) * d + (points[0].x + center2.x) / 2;
  cardinalityPosition.y = -Math.cos(angle2) * d + (points[0].y + center2.y) / 2;
  return cardinalityPosition;
};
const calcTerminalLabelPosition = (terminalMarkerSize, position2, _points) => {
  let points = JSON.parse(JSON.stringify(_points));
  let prevPoint;
  log$1.info("our points", points);
  if (position2 !== "start_left" && position2 !== "start_right") {
    points = points.reverse();
  }
  points.forEach((point2) => {
    prevPoint = point2;
  });
  const distanceToCardinalityPoint = 25 + terminalMarkerSize;
  let remainingDistance = distanceToCardinalityPoint;
  let center2;
  prevPoint = void 0;
  points.forEach((point2) => {
    if (prevPoint && !center2) {
      const vectorDistance = distance(point2, prevPoint);
      if (vectorDistance < remainingDistance) {
        remainingDistance -= vectorDistance;
      } else {
        const distanceRatio = remainingDistance / vectorDistance;
        if (distanceRatio <= 0)
          center2 = prevPoint;
        if (distanceRatio >= 1)
          center2 = { x: point2.x, y: point2.y };
        if (distanceRatio > 0 && distanceRatio < 1) {
          center2 = {
            x: (1 - distanceRatio) * prevPoint.x + distanceRatio * point2.x,
            y: (1 - distanceRatio) * prevPoint.y + distanceRatio * point2.y
          };
        }
      }
    }
    prevPoint = point2;
  });
  const d = 10 + terminalMarkerSize * 0.5;
  const angle2 = Math.atan2(points[0].y - center2.y, points[0].x - center2.x);
  const cardinalityPosition = { x: 0, y: 0 };
  cardinalityPosition.x = Math.sin(angle2) * d + (points[0].x + center2.x) / 2;
  cardinalityPosition.y = -Math.cos(angle2) * d + (points[0].y + center2.y) / 2;
  if (position2 === "start_left") {
    cardinalityPosition.x = Math.sin(angle2 + Math.PI) * d + (points[0].x + center2.x) / 2;
    cardinalityPosition.y = -Math.cos(angle2 + Math.PI) * d + (points[0].y + center2.y) / 2;
  }
  if (position2 === "end_right") {
    cardinalityPosition.x = Math.sin(angle2 - Math.PI) * d + (points[0].x + center2.x) / 2 - 5;
    cardinalityPosition.y = -Math.cos(angle2 - Math.PI) * d + (points[0].y + center2.y) / 2 - 5;
  }
  if (position2 === "end_left") {
    cardinalityPosition.x = Math.sin(angle2) * d + (points[0].x + center2.x) / 2 - 5;
    cardinalityPosition.y = -Math.cos(angle2) * d + (points[0].y + center2.y) / 2 - 5;
  }
  return cardinalityPosition;
};
const getStylesFromArray = (arr) => {
  let style2 = "";
  let labelStyle = "";
  for (let i = 0; i < arr.length; i++) {
    if (typeof arr[i] !== "undefined") {
      if (arr[i].startsWith("color:") || arr[i].startsWith("text-align:")) {
        labelStyle = labelStyle + arr[i] + ";";
      } else {
        style2 = style2 + arr[i] + ";";
      }
    }
  }
  return { style: style2, labelStyle };
};
let cnt$1 = 0;
const generateId$1 = () => {
  cnt$1++;
  return "id-" + Math.random().toString(36).substr(2, 12) + "-" + cnt$1;
};
function makeid(length2) {
  let result = "";
  const characters2 = "0123456789abcdef";
  const charactersLength = characters2.length;
  for (let i = 0; i < length2; i++) {
    result += characters2.charAt(Math.floor(Math.random() * charactersLength));
  }
  return result;
}
const random = (options2) => {
  return makeid(options2.length);
};
const getTextObj$3 = function() {
  return {
    x: 0,
    y: 0,
    fill: void 0,
    anchor: "start",
    style: "#666",
    width: 100,
    height: 100,
    textMargin: 0,
    rx: 0,
    ry: 0,
    valign: void 0
  };
};
const drawSimpleText = function(elem, textData) {
  const nText = textData.text.replace(common.lineBreakRegex, " ");
  const textElem = elem.append("text");
  textElem.attr("x", textData.x);
  textElem.attr("y", textData.y);
  textElem.style("text-anchor", textData.anchor);
  textElem.style("font-family", textData.fontFamily);
  textElem.style("font-size", textData.fontSize);
  textElem.style("font-weight", textData.fontWeight);
  textElem.attr("fill", textData.fill);
  if (typeof textData.class !== "undefined") {
    textElem.attr("class", textData.class);
  }
  const span = textElem.append("tspan");
  span.attr("x", textData.x + textData.textMargin * 2);
  span.attr("fill", textData.fill);
  span.text(nText);
  return textElem;
};
const wrapLabel = memoize_1(
  (label, maxWidth, config2) => {
    if (!label) {
      return label;
    }
    config2 = Object.assign(
      { fontSize: 12, fontWeight: 400, fontFamily: "Arial", joinWith: "<br/>" },
      config2
    );
    if (common.lineBreakRegex.test(label)) {
      return label;
    }
    const words = label.split(" ");
    const completedLines = [];
    let nextLine = "";
    words.forEach((word, index2) => {
      const wordLength = calculateTextWidth(`${word} `, config2);
      const nextLineLength = calculateTextWidth(nextLine, config2);
      if (wordLength > maxWidth) {
        const { hyphenatedStrings, remainingWord } = breakString(word, maxWidth, "-", config2);
        completedLines.push(nextLine, ...hyphenatedStrings);
        nextLine = remainingWord;
      } else if (nextLineLength + wordLength >= maxWidth) {
        completedLines.push(nextLine);
        nextLine = word;
      } else {
        nextLine = [nextLine, word].filter(Boolean).join(" ");
      }
      const currentWord = index2 + 1;
      const isLastWord = currentWord === words.length;
      if (isLastWord) {
        completedLines.push(nextLine);
      }
    });
    return completedLines.filter((line2) => line2 !== "").join(config2.joinWith);
  },
  (label, maxWidth, config2) => `${label}${maxWidth}${config2.fontSize}${config2.fontWeight}${config2.fontFamily}${config2.joinWith}`
);
const breakString = memoize_1(
  (word, maxWidth, hyphenCharacter = "-", config2) => {
    config2 = Object.assign(
      { fontSize: 12, fontWeight: 400, fontFamily: "Arial", margin: 0 },
      config2
    );
    const characters2 = word.split("");
    const lines = [];
    let currentLine = "";
    characters2.forEach((character2, index2) => {
      const nextLine = `${currentLine}${character2}`;
      const lineWidth = calculateTextWidth(nextLine, config2);
      if (lineWidth >= maxWidth) {
        const currentCharacter = index2 + 1;
        const isLastLine = characters2.length === currentCharacter;
        const hyphenatedNextLine = `${nextLine}${hyphenCharacter}`;
        lines.push(isLastLine ? nextLine : hyphenatedNextLine);
        currentLine = "";
      } else {
        currentLine = nextLine;
      }
    });
    return { hyphenatedStrings: lines, remainingWord: currentLine };
  },
  (word, maxWidth, hyphenCharacter = "-", config2) => `${word}${maxWidth}${hyphenCharacter}${config2.fontSize}${config2.fontWeight}${config2.fontFamily}`
);
const calculateTextHeight = function(text2, config2) {
  config2 = Object.assign(
    { fontSize: 12, fontWeight: 400, fontFamily: "Arial", margin: 15 },
    config2
  );
  return calculateTextDimensions(text2, config2).height;
};
const calculateTextWidth = function(text2, config2) {
  config2 = Object.assign({ fontSize: 12, fontWeight: 400, fontFamily: "Arial" }, config2);
  return calculateTextDimensions(text2, config2).width;
};
const calculateTextDimensions = memoize_1(
  function(text2, config2) {
    config2 = Object.assign({ fontSize: 12, fontWeight: 400, fontFamily: "Arial" }, config2);
    const { fontSize, fontFamily, fontWeight } = config2;
    if (!text2) {
      return { width: 0, height: 0 };
    }
    const fontFamilies = ["sans-serif", fontFamily];
    const lines = text2.split(common.lineBreakRegex);
    const dims = [];
    const body = select$1("body");
    if (!body.remove) {
      return { width: 0, height: 0, lineHeight: 0 };
    }
    const g2 = body.append("svg");
    for (const fontFamily2 of fontFamilies) {
      let cheight = 0;
      const dim = { width: 0, height: 0, lineHeight: 0 };
      for (const line2 of lines) {
        const textObj = getTextObj$3();
        textObj.text = line2;
        const textElem = drawSimpleText(g2, textObj).style("font-size", fontSize).style("font-weight", fontWeight).style("font-family", fontFamily2);
        const bBox = (textElem._groups || textElem)[0][0].getBBox();
        dim.width = Math.round(Math.max(dim.width, bBox.width));
        cheight = Math.round(bBox.height);
        dim.height += cheight;
        dim.lineHeight = Math.round(Math.max(dim.lineHeight, cheight));
      }
      dims.push(dim);
    }
    g2.remove();
    const index2 = isNaN(dims[1].height) || isNaN(dims[1].width) || isNaN(dims[1].lineHeight) || dims[0].height > dims[1].height && dims[0].width > dims[1].width && dims[0].lineHeight > dims[1].lineHeight ? 0 : 1;
    return dims[index2];
  },
  (text2, config2) => `${text2}${config2.fontSize}${config2.fontWeight}${config2.fontFamily}`
);
const initIdGenerator = class iterator {
  constructor(deterministic, seed) {
    this.deterministic = deterministic;
    this.seed = seed;
    this.count = seed ? seed.length : 0;
  }
  next() {
    if (!this.deterministic)
      return Date.now();
    return this.count++;
  }
};
let decoder;
const entityDecode = function(html2) {
  decoder = decoder || document.createElement("div");
  html2 = escape(html2).replace(/%26/g, "&").replace(/%23/g, "#").replace(/%3B/g, ";");
  decoder.innerHTML = html2;
  return unescape(decoder.textContent);
};
const directiveSanitizer = (args) => {
  log$1.debug("directiveSanitizer called with", args);
  if (typeof args === "object") {
    if (args.length) {
      args.forEach((arg) => directiveSanitizer(arg));
    } else {
      Object.keys(args).forEach((key) => {
        log$1.debug("Checking key", key);
        if (key.indexOf("__") === 0) {
          log$1.debug("sanitize deleting __ option", key);
          delete args[key];
        }
        if (key.indexOf("proto") >= 0) {
          log$1.debug("sanitize deleting proto option", key);
          delete args[key];
        }
        if (key.indexOf("constr") >= 0) {
          log$1.debug("sanitize deleting constr option", key);
          delete args[key];
        }
        if (key.indexOf("themeCSS") >= 0) {
          log$1.debug("sanitizing themeCss option");
          args[key] = sanitizeCss(args[key]);
        }
        if (key.indexOf("fontFamily") >= 0) {
          log$1.debug("sanitizing fontFamily option");
          args[key] = sanitizeCss(args[key]);
        }
        if (key.indexOf("altFontFamily") >= 0) {
          log$1.debug("sanitizing altFontFamily option");
          args[key] = sanitizeCss(args[key]);
        }
        if (configKeys.indexOf(key) < 0) {
          log$1.debug("sanitize deleting option", key);
          delete args[key];
        } else {
          if (typeof args[key] === "object") {
            log$1.debug("sanitize deleting object", key);
            directiveSanitizer(args[key]);
          }
        }
      });
    }
  }
  if (args.themeVariables) {
    const kArr = Object.keys(args.themeVariables);
    for (let i = 0; i < kArr.length; i++) {
      const k2 = kArr[i];
      const val = args.themeVariables[k2];
      if (val && val.match && !val.match(/^[a-zA-Z0-9#,";()%. ]+$/)) {
        args.themeVariables[k2] = "";
      }
    }
  }
  log$1.debug("After sanitization", args);
};
const sanitizeCss = (str) => {
  let startCnt2 = 0;
  let endCnt = 0;
  for (let i = 0; i < str.length; i++) {
    if (startCnt2 < endCnt) {
      return "{ /* ERROR: Unbalanced CSS */ }";
    }
    if (str[i] === "{") {
      startCnt2++;
    } else if (str[i] === "}") {
      endCnt++;
    }
  }
  if (startCnt2 !== endCnt) {
    return "{ /* ERROR: Unbalanced CSS */ }";
  }
  return str;
};
function isDetailedError(error) {
  return "str" in error;
}
function getErrorMessage(error) {
  if (error instanceof Error)
    return error.message;
  return String(error);
}
const utils = {
  assignWithDepth,
  wrapLabel,
  calculateTextHeight,
  calculateTextWidth,
  calculateTextDimensions,
  detectInit,
  detectDirective,
  isSubstringInArray,
  interpolateToCurve,
  calcLabelPosition,
  calcCardinalityPosition,
  calcTerminalLabelPosition,
  formatUrl,
  getStylesFromArray,
  generateId: generateId$1,
  random,
  runFunc,
  entityDecode,
  initIdGenerator,
  directiveSanitizer,
  sanitizeCss
};
const name = "mermaid";
const version$1 = "9.2.0";
const description$1 = "Markdownish syntax for generating flowcharts, sequence diagrams, class diagrams, gantt charts and git graphs.";
const main = "./dist/mermaid.core.mjs";
const module = "./dist/mermaid.core.mjs";
const types = "./dist/mermaid.d.ts";
const type = "module";
const exports = {
  ".": {
    require: "./dist/mermaid.min.js",
    "import": "./dist/mermaid.core.mjs",
    types: "./dist/mermaid.d.ts"
  },
  "./*": "./*"
};
const keywords = [
  "diagram",
  "markdown",
  "flowchart",
  "sequence diagram",
  "gantt",
  "class diagram",
  "git graph"
];
const scripts = {
  clean: "rimraf dist",
  "build:code": "node .esbuild/esbuild.cjs",
  "build:types": "tsc -p ./tsconfig.json --emitDeclarationOnly",
  "build:watch": "yarn build:code --watch",
  "build:esbuild": 'concurrently "yarn build:code" "yarn build:types"',
  build: "yarn clean; yarn build:esbuild",
  dev: "node .esbuild/serve.cjs",
  "docs:build": "ts-node-esm src/docs.mts",
  "docs:verify": "yarn docs:build --verify",
  "todo-postbuild": "documentation build src/mermaidAPI.ts src/config.ts src/defaultConfig.ts --shallow -f md --markdown-toc false > src/docs/Setup.md && prettier --write src/docs/Setup.md",
  release: "yarn build",
  lint: "eslint --cache --ignore-path .gitignore . && yarn lint:jison && prettier --check .",
  "lint:fix": "eslint --fix --ignore-path .gitignore . && prettier --write .",
  "lint:jison": "ts-node-esm src/jison/lint.mts",
  cypress: "cypress run",
  "cypress:open": "cypress open",
  e2e: "start-server-and-test dev http://localhost:9000/ cypress",
  "todo-prepare": 'concurrently "husky install" "yarn build"',
  "pre-commit": "lint-staged"
};
const repository = {
  type: "git",
  url: "https://github.com/mermaid-js/mermaid"
};
const author = "Knut Sveidqvist";
const license = "MIT";
const standard = {
  ignore: [
    "**/parser/*.js",
    "dist/**/*.js",
    "cypress/**/*.js"
  ],
  globals: [
    "page"
  ]
};
const dependencies = {
  "@braintree/sanitize-url": "^6.0.0",
  d3: "^7.0.0",
  dagre: "^0.8.5",
  "dagre-d3": "^0.6.4",
  dompurify: "2.4.0",
  "fast-clone": "^1.5.13",
  graphlib: "^2.1.8",
  khroma: "^2.0.0",
  lodash: "^4.17.21",
  "moment-mini": "^2.24.0",
  "non-layered-tidy-tree-layout": "^2.0.2",
  stylis: "^4.1.2",
  uuid: "^9.0.0"
};
const devDependencies = {
  "@applitools/eyes-cypress": "^3.25.7",
  "@commitlint/cli": "^17.1.2",
  "@commitlint/config-conventional": "^17.0.0",
  "@types/d3": "^7.4.0",
  "@types/dompurify": "^2.3.4",
  "@types/eslint": "^8.4.6",
  "@types/express": "^4.17.13",
  "@types/jsdom": "^20.0.0",
  "@types/lodash": "^4.14.185",
  "@types/prettier": "^2.7.0",
  "@types/stylis": "^4.0.2",
  "@types/uuid": "^8.3.4",
  "@typescript-eslint/eslint-plugin": "^5.37.0",
  "@typescript-eslint/parser": "^5.37.0",
  concurrently: "^7.4.0",
  coveralls: "^3.1.1",
  cypress: "^10.0.0",
  "cypress-image-snapshot": "^4.0.1",
  documentation: "13.2.0",
  esbuild: "^0.15.8",
  eslint: "^8.23.1",
  "eslint-config-prettier": "^8.5.0",
  "eslint-plugin-cypress": "^2.12.1",
  "eslint-plugin-html": "^7.1.0",
  "eslint-plugin-jest": "^27.0.4",
  "eslint-plugin-jsdoc": "^39.3.6",
  "eslint-plugin-json": "^3.1.0",
  "eslint-plugin-markdown": "^3.0.0",
  express: "^4.18.1",
  globby: "^13.1.2",
  husky: "^8.0.0",
  "identity-obj-proxy": "^3.0.0",
  jison: "^0.4.18",
  "js-base64": "3.7.2",
  jsdom: "^20.0.0",
  "lint-staged": "^13.0.0",
  moment: "^2.23.0",
  "path-browserify": "^1.0.1",
  prettier: "^2.7.1",
  "prettier-plugin-jsdoc": "^0.4.2",
  remark: "^14.0.2",
  rimraf: "^3.0.2",
  "start-server-and-test": "^1.12.6",
  "ts-node": "^10.9.1",
  typescript: "^4.8.3",
  "unist-util-flatmap": "^1.0.0"
};
const resolutions = {
  d3: "^7.0.0"
};
const files = [
  "dist"
];
const sideEffects = [
  "**/*.css",
  "**/*.scss"
];
const pkg = {
  name,
  version: version$1,
  description: description$1,
  main,
  module,
  types,
  type,
  exports,
  keywords,
  scripts,
  repository,
  author,
  license,
  standard,
  dependencies,
  devDependencies,
  resolutions,
  files,
  sideEffects
};
const defaultConfig = Object.freeze(config$1);
let siteConfig = assignWithDepth({}, defaultConfig);
let configFromInitialize;
let directives = [];
let currentConfig = assignWithDepth({}, defaultConfig);
const updateCurrentConfig = (siteCfg, _directives) => {
  let cfg = assignWithDepth({}, siteCfg);
  let sumOfDirectives = {};
  for (let i = 0; i < _directives.length; i++) {
    const d = _directives[i];
    sanitize(d);
    sumOfDirectives = assignWithDepth(sumOfDirectives, d);
  }
  cfg = assignWithDepth(cfg, sumOfDirectives);
  if (sumOfDirectives.theme && sumOfDirectives.theme in theme$3) {
    const tmpConfigFromInitialize = assignWithDepth({}, configFromInitialize);
    const themeVariables = assignWithDepth(
      tmpConfigFromInitialize.themeVariables || {},
      sumOfDirectives.themeVariables
    );
    if (cfg.theme && cfg.theme in theme$3) {
      cfg.themeVariables = theme$3[cfg.theme].getThemeVariables(themeVariables);
    }
  }
  currentConfig = cfg;
  return cfg;
};
const setSiteConfig = (conf2) => {
  siteConfig = assignWithDepth({}, defaultConfig);
  siteConfig = assignWithDepth(siteConfig, conf2);
  if (conf2.theme && theme$3[conf2.theme]) {
    siteConfig.themeVariables = theme$3[conf2.theme].getThemeVariables(conf2.themeVariables);
  }
  currentConfig = updateCurrentConfig(siteConfig, directives);
  return siteConfig;
};
const saveConfigFromInitialize = (conf2) => {
  configFromInitialize = assignWithDepth({}, conf2);
};
const updateSiteConfig = (conf2) => {
  siteConfig = assignWithDepth(siteConfig, conf2);
  updateCurrentConfig(siteConfig, directives);
  return siteConfig;
};
const getSiteConfig = () => {
  return assignWithDepth({}, siteConfig);
};
const setConfig = (conf2) => {
  assignWithDepth(currentConfig, conf2);
  return getConfig$1();
};
const getConfig$1 = () => {
  return assignWithDepth({}, currentConfig);
};
const sanitize = (options2) => {
  var _a2;
  ["secure", ...(_a2 = siteConfig.secure) != null ? _a2 : []].forEach((key) => {
    if (typeof options2[key] !== "undefined") {
      log$1.debug(`Denied attempt to modify a secure key ${key}`, options2[key]);
      delete options2[key];
    }
  });
  Object.keys(options2).forEach((key) => {
    if (key.indexOf("__") === 0) {
      delete options2[key];
    }
  });
  Object.keys(options2).forEach((key) => {
    if (typeof options2[key] === "string") {
      if (options2[key].indexOf("<") > -1 || options2[key].indexOf(">") > -1 || options2[key].indexOf("url(data:") > -1) {
        delete options2[key];
      }
    }
    if (typeof options2[key] === "object") {
      sanitize(options2[key]);
    }
  });
};
const addDirective = (directive2) => {
  if (directive2.fontFamily) {
    if (!directive2.themeVariables) {
      directive2.themeVariables = { fontFamily: directive2.fontFamily };
    } else {
      if (!directive2.themeVariables.fontFamily) {
        directive2.themeVariables = { fontFamily: directive2.fontFamily };
      }
    }
  }
  directives.push(directive2);
  updateCurrentConfig(siteConfig, directives);
};
const reset = (config2 = siteConfig) => {
  directives = [];
  updateCurrentConfig(config2, directives);
};
const d3Attrs = function(d3Elem, attrs) {
  for (let attr of attrs) {
    d3Elem.attr(attr[0], attr[1]);
  }
};
const calculateSvgSizeAttrs = function(height2, width2, useMaxWidth) {
  let attrs = /* @__PURE__ */ new Map();
  if (useMaxWidth) {
    attrs.set("width", "100%");
    attrs.set("style", `max-width: ${width2}px;`);
  } else {
    attrs.set("width", width2);
  }
  return attrs;
};
const configureSvgSize = function(svgElem, height2, width2, useMaxWidth) {
  const attrs = calculateSvgSizeAttrs(height2, width2, useMaxWidth);
  d3Attrs(svgElem, attrs);
};
const setupGraphViewbox$1 = function(graph2, svgElem, padding2, useMaxWidth) {
  const svgBounds = svgElem.node().getBBox();
  const sWidth = svgBounds.width;
  const sHeight = svgBounds.height;
  log$1.info(`SVG bounds: ${sWidth}x${sHeight}`, svgBounds);
  let width2 = 0;
  let height2 = 0;
  log$1.info(`Graph bounds: ${width2}x${height2}`, graph2);
  width2 = sWidth + padding2 * 2;
  height2 = sHeight + padding2 * 2;
  log$1.info(`Calculated bounds: ${width2}x${height2}`);
  configureSvgSize(svgElem, height2, width2, useMaxWidth);
  const vBox = `${svgBounds.x - padding2} ${svgBounds.y - padding2} ${svgBounds.width + 2 * padding2} ${svgBounds.height + 2 * padding2}`;
  svgElem.attr("viewBox", vBox);
};
const getStyles$d = (options2) => `g.classGroup text {
  fill: ${options2.nodeBorder};
  fill: ${options2.classText};
  stroke: none;
  font-family: ${options2.fontFamily};
  font-size: 10px;

  .title {
    font-weight: bolder;
  }

}

.nodeLabel, .edgeLabel {
  color: ${options2.classText};
}
.edgeLabel .label rect {
  fill: ${options2.mainBkg};
}
.label text {
  fill: ${options2.classText};
}
.edgeLabel .label span {
  background: ${options2.mainBkg};
}

.classTitle {
  font-weight: bolder;
}
.node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${options2.mainBkg};
    stroke: ${options2.nodeBorder};
    stroke-width: 1px;
  }


.divider {
  stroke: ${options2.nodeBorder};
  stroke: 1;
}

g.clickable {
  cursor: pointer;
}

g.classGroup rect {
  fill: ${options2.mainBkg};
  stroke: ${options2.nodeBorder};
}

g.classGroup line {
  stroke: ${options2.nodeBorder};
  stroke-width: 1;
}

.classLabel .box {
  stroke: none;
  stroke-width: 0;
  fill: ${options2.mainBkg};
  opacity: 0.5;
}

.classLabel .label {
  fill: ${options2.nodeBorder};
  font-size: 10px;
}

.relation {
  stroke: ${options2.lineColor};
  stroke-width: 1;
  fill: none;
}

.dashed-line{
  stroke-dasharray: 3;
}

#compositionStart, .composition {
  fill: ${options2.lineColor} !important;
  stroke: ${options2.lineColor} !important;
  stroke-width: 1;
}

#compositionEnd, .composition {
  fill: ${options2.lineColor} !important;
  stroke: ${options2.lineColor} !important;
  stroke-width: 1;
}

#dependencyStart, .dependency {
  fill: ${options2.lineColor} !important;
  stroke: ${options2.lineColor} !important;
  stroke-width: 1;
}

#dependencyStart, .dependency {
  fill: ${options2.lineColor} !important;
  stroke: ${options2.lineColor} !important;
  stroke-width: 1;
}

#extensionStart, .extension {
  fill: ${options2.lineColor} !important;
  stroke: ${options2.lineColor} !important;
  stroke-width: 1;
}

#extensionEnd, .extension {
  fill: ${options2.lineColor} !important;
  stroke: ${options2.lineColor} !important;
  stroke-width: 1;
}

#aggregationStart, .aggregation {
  fill: ${options2.mainBkg} !important;
  stroke: ${options2.lineColor} !important;
  stroke-width: 1;
}

#aggregationEnd, .aggregation {
  fill: ${options2.mainBkg} !important;
  stroke: ${options2.lineColor} !important;
  stroke-width: 1;
}

#lollipopStart, .lollipop {
  fill: ${options2.mainBkg} !important;
  stroke: ${options2.lineColor} !important;
  stroke-width: 1;
}

#lollipopEnd, .lollipop {
  fill: ${options2.mainBkg} !important;
  stroke: ${options2.lineColor} !important;
  stroke-width: 1;
}

.edgeTerminals {
  font-size: 11px;
}

`;
const getStyles$c = (options2) => `
  .entityBox {
    fill: ${options2.mainBkg};
    stroke: ${options2.nodeBorder};
  }

  .attributeBoxOdd {
    fill: ${options2.attributeBackgroundColorOdd};
    stroke: ${options2.nodeBorder};
  }

  .attributeBoxEven {
    fill:  ${options2.attributeBackgroundColorEven};
    stroke: ${options2.nodeBorder};
  }

  .relationshipLabelBox {
    fill: ${options2.tertiaryColor};
    opacity: 0.7;
    background-color: ${options2.tertiaryColor};
      rect {
        opacity: 0.5;
      }
  }

    .relationshipLine {
      stroke: ${options2.lineColor};
    }
`;
const getStyles$b = () => ``;
const getStyles$a = (options2) => `.label {
    font-family: ${options2.fontFamily};
    color: ${options2.nodeTextColor || options2.textColor};
  }
  .cluster-label text {
    fill: ${options2.titleColor};
  }
  .cluster-label span {
    color: ${options2.titleColor};
  }

  .label text,span {
    fill: ${options2.nodeTextColor || options2.textColor};
    color: ${options2.nodeTextColor || options2.textColor};
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${options2.mainBkg};
    stroke: ${options2.nodeBorder};
    stroke-width: 1px;
  }

  .node .label {
    text-align: center;
  }
  .node.clickable {
    cursor: pointer;
  }

  .arrowheadPath {
    fill: ${options2.arrowheadColor};
  }

  .edgePath .path {
    stroke: ${options2.lineColor};
    stroke-width: 2.0px;
  }

  .flowchart-link {
    stroke: ${options2.lineColor};
    fill: none;
  }

  .edgeLabel {
    background-color: ${options2.edgeLabelBackground};
    rect {
      opacity: 0.5;
      background-color: ${options2.edgeLabelBackground};
      fill: ${options2.edgeLabelBackground};
    }
    text-align: center;
  }

  .cluster rect {
    fill: ${options2.clusterBkg};
    stroke: ${options2.clusterBorder};
    stroke-width: 1px;
  }

  .cluster text {
    fill: ${options2.titleColor};
  }

  .cluster span {
    color: ${options2.titleColor};
  }
  /* .cluster div {
    color: ${options2.titleColor};
  } */

  div.mermaidTooltip {
    position: absolute;
    text-align: center;
    max-width: 200px;
    padding: 2px;
    font-family: ${options2.fontFamily};
    font-size: 12px;
    background: ${options2.tertiaryColor};
    border: 1px solid ${options2.border2};
    border-radius: 2px;
    pointer-events: none;
    z-index: 100;
  }
`;
const getStyles$9 = (options2) => `
  .mermaid-main-font {
    font-family: "trebuchet ms", verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
  }
  .exclude-range {
    fill: ${options2.excludeBkgColor};
  }

  .section {
    stroke: none;
    opacity: 0.2;
  }

  .section0 {
    fill: ${options2.sectionBkgColor};
  }

  .section2 {
    fill: ${options2.sectionBkgColor2};
  }

  .section1,
  .section3 {
    fill: ${options2.altSectionBkgColor};
    opacity: 0.2;
  }

  .sectionTitle0 {
    fill: ${options2.titleColor};
  }

  .sectionTitle1 {
    fill: ${options2.titleColor};
  }

  .sectionTitle2 {
    fill: ${options2.titleColor};
  }

  .sectionTitle3 {
    fill: ${options2.titleColor};
  }

  .sectionTitle {
    text-anchor: start;
    // font-size: ${options2.ganttFontSize};
    // text-height: 14px;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);

  }


  /* Grid and axis */

  .grid .tick {
    stroke: ${options2.gridColor};
    opacity: 0.8;
    shape-rendering: crispEdges;
    text {
      font-family: ${options2.fontFamily};
      fill: ${options2.textColor};
    }
  }

  .grid path {
    stroke-width: 0;
  }


  /* Today line */

  .today {
    fill: none;
    stroke: ${options2.todayLineColor};
    stroke-width: 2px;
  }


  /* Task styling */

  /* Default task */

  .task {
    stroke-width: 2;
  }

  .taskText {
    text-anchor: middle;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
  }

  // .taskText:not([font-size]) {
  //   font-size: ${options2.ganttFontSize};
  // }

  .taskTextOutsideRight {
    fill: ${options2.taskTextDarkColor};
    text-anchor: start;
    // font-size: ${options2.ganttFontSize};
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);

  }

  .taskTextOutsideLeft {
    fill: ${options2.taskTextDarkColor};
    text-anchor: end;
    // font-size: ${options2.ganttFontSize};
  }

  /* Special case clickable */
  .task.clickable {
    cursor: pointer;
  }
  .taskText.clickable {
    cursor: pointer;
    fill: ${options2.taskTextClickableColor} !important;
    font-weight: bold;
  }

  .taskTextOutsideLeft.clickable {
    cursor: pointer;
    fill: ${options2.taskTextClickableColor} !important;
    font-weight: bold;
  }

  .taskTextOutsideRight.clickable {
    cursor: pointer;
    fill: ${options2.taskTextClickableColor} !important;
    font-weight: bold;
  }

  /* Specific task settings for the sections*/

  .taskText0,
  .taskText1,
  .taskText2,
  .taskText3 {
    fill: ${options2.taskTextColor};
  }

  .task0,
  .task1,
  .task2,
  .task3 {
    fill: ${options2.taskBkgColor};
    stroke: ${options2.taskBorderColor};
  }

  .taskTextOutside0,
  .taskTextOutside2
  {
    fill: ${options2.taskTextOutsideColor};
  }

  .taskTextOutside1,
  .taskTextOutside3 {
    fill: ${options2.taskTextOutsideColor};
  }


  /* Active task */

  .active0,
  .active1,
  .active2,
  .active3 {
    fill: ${options2.activeTaskBkgColor};
    stroke: ${options2.activeTaskBorderColor};
  }

  .activeText0,
  .activeText1,
  .activeText2,
  .activeText3 {
    fill: ${options2.taskTextDarkColor} !important;
  }


  /* Completed task */

  .done0,
  .done1,
  .done2,
  .done3 {
    stroke: ${options2.doneTaskBorderColor};
    fill: ${options2.doneTaskBkgColor};
    stroke-width: 2;
  }

  .doneText0,
  .doneText1,
  .doneText2,
  .doneText3 {
    fill: ${options2.taskTextDarkColor} !important;
  }


  /* Tasks on the critical line */

  .crit0,
  .crit1,
  .crit2,
  .crit3 {
    stroke: ${options2.critBorderColor};
    fill: ${options2.critBkgColor};
    stroke-width: 2;
  }

  .activeCrit0,
  .activeCrit1,
  .activeCrit2,
  .activeCrit3 {
    stroke: ${options2.critBorderColor};
    fill: ${options2.activeTaskBkgColor};
    stroke-width: 2;
  }

  .doneCrit0,
  .doneCrit1,
  .doneCrit2,
  .doneCrit3 {
    stroke: ${options2.critBorderColor};
    fill: ${options2.doneTaskBkgColor};
    stroke-width: 2;
    cursor: pointer;
    shape-rendering: crispEdges;
  }

  .milestone {
    transform: rotate(45deg) scale(0.8,0.8);
  }

  .milestoneText {
    font-style: italic;
  }
  .doneCritText0,
  .doneCritText1,
  .doneCritText2,
  .doneCritText3 {
    fill: ${options2.taskTextDarkColor} !important;
  }

  .activeCritText0,
  .activeCritText1,
  .activeCritText2,
  .activeCritText3 {
    fill: ${options2.taskTextDarkColor} !important;
  }

  .titleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${options2.textColor}    ;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
  }
`;
const getStyles$8 = () => ``;
const getStyles$7 = (options2) => `
  .pieCircle{
    stroke: ${options2.pieStrokeColor};
    stroke-width : ${options2.pieStrokeWidth};
    opacity : ${options2.pieOpacity};
  }
  .pieTitleText {
    text-anchor: middle;
    font-size: ${options2.pieTitleTextSize};
    fill: ${options2.pieTitleTextColor};
    font-family: ${options2.fontFamily};
  }
  .slice {
    font-family: ${options2.fontFamily};
    fill: ${options2.pieSectionTextColor};
    font-size:${options2.pieSectionTextSize};
    // fill: white;
  }
  .legend text {
    fill: ${options2.pieLegendTextColor};
    font-family: ${options2.fontFamily};
    font-size: ${options2.pieLegendTextSize};
  }
`;
const getStyles$6 = (options2) => `

  marker {
    fill: ${options2.relationColor};
    stroke: ${options2.relationColor};
  }

  marker.cross {
    stroke: ${options2.lineColor};
  }

  svg {
    font-family: ${options2.fontFamily};
    font-size: ${options2.fontSize};
  }

  .reqBox {
    fill: ${options2.requirementBackground};
    fill-opacity: 100%;
    stroke: ${options2.requirementBorderColor};
    stroke-width: ${options2.requirementBorderSize};
  }
  
  .reqTitle, .reqLabel{
    fill:  ${options2.requirementTextColor};
  }
  .reqLabelBox {
    fill: ${options2.relationLabelBackground};
    fill-opacity: 100%;
  }

  .req-title-line {
    stroke: ${options2.requirementBorderColor};
    stroke-width: ${options2.requirementBorderSize};
  }
  .relationshipLine {
    stroke: ${options2.relationColor};
    stroke-width: 1;
  }
  .relationshipLabel {
    fill: ${options2.relationLabelColor};
  }

`;
const getStyles$5 = (options2) => `.actor {
    stroke: ${options2.actorBorder};
    fill: ${options2.actorBkg};
  }

  text.actor > tspan {
    fill: ${options2.actorTextColor};
    stroke: none;
  }

  .actor-line {
    stroke: ${options2.actorLineColor};
  }

  .messageLine0 {
    stroke-width: 1.5;
    stroke-dasharray: none;
    stroke: ${options2.signalColor};
  }

  .messageLine1 {
    stroke-width: 1.5;
    stroke-dasharray: 2, 2;
    stroke: ${options2.signalColor};
  }

  #arrowhead path {
    fill: ${options2.signalColor};
    stroke: ${options2.signalColor};
  }

  .sequenceNumber {
    fill: ${options2.sequenceNumberColor};
  }

  #sequencenumber {
    fill: ${options2.signalColor};
  }

  #crosshead path {
    fill: ${options2.signalColor};
    stroke: ${options2.signalColor};
  }

  .messageText {
    fill: ${options2.signalTextColor};
    stroke: none;
  }

  .labelBox {
    stroke: ${options2.labelBoxBorderColor};
    fill: ${options2.labelBoxBkgColor};
  }

  .labelText, .labelText > tspan {
    fill: ${options2.labelTextColor};
    stroke: none;
  }

  .loopText, .loopText > tspan {
    fill: ${options2.loopTextColor};
    stroke: none;
  }

  .loopLine {
    stroke-width: 2px;
    stroke-dasharray: 2, 2;
    stroke: ${options2.labelBoxBorderColor};
    fill: ${options2.labelBoxBorderColor};
  }

  .note {
    //stroke: #decc93;
    stroke: ${options2.noteBorderColor};
    fill: ${options2.noteBkgColor};
  }

  .noteText, .noteText > tspan {
    fill: ${options2.noteTextColor};
    stroke: none;
  }

  .activation0 {
    fill: ${options2.activationBkgColor};
    stroke: ${options2.activationBorderColor};
  }

  .activation1 {
    fill: ${options2.activationBkgColor};
    stroke: ${options2.activationBorderColor};
  }

  .activation2 {
    fill: ${options2.activationBkgColor};
    stroke: ${options2.activationBorderColor};
  }

  .actorPopupMenu {
    position: absolute;
  }

  .actorPopupMenuPanel {
    position: absolute;
    fill: ${options2.actorBkg};
    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
    filter: drop-shadow(3px 5px 2px rgb(0 0 0 / 0.4));
}
  .actor-man line {
    stroke: ${options2.actorBorder};
    fill: ${options2.actorBkg};
  }
  .actor-man circle, line {
    stroke: ${options2.actorBorder};
    fill: ${options2.actorBkg};
    stroke-width: 2px;
  }
`;
const getStyles$4 = (options2) => `
defs #statediagram-barbEnd {
    fill: ${options2.transitionColor};
    stroke: ${options2.transitionColor};
  }
g.stateGroup text {
  fill: ${options2.nodeBorder};
  stroke: none;
  font-size: 10px;
}
g.stateGroup text {
  fill: ${options2.textColor};
  stroke: none;
  font-size: 10px;

}
g.stateGroup .state-title {
  font-weight: bolder;
  fill: ${options2.stateLabelColor};
}

g.stateGroup rect {
  fill: ${options2.mainBkg};
  stroke: ${options2.nodeBorder};
}

g.stateGroup line {
  stroke: ${options2.lineColor};
  stroke-width: 1;
}

.transition {
  stroke: ${options2.transitionColor};
  stroke-width: 1;
  fill: none;
}

.stateGroup .composit {
  fill: ${options2.background};
  border-bottom: 1px
}

.stateGroup .alt-composit {
  fill: #e0e0e0;
  border-bottom: 1px
}

.state-note {
  stroke: ${options2.noteBorderColor};
  fill: ${options2.noteBkgColor};

  text {
    fill: ${options2.noteTextColor};
    stroke: none;
    font-size: 10px;
  }
}

.stateLabel .box {
  stroke: none;
  stroke-width: 0;
  fill: ${options2.mainBkg};
  opacity: 0.5;
}

.edgeLabel .label rect {
  fill: ${options2.labelBackgroundColor};
  opacity: 0.5;
}
.edgeLabel .label text {
  fill: ${options2.transitionLabelColor || options2.tertiaryTextColor};
}
.label div .edgeLabel {
  color: ${options2.transitionLabelColor || options2.tertiaryTextColor};
}

.stateLabel text {
  fill: ${options2.stateLabelColor};
  font-size: 10px;
  font-weight: bold;
}

.node circle.state-start {
  fill: ${options2.specialStateColor};
  stroke: ${options2.specialStateColor};
}

.node .fork-join {
  fill: ${options2.specialStateColor};
  stroke: ${options2.specialStateColor};
}

.node circle.state-end {
  fill: ${options2.innerEndBackground};
  stroke: ${options2.background};
  stroke-width: 1.5
}
.end-state-inner {
  fill: ${options2.compositeBackground || options2.background};
  // stroke: ${options2.background};
  stroke-width: 1.5
}

.node rect {
  fill: ${options2.stateBkg || options2.mainBkg};
  stroke: ${options2.stateBorder || options2.nodeBorder};
  stroke-width: 1px;
}
.node polygon {
  fill: ${options2.mainBkg};
  stroke: ${options2.stateBorder || options2.nodeBorder};;
  stroke-width: 1px;
}
#statediagram-barbEnd {
  fill: ${options2.lineColor};
}

.statediagram-cluster rect {
  fill: ${options2.compositeTitleBackground};
  stroke: ${options2.stateBorder || options2.nodeBorder};
  stroke-width: 1px;
}

.cluster-label, .nodeLabel {
  color: ${options2.stateLabelColor};
}

.statediagram-cluster rect.outer {
  rx: 5px;
  ry: 5px;
}
.statediagram-state .divider {
  stroke: ${options2.stateBorder || options2.nodeBorder};
}

.statediagram-state .title-state {
  rx: 5px;
  ry: 5px;
}
.statediagram-cluster.statediagram-cluster .inner {
  fill: ${options2.compositeBackground || options2.background};
}
.statediagram-cluster.statediagram-cluster-alt .inner {
  fill: ${options2.altBackground ? options2.altBackground : "#efefef"};
}

.statediagram-cluster .inner {
  rx:0;
  ry:0;
}

.statediagram-state rect.basic {
  rx: 5px;
  ry: 5px;
}
.statediagram-state rect.divider {
  stroke-dasharray: 10,10;
  fill: ${options2.altBackground ? options2.altBackground : "#efefef"};
}

.note-edge {
  stroke-dasharray: 5;
}

.statediagram-note rect {
  fill: ${options2.noteBkgColor};
  stroke: ${options2.noteBorderColor};
  stroke-width: 1px;
  rx: 0;
  ry: 0;
}
.statediagram-note rect {
  fill: ${options2.noteBkgColor};
  stroke: ${options2.noteBorderColor};
  stroke-width: 1px;
  rx: 0;
  ry: 0;
}

.statediagram-note text {
  fill: ${options2.noteTextColor};
}

.statediagram-note .nodeLabel {
  color: ${options2.noteTextColor};
}
.statediagram .edgeLabel {
  color: red; // ${options2.noteTextColor};
}

#dependencyStart, #dependencyEnd {
  fill: ${options2.lineColor};
  stroke: ${options2.lineColor};
  stroke-width: 1;
}
`;
const getStyles$3 = (options2) => `.label {
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
    color: ${options2.textColor};
  }
  .mouth {
    stroke: #666;
  }

  line {
    stroke: ${options2.textColor}
  }

  .legend {
    fill: ${options2.textColor};
  }

  .label text {
    fill: #333;
  }
  .label {
    color: ${options2.textColor}
  }

  .face {
    ${options2.faceColor ? `fill: ${options2.faceColor}` : "fill: #FFF8DC"};
    stroke: #999;
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${options2.mainBkg};
    stroke: ${options2.nodeBorder};
    stroke-width: 1px;
  }

  .node .label {
    text-align: center;
  }
  .node.clickable {
    cursor: pointer;
  }

  .arrowheadPath {
    fill: ${options2.arrowheadColor};
  }

  .edgePath .path {
    stroke: ${options2.lineColor};
    stroke-width: 1.5px;
  }

  .flowchart-link {
    stroke: ${options2.lineColor};
    fill: none;
  }

  .edgeLabel {
    background-color: ${options2.edgeLabelBackground};
    rect {
      opacity: 0.5;
    }
    text-align: center;
  }

  .cluster rect {
  }

  .cluster text {
    fill: ${options2.titleColor};
  }

  div.mermaidTooltip {
    position: absolute;
    text-align: center;
    max-width: 200px;
    padding: 2px;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
    font-size: 12px;
    background: ${options2.tertiaryColor};
    border: 1px solid ${options2.border2};
    border-radius: 2px;
    pointer-events: none;
    z-index: 100;
  }

  .task-type-0, .section-type-0  {
    ${options2.fillType0 ? `fill: ${options2.fillType0}` : ""};
  }
  .task-type-1, .section-type-1  {
    ${options2.fillType0 ? `fill: ${options2.fillType1}` : ""};
  }
  .task-type-2, .section-type-2  {
    ${options2.fillType0 ? `fill: ${options2.fillType2}` : ""};
  }
  .task-type-3, .section-type-3  {
    ${options2.fillType0 ? `fill: ${options2.fillType3}` : ""};
  }
  .task-type-4, .section-type-4  {
    ${options2.fillType0 ? `fill: ${options2.fillType4}` : ""};
  }
  .task-type-5, .section-type-5  {
    ${options2.fillType0 ? `fill: ${options2.fillType5}` : ""};
  }
  .task-type-6, .section-type-6  {
    ${options2.fillType0 ? `fill: ${options2.fillType6}` : ""};
  }
  .task-type-7, .section-type-7  {
    ${options2.fillType0 ? `fill: ${options2.fillType7}` : ""};
  }

  .actor-0 {
    ${options2.actor0 ? `fill: ${options2.actor0}` : ""};
  }
  .actor-1 {
    ${options2.actor1 ? `fill: ${options2.actor1}` : ""};
  }
  .actor-2 {
    ${options2.actor2 ? `fill: ${options2.actor2}` : ""};
  }
  .actor-3 {
    ${options2.actor3 ? `fill: ${options2.actor3}` : ""};
  }
  .actor-4 {
    ${options2.actor4 ? `fill: ${options2.actor4}` : ""};
  }
  .actor-5 {
    ${options2.actor5 ? `fill: ${options2.actor5}` : ""};
  }
`;
const getStyles$2 = (options2) => `.person {
    stroke: ${options2.personBorder};
    fill: ${options2.personBkg};
  }
`;
const themes = {
  flowchart: getStyles$a,
  "flowchart-v2": getStyles$a,
  sequence: getStyles$5,
  gantt: getStyles$9,
  classDiagram: getStyles$d,
  "classDiagram-v2": getStyles$d,
  class: getStyles$d,
  stateDiagram: getStyles$4,
  state: getStyles$4,
  info: getStyles$8,
  pie: getStyles$7,
  er: getStyles$c,
  error: getStyles$b,
  journey: getStyles$3,
  requirement: getStyles$6,
  c4: getStyles$2
};
const getStyles$1 = (type2, userStyles, options2) => {
  let diagramStyles = "";
  if (type2 in themes && themes[type2]) {
    diagramStyles = themes[type2](options2);
  } else {
    log$1.warn(`No theme found for ${type2}`);
  }
  return ` {
    font-family: ${options2.fontFamily};
    font-size: ${options2.fontSize};
    fill: ${options2.textColor}
  }

  /* Classes common for multiple diagrams */

  .error-icon {
    fill: ${options2.errorBkgColor};
  }
  .error-text {
    fill: ${options2.errorTextColor};
    stroke: ${options2.errorTextColor};
  }

  .edge-thickness-normal {
    stroke-width: 2px;
  }
  .edge-thickness-thick {
    stroke-width: 3.5px
  }
  .edge-pattern-solid {
    stroke-dasharray: 0;
  }

  .edge-pattern-dashed{
    stroke-dasharray: 3;
  }
  .edge-pattern-dotted {
    stroke-dasharray: 2;
  }

  .marker {
    fill: ${options2.lineColor};
    stroke: ${options2.lineColor};
  }
  .marker.cross {
    stroke: ${options2.lineColor};
  }

  svg {
    font-family: ${options2.fontFamily};
    font-size: ${options2.fontSize};
  }

  ${diagramStyles}

  ${userStyles}
`;
};
const addStylesForDiagram = (type2, diagramTheme) => {
  themes[type2] = diagramTheme;
};
const log = log$1;
const setLogLevel = setLogLevel$1;
const getConfig = getConfig$1;
const sanitizeText$4 = (text2) => sanitizeText$5(text2, getConfig());
const setupGraphViewbox = setupGraphViewbox$1;
const diagrams = {};
const registerDiagram = (id2, diagram, detector, callback) => {
  log.debug(`Registering diagram ${id2}`);
  if (diagrams[id2]) {
    log.warn(`Diagram ${id2} already registered.`);
  }
  diagrams[id2] = diagram;
  if (detector) {
    addDetector(id2, detector);
  }
  addStylesForDiagram(id2, diagram.styles);
  if (typeof callback !== "undefined") {
    callback(log, setLogLevel, getConfig, sanitizeText$4, setupGraphViewbox);
  }
  log.debug(`Registered diagram ${id2}. ${Object.keys(diagrams).join(", ")} diagrams registered.`);
};
const getDiagram = (name2) => {
  log.debug(`Getting diagram ${name2}. ${Object.keys(diagrams).join(", ")} diagrams registered.`);
  if (name2 in diagrams) {
    return diagrams[name2];
  }
  throw new DiagramNotFoundError(name2);
};
class DiagramNotFoundError extends Error {
  constructor(message2) {
    super(`Diagram ${message2} not found.`);
  }
}
var parser$b = function() {
  var o = function(k2, v, o2, l2) {
    for (o2 = o2 || {}, l2 = k2.length; l2--; o2[k2[l2]] = v)
      ;
    return o2;
  }, $V0 = [1, 4], $V1 = [1, 7], $V2 = [1, 5], $V3 = [1, 9], $V4 = [1, 6], $V5 = [2, 6], $V6 = [1, 16], $V7 = [6, 8, 14, 20, 22, 24, 25, 27, 29, 32, 37, 40, 50, 54], $V8 = [8, 14, 20, 22, 24, 25, 27, 29, 32, 37, 40], $V9 = [8, 13, 14, 20, 22, 24, 25, 27, 29, 32, 37, 40], $Va = [1, 26], $Vb = [6, 8, 14, 50, 54], $Vc = [8, 14, 54], $Vd = [1, 65], $Ve = [1, 66], $Vf = [1, 67], $Vg = [8, 14, 33, 35, 42, 54];
  var parser2 = {
    trace: function trace() {
    },
    yy: {},
    symbols_: { "error": 2, "start": 3, "eol": 4, "directive": 5, "GG": 6, "document": 7, "EOF": 8, ":": 9, "DIR": 10, "options": 11, "body": 12, "OPT": 13, "NL": 14, "line": 15, "statement": 16, "commitStatement": 17, "mergeStatement": 18, "cherryPickStatement": 19, "acc_title": 20, "acc_title_value": 21, "acc_descr": 22, "acc_descr_value": 23, "acc_descr_multiline_value": 24, "section": 25, "branchStatement": 26, "CHECKOUT": 27, "ID": 28, "BRANCH": 29, "ORDER": 30, "NUM": 31, "CHERRY_PICK": 32, "COMMIT_ID": 33, "STR": 34, "COMMIT_TAG": 35, "EMPTYSTR": 36, "MERGE": 37, "COMMIT_TYPE": 38, "commitType": 39, "COMMIT": 40, "commit_arg": 41, "COMMIT_MSG": 42, "NORMAL": 43, "REVERSE": 44, "HIGHLIGHT": 45, "openDirective": 46, "typeDirective": 47, "closeDirective": 48, "argDirective": 49, "open_directive": 50, "type_directive": 51, "arg_directive": 52, "close_directive": 53, ";": 54, "$accept": 0, "$end": 1 },
    terminals_: { 2: "error", 6: "GG", 8: "EOF", 9: ":", 10: "DIR", 13: "OPT", 14: "NL", 20: "acc_title", 21: "acc_title_value", 22: "acc_descr", 23: "acc_descr_value", 24: "acc_descr_multiline_value", 25: "section", 27: "CHECKOUT", 28: "ID", 29: "BRANCH", 30: "ORDER", 31: "NUM", 32: "CHERRY_PICK", 33: "COMMIT_ID", 34: "STR", 35: "COMMIT_TAG", 36: "EMPTYSTR", 37: "MERGE", 38: "COMMIT_TYPE", 40: "COMMIT", 42: "COMMIT_MSG", 43: "NORMAL", 44: "REVERSE", 45: "HIGHLIGHT", 50: "open_directive", 51: "type_directive", 52: "arg_directive", 53: "close_directive", 54: ";" },
    productions_: [0, [3, 2], [3, 2], [3, 3], [3, 4], [3, 5], [7, 0], [7, 2], [11, 2], [11, 1], [12, 0], [12, 2], [15, 2], [15, 1], [16, 1], [16, 1], [16, 1], [16, 2], [16, 2], [16, 1], [16, 1], [16, 1], [16, 2], [26, 2], [26, 4], [19, 3], [19, 5], [19, 5], [19, 5], [19, 5], [18, 2], [18, 4], [18, 4], [18, 4], [18, 6], [18, 6], [18, 6], [18, 6], [18, 6], [18, 6], [18, 8], [18, 8], [18, 8], [18, 8], [18, 8], [18, 8], [17, 2], [17, 3], [17, 3], [17, 5], [17, 5], [17, 3], [17, 5], [17, 5], [17, 5], [17, 5], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 3], [17, 5], [17, 5], [17, 5], [17, 5], [17, 5], [17, 5], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [41, 0], [41, 1], [39, 1], [39, 1], [39, 1], [5, 3], [5, 5], [46, 1], [47, 1], [49, 1], [48, 1], [4, 1], [4, 1], [4, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 3:
          return $$[$0];
        case 4:
          return $$[$0 - 1];
        case 5:
          yy.setDirection($$[$0 - 3]);
          return $$[$0 - 1];
        case 7:
          yy.setOptions($$[$0 - 1]);
          this.$ = $$[$0];
          break;
        case 8:
          $$[$0 - 1] += $$[$0];
          this.$ = $$[$0 - 1];
          break;
        case 10:
          this.$ = [];
          break;
        case 11:
          $$[$0 - 1].push($$[$0]);
          this.$ = $$[$0 - 1];
          break;
        case 12:
          this.$ = $$[$0 - 1];
          break;
        case 17:
          this.$ = $$[$0].trim();
          yy.setAccTitle(this.$);
          break;
        case 18:
        case 19:
          this.$ = $$[$0].trim();
          yy.setAccDescription(this.$);
          break;
        case 20:
          yy.addSection($$[$0].substr(8));
          this.$ = $$[$0].substr(8);
          break;
        case 22:
          yy.checkout($$[$0]);
          break;
        case 23:
          yy.branch($$[$0]);
          break;
        case 24:
          yy.branch($$[$0 - 2], $$[$0]);
          break;
        case 25:
          yy.cherryPick($$[$0], "", void 0);
          break;
        case 26:
          yy.cherryPick($$[$0 - 2], "", $$[$0]);
          break;
        case 27:
        case 29:
          yy.cherryPick($$[$0 - 2], "", "");
          break;
        case 28:
          yy.cherryPick($$[$0], "", $$[$0 - 2]);
          break;
        case 30:
          yy.merge($$[$0], "", "", "");
          break;
        case 31:
          yy.merge($$[$0 - 2], $$[$0], "", "");
          break;
        case 32:
          yy.merge($$[$0 - 2], "", $$[$0], "");
          break;
        case 33:
          yy.merge($$[$0 - 2], "", "", $$[$0]);
          break;
        case 34:
          yy.merge($$[$0 - 4], $$[$0], "", $$[$0 - 2]);
          break;
        case 35:
          yy.merge($$[$0 - 4], "", $$[$0], $$[$0 - 2]);
          break;
        case 36:
          yy.merge($$[$0 - 4], "", $$[$0 - 2], $$[$0]);
          break;
        case 37:
          yy.merge($$[$0 - 4], $$[$0 - 2], $$[$0], "");
          break;
        case 38:
          yy.merge($$[$0 - 4], $$[$0 - 2], "", $$[$0]);
          break;
        case 39:
          yy.merge($$[$0 - 4], $$[$0], $$[$0 - 2], "");
          break;
        case 40:
          yy.merge($$[$0 - 6], $$[$0 - 4], $$[$0 - 2], $$[$0]);
          break;
        case 41:
          yy.merge($$[$0 - 6], $$[$0], $$[$0 - 4], $$[$0 - 2]);
          break;
        case 42:
          yy.merge($$[$0 - 6], $$[$0 - 4], $$[$0], $$[$0 - 2]);
          break;
        case 43:
          yy.merge($$[$0 - 6], $$[$0 - 2], $$[$0 - 4], $$[$0]);
          break;
        case 44:
          yy.merge($$[$0 - 6], $$[$0], $$[$0 - 2], $$[$0 - 4]);
          break;
        case 45:
          yy.merge($$[$0 - 6], $$[$0 - 2], $$[$0], $$[$0 - 4]);
          break;
        case 46:
          yy.commit($$[$0]);
          break;
        case 47:
          yy.commit("", "", yy.commitType.NORMAL, $$[$0]);
          break;
        case 48:
          yy.commit("", "", $$[$0], "");
          break;
        case 49:
          yy.commit("", "", $$[$0], $$[$0 - 2]);
          break;
        case 50:
          yy.commit("", "", $$[$0 - 2], $$[$0]);
          break;
        case 51:
          yy.commit("", $$[$0], yy.commitType.NORMAL, "");
          break;
        case 52:
          yy.commit("", $$[$0 - 2], yy.commitType.NORMAL, $$[$0]);
          break;
        case 53:
          yy.commit("", $$[$0], yy.commitType.NORMAL, $$[$0 - 2]);
          break;
        case 54:
          yy.commit("", $$[$0 - 2], $$[$0], "");
          break;
        case 55:
          yy.commit("", $$[$0], $$[$0 - 2], "");
          break;
        case 56:
          yy.commit("", $$[$0 - 4], $$[$0 - 2], $$[$0]);
          break;
        case 57:
          yy.commit("", $$[$0 - 4], $$[$0], $$[$0 - 2]);
          break;
        case 58:
          yy.commit("", $$[$0 - 2], $$[$0 - 4], $$[$0]);
          break;
        case 59:
          yy.commit("", $$[$0], $$[$0 - 4], $$[$0 - 2]);
          break;
        case 60:
          yy.commit("", $$[$0], $$[$0 - 2], $$[$0 - 4]);
          break;
        case 61:
          yy.commit("", $$[$0 - 2], $$[$0], $$[$0 - 4]);
          break;
        case 62:
          yy.commit($$[$0], "", yy.commitType.NORMAL, "");
          break;
        case 63:
          yy.commit($$[$0], "", yy.commitType.NORMAL, $$[$0 - 2]);
          break;
        case 64:
          yy.commit($$[$0 - 2], "", yy.commitType.NORMAL, $$[$0]);
          break;
        case 65:
          yy.commit($$[$0 - 2], "", $$[$0], "");
          break;
        case 66:
          yy.commit($$[$0], "", $$[$0 - 2], "");
          break;
        case 67:
          yy.commit($$[$0], $$[$0 - 2], yy.commitType.NORMAL, "");
          break;
        case 68:
          yy.commit($$[$0 - 2], $$[$0], yy.commitType.NORMAL, "");
          break;
        case 69:
          yy.commit($$[$0 - 4], "", $$[$0 - 2], $$[$0]);
          break;
        case 70:
          yy.commit($$[$0 - 4], "", $$[$0], $$[$0 - 2]);
          break;
        case 71:
          yy.commit($$[$0 - 2], "", $$[$0 - 4], $$[$0]);
          break;
        case 72:
          yy.commit($$[$0], "", $$[$0 - 4], $$[$0 - 2]);
          break;
        case 73:
          yy.commit($$[$0], "", $$[$0 - 2], $$[$0 - 4]);
          break;
        case 74:
          yy.commit($$[$0 - 2], "", $$[$0], $$[$0 - 4]);
          break;
        case 75:
          yy.commit($$[$0 - 4], $$[$0], $$[$0 - 2], "");
          break;
        case 76:
          yy.commit($$[$0 - 4], $$[$0 - 2], $$[$0], "");
          break;
        case 77:
          yy.commit($$[$0 - 2], $$[$0], $$[$0 - 4], "");
          break;
        case 78:
          yy.commit($$[$0], $$[$0 - 2], $$[$0 - 4], "");
          break;
        case 79:
          yy.commit($$[$0], $$[$0 - 4], $$[$0 - 2], "");
          break;
        case 80:
          yy.commit($$[$0 - 2], $$[$0 - 4], $$[$0], "");
          break;
        case 81:
          yy.commit($$[$0 - 4], $$[$0], yy.commitType.NORMAL, $$[$0 - 2]);
          break;
        case 82:
          yy.commit($$[$0 - 4], $$[$0 - 2], yy.commitType.NORMAL, $$[$0]);
          break;
        case 83:
          yy.commit($$[$0 - 2], $$[$0], yy.commitType.NORMAL, $$[$0 - 4]);
          break;
        case 84:
          yy.commit($$[$0], $$[$0 - 2], yy.commitType.NORMAL, $$[$0 - 4]);
          break;
        case 85:
          yy.commit($$[$0], $$[$0 - 4], yy.commitType.NORMAL, $$[$0 - 2]);
          break;
        case 86:
          yy.commit($$[$0 - 2], $$[$0 - 4], yy.commitType.NORMAL, $$[$0]);
          break;
        case 87:
          yy.commit($$[$0 - 6], $$[$0 - 4], $$[$0 - 2], $$[$0]);
          break;
        case 88:
          yy.commit($$[$0 - 6], $$[$0 - 4], $$[$0], $$[$0 - 2]);
          break;
        case 89:
          yy.commit($$[$0 - 6], $$[$0 - 2], $$[$0 - 4], $$[$0]);
          break;
        case 90:
          yy.commit($$[$0 - 6], $$[$0], $$[$0 - 4], $$[$0 - 2]);
          break;
        case 91:
          yy.commit($$[$0 - 6], $$[$0 - 2], $$[$0], $$[$0 - 4]);
          break;
        case 92:
          yy.commit($$[$0 - 6], $$[$0], $$[$0 - 2], $$[$0 - 4]);
          break;
        case 93:
          yy.commit($$[$0 - 4], $$[$0 - 6], $$[$0 - 2], $$[$0]);
          break;
        case 94:
          yy.commit($$[$0 - 4], $$[$0 - 6], $$[$0], $$[$0 - 2]);
          break;
        case 95:
          yy.commit($$[$0 - 2], $$[$0 - 6], $$[$0 - 4], $$[$0]);
          break;
        case 96:
          yy.commit($$[$0], $$[$0 - 6], $$[$0 - 4], $$[$0 - 2]);
          break;
        case 97:
          yy.commit($$[$0 - 2], $$[$0 - 6], $$[$0], $$[$0 - 4]);
          break;
        case 98:
          yy.commit($$[$0], $$[$0 - 6], $$[$0 - 2], $$[$0 - 4]);
          break;
        case 99:
          yy.commit($$[$0], $$[$0 - 4], $$[$0 - 2], $$[$0 - 6]);
          break;
        case 100:
          yy.commit($$[$0 - 2], $$[$0 - 4], $$[$0], $$[$0 - 6]);
          break;
        case 101:
          yy.commit($$[$0], $$[$0 - 2], $$[$0 - 4], $$[$0 - 6]);
          break;
        case 102:
          yy.commit($$[$0 - 2], $$[$0], $$[$0 - 4], $$[$0 - 6]);
          break;
        case 103:
          yy.commit($$[$0 - 4], $$[$0 - 2], $$[$0], $$[$0 - 6]);
          break;
        case 104:
          yy.commit($$[$0 - 4], $$[$0], $$[$0 - 2], $$[$0 - 6]);
          break;
        case 105:
          yy.commit($$[$0 - 2], $$[$0 - 4], $$[$0 - 6], $$[$0]);
          break;
        case 106:
          yy.commit($$[$0], $$[$0 - 4], $$[$0 - 6], $$[$0 - 2]);
          break;
        case 107:
          yy.commit($$[$0 - 2], $$[$0], $$[$0 - 6], $$[$0 - 4]);
          break;
        case 108:
          yy.commit($$[$0], $$[$0 - 2], $$[$0 - 6], $$[$0 - 4]);
          break;
        case 109:
          yy.commit($$[$0 - 4], $$[$0 - 2], $$[$0 - 6], $$[$0]);
          break;
        case 110:
          yy.commit($$[$0 - 4], $$[$0], $$[$0 - 6], $$[$0 - 2]);
          break;
        case 111:
          this.$ = "";
          break;
        case 112:
          this.$ = $$[$0];
          break;
        case 113:
          this.$ = yy.commitType.NORMAL;
          break;
        case 114:
          this.$ = yy.commitType.REVERSE;
          break;
        case 115:
          this.$ = yy.commitType.HIGHLIGHT;
          break;
        case 118:
          yy.parseDirective("%%{", "open_directive");
          break;
        case 119:
          yy.parseDirective($$[$0], "type_directive");
          break;
        case 120:
          $$[$0] = $$[$0].trim().replace(/'/g, '"');
          yy.parseDirective($$[$0], "arg_directive");
          break;
        case 121:
          yy.parseDirective("}%%", "close_directive", "gitGraph");
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 5: 3, 6: $V0, 8: $V1, 14: $V2, 46: 8, 50: $V3, 54: $V4 }, { 1: [3] }, { 3: 10, 4: 2, 5: 3, 6: $V0, 8: $V1, 14: $V2, 46: 8, 50: $V3, 54: $V4 }, { 3: 11, 4: 2, 5: 3, 6: $V0, 8: $V1, 14: $V2, 46: 8, 50: $V3, 54: $V4 }, { 7: 12, 8: $V5, 9: [1, 13], 10: [1, 14], 11: 15, 14: $V6 }, o($V7, [2, 122]), o($V7, [2, 123]), o($V7, [2, 124]), { 47: 17, 51: [1, 18] }, { 51: [2, 118] }, { 1: [2, 1] }, { 1: [2, 2] }, { 8: [1, 19] }, { 7: 20, 8: $V5, 11: 15, 14: $V6 }, { 9: [1, 21] }, o($V8, [2, 10], { 12: 22, 13: [1, 23] }), o($V9, [2, 9]), { 9: [1, 25], 48: 24, 53: $Va }, o([9, 53], [2, 119]), { 1: [2, 3] }, { 8: [1, 27] }, { 7: 28, 8: $V5, 11: 15, 14: $V6 }, { 8: [2, 7], 14: [1, 31], 15: 29, 16: 30, 17: 32, 18: 33, 19: 34, 20: [1, 35], 22: [1, 36], 24: [1, 37], 25: [1, 38], 26: 39, 27: [1, 40], 29: [1, 44], 32: [1, 43], 37: [1, 42], 40: [1, 41] }, o($V9, [2, 8]), o($Vb, [2, 116]), { 49: 45, 52: [1, 46] }, o($Vb, [2, 121]), { 1: [2, 4] }, { 8: [1, 47] }, o($V8, [2, 11]), { 4: 48, 8: $V1, 14: $V2, 54: $V4 }, o($V8, [2, 13]), o($Vc, [2, 14]), o($Vc, [2, 15]), o($Vc, [2, 16]), { 21: [1, 49] }, { 23: [1, 50] }, o($Vc, [2, 19]), o($Vc, [2, 20]), o($Vc, [2, 21]), { 28: [1, 51] }, o($Vc, [2, 111], { 41: 52, 33: [1, 55], 34: [1, 57], 35: [1, 53], 38: [1, 54], 42: [1, 56] }), { 28: [1, 58] }, { 33: [1, 59], 35: [1, 60] }, { 28: [1, 61] }, { 48: 62, 53: $Va }, { 53: [2, 120] }, { 1: [2, 5] }, o($V8, [2, 12]), o($Vc, [2, 17]), o($Vc, [2, 18]), o($Vc, [2, 22]), o($Vc, [2, 46]), { 34: [1, 63] }, { 39: 64, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 68] }, { 34: [1, 69] }, o($Vc, [2, 112]), o($Vc, [2, 30], { 33: [1, 70], 35: [1, 72], 38: [1, 71] }), { 34: [1, 73] }, { 34: [1, 74], 36: [1, 75] }, o($Vc, [2, 23], { 30: [1, 76] }), o($Vb, [2, 117]), o($Vc, [2, 47], { 33: [1, 78], 38: [1, 77], 42: [1, 79] }), o($Vc, [2, 48], { 33: [1, 81], 35: [1, 80], 42: [1, 82] }), o($Vg, [2, 113]), o($Vg, [2, 114]), o($Vg, [2, 115]), o($Vc, [2, 51], { 35: [1, 83], 38: [1, 84], 42: [1, 85] }), o($Vc, [2, 62], { 33: [1, 88], 35: [1, 86], 38: [1, 87] }), { 34: [1, 89] }, { 39: 90, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 91] }, o($Vc, [2, 25], { 35: [1, 92] }), { 33: [1, 93] }, { 33: [1, 94] }, { 31: [1, 95] }, { 39: 96, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 97] }, { 34: [1, 98] }, { 34: [1, 99] }, { 34: [1, 100] }, { 34: [1, 101] }, { 34: [1, 102] }, { 39: 103, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 104] }, { 34: [1, 105] }, { 39: 106, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 107] }, o($Vc, [2, 31], { 35: [1, 109], 38: [1, 108] }), o($Vc, [2, 32], { 33: [1, 111], 35: [1, 110] }), o($Vc, [2, 33], { 33: [1, 112], 38: [1, 113] }), { 34: [1, 114], 36: [1, 115] }, { 34: [1, 116] }, { 34: [1, 117] }, o($Vc, [2, 24]), o($Vc, [2, 49], { 33: [1, 118], 42: [1, 119] }), o($Vc, [2, 53], { 38: [1, 120], 42: [1, 121] }), o($Vc, [2, 63], { 33: [1, 123], 38: [1, 122] }), o($Vc, [2, 50], { 33: [1, 124], 42: [1, 125] }), o($Vc, [2, 55], { 35: [1, 126], 42: [1, 127] }), o($Vc, [2, 66], { 33: [1, 129], 35: [1, 128] }), o($Vc, [2, 52], { 38: [1, 130], 42: [1, 131] }), o($Vc, [2, 54], { 35: [1, 132], 42: [1, 133] }), o($Vc, [2, 67], { 35: [1, 135], 38: [1, 134] }), o($Vc, [2, 64], { 33: [1, 137], 38: [1, 136] }), o($Vc, [2, 65], { 33: [1, 139], 35: [1, 138] }), o($Vc, [2, 68], { 35: [1, 141], 38: [1, 140] }), { 39: 142, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 143] }, { 34: [1, 144] }, { 34: [1, 145] }, { 34: [1, 146] }, { 39: 147, 43: $Vd, 44: $Ve, 45: $Vf }, o($Vc, [2, 26]), o($Vc, [2, 27]), o($Vc, [2, 28]), o($Vc, [2, 29]), { 34: [1, 148] }, { 34: [1, 149] }, { 39: 150, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 151] }, { 39: 152, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 153] }, { 34: [1, 154] }, { 34: [1, 155] }, { 34: [1, 156] }, { 34: [1, 157] }, { 34: [1, 158] }, { 34: [1, 159] }, { 39: 160, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 161] }, { 34: [1, 162] }, { 34: [1, 163] }, { 39: 164, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 165] }, { 39: 166, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 167] }, { 34: [1, 168] }, { 34: [1, 169] }, { 39: 170, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 171] }, o($Vc, [2, 37], { 35: [1, 172] }), o($Vc, [2, 38], { 38: [1, 173] }), o($Vc, [2, 36], { 33: [1, 174] }), o($Vc, [2, 39], { 35: [1, 175] }), o($Vc, [2, 34], { 38: [1, 176] }), o($Vc, [2, 35], { 33: [1, 177] }), o($Vc, [2, 60], { 42: [1, 178] }), o($Vc, [2, 73], { 33: [1, 179] }), o($Vc, [2, 61], { 42: [1, 180] }), o($Vc, [2, 84], { 38: [1, 181] }), o($Vc, [2, 74], { 33: [1, 182] }), o($Vc, [2, 83], { 38: [1, 183] }), o($Vc, [2, 59], { 42: [1, 184] }), o($Vc, [2, 72], { 33: [1, 185] }), o($Vc, [2, 58], { 42: [1, 186] }), o($Vc, [2, 78], { 35: [1, 187] }), o($Vc, [2, 71], { 33: [1, 188] }), o($Vc, [2, 77], { 35: [1, 189] }), o($Vc, [2, 57], { 42: [1, 190] }), o($Vc, [2, 85], { 38: [1, 191] }), o($Vc, [2, 56], { 42: [1, 192] }), o($Vc, [2, 79], { 35: [1, 193] }), o($Vc, [2, 80], { 35: [1, 194] }), o($Vc, [2, 86], { 38: [1, 195] }), o($Vc, [2, 70], { 33: [1, 196] }), o($Vc, [2, 81], { 38: [1, 197] }), o($Vc, [2, 69], { 33: [1, 198] }), o($Vc, [2, 75], { 35: [1, 199] }), o($Vc, [2, 76], { 35: [1, 200] }), o($Vc, [2, 82], { 38: [1, 201] }), { 34: [1, 202] }, { 39: 203, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 204] }, { 34: [1, 205] }, { 39: 206, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 207] }, { 34: [1, 208] }, { 34: [1, 209] }, { 34: [1, 210] }, { 39: 211, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 212] }, { 39: 213, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 214] }, { 34: [1, 215] }, { 34: [1, 216] }, { 34: [1, 217] }, { 34: [1, 218] }, { 34: [1, 219] }, { 34: [1, 220] }, { 39: 221, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 222] }, { 34: [1, 223] }, { 34: [1, 224] }, { 39: 225, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 226] }, { 39: 227, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 228] }, { 34: [1, 229] }, { 34: [1, 230] }, { 39: 231, 43: $Vd, 44: $Ve, 45: $Vf }, o($Vc, [2, 40]), o($Vc, [2, 42]), o($Vc, [2, 41]), o($Vc, [2, 43]), o($Vc, [2, 45]), o($Vc, [2, 44]), o($Vc, [2, 101]), o($Vc, [2, 102]), o($Vc, [2, 99]), o($Vc, [2, 100]), o($Vc, [2, 104]), o($Vc, [2, 103]), o($Vc, [2, 108]), o($Vc, [2, 107]), o($Vc, [2, 106]), o($Vc, [2, 105]), o($Vc, [2, 110]), o($Vc, [2, 109]), o($Vc, [2, 98]), o($Vc, [2, 97]), o($Vc, [2, 96]), o($Vc, [2, 95]), o($Vc, [2, 93]), o($Vc, [2, 94]), o($Vc, [2, 92]), o($Vc, [2, 91]), o($Vc, [2, 90]), o($Vc, [2, 89]), o($Vc, [2, 87]), o($Vc, [2, 88])],
    defaultActions: { 9: [2, 118], 10: [2, 1], 11: [2, 2], 19: [2, 3], 27: [2, 4], 46: [2, 120], 47: [2, 5] },
    parseError: function parseError(str, hash2) {
      if (hash2.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash2;
        throw error;
      }
    },
    parse: function parse2(input) {
      var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k2 in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
          sharedState.yy[k2] = this.yy[k2];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges2 = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function lex() {
        var token2;
        token2 = tstack.pop() || lexer2.lex() || EOF2;
        if (typeof token2 !== "number") {
          if (token2 instanceof Array) {
            tstack = token2;
            token2 = tstack.pop();
          }
          token2 = self2.symbols_[token2] || token2;
        }
        return token2;
      }
      var symbol2, state, action, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack2[stack2.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol2 === null || typeof symbol2 == "undefined") {
            symbol2 = lex();
          }
          action = table[state] && table[state][symbol2];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push("'" + this.terminals_[p] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol2] || symbol2) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol2 == EOF2 ? "end of input" : "'" + (this.terminals_[symbol2] || symbol2) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol2] || symbol2,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol2);
        }
        switch (action[0]) {
          case 1:
            stack2.push(symbol2);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack2.push(action[1]);
            symbol2 = null;
            {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges2) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
              ];
            }
            r = this.performAction.apply(yyval, [
              yytext,
              yyleng,
              yylineno,
              sharedState.yy,
              action[1],
              vstack,
              lstack
            ].concat(args));
            if (typeof r !== "undefined") {
              return r;
            }
            if (len) {
              stack2 = stack2.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack2.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
            stack2.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash2) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash2);
        } else {
          throw new Error(str);
        }
      },
      setInput: function(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      input: function() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      unput: function(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      more: function() {
        this._more = true;
        return this;
      },
      reject: function() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      less: function(n) {
        this.unput(this.match.slice(n));
      },
      pastInput: function() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var next2 = this.match;
        if (next2.length < 20) {
          next2 += this._input.substr(0, 20 - next2.length);
        }
        return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var pre = this.pastInput();
        var c2 = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c2 + "^";
      },
      test_match: function(match, indexed_rule) {
        var token2, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token2) {
          return token2;
        } else if (this._backtrack) {
          for (var k2 in backup) {
            this[k2] = backup[k2];
          }
          return false;
        }
        return false;
      },
      next: function() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token2, match, tempMatch, index2;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index2 = i;
            if (this.options.backtrack_lexer) {
              token2 = this.test_match(tempMatch, rules[i]);
              if (token2 !== false) {
                return token2;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token2 = this.test_match(match, rules[index2]);
          if (token2 !== false) {
            return token2;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": true },
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        switch ($avoiding_name_collisions) {
          case 0:
            this.begin("open_directive");
            return 50;
          case 1:
            this.begin("type_directive");
            return 51;
          case 2:
            this.popState();
            this.begin("arg_directive");
            return 9;
          case 3:
            this.popState();
            this.popState();
            return 53;
          case 4:
            return 52;
          case 5:
            this.begin("acc_title");
            return 20;
          case 6:
            this.popState();
            return "acc_title_value";
          case 7:
            this.begin("acc_descr");
            return 22;
          case 8:
            this.popState();
            return "acc_descr_value";
          case 9:
            this.begin("acc_descr_multiline");
            break;
          case 10:
            this.popState();
            break;
          case 11:
            return "acc_descr_multiline_value";
          case 12:
            return 14;
          case 13:
            break;
          case 14:
            break;
          case 15:
            return 6;
          case 16:
            return 40;
          case 17:
            return 33;
          case 18:
            return 38;
          case 19:
            return 42;
          case 20:
            return 43;
          case 21:
            return 44;
          case 22:
            return 45;
          case 23:
            return 35;
          case 24:
            return 29;
          case 25:
            return 30;
          case 26:
            return 37;
          case 27:
            return 32;
          case 28:
            return 27;
          case 29:
            return 10;
          case 30:
            return 10;
          case 31:
            return 9;
          case 32:
            return "CARET";
          case 33:
            this.begin("options");
            break;
          case 34:
            this.popState();
            break;
          case 35:
            return 13;
          case 36:
            return 36;
          case 37:
            this.begin("string");
            break;
          case 38:
            this.popState();
            break;
          case 39:
            return 34;
          case 40:
            return 31;
          case 41:
            return 28;
          case 42:
            return 8;
        }
      },
      rules: [/^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:(\r?\n)+)/i, /^(?:#[^\n]*)/i, /^(?:%[^\n]*)/i, /^(?:gitGraph\b)/i, /^(?:commit(?=\s|$))/i, /^(?:id:)/i, /^(?:type:)/i, /^(?:msg:)/i, /^(?:NORMAL\b)/i, /^(?:REVERSE\b)/i, /^(?:HIGHLIGHT\b)/i, /^(?:tag:)/i, /^(?:branch(?=\s|$))/i, /^(?:order:)/i, /^(?:merge(?=\s|$))/i, /^(?:cherry-pick(?=\s|$))/i, /^(?:checkout(?=\s|$))/i, /^(?:LR\b)/i, /^(?:BT\b)/i, /^(?::)/i, /^(?:\^)/i, /^(?:options\r?\n)/i, /^(?:[ \r\n\t]+end\b)/i, /^(?:[\s\S]+(?=[ \r\n\t]+end))/i, /^(?:["]["])/i, /^(?:["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:[0-9]+(?=\s|$))/i, /^(?:\w([-\./\w]*[-\w])?)/i, /^(?:$)/i, /^(?:\s+)/i],
      conditions: { "acc_descr_multiline": { "rules": [10, 11], "inclusive": false }, "acc_descr": { "rules": [8], "inclusive": false }, "acc_title": { "rules": [6], "inclusive": false }, "close_directive": { "rules": [], "inclusive": false }, "arg_directive": { "rules": [3, 4], "inclusive": false }, "type_directive": { "rules": [2, 3], "inclusive": false }, "open_directive": { "rules": [1], "inclusive": false }, "options": { "rules": [34, 35], "inclusive": false }, "string": { "rules": [38, 39], "inclusive": false }, "INITIAL": { "rules": [0, 5, 7, 9, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 36, 37, 40, 41, 42, 43], "inclusive": true } }
    };
    return lexer2;
  }();
  parser2.lexer = lexer;
  function Parser2() {
    this.yy = {};
  }
  Parser2.prototype = parser2;
  parser2.Parser = Parser2;
  return new Parser2();
}();
parser$b.parser = parser$b;
const gitGraphDetector = (txt) => {
  return txt.match(/^\s*gitGraph/) !== null;
};
let title$1 = "";
let diagramTitle = "";
let description = "";
const sanitizeText$3 = (txt) => sanitizeText$5(txt, getConfig$1());
const clear$g = function() {
  title$1 = "";
  description = "";
  diagramTitle = "";
};
const setAccTitle = function(txt) {
  title$1 = sanitizeText$3(txt).replace(/^\s+/g, "");
};
const getAccTitle = function() {
  return title$1 || diagramTitle;
};
const setAccDescription = function(txt) {
  description = sanitizeText$3(txt).replace(/\n\s+/g, "\n");
};
const getAccDescription = function() {
  return description;
};
const setDiagramTitle = function(txt) {
  diagramTitle = sanitizeText$3(txt);
};
const getDiagramTitle = function() {
  return diagramTitle;
};
let mainBranchName = getConfig$1().gitGraph.mainBranchName;
let mainBranchOrder = getConfig$1().gitGraph.mainBranchOrder;
let commits = {};
let head = null;
let branchesConfig = {};
branchesConfig[mainBranchName] = { name: mainBranchName, order: mainBranchOrder };
let branches = {};
branches[mainBranchName] = head;
let curBranch = mainBranchName;
let direction$3 = "LR";
let seq = 0;
function getId() {
  return random({ length: 7 });
}
const parseDirective$b = function(statement, context, type2) {
  mermaidAPI.parseDirective(this, statement, context, type2);
};
function uniqBy(list2, fn2) {
  const recordMap = /* @__PURE__ */ Object.create(null);
  return list2.reduce((out, item) => {
    const key = fn2(item);
    if (!recordMap[key]) {
      recordMap[key] = true;
      out.push(item);
    }
    return out;
  }, []);
}
const setDirection$3 = function(dir) {
  direction$3 = dir;
};
let options = {};
const setOptions = function(rawOptString) {
  log$1.debug("options str", rawOptString);
  rawOptString = rawOptString && rawOptString.trim();
  rawOptString = rawOptString || "{}";
  try {
    options = JSON.parse(rawOptString);
  } catch (e) {
    log$1.error("error while parsing gitGraph options", e.message);
  }
};
const getOptions = function() {
  return options;
};
const commit = function(msg, id2, type2, tag) {
  log$1.debug("Entering commit:", msg, id2, type2, tag);
  id2 = common.sanitizeText(id2, getConfig$1());
  msg = common.sanitizeText(msg, getConfig$1());
  tag = common.sanitizeText(tag, getConfig$1());
  const commit2 = {
    id: id2 ? id2 : seq + "-" + getId(),
    message: msg,
    seq: seq++,
    type: type2 ? type2 : commitType$1.NORMAL,
    tag: tag ? tag : "",
    parents: head == null ? [] : [head.id],
    branch: curBranch
  };
  head = commit2;
  commits[commit2.id] = commit2;
  branches[curBranch] = commit2.id;
  log$1.debug("in pushCommit " + commit2.id);
};
const branch = function(name2, order2) {
  name2 = common.sanitizeText(name2, getConfig$1());
  if (typeof branches[name2] === "undefined") {
    branches[name2] = head != null ? head.id : null;
    branchesConfig[name2] = { name: name2, order: order2 ? parseInt(order2, 10) : null };
    checkout(name2);
    log$1.debug("in createBranch");
  } else {
    let error = new Error(
      'Trying to create an existing branch. (Help: Either use a new name if you want create a new branch or try using "checkout ' + name2 + '")'
    );
    error.hash = {
      text: "branch " + name2,
      token: "branch " + name2,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ['"checkout ' + name2 + '"']
    };
    throw error;
  }
};
const merge = function(otherBranch, custom_id, override_type, custom_tag) {
  otherBranch = common.sanitizeText(otherBranch, getConfig$1());
  custom_id = common.sanitizeText(custom_id, getConfig$1());
  const currentCommit = commits[branches[curBranch]];
  const otherCommit = commits[branches[otherBranch]];
  if (curBranch === otherBranch) {
    let error = new Error('Incorrect usage of "merge". Cannot merge a branch to itself');
    error.hash = {
      text: "merge " + otherBranch,
      token: "merge " + otherBranch,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ["branch abc"]
    };
    throw error;
  } else if (typeof currentCommit === "undefined" || !currentCommit) {
    let error = new Error(
      'Incorrect usage of "merge". Current branch (' + curBranch + ")has no commits"
    );
    error.hash = {
      text: "merge " + otherBranch,
      token: "merge " + otherBranch,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ["commit"]
    };
    throw error;
  } else if (typeof branches[otherBranch] === "undefined") {
    let error = new Error(
      'Incorrect usage of "merge". Branch to be merged (' + otherBranch + ") does not exist"
    );
    error.hash = {
      text: "merge " + otherBranch,
      token: "merge " + otherBranch,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ["branch " + otherBranch]
    };
    throw error;
  } else if (typeof otherCommit === "undefined" || !otherCommit) {
    let error = new Error(
      'Incorrect usage of "merge". Branch to be merged (' + otherBranch + ") has no commits"
    );
    error.hash = {
      text: "merge " + otherBranch,
      token: "merge " + otherBranch,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ['"commit"']
    };
    throw error;
  } else if (currentCommit === otherCommit) {
    let error = new Error('Incorrect usage of "merge". Both branches have same head');
    error.hash = {
      text: "merge " + otherBranch,
      token: "merge " + otherBranch,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ["branch abc"]
    };
    throw error;
  } else if (custom_id && typeof commits[custom_id] !== "undefined") {
    let error = new Error(
      'Incorrect usage of "merge". Commit with id:' + custom_id + " already exists, use different custom Id"
    );
    error.hash = {
      text: "merge " + otherBranch + custom_id + override_type + custom_tag,
      token: "merge " + otherBranch + custom_id + override_type + custom_tag,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: [
        "merge " + otherBranch + " " + custom_id + "_UNIQUE " + override_type + " " + custom_tag
      ]
    };
    throw error;
  }
  const commit2 = {
    id: custom_id ? custom_id : seq + "-" + getId(),
    message: "merged branch " + otherBranch + " into " + curBranch,
    seq: seq++,
    parents: [head == null ? null : head.id, branches[otherBranch]],
    branch: curBranch,
    type: commitType$1.MERGE,
    customType: override_type,
    customId: custom_id ? true : false,
    tag: custom_tag ? custom_tag : ""
  };
  head = commit2;
  commits[commit2.id] = commit2;
  branches[curBranch] = commit2.id;
  log$1.debug(branches);
  log$1.debug("in mergeBranch");
};
const cherryPick = function(sourceId, targetId, tag) {
  log$1.debug("Entering cherryPick:", sourceId, targetId, tag);
  sourceId = common.sanitizeText(sourceId, getConfig$1());
  targetId = common.sanitizeText(targetId, getConfig$1());
  tag = common.sanitizeText(tag, getConfig$1());
  if (!sourceId || typeof commits[sourceId] === "undefined") {
    let error = new Error(
      'Incorrect usage of "cherryPick". Source commit id should exist and provided'
    );
    error.hash = {
      text: "cherryPick " + sourceId + " " + targetId,
      token: "cherryPick " + sourceId + " " + targetId,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ["cherry-pick abc"]
    };
    throw error;
  }
  let sourceCommit = commits[sourceId];
  let sourceCommitBranch = sourceCommit.branch;
  if (sourceCommit.type === commitType$1.MERGE) {
    let error = new Error(
      'Incorrect usage of "cherryPick". Source commit should not be a merge commit'
    );
    error.hash = {
      text: "cherryPick " + sourceId + " " + targetId,
      token: "cherryPick " + sourceId + " " + targetId,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ["cherry-pick abc"]
    };
    throw error;
  }
  if (!targetId || typeof commits[targetId] === "undefined") {
    if (sourceCommitBranch === curBranch) {
      let error = new Error(
        'Incorrect usage of "cherryPick". Source commit is already on current branch'
      );
      error.hash = {
        text: "cherryPick " + sourceId + " " + targetId,
        token: "cherryPick " + sourceId + " " + targetId,
        line: "1",
        loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
        expected: ["cherry-pick abc"]
      };
      throw error;
    }
    const currentCommit = commits[branches[curBranch]];
    if (typeof currentCommit === "undefined" || !currentCommit) {
      let error = new Error(
        'Incorrect usage of "cherry-pick". Current branch (' + curBranch + ")has no commits"
      );
      error.hash = {
        text: "cherryPick " + sourceId + " " + targetId,
        token: "cherryPick " + sourceId + " " + targetId,
        line: "1",
        loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
        expected: ["cherry-pick abc"]
      };
      throw error;
    }
    const commit2 = {
      id: seq + "-" + getId(),
      message: "cherry-picked " + sourceCommit + " into " + curBranch,
      seq: seq++,
      parents: [head == null ? null : head.id, sourceCommit.id],
      branch: curBranch,
      type: commitType$1.CHERRY_PICK,
      tag: tag != null ? tag : "cherry-pick:" + sourceCommit.id
    };
    head = commit2;
    commits[commit2.id] = commit2;
    branches[curBranch] = commit2.id;
    log$1.debug(branches);
    log$1.debug("in cherryPick");
  }
};
const checkout = function(branch2) {
  branch2 = common.sanitizeText(branch2, getConfig$1());
  if (typeof branches[branch2] === "undefined") {
    let error = new Error(
      'Trying to checkout branch which is not yet created. (Help try using "branch ' + branch2 + '")'
    );
    error.hash = {
      text: "checkout " + branch2,
      token: "checkout " + branch2,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ['"branch ' + branch2 + '"']
    };
    throw error;
  } else {
    curBranch = branch2;
    const id2 = branches[curBranch];
    head = commits[id2];
  }
};
function upsert(arr, key, newval) {
  const index2 = arr.indexOf(key);
  if (index2 === -1) {
    arr.push(newval);
  } else {
    arr.splice(index2, 1, newval);
  }
}
function prettyPrintCommitHistory(commitArr) {
  const commit2 = commitArr.reduce((out, commit3) => {
    if (out.seq > commit3.seq)
      return out;
    return commit3;
  }, commitArr[0]);
  let line2 = "";
  commitArr.forEach(function(c2) {
    if (c2 === commit2) {
      line2 += "	*";
    } else {
      line2 += "	|";
    }
  });
  const label = [line2, commit2.id, commit2.seq];
  for (let branch2 in branches) {
    if (branches[branch2] === commit2.id)
      label.push(branch2);
  }
  log$1.debug(label.join(" "));
  if (commit2.parents && commit2.parents.length == 2) {
    const newCommit = commits[commit2.parents[0]];
    upsert(commitArr, commit2, newCommit);
    commitArr.push(commits[commit2.parents[1]]);
  } else if (commit2.parents.length == 0) {
    return;
  } else {
    const nextCommit = commits[commit2.parents];
    upsert(commitArr, commit2, nextCommit);
  }
  commitArr = uniqBy(commitArr, (c2) => c2.id);
  prettyPrintCommitHistory(commitArr);
}
const prettyPrint = function() {
  log$1.debug(commits);
  const node2 = getCommitsArray()[0];
  prettyPrintCommitHistory([node2]);
};
const clear$f = function() {
  commits = {};
  head = null;
  let mainBranch = getConfig$1().gitGraph.mainBranchName;
  let mainBranchOrder2 = getConfig$1().gitGraph.mainBranchOrder;
  branches = {};
  branches[mainBranch] = null;
  branchesConfig = {};
  branchesConfig[mainBranch] = { name: mainBranch, order: mainBranchOrder2 };
  curBranch = mainBranch;
  seq = 0;
  clear$g();
};
const getBranchesAsObjArray = function() {
  const branchesArray = Object.values(branchesConfig).map((branchConfig, i) => {
    if (branchConfig.order !== null)
      return branchConfig;
    return {
      ...branchConfig,
      order: parseFloat(`0.${i}`, 10)
    };
  }).sort((a2, b) => a2.order - b.order).map(({ name: name2 }) => ({ name: name2 }));
  return branchesArray;
};
const getBranches = function() {
  return branches;
};
const getCommits = function() {
  return commits;
};
const getCommitsArray = function() {
  const commitArr = Object.keys(commits).map(function(key) {
    return commits[key];
  });
  commitArr.forEach(function(o) {
    log$1.debug(o.id);
  });
  commitArr.sort((a2, b) => a2.seq - b.seq);
  return commitArr;
};
const getCurrentBranch = function() {
  return curBranch;
};
const getDirection$3 = function() {
  return direction$3;
};
const getHead = function() {
  return head;
};
const commitType$1 = {
  NORMAL: 0,
  REVERSE: 1,
  HIGHLIGHT: 2,
  MERGE: 3,
  CHERRY_PICK: 4
};
const gitGraphDb = {
  parseDirective: parseDirective$b,
  getConfig: () => getConfig$1().gitGraph,
  setDirection: setDirection$3,
  setOptions,
  getOptions,
  commit,
  branch,
  merge,
  cherryPick,
  checkout,
  prettyPrint,
  clear: clear$f,
  getBranchesAsObjArray,
  getBranches,
  getCommits,
  getCommitsArray,
  getCurrentBranch,
  getDirection: getDirection$3,
  getHead,
  setAccTitle,
  getAccTitle,
  getAccDescription,
  setAccDescription,
  commitType: commitType$1
};
function addSVGAccessibilityFields(yy_parser, svg2, id2) {
  if (typeof svg2.insert === "undefined") {
    return;
  }
  let title_string = yy_parser.getAccTitle();
  let description2 = yy_parser.getAccDescription();
  svg2.attr("role", "img").attr("aria-labelledby", "chart-title-" + id2 + " chart-desc-" + id2);
  svg2.insert("desc", ":first-child").attr("id", "chart-desc-" + id2).text(description2);
  svg2.insert("title", ":first-child").attr("id", "chart-title-" + id2).text(title_string);
}
let allCommitsDict = {};
const commitType = {
  NORMAL: 0,
  REVERSE: 1,
  HIGHLIGHT: 2,
  MERGE: 3,
  CHERRY_PICK: 4
};
const THEME_COLOR_LIMIT = 8;
let branchPos = {};
let commitPos = {};
let lanes = [];
let maxPos = 0;
const clear$e = () => {
  branchPos = {};
  commitPos = {};
  allCommitsDict = {};
  maxPos = 0;
  lanes = [];
};
const drawText$3 = (txt) => {
  const svgLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
  let rows = [];
  if (typeof txt === "string") {
    rows = txt.split(/\\n|\n|<br\s*\/?>/gi);
  } else if (Array.isArray(txt)) {
    rows = txt;
  } else {
    rows = [];
  }
  for (let j2 = 0; j2 < rows.length; j2++) {
    const tspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
    tspan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
    tspan.setAttribute("dy", "1em");
    tspan.setAttribute("x", "0");
    tspan.setAttribute("class", "row");
    tspan.textContent = rows[j2].trim();
    svgLabel.appendChild(tspan);
  }
  return svgLabel;
};
const drawCommits = (svg2, commits2, modifyGraph) => {
  const gitGraphConfig = getConfig().gitGraph;
  const gBullets = svg2.append("g").attr("class", "commit-bullets");
  const gLabels = svg2.append("g").attr("class", "commit-labels");
  let pos = 0;
  const keys2 = Object.keys(commits2);
  const sortedKeys = keys2.sort((a2, b) => {
    return commits2[a2].seq - commits2[b].seq;
  });
  sortedKeys.forEach((key) => {
    const commit2 = commits2[key];
    const y2 = branchPos[commit2.branch].pos;
    const x2 = pos + 10;
    if (modifyGraph) {
      let typeClass;
      let commitSymbolType = typeof commit2.customType !== "undefined" && commit2.customType !== "" ? commit2.customType : commit2.type;
      switch (commitSymbolType) {
        case commitType.NORMAL:
          typeClass = "commit-normal";
          break;
        case commitType.REVERSE:
          typeClass = "commit-reverse";
          break;
        case commitType.HIGHLIGHT:
          typeClass = "commit-highlight";
          break;
        case commitType.MERGE:
          typeClass = "commit-merge";
          break;
        case commitType.CHERRY_PICK:
          typeClass = "commit-cherry-pick";
          break;
        default:
          typeClass = "commit-normal";
      }
      if (commitSymbolType === commitType.HIGHLIGHT) {
        const circle2 = gBullets.append("rect");
        circle2.attr("x", x2 - 10);
        circle2.attr("y", y2 - 10);
        circle2.attr("height", 20);
        circle2.attr("width", 20);
        circle2.attr(
          "class",
          `commit ${commit2.id} commit-highlight${branchPos[commit2.branch].index % THEME_COLOR_LIMIT} ${typeClass}-outer`
        );
        gBullets.append("rect").attr("x", x2 - 6).attr("y", y2 - 6).attr("height", 12).attr("width", 12).attr(
          "class",
          `commit ${commit2.id} commit${branchPos[commit2.branch].index % THEME_COLOR_LIMIT} ${typeClass}-inner`
        );
      } else if (commitSymbolType === commitType.CHERRY_PICK) {
        gBullets.append("circle").attr("cx", x2).attr("cy", y2).attr("r", 10).attr("class", `commit ${commit2.id} ${typeClass}`);
        gBullets.append("circle").attr("cx", x2 - 3).attr("cy", y2 + 2).attr("r", 2.75).attr("fill", "#fff").attr("class", `commit ${commit2.id} ${typeClass}`);
        gBullets.append("circle").attr("cx", x2 + 3).attr("cy", y2 + 2).attr("r", 2.75).attr("fill", "#fff").attr("class", `commit ${commit2.id} ${typeClass}`);
        gBullets.append("line").attr("x1", x2 + 3).attr("y1", y2 + 1).attr("x2", x2).attr("y2", y2 - 5).attr("stroke", "#fff").attr("class", `commit ${commit2.id} ${typeClass}`);
        gBullets.append("line").attr("x1", x2 - 3).attr("y1", y2 + 1).attr("x2", x2).attr("y2", y2 - 5).attr("stroke", "#fff").attr("class", `commit ${commit2.id} ${typeClass}`);
      } else {
        const circle2 = gBullets.append("circle");
        circle2.attr("cx", x2);
        circle2.attr("cy", y2);
        circle2.attr("r", commit2.type === commitType.MERGE ? 9 : 10);
        circle2.attr(
          "class",
          `commit ${commit2.id} commit${branchPos[commit2.branch].index % THEME_COLOR_LIMIT}`
        );
        if (commitSymbolType === commitType.MERGE) {
          const circle22 = gBullets.append("circle");
          circle22.attr("cx", x2);
          circle22.attr("cy", y2);
          circle22.attr("r", 6);
          circle22.attr(
            "class",
            `commit ${typeClass} ${commit2.id} commit${branchPos[commit2.branch].index % THEME_COLOR_LIMIT}`
          );
        }
        if (commitSymbolType === commitType.REVERSE) {
          const cross2 = gBullets.append("path");
          cross2.attr("d", `M ${x2 - 5},${y2 - 5}L${x2 + 5},${y2 + 5}M${x2 - 5},${y2 + 5}L${x2 + 5},${y2 - 5}`).attr(
            "class",
            `commit ${typeClass} ${commit2.id} commit${branchPos[commit2.branch].index % THEME_COLOR_LIMIT}`
          );
        }
      }
    }
    commitPos[commit2.id] = { x: pos + 10, y: y2 };
    if (modifyGraph) {
      const px = 4;
      const py = 2;
      if (commit2.type !== commitType.CHERRY_PICK && (commit2.customId && commit2.type === commitType.MERGE || commit2.type !== commitType.MERGE) && gitGraphConfig.showCommitLabel) {
        const wrapper = gLabels.append("g");
        const labelBkg = wrapper.insert("rect").attr("class", "commit-label-bkg");
        const text2 = wrapper.append("text").attr("x", pos).attr("y", y2 + 25).attr("class", "commit-label").text(commit2.id);
        let bbox = text2.node().getBBox();
        labelBkg.attr("x", pos + 10 - bbox.width / 2 - py).attr("y", y2 + 13.5).attr("width", bbox.width + 2 * py).attr("height", bbox.height + 2 * py);
        text2.attr("x", pos + 10 - bbox.width / 2);
        if (gitGraphConfig.rotateCommitLabel) {
          let r_x = -7.5 - (bbox.width + 10) / 25 * 9.5;
          let r_y = 10 + bbox.width / 25 * 8.5;
          wrapper.attr(
            "transform",
            "translate(" + r_x + ", " + r_y + ") rotate(" + -45 + ", " + pos + ", " + y2 + ")"
          );
        }
      }
      if (commit2.tag) {
        const rect2 = gLabels.insert("polygon");
        const hole = gLabels.append("circle");
        const tag = gLabels.append("text").attr("y", y2 - 16).attr("class", "tag-label").text(commit2.tag);
        let tagBbox = tag.node().getBBox();
        tag.attr("x", pos + 10 - tagBbox.width / 2);
        const h2 = tagBbox.height / 2;
        const ly = y2 - 19.2;
        rect2.attr("class", "tag-label-bkg").attr(
          "points",
          `
          ${pos - tagBbox.width / 2 - px / 2},${ly + py}
          ${pos - tagBbox.width / 2 - px / 2},${ly - py}
          ${pos + 10 - tagBbox.width / 2 - px},${ly - h2 - py}
          ${pos + 10 + tagBbox.width / 2 + px},${ly - h2 - py}
          ${pos + 10 + tagBbox.width / 2 + px},${ly + h2 + py}
          ${pos + 10 - tagBbox.width / 2 - px},${ly + h2 + py}`
        );
        hole.attr("cx", pos - tagBbox.width / 2 + px / 2).attr("cy", ly).attr("r", 1.5).attr("class", "tag-hole");
      }
    }
    pos += 50;
    if (pos > maxPos) {
      maxPos = pos;
    }
  });
};
const hasOverlappingCommits = (commit1, commit2, allCommits) => {
  const keys2 = Object.keys(allCommits);
  const overlappingComits = keys2.filter((key) => {
    return allCommits[key].branch === commit2.branch && allCommits[key].seq > commit1.seq && allCommits[key].seq < commit2.seq;
  });
  return overlappingComits.length > 0;
};
const findLane = (y12, y2, _depth) => {
  const depth = _depth || 0;
  const candidate = y12 + Math.abs(y12 - y2) / 2;
  if (depth > 5) {
    return candidate;
  }
  let ok = true;
  for (let i = 0; i < lanes.length; i++) {
    if (Math.abs(lanes[i] - candidate) < 10) {
      ok = false;
    }
  }
  if (ok) {
    lanes.push(candidate);
    return candidate;
  }
  const diff = Math.abs(y12 - y2);
  return findLane(y12, y2 - diff / 5, depth + 1);
};
const drawArrow = (svg2, commit1, commit2, allCommits) => {
  const p1 = commitPos[commit1.id];
  const p2 = commitPos[commit2.id];
  const overlappingCommits = hasOverlappingCommits(commit1, commit2, allCommits);
  let arc2 = "";
  let arc22 = "";
  let radius = 0;
  let offset = 0;
  let colorClassNum = branchPos[commit2.branch].index;
  let lineDef;
  if (overlappingCommits) {
    arc2 = "A 10 10, 0, 0, 0,";
    arc22 = "A 10 10, 0, 0, 1,";
    radius = 10;
    offset = 10;
    colorClassNum = branchPos[commit2.branch].index;
    const lineY = p1.y < p2.y ? findLane(p1.y, p2.y) : findLane(p2.y, p1.y);
    if (p1.y < p2.y) {
      lineDef = `M ${p1.x} ${p1.y} L ${p1.x} ${lineY - radius} ${arc2} ${p1.x + offset} ${lineY} L ${p2.x - radius} ${lineY} ${arc22} ${p2.x} ${lineY + offset} L ${p2.x} ${p2.y}`;
    } else {
      lineDef = `M ${p1.x} ${p1.y} L ${p1.x} ${lineY + radius} ${arc22} ${p1.x + offset} ${lineY} L ${p2.x - radius} ${lineY} ${arc2} ${p2.x} ${lineY - offset} L ${p2.x} ${p2.y}`;
    }
  } else {
    if (p1.y < p2.y) {
      arc2 = "A 20 20, 0, 0, 0,";
      radius = 20;
      offset = 20;
      colorClassNum = branchPos[commit2.branch].index;
      lineDef = `M ${p1.x} ${p1.y} L ${p1.x} ${p2.y - radius} ${arc2} ${p1.x + offset} ${p2.y} L ${p2.x} ${p2.y}`;
    }
    if (p1.y > p2.y) {
      arc2 = "A 20 20, 0, 0, 0,";
      radius = 20;
      offset = 20;
      colorClassNum = branchPos[commit1.branch].index;
      lineDef = `M ${p1.x} ${p1.y} L ${p2.x - radius} ${p1.y} ${arc2} ${p2.x} ${p1.y - offset} L ${p2.x} ${p2.y}`;
    }
    if (p1.y === p2.y) {
      colorClassNum = branchPos[commit1.branch].index;
      lineDef = `M ${p1.x} ${p1.y} L ${p1.x} ${p2.y - radius} ${arc2} ${p1.x + offset} ${p2.y} L ${p2.x} ${p2.y}`;
    }
  }
  svg2.append("path").attr("d", lineDef).attr("class", "arrow arrow" + colorClassNum % THEME_COLOR_LIMIT);
};
const drawArrows = (svg2, commits2) => {
  const gArrows = svg2.append("g").attr("class", "commit-arrows");
  Object.keys(commits2).forEach((key) => {
    const commit2 = commits2[key];
    if (commit2.parents && commit2.parents.length > 0) {
      commit2.parents.forEach((parent) => {
        drawArrow(gArrows, commits2[parent], commit2, commits2);
      });
    }
  });
};
const drawBranches = (svg2, branches2) => {
  const gitGraphConfig = getConfig().gitGraph;
  const g2 = svg2.append("g");
  branches2.forEach((branch2, index2) => {
    const adjustIndexForTheme = index2 % THEME_COLOR_LIMIT;
    const pos = branchPos[branch2.name].pos;
    const line2 = g2.append("line");
    line2.attr("x1", 0);
    line2.attr("y1", pos);
    line2.attr("x2", maxPos);
    line2.attr("y2", pos);
    line2.attr("class", "branch branch" + adjustIndexForTheme);
    lanes.push(pos);
    let name2 = branch2.name;
    const labelElement = drawText$3(name2);
    const bkg = g2.insert("rect");
    const branchLabel = g2.insert("g").attr("class", "branchLabel");
    const label = branchLabel.insert("g").attr("class", "label branch-label" + adjustIndexForTheme);
    label.node().appendChild(labelElement);
    let bbox = labelElement.getBBox();
    bkg.attr("class", "branchLabelBkg label" + adjustIndexForTheme).attr("rx", 4).attr("ry", 4).attr("x", -bbox.width - 4 - (gitGraphConfig.rotateCommitLabel === true ? 30 : 0)).attr("y", -bbox.height / 2 + 8).attr("width", bbox.width + 18).attr("height", bbox.height + 4);
    label.attr(
      "transform",
      "translate(" + (-bbox.width - 14 - (gitGraphConfig.rotateCommitLabel === true ? 30 : 0)) + ", " + (pos - bbox.height / 2 - 1) + ")"
    );
    bkg.attr("transform", "translate(" + -19 + ", " + (pos - bbox.height / 2) + ")");
  });
};
const draw$f = function(txt, id2, ver, diagObj) {
  clear$e();
  const conf2 = getConfig();
  const gitGraphConfig = getConfig().gitGraph;
  log$1.debug("in gitgraph renderer", txt + "\n", "id:", id2, ver);
  allCommitsDict = diagObj.db.getCommits();
  const branches2 = diagObj.db.getBranchesAsObjArray();
  let pos = 0;
  branches2.forEach((branch2, index2) => {
    branchPos[branch2.name] = { pos, index: index2 };
    pos += 50 + (gitGraphConfig.rotateCommitLabel ? 40 : 0);
  });
  const diagram = select$1(`[id="${id2}"]`);
  addSVGAccessibilityFields(diagObj.db, diagram, id2);
  drawCommits(diagram, allCommitsDict, false);
  if (gitGraphConfig.showBranches) {
    drawBranches(diagram, branches2);
  }
  drawArrows(diagram, allCommitsDict);
  drawCommits(diagram, allCommitsDict, true);
  setupGraphViewbox(void 0, diagram, gitGraphConfig.diagramPadding, conf2.useMaxWidth);
};
const gitGraphRenderer = {
  draw: draw$f
};
const getStyles = (options2) => `
  .commit-id,
  .commit-msg,
  .branch-label {
    fill: lightgrey;
    color: lightgrey;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
  }
  ${[0, 1, 2, 3, 4, 5, 6, 7].map(
  (i) => `
        .branch-label${i} { fill: ${options2["gitBranchLabel" + i]}; }
        .commit${i} { stroke: ${options2["git" + i]}; fill: ${options2["git" + i]}; }
        .commit-highlight${i} { stroke: ${options2["gitInv" + i]}; fill: ${options2["gitInv" + i]}; }
        .label${i}  { fill: ${options2["git" + i]}; }
        .arrow${i} { stroke: ${options2["git" + i]}; }
        `
).join("\n")}

  .branch {
    stroke-width: 1;
    stroke: ${options2.lineColor};
    stroke-dasharray: 2;
  }
  .commit-label { font-size: ${options2.commitLabelFontSize}; fill: ${options2.commitLabelColor};}
  .commit-label-bkg { font-size: ${options2.commitLabelFontSize}; fill: ${options2.commitLabelBackground}; opacity: 0.5; }
  .tag-label { font-size: ${options2.tagLabelFontSize}; fill: ${options2.tagLabelColor};}
  .tag-label-bkg { fill: ${options2.tagLabelBackground}; stroke: ${options2.tagLabelBorder}; }
  .tag-hole { fill: ${options2.textColor}; }

  .commit-merge {
    stroke: ${options2.primaryColor};
    fill: ${options2.primaryColor};
  }
  .commit-reverse {
    stroke: ${options2.primaryColor};
    fill: ${options2.primaryColor};
    stroke-width: 3;
  }
  .commit-highlight-outer {
  }
  .commit-highlight-inner {
    stroke: ${options2.primaryColor};
    fill: ${options2.primaryColor};
  }

  .arrow { stroke-width: 8; stroke-linecap: round; fill: none}
  }
`;
var parser$a = function() {
  var o = function(k2, v, o2, l2) {
    for (o2 = o2 || {}, l2 = k2.length; l2--; o2[k2[l2]] = v)
      ;
    return o2;
  }, $V0 = [1, 6], $V1 = [1, 7], $V2 = [1, 8], $V3 = [1, 9], $V4 = [1, 16], $V5 = [1, 11], $V6 = [1, 12], $V7 = [1, 13], $V8 = [1, 14], $V9 = [1, 15], $Va = [1, 27], $Vb = [1, 33], $Vc = [1, 34], $Vd = [1, 35], $Ve = [1, 36], $Vf = [1, 37], $Vg = [1, 72], $Vh = [1, 73], $Vi = [1, 74], $Vj = [1, 75], $Vk = [1, 76], $Vl = [1, 77], $Vm = [1, 78], $Vn = [1, 38], $Vo = [1, 39], $Vp = [1, 40], $Vq = [1, 41], $Vr = [1, 42], $Vs = [1, 43], $Vt = [1, 44], $Vu = [1, 45], $Vv = [1, 46], $Vw = [1, 47], $Vx = [1, 48], $Vy = [1, 49], $Vz = [1, 50], $VA = [1, 51], $VB = [1, 52], $VC = [1, 53], $VD = [1, 54], $VE = [1, 55], $VF = [1, 56], $VG = [1, 57], $VH = [1, 59], $VI = [1, 60], $VJ = [1, 61], $VK = [1, 62], $VL = [1, 63], $VM = [1, 64], $VN = [1, 65], $VO = [1, 66], $VP = [1, 67], $VQ = [1, 68], $VR = [1, 69], $VS = [24, 52], $VT = [24, 44, 46, 47, 48, 49, 50, 51, 52, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84], $VU = [15, 24, 44, 46, 47, 48, 49, 50, 51, 52, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84], $VV = [1, 94], $VW = [1, 95], $VX = [1, 96], $VY = [1, 97], $VZ = [15, 24, 52], $V_ = [7, 8, 9, 10, 18, 22, 25, 26, 27, 28], $V$ = [15, 24, 43, 52], $V01 = [15, 24, 43, 52, 86, 87, 89, 90], $V11 = [15, 43], $V21 = [44, 46, 47, 48, 49, 50, 51, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84];
  var parser2 = {
    trace: function trace() {
    },
    yy: {},
    symbols_: { "error": 2, "start": 3, "mermaidDoc": 4, "direction": 5, "directive": 6, "direction_tb": 7, "direction_bt": 8, "direction_rl": 9, "direction_lr": 10, "graphConfig": 11, "openDirective": 12, "typeDirective": 13, "closeDirective": 14, "NEWLINE": 15, ":": 16, "argDirective": 17, "open_directive": 18, "type_directive": 19, "arg_directive": 20, "close_directive": 21, "C4_CONTEXT": 22, "statements": 23, "EOF": 24, "C4_CONTAINER": 25, "C4_COMPONENT": 26, "C4_DYNAMIC": 27, "C4_DEPLOYMENT": 28, "otherStatements": 29, "diagramStatements": 30, "otherStatement": 31, "title": 32, "accDescription": 33, "acc_title": 34, "acc_title_value": 35, "acc_descr": 36, "acc_descr_value": 37, "acc_descr_multiline_value": 38, "boundaryStatement": 39, "boundaryStartStatement": 40, "boundaryStopStatement": 41, "boundaryStart": 42, "LBRACE": 43, "ENTERPRISE_BOUNDARY": 44, "attributes": 45, "SYSTEM_BOUNDARY": 46, "BOUNDARY": 47, "CONTAINER_BOUNDARY": 48, "NODE": 49, "NODE_L": 50, "NODE_R": 51, "RBRACE": 52, "diagramStatement": 53, "PERSON": 54, "PERSON_EXT": 55, "SYSTEM": 56, "SYSTEM_DB": 57, "SYSTEM_QUEUE": 58, "SYSTEM_EXT": 59, "SYSTEM_EXT_DB": 60, "SYSTEM_EXT_QUEUE": 61, "CONTAINER": 62, "CONTAINER_DB": 63, "CONTAINER_QUEUE": 64, "CONTAINER_EXT": 65, "CONTAINER_EXT_DB": 66, "CONTAINER_EXT_QUEUE": 67, "COMPONENT": 68, "COMPONENT_DB": 69, "COMPONENT_QUEUE": 70, "COMPONENT_EXT": 71, "COMPONENT_EXT_DB": 72, "COMPONENT_EXT_QUEUE": 73, "REL": 74, "BIREL": 75, "REL_U": 76, "REL_D": 77, "REL_L": 78, "REL_R": 79, "REL_B": 80, "REL_INDEX": 81, "UPDATE_EL_STYLE": 82, "UPDATE_REL_STYLE": 83, "UPDATE_LAYOUT_CONFIG": 84, "attribute": 85, "STR": 86, "STR_KEY": 87, "STR_VALUE": 88, "ATTRIBUTE": 89, "ATTRIBUTE_EMPTY": 90, "$accept": 0, "$end": 1 },
    terminals_: { 2: "error", 7: "direction_tb", 8: "direction_bt", 9: "direction_rl", 10: "direction_lr", 15: "NEWLINE", 16: ":", 18: "open_directive", 19: "type_directive", 20: "arg_directive", 21: "close_directive", 22: "C4_CONTEXT", 24: "EOF", 25: "C4_CONTAINER", 26: "C4_COMPONENT", 27: "C4_DYNAMIC", 28: "C4_DEPLOYMENT", 32: "title", 33: "accDescription", 34: "acc_title", 35: "acc_title_value", 36: "acc_descr", 37: "acc_descr_value", 38: "acc_descr_multiline_value", 43: "LBRACE", 44: "ENTERPRISE_BOUNDARY", 46: "SYSTEM_BOUNDARY", 47: "BOUNDARY", 48: "CONTAINER_BOUNDARY", 49: "NODE", 50: "NODE_L", 51: "NODE_R", 52: "RBRACE", 54: "PERSON", 55: "PERSON_EXT", 56: "SYSTEM", 57: "SYSTEM_DB", 58: "SYSTEM_QUEUE", 59: "SYSTEM_EXT", 60: "SYSTEM_EXT_DB", 61: "SYSTEM_EXT_QUEUE", 62: "CONTAINER", 63: "CONTAINER_DB", 64: "CONTAINER_QUEUE", 65: "CONTAINER_EXT", 66: "CONTAINER_EXT_DB", 67: "CONTAINER_EXT_QUEUE", 68: "COMPONENT", 69: "COMPONENT_DB", 70: "COMPONENT_QUEUE", 71: "COMPONENT_EXT", 72: "COMPONENT_EXT_DB", 73: "COMPONENT_EXT_QUEUE", 74: "REL", 75: "BIREL", 76: "REL_U", 77: "REL_D", 78: "REL_L", 79: "REL_R", 80: "REL_B", 81: "REL_INDEX", 82: "UPDATE_EL_STYLE", 83: "UPDATE_REL_STYLE", 84: "UPDATE_LAYOUT_CONFIG", 86: "STR", 87: "STR_KEY", 88: "STR_VALUE", 89: "ATTRIBUTE", 90: "ATTRIBUTE_EMPTY" },
    productions_: [0, [3, 1], [3, 1], [3, 2], [5, 1], [5, 1], [5, 1], [5, 1], [4, 1], [6, 4], [6, 6], [12, 1], [13, 1], [17, 1], [14, 1], [11, 4], [11, 4], [11, 4], [11, 4], [11, 4], [23, 1], [23, 1], [23, 2], [29, 1], [29, 2], [29, 3], [31, 1], [31, 1], [31, 2], [31, 2], [31, 1], [39, 3], [40, 3], [40, 3], [40, 4], [42, 2], [42, 2], [42, 2], [42, 2], [42, 2], [42, 2], [42, 2], [41, 1], [30, 1], [30, 2], [30, 3], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 1], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [45, 1], [45, 2], [85, 1], [85, 2], [85, 1], [85, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 4:
          yy.setDirection("TB");
          break;
        case 5:
          yy.setDirection("BT");
          break;
        case 6:
          yy.setDirection("RL");
          break;
        case 7:
          yy.setDirection("LR");
          break;
        case 11:
          yy.parseDirective("%%{", "open_directive");
          break;
        case 12:
          break;
        case 13:
          $$[$0] = $$[$0].trim().replace(/'/g, '"');
          yy.parseDirective($$[$0], "arg_directive");
          break;
        case 14:
          yy.parseDirective("}%%", "close_directive", "c4Context");
          break;
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
          yy.setC4Type($$[$0 - 3]);
          break;
        case 26:
          yy.setTitle($$[$0].substring(6));
          this.$ = $$[$0].substring(6);
          break;
        case 27:
          yy.setAccDescription($$[$0].substring(15));
          this.$ = $$[$0].substring(15);
          break;
        case 28:
          this.$ = $$[$0].trim();
          yy.setTitle(this.$);
          break;
        case 29:
        case 30:
          this.$ = $$[$0].trim();
          yy.setAccDescription(this.$);
          break;
        case 35:
        case 36:
          $$[$0].splice(2, 0, "ENTERPRISE");
          yy.addPersonOrSystemBoundary(...$$[$0]);
          this.$ = $$[$0];
          break;
        case 37:
          yy.addPersonOrSystemBoundary(...$$[$0]);
          this.$ = $$[$0];
          break;
        case 38:
          $$[$0].splice(2, 0, "CONTAINER");
          yy.addContainerBoundary(...$$[$0]);
          this.$ = $$[$0];
          break;
        case 39:
          yy.addDeploymentNode("node", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 40:
          yy.addDeploymentNode("nodeL", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 41:
          yy.addDeploymentNode("nodeR", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 42:
          yy.popBoundaryParseStack();
          break;
        case 46:
          yy.addPersonOrSystem("person", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 47:
          yy.addPersonOrSystem("external_person", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 48:
          yy.addPersonOrSystem("system", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 49:
          yy.addPersonOrSystem("system_db", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 50:
          yy.addPersonOrSystem("system_queue", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 51:
          yy.addPersonOrSystem("external_system", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 52:
          yy.addPersonOrSystem("external_system_db", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 53:
          yy.addPersonOrSystem("external_system_queue", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 54:
          yy.addContainer("container", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 55:
          yy.addContainer("container_db", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 56:
          yy.addContainer("container_queue", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 57:
          yy.addContainer("external_container", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 58:
          yy.addContainer("external_container_db", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 59:
          yy.addContainer("external_container_queue", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 60:
          yy.addComponent("component", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 61:
          yy.addComponent("component_db", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 62:
          yy.addComponent("component_queue", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 63:
          yy.addComponent("external_component", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 64:
          yy.addComponent("external_component_db", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 65:
          yy.addComponent("external_component_queue", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 67:
          yy.addRel("rel", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 68:
          yy.addRel("birel", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 69:
          yy.addRel("rel_u", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 70:
          yy.addRel("rel_d", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 71:
          yy.addRel("rel_l", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 72:
          yy.addRel("rel_r", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 73:
          yy.addRel("rel_b", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 74:
          $$[$0].splice(0, 1);
          yy.addRel("rel", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 75:
          yy.updateElStyle("update_el_style", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 76:
          yy.updateRelStyle("update_rel_style", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 77:
          yy.updateLayoutConfig("update_layout_config", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 78:
          this.$ = [$$[$0]];
          break;
        case 79:
          $$[$0].unshift($$[$0 - 1]);
          this.$ = $$[$0];
          break;
        case 80:
        case 82:
          this.$ = $$[$0].trim();
          break;
        case 81:
          let kv = {};
          kv[$$[$0 - 1].trim()] = $$[$0].trim();
          this.$ = kv;
          break;
        case 83:
          this.$ = "";
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 5: 3, 6: 4, 7: $V0, 8: $V1, 9: $V2, 10: $V3, 11: 5, 12: 10, 18: $V4, 22: $V5, 25: $V6, 26: $V7, 27: $V8, 28: $V9 }, { 1: [3] }, { 1: [2, 1] }, { 1: [2, 2] }, { 3: 17, 4: 2, 5: 3, 6: 4, 7: $V0, 8: $V1, 9: $V2, 10: $V3, 11: 5, 12: 10, 18: $V4, 22: $V5, 25: $V6, 26: $V7, 27: $V8, 28: $V9 }, { 1: [2, 8] }, { 1: [2, 4] }, { 1: [2, 5] }, { 1: [2, 6] }, { 1: [2, 7] }, { 13: 18, 19: [1, 19] }, { 15: [1, 20] }, { 15: [1, 21] }, { 15: [1, 22] }, { 15: [1, 23] }, { 15: [1, 24] }, { 19: [2, 11] }, { 1: [2, 3] }, { 14: 25, 16: [1, 26], 21: $Va }, o([16, 21], [2, 12]), { 23: 28, 29: 29, 30: 30, 31: 31, 32: $Vb, 33: $Vc, 34: $Vd, 36: $Ve, 38: $Vf, 39: 58, 40: 70, 42: 71, 44: $Vg, 46: $Vh, 47: $Vi, 48: $Vj, 49: $Vk, 50: $Vl, 51: $Vm, 53: 32, 54: $Vn, 55: $Vo, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt, 61: $Vu, 62: $Vv, 63: $Vw, 64: $Vx, 65: $Vy, 66: $Vz, 67: $VA, 68: $VB, 69: $VC, 70: $VD, 71: $VE, 72: $VF, 73: $VG, 74: $VH, 75: $VI, 76: $VJ, 77: $VK, 78: $VL, 79: $VM, 80: $VN, 81: $VO, 82: $VP, 83: $VQ, 84: $VR }, { 23: 79, 29: 29, 30: 30, 31: 31, 32: $Vb, 33: $Vc, 34: $Vd, 36: $Ve, 38: $Vf, 39: 58, 40: 70, 42: 71, 44: $Vg, 46: $Vh, 47: $Vi, 48: $Vj, 49: $Vk, 50: $Vl, 51: $Vm, 53: 32, 54: $Vn, 55: $Vo, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt, 61: $Vu, 62: $Vv, 63: $Vw, 64: $Vx, 65: $Vy, 66: $Vz, 67: $VA, 68: $VB, 69: $VC, 70: $VD, 71: $VE, 72: $VF, 73: $VG, 74: $VH, 75: $VI, 76: $VJ, 77: $VK, 78: $VL, 79: $VM, 80: $VN, 81: $VO, 82: $VP, 83: $VQ, 84: $VR }, { 23: 80, 29: 29, 30: 30, 31: 31, 32: $Vb, 33: $Vc, 34: $Vd, 36: $Ve, 38: $Vf, 39: 58, 40: 70, 42: 71, 44: $Vg, 46: $Vh, 47: $Vi, 48: $Vj, 49: $Vk, 50: $Vl, 51: $Vm, 53: 32, 54: $Vn, 55: $Vo, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt, 61: $Vu, 62: $Vv, 63: $Vw, 64: $Vx, 65: $Vy, 66: $Vz, 67: $VA, 68: $VB, 69: $VC, 70: $VD, 71: $VE, 72: $VF, 73: $VG, 74: $VH, 75: $VI, 76: $VJ, 77: $VK, 78: $VL, 79: $VM, 80: $VN, 81: $VO, 82: $VP, 83: $VQ, 84: $VR }, { 23: 81, 29: 29, 30: 30, 31: 31, 32: $Vb, 33: $Vc, 34: $Vd, 36: $Ve, 38: $Vf, 39: 58, 40: 70, 42: 71, 44: $Vg, 46: $Vh, 47: $Vi, 48: $Vj, 49: $Vk, 50: $Vl, 51: $Vm, 53: 32, 54: $Vn, 55: $Vo, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt, 61: $Vu, 62: $Vv, 63: $Vw, 64: $Vx, 65: $Vy, 66: $Vz, 67: $VA, 68: $VB, 69: $VC, 70: $VD, 71: $VE, 72: $VF, 73: $VG, 74: $VH, 75: $VI, 76: $VJ, 77: $VK, 78: $VL, 79: $VM, 80: $VN, 81: $VO, 82: $VP, 83: $VQ, 84: $VR }, { 23: 82, 29: 29, 30: 30, 31: 31, 32: $Vb, 33: $Vc, 34: $Vd, 36: $Ve, 38: $Vf, 39: 58, 40: 70, 42: 71, 44: $Vg, 46: $Vh, 47: $Vi, 48: $Vj, 49: $Vk, 50: $Vl, 51: $Vm, 53: 32, 54: $Vn, 55: $Vo, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt, 61: $Vu, 62: $Vv, 63: $Vw, 64: $Vx, 65: $Vy, 66: $Vz, 67: $VA, 68: $VB, 69: $VC, 70: $VD, 71: $VE, 72: $VF, 73: $VG, 74: $VH, 75: $VI, 76: $VJ, 77: $VK, 78: $VL, 79: $VM, 80: $VN, 81: $VO, 82: $VP, 83: $VQ, 84: $VR }, { 15: [1, 83] }, { 17: 84, 20: [1, 85] }, { 15: [2, 14] }, { 24: [1, 86] }, o($VS, [2, 20], { 53: 32, 39: 58, 40: 70, 42: 71, 30: 87, 44: $Vg, 46: $Vh, 47: $Vi, 48: $Vj, 49: $Vk, 50: $Vl, 51: $Vm, 54: $Vn, 55: $Vo, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt, 61: $Vu, 62: $Vv, 63: $Vw, 64: $Vx, 65: $Vy, 66: $Vz, 67: $VA, 68: $VB, 69: $VC, 70: $VD, 71: $VE, 72: $VF, 73: $VG, 74: $VH, 75: $VI, 76: $VJ, 77: $VK, 78: $VL, 79: $VM, 80: $VN, 81: $VO, 82: $VP, 83: $VQ, 84: $VR }), o($VS, [2, 21]), o($VT, [2, 23], { 15: [1, 88] }), o($VS, [2, 43], { 15: [1, 89] }), o($VU, [2, 26]), o($VU, [2, 27]), { 35: [1, 90] }, { 37: [1, 91] }, o($VU, [2, 30]), { 45: 92, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 98, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 99, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 100, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 101, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 102, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 103, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 104, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 105, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 106, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 107, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 108, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 109, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 110, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 111, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 112, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 113, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 114, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 115, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 116, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, o($VZ, [2, 66]), { 45: 117, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 118, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 119, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 120, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 121, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 122, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 123, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 124, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 125, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 126, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 127, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 30: 128, 39: 58, 40: 70, 42: 71, 44: $Vg, 46: $Vh, 47: $Vi, 48: $Vj, 49: $Vk, 50: $Vl, 51: $Vm, 53: 32, 54: $Vn, 55: $Vo, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt, 61: $Vu, 62: $Vv, 63: $Vw, 64: $Vx, 65: $Vy, 66: $Vz, 67: $VA, 68: $VB, 69: $VC, 70: $VD, 71: $VE, 72: $VF, 73: $VG, 74: $VH, 75: $VI, 76: $VJ, 77: $VK, 78: $VL, 79: $VM, 80: $VN, 81: $VO, 82: $VP, 83: $VQ, 84: $VR }, { 15: [1, 130], 43: [1, 129] }, { 45: 131, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 132, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 133, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 134, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 135, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 136, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 137, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 24: [1, 138] }, { 24: [1, 139] }, { 24: [1, 140] }, { 24: [1, 141] }, o($V_, [2, 9]), { 14: 142, 21: $Va }, { 21: [2, 13] }, { 1: [2, 15] }, o($VS, [2, 22]), o($VT, [2, 24], { 31: 31, 29: 143, 32: $Vb, 33: $Vc, 34: $Vd, 36: $Ve, 38: $Vf }), o($VS, [2, 44], { 29: 29, 30: 30, 31: 31, 53: 32, 39: 58, 40: 70, 42: 71, 23: 144, 32: $Vb, 33: $Vc, 34: $Vd, 36: $Ve, 38: $Vf, 44: $Vg, 46: $Vh, 47: $Vi, 48: $Vj, 49: $Vk, 50: $Vl, 51: $Vm, 54: $Vn, 55: $Vo, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt, 61: $Vu, 62: $Vv, 63: $Vw, 64: $Vx, 65: $Vy, 66: $Vz, 67: $VA, 68: $VB, 69: $VC, 70: $VD, 71: $VE, 72: $VF, 73: $VG, 74: $VH, 75: $VI, 76: $VJ, 77: $VK, 78: $VL, 79: $VM, 80: $VN, 81: $VO, 82: $VP, 83: $VQ, 84: $VR }), o($VU, [2, 28]), o($VU, [2, 29]), o($VZ, [2, 46]), o($V$, [2, 78], { 85: 93, 45: 145, 86: $VV, 87: $VW, 89: $VX, 90: $VY }), o($V01, [2, 80]), { 88: [1, 146] }, o($V01, [2, 82]), o($V01, [2, 83]), o($VZ, [2, 47]), o($VZ, [2, 48]), o($VZ, [2, 49]), o($VZ, [2, 50]), o($VZ, [2, 51]), o($VZ, [2, 52]), o($VZ, [2, 53]), o($VZ, [2, 54]), o($VZ, [2, 55]), o($VZ, [2, 56]), o($VZ, [2, 57]), o($VZ, [2, 58]), o($VZ, [2, 59]), o($VZ, [2, 60]), o($VZ, [2, 61]), o($VZ, [2, 62]), o($VZ, [2, 63]), o($VZ, [2, 64]), o($VZ, [2, 65]), o($VZ, [2, 67]), o($VZ, [2, 68]), o($VZ, [2, 69]), o($VZ, [2, 70]), o($VZ, [2, 71]), o($VZ, [2, 72]), o($VZ, [2, 73]), o($VZ, [2, 74]), o($VZ, [2, 75]), o($VZ, [2, 76]), o($VZ, [2, 77]), { 41: 147, 52: [1, 148] }, { 15: [1, 149] }, { 43: [1, 150] }, o($V11, [2, 35]), o($V11, [2, 36]), o($V11, [2, 37]), o($V11, [2, 38]), o($V11, [2, 39]), o($V11, [2, 40]), o($V11, [2, 41]), { 1: [2, 16] }, { 1: [2, 17] }, { 1: [2, 18] }, { 1: [2, 19] }, { 15: [1, 151] }, o($VT, [2, 25]), o($VS, [2, 45]), o($V$, [2, 79]), o($V01, [2, 81]), o($VZ, [2, 31]), o($VZ, [2, 42]), o($V21, [2, 32]), o($V21, [2, 33], { 15: [1, 152] }), o($V_, [2, 10]), o($V21, [2, 34])],
    defaultActions: { 2: [2, 1], 3: [2, 2], 5: [2, 8], 6: [2, 4], 7: [2, 5], 8: [2, 6], 9: [2, 7], 16: [2, 11], 17: [2, 3], 27: [2, 14], 85: [2, 13], 86: [2, 15], 138: [2, 16], 139: [2, 17], 140: [2, 18], 141: [2, 19] },
    parseError: function parseError(str, hash2) {
      if (hash2.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash2;
        throw error;
      }
    },
    parse: function parse2(input) {
      var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k2 in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
          sharedState.yy[k2] = this.yy[k2];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges2 = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function lex() {
        var token2;
        token2 = tstack.pop() || lexer2.lex() || EOF2;
        if (typeof token2 !== "number") {
          if (token2 instanceof Array) {
            tstack = token2;
            token2 = tstack.pop();
          }
          token2 = self2.symbols_[token2] || token2;
        }
        return token2;
      }
      var symbol2, state, action, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack2[stack2.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol2 === null || typeof symbol2 == "undefined") {
            symbol2 = lex();
          }
          action = table[state] && table[state][symbol2];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push("'" + this.terminals_[p] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol2] || symbol2) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol2 == EOF2 ? "end of input" : "'" + (this.terminals_[symbol2] || symbol2) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol2] || symbol2,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol2);
        }
        switch (action[0]) {
          case 1:
            stack2.push(symbol2);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack2.push(action[1]);
            symbol2 = null;
            {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges2) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
              ];
            }
            r = this.performAction.apply(yyval, [
              yytext,
              yyleng,
              yylineno,
              sharedState.yy,
              action[1],
              vstack,
              lstack
            ].concat(args));
            if (typeof r !== "undefined") {
              return r;
            }
            if (len) {
              stack2 = stack2.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack2.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
            stack2.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash2) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash2);
        } else {
          throw new Error(str);
        }
      },
      setInput: function(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      input: function() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      unput: function(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      more: function() {
        this._more = true;
        return this;
      },
      reject: function() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      less: function(n) {
        this.unput(this.match.slice(n));
      },
      pastInput: function() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var next2 = this.match;
        if (next2.length < 20) {
          next2 += this._input.substr(0, 20 - next2.length);
        }
        return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var pre = this.pastInput();
        var c2 = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c2 + "^";
      },
      test_match: function(match, indexed_rule) {
        var token2, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token2) {
          return token2;
        } else if (this._backtrack) {
          for (var k2 in backup) {
            this[k2] = backup[k2];
          }
          return false;
        }
        return false;
      },
      next: function() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token2, match, tempMatch, index2;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index2 = i;
            if (this.options.backtrack_lexer) {
              token2 = this.test_match(tempMatch, rules[i]);
              if (token2 !== false) {
                return token2;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token2 = this.test_match(match, rules[index2]);
          if (token2 !== false) {
            return token2;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: {},
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        switch ($avoiding_name_collisions) {
          case 0:
            this.begin("open_directive");
            return 18;
          case 1:
            return 7;
          case 2:
            return 8;
          case 3:
            return 9;
          case 4:
            return 10;
          case 5:
            this.begin("type_directive");
            return 19;
          case 6:
            this.popState();
            this.begin("arg_directive");
            return 16;
          case 7:
            this.popState();
            this.popState();
            return 21;
          case 8:
            return 20;
          case 9:
            return 32;
          case 10:
            return 33;
          case 11:
            this.begin("acc_title");
            return 34;
          case 12:
            this.popState();
            return "acc_title_value";
          case 13:
            this.begin("acc_descr");
            return 36;
          case 14:
            this.popState();
            return "acc_descr_value";
          case 15:
            this.begin("acc_descr_multiline");
            break;
          case 16:
            this.popState();
            break;
          case 17:
            return "acc_descr_multiline_value";
          case 18:
            break;
          case 19:
            c;
            break;
          case 20:
            return 15;
          case 21:
            break;
          case 22:
            return 22;
          case 23:
            return 25;
          case 24:
            return 26;
          case 25:
            return 27;
          case 26:
            return 28;
          case 27:
            this.begin("person_ext");
            return 55;
          case 28:
            this.begin("person");
            return 54;
          case 29:
            this.begin("system_ext_queue");
            return 61;
          case 30:
            this.begin("system_ext_db");
            return 60;
          case 31:
            this.begin("system_ext");
            return 59;
          case 32:
            this.begin("system_queue");
            return 58;
          case 33:
            this.begin("system_db");
            return 57;
          case 34:
            this.begin("system");
            return 56;
          case 35:
            this.begin("boundary");
            return 47;
          case 36:
            this.begin("enterprise_boundary");
            return 44;
          case 37:
            this.begin("system_boundary");
            return 46;
          case 38:
            this.begin("container_ext_queue");
            return 67;
          case 39:
            this.begin("container_ext_db");
            return 66;
          case 40:
            this.begin("container_ext");
            return 65;
          case 41:
            this.begin("container_queue");
            return 64;
          case 42:
            this.begin("container_db");
            return 63;
          case 43:
            this.begin("container");
            return 62;
          case 44:
            this.begin("container_boundary");
            return 48;
          case 45:
            this.begin("component_ext_queue");
            return 73;
          case 46:
            this.begin("component_ext_db");
            return 72;
          case 47:
            this.begin("component_ext");
            return 71;
          case 48:
            this.begin("component_queue");
            return 70;
          case 49:
            this.begin("component_db");
            return 69;
          case 50:
            this.begin("component");
            return 68;
          case 51:
            this.begin("node");
            return 49;
          case 52:
            this.begin("node");
            return 49;
          case 53:
            this.begin("node_l");
            return 50;
          case 54:
            this.begin("node_r");
            return 51;
          case 55:
            this.begin("rel");
            return 74;
          case 56:
            this.begin("birel");
            return 75;
          case 57:
            this.begin("rel_u");
            return 76;
          case 58:
            this.begin("rel_u");
            return 76;
          case 59:
            this.begin("rel_d");
            return 77;
          case 60:
            this.begin("rel_d");
            return 77;
          case 61:
            this.begin("rel_l");
            return 78;
          case 62:
            this.begin("rel_l");
            return 78;
          case 63:
            this.begin("rel_r");
            return 79;
          case 64:
            this.begin("rel_r");
            return 79;
          case 65:
            this.begin("rel_b");
            return 80;
          case 66:
            this.begin("rel_index");
            return 81;
          case 67:
            this.begin("update_el_style");
            return 82;
          case 68:
            this.begin("update_rel_style");
            return 83;
          case 69:
            this.begin("update_layout_config");
            return 84;
          case 70:
            return "EOF_IN_STRUCT";
          case 71:
            this.begin("attribute");
            return "ATTRIBUTE_EMPTY";
          case 72:
            this.begin("attribute");
            break;
          case 73:
            this.popState();
            this.popState();
            break;
          case 74:
            return 90;
          case 75:
            break;
          case 76:
            return 90;
          case 77:
            this.begin("string");
            break;
          case 78:
            this.popState();
            break;
          case 79:
            return "STR";
          case 80:
            this.begin("string_kv");
            break;
          case 81:
            this.begin("string_kv_key");
            return "STR_KEY";
          case 82:
            this.popState();
            this.begin("string_kv_value");
            break;
          case 83:
            return "STR_VALUE";
          case 84:
            this.popState();
            this.popState();
            break;
          case 85:
            return "STR";
          case 86:
            return "LBRACE";
          case 87:
            return "RBRACE";
          case 88:
            return "SPACE";
          case 89:
            return "EOL";
          case 90:
            return 24;
        }
      },
      rules: [/^(?:%%\{)/, /^(?:.*direction\s+TB[^\n]*)/, /^(?:.*direction\s+BT[^\n]*)/, /^(?:.*direction\s+RL[^\n]*)/, /^(?:.*direction\s+LR[^\n]*)/, /^(?:((?:(?!\}%%)[^:.])*))/, /^(?::)/, /^(?:\}%%)/, /^(?:((?:(?!\}%%).|\n)*))/, /^(?:title\s[^#\n;]+)/, /^(?:accDescription\s[^#\n;]+)/, /^(?:accTitle\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*\{\s*)/, /^(?:[\}])/, /^(?:[^\}]*)/, /^(?:%%(?!\{)*[^\n]*(\r?\n?)+)/, /^(?:%%[^\n]*(\r?\n)*)/, /^(?:\s*(\r?\n)+)/, /^(?:\s+)/, /^(?:C4Context\b)/, /^(?:C4Container\b)/, /^(?:C4Component\b)/, /^(?:C4Dynamic\b)/, /^(?:C4Deployment\b)/, /^(?:Person_Ext\b)/, /^(?:Person\b)/, /^(?:SystemQueue_Ext\b)/, /^(?:SystemDb_Ext\b)/, /^(?:System_Ext\b)/, /^(?:SystemQueue\b)/, /^(?:SystemDb\b)/, /^(?:System\b)/, /^(?:Boundary\b)/, /^(?:Enterprise_Boundary\b)/, /^(?:System_Boundary\b)/, /^(?:ContainerQueue_Ext\b)/, /^(?:ContainerDb_Ext\b)/, /^(?:Container_Ext\b)/, /^(?:ContainerQueue\b)/, /^(?:ContainerDb\b)/, /^(?:Container\b)/, /^(?:Container_Boundary\b)/, /^(?:ComponentQueue_Ext\b)/, /^(?:ComponentDb_Ext\b)/, /^(?:Component_Ext\b)/, /^(?:ComponentQueue\b)/, /^(?:ComponentDb\b)/, /^(?:Component\b)/, /^(?:Deployment_Node\b)/, /^(?:Node\b)/, /^(?:Node_L\b)/, /^(?:Node_R\b)/, /^(?:Rel\b)/, /^(?:BiRel\b)/, /^(?:Rel_Up\b)/, /^(?:Rel_U\b)/, /^(?:Rel_Down\b)/, /^(?:Rel_D\b)/, /^(?:Rel_Left\b)/, /^(?:Rel_L\b)/, /^(?:Rel_Right\b)/, /^(?:Rel_R\b)/, /^(?:Rel_Back\b)/, /^(?:RelIndex\b)/, /^(?:UpdateElementStyle\b)/, /^(?:UpdateRelStyle\b)/, /^(?:UpdateLayoutConfig\b)/, /^(?:$)/, /^(?:[(][ ]*[,])/, /^(?:[(])/, /^(?:[)])/, /^(?:,,)/, /^(?:,)/, /^(?:[ ]*["]["])/, /^(?:[ ]*["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:[ ]*[\$])/, /^(?:[^=]*)/, /^(?:[=][ ]*["])/, /^(?:[^"]+)/, /^(?:["])/, /^(?:[^,]+)/, /^(?:\{)/, /^(?:\})/, /^(?:[\s]+)/, /^(?:[\n\r]+)/, /^(?:$)/],
      conditions: { "acc_descr_multiline": { "rules": [16, 17], "inclusive": false }, "acc_descr": { "rules": [14], "inclusive": false }, "acc_title": { "rules": [12], "inclusive": false }, "close_directive": { "rules": [], "inclusive": false }, "arg_directive": { "rules": [7, 8], "inclusive": false }, "type_directive": { "rules": [6, 7], "inclusive": false }, "open_directive": { "rules": [5], "inclusive": false }, "string_kv_value": { "rules": [83, 84], "inclusive": false }, "string_kv_key": { "rules": [82], "inclusive": false }, "string_kv": { "rules": [81], "inclusive": false }, "string": { "rules": [78, 79], "inclusive": false }, "attribute": { "rules": [73, 74, 75, 76, 77, 80, 85], "inclusive": false }, "update_layout_config": { "rules": [70, 71, 72, 73], "inclusive": false }, "update_rel_style": { "rules": [70, 71, 72, 73], "inclusive": false }, "update_el_style": { "rules": [70, 71, 72, 73], "inclusive": false }, "rel_b": { "rules": [70, 71, 72, 73], "inclusive": false }, "rel_r": { "rules": [70, 71, 72, 73], "inclusive": false }, "rel_l": { "rules": [70, 71, 72, 73], "inclusive": false }, "rel_d": { "rules": [70, 71, 72, 73], "inclusive": false }, "rel_u": { "rules": [70, 71, 72, 73], "inclusive": false }, "rel_bi": { "rules": [], "inclusive": false }, "rel": { "rules": [70, 71, 72, 73], "inclusive": false }, "node_r": { "rules": [70, 71, 72, 73], "inclusive": false }, "node_l": { "rules": [70, 71, 72, 73], "inclusive": false }, "node": { "rules": [70, 71, 72, 73], "inclusive": false }, "index": { "rules": [], "inclusive": false }, "rel_index": { "rules": [70, 71, 72, 73], "inclusive": false }, "component_ext_queue": { "rules": [], "inclusive": false }, "component_ext_db": { "rules": [70, 71, 72, 73], "inclusive": false }, "component_ext": { "rules": [70, 71, 72, 73], "inclusive": false }, "component_queue": { "rules": [70, 71, 72, 73], "inclusive": false }, "component_db": { "rules": [70, 71, 72, 73], "inclusive": false }, "component": { "rules": [70, 71, 72, 73], "inclusive": false }, "container_boundary": { "rules": [70, 71, 72, 73], "inclusive": false }, "container_ext_queue": { "rules": [], "inclusive": false }, "container_ext_db": { "rules": [70, 71, 72, 73], "inclusive": false }, "container_ext": { "rules": [70, 71, 72, 73], "inclusive": false }, "container_queue": { "rules": [70, 71, 72, 73], "inclusive": false }, "container_db": { "rules": [70, 71, 72, 73], "inclusive": false }, "container": { "rules": [70, 71, 72, 73], "inclusive": false }, "birel": { "rules": [70, 71, 72, 73], "inclusive": false }, "system_boundary": { "rules": [70, 71, 72, 73], "inclusive": false }, "enterprise_boundary": { "rules": [70, 71, 72, 73], "inclusive": false }, "boundary": { "rules": [70, 71, 72, 73], "inclusive": false }, "system_ext_queue": { "rules": [70, 71, 72, 73], "inclusive": false }, "system_ext_db": { "rules": [70, 71, 72, 73], "inclusive": false }, "system_ext": { "rules": [70, 71, 72, 73], "inclusive": false }, "system_queue": { "rules": [70, 71, 72, 73], "inclusive": false }, "system_db": { "rules": [70, 71, 72, 73], "inclusive": false }, "system": { "rules": [70, 71, 72, 73], "inclusive": false }, "person_ext": { "rules": [70, 71, 72, 73], "inclusive": false }, "person": { "rules": [70, 71, 72, 73], "inclusive": false }, "INITIAL": { "rules": [0, 1, 2, 3, 4, 9, 10, 11, 13, 15, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 86, 87, 88, 89, 90], "inclusive": true } }
    };
    return lexer2;
  }();
  parser2.lexer = lexer;
  function Parser2() {
    this.yy = {};
  }
  Parser2.prototype = parser2;
  parser2.Parser = Parser2;
  return new Parser2();
}();
parser$a.parser = parser$a;
const c4Detector = (txt) => {
  return txt.match(/^\s*C4Context|C4Container|C4Component|C4Dynamic|C4Deployment/) !== null;
};
let c4ShapeArray = [];
let boundaryParseStack = [""];
let currentBoundaryParse = "global";
let parentBoundaryParse = "";
let boundarys = [
  {
    alias: "global",
    label: { text: "global" },
    type: { text: "global" },
    tags: null,
    link: null,
    parentBoundary: ""
  }
];
let rels = [];
let title = "";
let wrapEnabled$1 = false;
let c4ShapeInRow$1 = 4;
let c4BoundaryInRow$1 = 2;
var c4Type;
const getC4Type = function() {
  return c4Type;
};
const setC4Type = function(c4TypeParam) {
  let sanitizedText = sanitizeText$5(c4TypeParam, getConfig$1());
  c4Type = sanitizedText;
};
const parseDirective$a = function(statement, context, type2) {
  mermaidAPI.parseDirective(this, statement, context, type2);
};
const addRel = function(type2, from2, to2, label, techn, descr, sprite, tags2, link2) {
  if (type2 === void 0 || type2 === null || from2 === void 0 || from2 === null || to2 === void 0 || to2 === null || label === void 0 || label === null)
    return;
  let rel = {};
  const old = rels.find((rel2) => rel2.from === from2 && rel2.to === to2);
  if (old) {
    rel = old;
  } else {
    rels.push(rel);
  }
  rel.type = type2;
  rel.from = from2;
  rel.to = to2;
  rel.label = { text: label };
  if (techn === void 0 || techn === null) {
    rel.techn = { text: "" };
  } else {
    if (typeof techn === "object") {
      let [key, value] = Object.entries(techn)[0];
      rel[key] = { text: value };
    } else {
      rel.techn = { text: techn };
    }
  }
  if (descr === void 0 || descr === null) {
    rel.descr = { text: "" };
  } else {
    if (typeof descr === "object") {
      let [key, value] = Object.entries(descr)[0];
      rel[key] = { text: value };
    } else {
      rel.descr = { text: descr };
    }
  }
  if (typeof sprite === "object") {
    let [key, value] = Object.entries(sprite)[0];
    rel[key] = value;
  } else {
    rel.sprite = sprite;
  }
  if (typeof tags2 === "object") {
    let [key, value] = Object.entries(tags2)[0];
    rel[key] = value;
  } else {
    rel.tags = tags2;
  }
  if (typeof link2 === "object") {
    let [key, value] = Object.entries(link2)[0];
    rel[key] = value;
  } else {
    rel.link = link2;
  }
  rel.wrap = autoWrap$1();
};
const addPersonOrSystem = function(typeC4Shape, alias, label, descr, sprite, tags2, link2) {
  if (alias === null || label === null)
    return;
  let personOrSystem = {};
  const old = c4ShapeArray.find((personOrSystem2) => personOrSystem2.alias === alias);
  if (old && alias === old.alias) {
    personOrSystem = old;
  } else {
    personOrSystem.alias = alias;
    c4ShapeArray.push(personOrSystem);
  }
  if (label === void 0 || label === null) {
    personOrSystem.label = { text: "" };
  } else {
    personOrSystem.label = { text: label };
  }
  if (descr === void 0 || descr === null) {
    personOrSystem.descr = { text: "" };
  } else {
    if (typeof descr === "object") {
      let [key, value] = Object.entries(descr)[0];
      personOrSystem[key] = { text: value };
    } else {
      personOrSystem.descr = { text: descr };
    }
  }
  if (typeof sprite === "object") {
    let [key, value] = Object.entries(sprite)[0];
    personOrSystem[key] = value;
  } else {
    personOrSystem.sprite = sprite;
  }
  if (typeof tags2 === "object") {
    let [key, value] = Object.entries(tags2)[0];
    personOrSystem[key] = value;
  } else {
    personOrSystem.tags = tags2;
  }
  if (typeof link2 === "object") {
    let [key, value] = Object.entries(link2)[0];
    personOrSystem[key] = value;
  } else {
    personOrSystem.link = link2;
  }
  personOrSystem.typeC4Shape = { text: typeC4Shape };
  personOrSystem.parentBoundary = currentBoundaryParse;
  personOrSystem.wrap = autoWrap$1();
};
const addContainer = function(typeC4Shape, alias, label, techn, descr, sprite, tags2, link2) {
  if (alias === null || label === null)
    return;
  let container = {};
  const old = c4ShapeArray.find((container2) => container2.alias === alias);
  if (old && alias === old.alias) {
    container = old;
  } else {
    container.alias = alias;
    c4ShapeArray.push(container);
  }
  if (label === void 0 || label === null) {
    container.label = { text: "" };
  } else {
    container.label = { text: label };
  }
  if (techn === void 0 || techn === null) {
    container.techn = { text: "" };
  } else {
    if (typeof techn === "object") {
      let [key, value] = Object.entries(techn)[0];
      container[key] = { text: value };
    } else {
      container.techn = { text: techn };
    }
  }
  if (descr === void 0 || descr === null) {
    container.descr = { text: "" };
  } else {
    if (typeof descr === "object") {
      let [key, value] = Object.entries(descr)[0];
      container[key] = { text: value };
    } else {
      container.descr = { text: descr };
    }
  }
  if (typeof sprite === "object") {
    let [key, value] = Object.entries(sprite)[0];
    container[key] = value;
  } else {
    container.sprite = sprite;
  }
  if (typeof tags2 === "object") {
    let [key, value] = Object.entries(tags2)[0];
    container[key] = value;
  } else {
    container.tags = tags2;
  }
  if (typeof link2 === "object") {
    let [key, value] = Object.entries(link2)[0];
    container[key] = value;
  } else {
    container.link = link2;
  }
  container.wrap = autoWrap$1();
  container.typeC4Shape = { text: typeC4Shape };
  container.parentBoundary = currentBoundaryParse;
};
const addComponent = function(typeC4Shape, alias, label, techn, descr, sprite, tags2, link2) {
  if (alias === null || label === null)
    return;
  let component = {};
  const old = c4ShapeArray.find((component2) => component2.alias === alias);
  if (old && alias === old.alias) {
    component = old;
  } else {
    component.alias = alias;
    c4ShapeArray.push(component);
  }
  if (label === void 0 || label === null) {
    component.label = { text: "" };
  } else {
    component.label = { text: label };
  }
  if (techn === void 0 || techn === null) {
    component.techn = { text: "" };
  } else {
    if (typeof techn === "object") {
      let [key, value] = Object.entries(techn)[0];
      component[key] = { text: value };
    } else {
      component.techn = { text: techn };
    }
  }
  if (descr === void 0 || descr === null) {
    component.descr = { text: "" };
  } else {
    if (typeof descr === "object") {
      let [key, value] = Object.entries(descr)[0];
      component[key] = { text: value };
    } else {
      component.descr = { text: descr };
    }
  }
  if (typeof sprite === "object") {
    let [key, value] = Object.entries(sprite)[0];
    component[key] = value;
  } else {
    component.sprite = sprite;
  }
  if (typeof tags2 === "object") {
    let [key, value] = Object.entries(tags2)[0];
    component[key] = value;
  } else {
    component.tags = tags2;
  }
  if (typeof link2 === "object") {
    let [key, value] = Object.entries(link2)[0];
    component[key] = value;
  } else {
    component.link = link2;
  }
  component.wrap = autoWrap$1();
  component.typeC4Shape = { text: typeC4Shape };
  component.parentBoundary = currentBoundaryParse;
};
const addPersonOrSystemBoundary = function(alias, label, type2, tags2, link2) {
  if (alias === null || label === null)
    return;
  let boundary = {};
  const old = boundarys.find((boundary2) => boundary2.alias === alias);
  if (old && alias === old.alias) {
    boundary = old;
  } else {
    boundary.alias = alias;
    boundarys.push(boundary);
  }
  if (label === void 0 || label === null) {
    boundary.label = { text: "" };
  } else {
    boundary.label = { text: label };
  }
  if (type2 === void 0 || type2 === null) {
    boundary.type = { text: "system" };
  } else {
    if (typeof type2 === "object") {
      let [key, value] = Object.entries(type2)[0];
      boundary[key] = { text: value };
    } else {
      boundary.type = { text: type2 };
    }
  }
  if (typeof tags2 === "object") {
    let [key, value] = Object.entries(tags2)[0];
    boundary[key] = value;
  } else {
    boundary.tags = tags2;
  }
  if (typeof link2 === "object") {
    let [key, value] = Object.entries(link2)[0];
    boundary[key] = value;
  } else {
    boundary.link = link2;
  }
  boundary.parentBoundary = currentBoundaryParse;
  boundary.wrap = autoWrap$1();
  parentBoundaryParse = currentBoundaryParse;
  currentBoundaryParse = alias;
  boundaryParseStack.push(parentBoundaryParse);
};
const addContainerBoundary = function(alias, label, type2, tags2, link2) {
  if (alias === null || label === null)
    return;
  let boundary = {};
  const old = boundarys.find((boundary2) => boundary2.alias === alias);
  if (old && alias === old.alias) {
    boundary = old;
  } else {
    boundary.alias = alias;
    boundarys.push(boundary);
  }
  if (label === void 0 || label === null) {
    boundary.label = { text: "" };
  } else {
    boundary.label = { text: label };
  }
  if (type2 === void 0 || type2 === null) {
    boundary.type = { text: "container" };
  } else {
    if (typeof type2 === "object") {
      let [key, value] = Object.entries(type2)[0];
      boundary[key] = { text: value };
    } else {
      boundary.type = { text: type2 };
    }
  }
  if (typeof tags2 === "object") {
    let [key, value] = Object.entries(tags2)[0];
    boundary[key] = value;
  } else {
    boundary.tags = tags2;
  }
  if (typeof link2 === "object") {
    let [key, value] = Object.entries(link2)[0];
    boundary[key] = value;
  } else {
    boundary.link = link2;
  }
  boundary.parentBoundary = currentBoundaryParse;
  boundary.wrap = autoWrap$1();
  parentBoundaryParse = currentBoundaryParse;
  currentBoundaryParse = alias;
  boundaryParseStack.push(parentBoundaryParse);
};
const addDeploymentNode = function(nodeType, alias, label, type2, descr, sprite, tags2, link2) {
  if (alias === null || label === null)
    return;
  let boundary = {};
  const old = boundarys.find((boundary2) => boundary2.alias === alias);
  if (old && alias === old.alias) {
    boundary = old;
  } else {
    boundary.alias = alias;
    boundarys.push(boundary);
  }
  if (label === void 0 || label === null) {
    boundary.label = { text: "" };
  } else {
    boundary.label = { text: label };
  }
  if (type2 === void 0 || type2 === null) {
    boundary.type = { text: "node" };
  } else {
    if (typeof type2 === "object") {
      let [key, value] = Object.entries(type2)[0];
      boundary[key] = { text: value };
    } else {
      boundary.type = { text: type2 };
    }
  }
  if (descr === void 0 || descr === null) {
    boundary.descr = { text: "" };
  } else {
    if (typeof descr === "object") {
      let [key, value] = Object.entries(descr)[0];
      boundary[key] = { text: value };
    } else {
      boundary.descr = { text: descr };
    }
  }
  if (typeof tags2 === "object") {
    let [key, value] = Object.entries(tags2)[0];
    boundary[key] = value;
  } else {
    boundary.tags = tags2;
  }
  if (typeof link2 === "object") {
    let [key, value] = Object.entries(link2)[0];
    boundary[key] = value;
  } else {
    boundary.link = link2;
  }
  boundary.nodeType = nodeType;
  boundary.parentBoundary = currentBoundaryParse;
  boundary.wrap = autoWrap$1();
  parentBoundaryParse = currentBoundaryParse;
  currentBoundaryParse = alias;
  boundaryParseStack.push(parentBoundaryParse);
};
const popBoundaryParseStack = function() {
  currentBoundaryParse = parentBoundaryParse;
  boundaryParseStack.pop();
  parentBoundaryParse = boundaryParseStack.pop();
  boundaryParseStack.push(parentBoundaryParse);
};
const updateElStyle = function(typeC4Shape, elementName2, bgColor, fontColor, borderColor, shadowing, shape, sprite, techn, legendText, legendSprite) {
  let old = c4ShapeArray.find((element) => element.alias === elementName2);
  if (old === void 0) {
    old = boundarys.find((element) => element.alias === elementName2);
    if (old === void 0) {
      return;
    }
  }
  if (bgColor !== void 0 && bgColor !== null) {
    if (typeof bgColor === "object") {
      let [key, value] = Object.entries(bgColor)[0];
      old[key] = value;
    } else {
      old.bgColor = bgColor;
    }
  }
  if (fontColor !== void 0 && fontColor !== null) {
    if (typeof fontColor === "object") {
      let [key, value] = Object.entries(fontColor)[0];
      old[key] = value;
    } else {
      old.fontColor = fontColor;
    }
  }
  if (borderColor !== void 0 && borderColor !== null) {
    if (typeof borderColor === "object") {
      let [key, value] = Object.entries(borderColor)[0];
      old[key] = value;
    } else {
      old.borderColor = borderColor;
    }
  }
  if (shadowing !== void 0 && shadowing !== null) {
    if (typeof shadowing === "object") {
      let [key, value] = Object.entries(shadowing)[0];
      old[key] = value;
    } else {
      old.shadowing = shadowing;
    }
  }
  if (shape !== void 0 && shape !== null) {
    if (typeof shape === "object") {
      let [key, value] = Object.entries(shape)[0];
      old[key] = value;
    } else {
      old.shape = shape;
    }
  }
  if (sprite !== void 0 && sprite !== null) {
    if (typeof sprite === "object") {
      let [key, value] = Object.entries(sprite)[0];
      old[key] = value;
    } else {
      old.sprite = sprite;
    }
  }
  if (techn !== void 0 && techn !== null) {
    if (typeof techn === "object") {
      let [key, value] = Object.entries(techn)[0];
      old[key] = value;
    } else {
      old.techn = techn;
    }
  }
  if (legendText !== void 0 && legendText !== null) {
    if (typeof legendText === "object") {
      let [key, value] = Object.entries(legendText)[0];
      old[key] = value;
    } else {
      old.legendText = legendText;
    }
  }
  if (legendSprite !== void 0 && legendSprite !== null) {
    if (typeof legendSprite === "object") {
      let [key, value] = Object.entries(legendSprite)[0];
      old[key] = value;
    } else {
      old.legendSprite = legendSprite;
    }
  }
};
const updateRelStyle = function(typeC4Shape, from2, to2, textColor, lineColor, offsetX, offsetY) {
  const old = rels.find((rel) => rel.from === from2 && rel.to === to2);
  if (old === void 0) {
    return;
  }
  if (textColor !== void 0 && textColor !== null) {
    if (typeof textColor === "object") {
      let [key, value] = Object.entries(textColor)[0];
      old[key] = value;
    } else {
      old.textColor = textColor;
    }
  }
  if (lineColor !== void 0 && lineColor !== null) {
    if (typeof lineColor === "object") {
      let [key, value] = Object.entries(lineColor)[0];
      old[key] = value;
    } else {
      old.lineColor = lineColor;
    }
  }
  if (offsetX !== void 0 && offsetX !== null) {
    if (typeof offsetX === "object") {
      let [key, value] = Object.entries(offsetX)[0];
      old[key] = parseInt(value);
    } else {
      old.offsetX = parseInt(offsetX);
    }
  }
  if (offsetY !== void 0 && offsetY !== null) {
    if (typeof offsetY === "object") {
      let [key, value] = Object.entries(offsetY)[0];
      old[key] = parseInt(value);
    } else {
      old.offsetY = parseInt(offsetY);
    }
  }
};
const updateLayoutConfig = function(typeC4Shape, c4ShapeInRowParam, c4BoundaryInRowParam) {
  let c4ShapeInRowValue = c4ShapeInRow$1;
  let c4BoundaryInRowValue = c4BoundaryInRow$1;
  if (typeof c4ShapeInRowParam === "object") {
    const value = Object.values(c4ShapeInRowParam)[0];
    c4ShapeInRowValue = parseInt(value);
  } else {
    c4ShapeInRowValue = parseInt(c4ShapeInRowParam);
  }
  if (typeof c4BoundaryInRowParam === "object") {
    const value = Object.values(c4BoundaryInRowParam)[0];
    c4BoundaryInRowValue = parseInt(value);
  } else {
    c4BoundaryInRowValue = parseInt(c4BoundaryInRowParam);
  }
  if (c4ShapeInRowValue >= 1)
    c4ShapeInRow$1 = c4ShapeInRowValue;
  if (c4BoundaryInRowValue >= 1)
    c4BoundaryInRow$1 = c4BoundaryInRowValue;
};
const getC4ShapeInRow = function() {
  return c4ShapeInRow$1;
};
const getC4BoundaryInRow = function() {
  return c4BoundaryInRow$1;
};
const getCurrentBoundaryParse = function() {
  return currentBoundaryParse;
};
const getParentBoundaryParse = function() {
  return parentBoundaryParse;
};
const getC4ShapeArray = function(parentBoundary) {
  if (parentBoundary === void 0 || parentBoundary === null)
    return c4ShapeArray;
  else
    return c4ShapeArray.filter((personOrSystem) => {
      return personOrSystem.parentBoundary === parentBoundary;
    });
};
const getC4Shape = function(alias) {
  return c4ShapeArray.find((personOrSystem) => personOrSystem.alias === alias);
};
const getC4ShapeKeys = function(parentBoundary) {
  return Object.keys(getC4ShapeArray(parentBoundary));
};
const getBoundarys = function(parentBoundary) {
  if (parentBoundary === void 0 || parentBoundary === null)
    return boundarys;
  else
    return boundarys.filter((boundary) => boundary.parentBoundary === parentBoundary);
};
const getRels = function() {
  return rels;
};
const getTitle = function() {
  return title;
};
const setWrap$1 = function(wrapSetting) {
  wrapEnabled$1 = wrapSetting;
};
const autoWrap$1 = function() {
  return wrapEnabled$1;
};
const clear$d = function() {
  c4ShapeArray = [];
  boundarys = [
    {
      alias: "global",
      label: { text: "global" },
      type: { text: "global" },
      tags: null,
      link: null,
      parentBoundary: ""
    }
  ];
  parentBoundaryParse = "";
  currentBoundaryParse = "global";
  boundaryParseStack = [""];
  rels = [];
  boundaryParseStack = [""];
  title = "";
  wrapEnabled$1 = false;
  c4ShapeInRow$1 = 4;
  c4BoundaryInRow$1 = 2;
};
const LINETYPE$1 = {
  SOLID: 0,
  DOTTED: 1,
  NOTE: 2,
  SOLID_CROSS: 3,
  DOTTED_CROSS: 4,
  SOLID_OPEN: 5,
  DOTTED_OPEN: 6,
  LOOP_START: 10,
  LOOP_END: 11,
  ALT_START: 12,
  ALT_ELSE: 13,
  ALT_END: 14,
  OPT_START: 15,
  OPT_END: 16,
  ACTIVE_START: 17,
  ACTIVE_END: 18,
  PAR_START: 19,
  PAR_AND: 20,
  PAR_END: 21,
  RECT_START: 22,
  RECT_END: 23,
  SOLID_POINT: 24,
  DOTTED_POINT: 25
};
const ARROWTYPE$1 = {
  FILLED: 0,
  OPEN: 1
};
const PLACEMENT$1 = {
  LEFTOF: 0,
  RIGHTOF: 1,
  OVER: 2
};
const setTitle = function(txt) {
  let sanitizedText = sanitizeText$5(txt, getConfig$1());
  title = sanitizedText;
};
const c4Db = {
  addPersonOrSystem,
  addPersonOrSystemBoundary,
  addContainer,
  addContainerBoundary,
  addComponent,
  addDeploymentNode,
  popBoundaryParseStack,
  addRel,
  updateElStyle,
  updateRelStyle,
  updateLayoutConfig,
  autoWrap: autoWrap$1,
  setWrap: setWrap$1,
  getC4ShapeArray,
  getC4Shape,
  getC4ShapeKeys,
  getBoundarys,
  getCurrentBoundaryParse,
  getParentBoundaryParse,
  getRels,
  getTitle,
  getC4Type,
  getC4ShapeInRow,
  getC4BoundaryInRow,
  setAccTitle,
  getAccTitle,
  getAccDescription,
  setAccDescription,
  parseDirective: parseDirective$a,
  getConfig: () => getConfig$1().c4,
  clear: clear$d,
  LINETYPE: LINETYPE$1,
  ARROWTYPE: ARROWTYPE$1,
  PLACEMENT: PLACEMENT$1,
  setTitle,
  setC4Type
};
const drawRect$2 = function(elem, rectData) {
  const rectElem = elem.append("rect");
  rectElem.attr("x", rectData.x);
  rectElem.attr("y", rectData.y);
  rectElem.attr("fill", rectData.fill);
  rectElem.attr("stroke", rectData.stroke);
  rectElem.attr("width", rectData.width);
  rectElem.attr("height", rectData.height);
  rectElem.attr("rx", rectData.rx);
  rectElem.attr("ry", rectData.ry);
  if (rectData.attrs !== "undefined" && rectData.attrs !== null) {
    for (let attrKey in rectData.attrs)
      rectElem.attr(attrKey, rectData.attrs[attrKey]);
  }
  if (rectData.class !== "undefined") {
    rectElem.attr("class", rectData.class);
  }
  return rectElem;
};
const drawImage$1 = function(elem, width2, height2, x2, y2, link2) {
  const imageElem = elem.append("image");
  imageElem.attr("width", width2);
  imageElem.attr("height", height2);
  imageElem.attr("x", x2);
  imageElem.attr("y", y2);
  let sanitizedLink = link2.startsWith("data:image/png;base64") ? link2 : sanitizeUrl_1(link2);
  imageElem.attr("xlink:href", sanitizedLink);
};
const drawEmbeddedImage$1 = function(elem, x2, y2, link2) {
  const imageElem = elem.append("use");
  imageElem.attr("x", x2);
  imageElem.attr("y", y2);
  var sanitizedLink = sanitizeUrl_1(link2);
  imageElem.attr("xlink:href", "#" + sanitizedLink);
};
const drawText$2 = function(elem, textData) {
  let prevTextHeight = 0, textHeight = 0;
  const lines = textData.text.split(common.lineBreakRegex);
  let textElems = [];
  let dy = 0;
  let yfunc = () => textData.y;
  if (typeof textData.valign !== "undefined" && typeof textData.textMargin !== "undefined" && textData.textMargin > 0) {
    switch (textData.valign) {
      case "top":
      case "start":
        yfunc = () => Math.round(textData.y + textData.textMargin);
        break;
      case "middle":
      case "center":
        yfunc = () => Math.round(textData.y + (prevTextHeight + textHeight + textData.textMargin) / 2);
        break;
      case "bottom":
      case "end":
        yfunc = () => Math.round(
          textData.y + (prevTextHeight + textHeight + 2 * textData.textMargin) - textData.textMargin
        );
        break;
    }
  }
  if (typeof textData.anchor !== "undefined" && typeof textData.textMargin !== "undefined" && typeof textData.width !== "undefined") {
    switch (textData.anchor) {
      case "left":
      case "start":
        textData.x = Math.round(textData.x + textData.textMargin);
        textData.anchor = "start";
        textData.dominantBaseline = "text-after-edge";
        textData.alignmentBaseline = "middle";
        break;
      case "middle":
      case "center":
        textData.x = Math.round(textData.x + textData.width / 2);
        textData.anchor = "middle";
        textData.dominantBaseline = "middle";
        textData.alignmentBaseline = "middle";
        break;
      case "right":
      case "end":
        textData.x = Math.round(textData.x + textData.width - textData.textMargin);
        textData.anchor = "end";
        textData.dominantBaseline = "text-before-edge";
        textData.alignmentBaseline = "middle";
        break;
    }
  }
  for (let i = 0; i < lines.length; i++) {
    let line2 = lines[i];
    if (typeof textData.textMargin !== "undefined" && textData.textMargin === 0 && typeof textData.fontSize !== "undefined") {
      dy = i * textData.fontSize;
    }
    const textElem = elem.append("text");
    textElem.attr("x", textData.x);
    textElem.attr("y", yfunc());
    if (typeof textData.anchor !== "undefined") {
      textElem.attr("text-anchor", textData.anchor).attr("dominant-baseline", textData.dominantBaseline).attr("alignment-baseline", textData.alignmentBaseline);
    }
    if (typeof textData.fontFamily !== "undefined") {
      textElem.style("font-family", textData.fontFamily);
    }
    if (typeof textData.fontSize !== "undefined") {
      textElem.style("font-size", textData.fontSize);
    }
    if (typeof textData.fontWeight !== "undefined") {
      textElem.style("font-weight", textData.fontWeight);
    }
    if (typeof textData.fill !== "undefined") {
      textElem.attr("fill", textData.fill);
    }
    if (typeof textData.class !== "undefined") {
      textElem.attr("class", textData.class);
    }
    if (typeof textData.dy !== "undefined") {
      textElem.attr("dy", textData.dy);
    } else if (dy !== 0) {
      textElem.attr("dy", dy);
    }
    if (textData.tspan) {
      const span = textElem.append("tspan");
      span.attr("x", textData.x);
      if (typeof textData.fill !== "undefined") {
        span.attr("fill", textData.fill);
      }
      span.text(line2);
    } else {
      textElem.text(line2);
    }
    if (typeof textData.valign !== "undefined" && typeof textData.textMargin !== "undefined" && textData.textMargin > 0) {
      textHeight += (textElem._groups || textElem)[0][0].getBBox().height;
      prevTextHeight = textHeight;
    }
    textElems.push(textElem);
  }
  return textElems;
};
const drawLabel$2 = function(elem, txtObject) {
  function genPoints(x2, y2, width2, height2, cut) {
    return x2 + "," + y2 + " " + (x2 + width2) + "," + y2 + " " + (x2 + width2) + "," + (y2 + height2 - cut) + " " + (x2 + width2 - cut * 1.2) + "," + (y2 + height2) + " " + x2 + "," + (y2 + height2);
  }
  const polygon = elem.append("polygon");
  polygon.attr("points", genPoints(txtObject.x, txtObject.y, txtObject.width, txtObject.height, 7));
  polygon.attr("class", "labelBox");
  txtObject.y = txtObject.y + txtObject.height / 2;
  drawText$2(elem, txtObject);
  return polygon;
};
const drawRels$1 = (elem, rels2, conf2) => {
  const relsElem = elem.append("g");
  let i = 0;
  for (let rel of rels2) {
    let textColor = rel.textColor ? rel.textColor : "#444444";
    let strokeColor = rel.lineColor ? rel.lineColor : "#444444";
    let offsetX = rel.offsetX ? parseInt(rel.offsetX) : 0;
    let offsetY = rel.offsetY ? parseInt(rel.offsetY) : 0;
    let url = "";
    if (i === 0) {
      let line2 = relsElem.append("line");
      line2.attr("x1", rel.startPoint.x);
      line2.attr("y1", rel.startPoint.y);
      line2.attr("x2", rel.endPoint.x);
      line2.attr("y2", rel.endPoint.y);
      line2.attr("stroke-width", "1");
      line2.attr("stroke", strokeColor);
      line2.style("fill", "none");
      if (rel.type !== "rel_b")
        line2.attr("marker-end", "url(" + url + "#arrowhead)");
      if (rel.type === "birel" || rel.type === "rel_b")
        line2.attr("marker-start", "url(" + url + "#arrowend)");
      i = -1;
    } else {
      let line2 = relsElem.append("path");
      line2.attr("fill", "none").attr("stroke-width", "1").attr("stroke", strokeColor).attr(
        "d",
        "Mstartx,starty Qcontrolx,controly stopx,stopy ".replaceAll("startx", rel.startPoint.x).replaceAll("starty", rel.startPoint.y).replaceAll(
          "controlx",
          rel.startPoint.x + (rel.endPoint.x - rel.startPoint.x) / 2 - (rel.endPoint.x - rel.startPoint.x) / 4
        ).replaceAll("controly", rel.startPoint.y + (rel.endPoint.y - rel.startPoint.y) / 2).replaceAll("stopx", rel.endPoint.x).replaceAll("stopy", rel.endPoint.y)
      );
      if (rel.type !== "rel_b")
        line2.attr("marker-end", "url(" + url + "#arrowhead)");
      if (rel.type === "birel" || rel.type === "rel_b")
        line2.attr("marker-start", "url(" + url + "#arrowend)");
    }
    let messageConf = conf2.messageFont();
    _drawTextCandidateFunc$2(conf2)(
      rel.label.text,
      relsElem,
      Math.min(rel.startPoint.x, rel.endPoint.x) + Math.abs(rel.endPoint.x - rel.startPoint.x) / 2 + offsetX,
      Math.min(rel.startPoint.y, rel.endPoint.y) + Math.abs(rel.endPoint.y - rel.startPoint.y) / 2 + offsetY,
      rel.label.width,
      rel.label.height,
      { fill: textColor },
      messageConf
    );
    if (rel.techn && rel.techn.text !== "") {
      messageConf = conf2.messageFont();
      _drawTextCandidateFunc$2(conf2)(
        "[" + rel.techn.text + "]",
        relsElem,
        Math.min(rel.startPoint.x, rel.endPoint.x) + Math.abs(rel.endPoint.x - rel.startPoint.x) / 2 + offsetX,
        Math.min(rel.startPoint.y, rel.endPoint.y) + Math.abs(rel.endPoint.y - rel.startPoint.y) / 2 + conf2.messageFontSize + 5 + offsetY,
        Math.max(rel.label.width, rel.techn.width),
        rel.techn.height,
        { fill: textColor, "font-style": "italic" },
        messageConf
      );
    }
  }
};
const drawBoundary$1 = function(elem, boundary, conf2) {
  const boundaryElem = elem.append("g");
  let fillColor = boundary.bgColor ? boundary.bgColor : "none";
  let strokeColor = boundary.borderColor ? boundary.borderColor : "#444444";
  let fontColor = boundary.fontColor ? boundary.fontColor : "black";
  let attrsValue = { "stroke-width": 1, "stroke-dasharray": "7.0,7.0" };
  if (boundary.nodeType)
    attrsValue = { "stroke-width": 1 };
  let rectData = {
    x: boundary.x,
    y: boundary.y,
    fill: fillColor,
    stroke: strokeColor,
    width: boundary.width,
    height: boundary.height,
    rx: 2.5,
    ry: 2.5,
    attrs: attrsValue
  };
  drawRect$2(boundaryElem, rectData);
  let boundaryConf = conf2.boundaryFont();
  boundaryConf.fontWeight = "bold";
  boundaryConf.fontSize = boundaryConf.fontSize + 2;
  boundaryConf.fontColor = fontColor;
  _drawTextCandidateFunc$2(conf2)(
    boundary.label.text,
    boundaryElem,
    boundary.x,
    boundary.y + boundary.label.Y,
    boundary.width,
    boundary.height,
    { fill: "#444444" },
    boundaryConf
  );
  if (boundary.type && boundary.type.text !== "") {
    boundaryConf = conf2.boundaryFont();
    boundaryConf.fontColor = fontColor;
    _drawTextCandidateFunc$2(conf2)(
      boundary.type.text,
      boundaryElem,
      boundary.x,
      boundary.y + boundary.type.Y,
      boundary.width,
      boundary.height,
      { fill: "#444444" },
      boundaryConf
    );
  }
  if (boundary.descr && boundary.descr.text !== "") {
    boundaryConf = conf2.boundaryFont();
    boundaryConf.fontSize = boundaryConf.fontSize - 2;
    boundaryConf.fontColor = fontColor;
    _drawTextCandidateFunc$2(conf2)(
      boundary.descr.text,
      boundaryElem,
      boundary.x,
      boundary.y + boundary.descr.Y,
      boundary.width,
      boundary.height,
      { fill: "#444444" },
      boundaryConf
    );
  }
};
const drawC4Shape = function(elem, c4Shape, conf2) {
  let fillColor = c4Shape.bgColor ? c4Shape.bgColor : conf2[c4Shape.typeC4Shape.text + "_bg_color"];
  let strokeColor = c4Shape.borderColor ? c4Shape.borderColor : conf2[c4Shape.typeC4Shape.text + "_border_color"];
  let fontColor = c4Shape.fontColor ? c4Shape.fontColor : "#FFFFFF";
  let personImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAACD0lEQVR4Xu2YoU4EMRCGT+4j8Ai8AhaH4QHgAUjQuFMECUgMIUgwJAgMhgQsAYUiJCiQIBBY+EITsjfTdme6V24v4c8vyGbb+ZjOtN0bNcvjQXmkH83WvYBWto6PLm6v7p7uH1/w2fXD+PBycX1Pv2l3IdDm/vn7x+dXQiAubRzoURa7gRZWd0iGRIiJbOnhnfYBQZNJjNbuyY2eJG8fkDE3bbG4ep6MHUAsgYxmE3nVs6VsBWJSGccsOlFPmLIViMzLOB7pCVO2AtHJMohH7Fh6zqitQK7m0rJvAVYgGcEpe//PLdDz65sM4pF9N7ICcXDKIB5Nv6j7tD0NoSdM2QrU9Gg0ewE1LqBhHR3BBdvj2vapnidjHxD/q6vd7Pvhr31AwcY8eXMTXAKECZZJFXuEq27aLgQK5uLMohCenGGuGewOxSjBvYBqeG6B+Nqiblggdjnc+ZXDy+FNFpFzw76O3UBAROuXh6FoiAcf5g9eTvUgzy0nWg6I8cXHRUpg5bOVBCo+KDpFajOf23GgPme7RSQ+lacIENUgJ6gg1k6HjgOlqnLqip4tEuhv0hNEMXUD0clyXE3p6pZA0S2nnvTlXwLJEZWlb7cTQH1+USgTN4VhAenm/wea1OCAOmqo6fE1WCb9WSKBah+rbUWPWAmE2Rvk0ApiB45eOyNAzU8xcTvj8KvkKEoOaIYeHNA3ZuygAvFMUO0AAAAASUVORK5CYII=";
  switch (c4Shape.typeC4Shape.text) {
    case "person":
      personImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAACD0lEQVR4Xu2YoU4EMRCGT+4j8Ai8AhaH4QHgAUjQuFMECUgMIUgwJAgMhgQsAYUiJCiQIBBY+EITsjfTdme6V24v4c8vyGbb+ZjOtN0bNcvjQXmkH83WvYBWto6PLm6v7p7uH1/w2fXD+PBycX1Pv2l3IdDm/vn7x+dXQiAubRzoURa7gRZWd0iGRIiJbOnhnfYBQZNJjNbuyY2eJG8fkDE3bbG4ep6MHUAsgYxmE3nVs6VsBWJSGccsOlFPmLIViMzLOB7pCVO2AtHJMohH7Fh6zqitQK7m0rJvAVYgGcEpe//PLdDz65sM4pF9N7ICcXDKIB5Nv6j7tD0NoSdM2QrU9Gg0ewE1LqBhHR3BBdvj2vapnidjHxD/q6vd7Pvhr31AwcY8eXMTXAKECZZJFXuEq27aLgQK5uLMohCenGGuGewOxSjBvYBqeG6B+Nqiblggdjnc+ZXDy+FNFpFzw76O3UBAROuXh6FoiAcf5g9eTvUgzy0nWg6I8cXHRUpg5bOVBCo+KDpFajOf23GgPme7RSQ+lacIENUgJ6gg1k6HjgOlqnLqip4tEuhv0hNEMXUD0clyXE3p6pZA0S2nnvTlXwLJEZWlb7cTQH1+USgTN4VhAenm/wea1OCAOmqo6fE1WCb9WSKBah+rbUWPWAmE2Rvk0ApiB45eOyNAzU8xcTvj8KvkKEoOaIYeHNA3ZuygAvFMUO0AAAAASUVORK5CYII=";
      break;
    case "external_person":
      personImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAAB6ElEQVR4Xu2YLY+EMBCG9+dWr0aj0Wg0Go1Go0+j8Xdv2uTCvv1gpt0ebHKPuhDaeW4605Z9mJvx4AdXUyTUdd08z+u6flmWZRnHsWkafk9DptAwDPu+f0eAYtu2PEaGWuj5fCIZrBAC2eLBAnRCsEkkxmeaJp7iDJ2QMDdHsLg8SxKFEJaAo8lAXnmuOFIhTMpxxKATebo4UiFknuNo4OniSIXQyRxEA3YsnjGCVEjVXD7yLUAqxBGUyPv/Y4W2beMgGuS7kVQIBycH0fD+oi5pezQETxdHKmQKGk1eQEYldK+jw5GxPfZ9z7Mk0Qnhf1W1m3w//EUn5BDmSZsbR44QQLBEqrBHqOrmSKaQAxdnLArCrxZcM7A7ZKs4ioRq8LFC+NpC3WCBJsvpVw5edm9iEXFuyNfxXAgSwfrFQ1c0iNda8AdejvUgnktOtJQQxmcfFzGglc5WVCj7oDgFqU18boeFSs52CUh8LE8BIVQDT1ABrB0HtgSEYlX5doJnCwv9TXocKCaKbnwhdDKPq4lf3SwU3HLq4V/+WYhHVMa/3b4IlfyikAduCkcBc7mQ3/z/Qq/cTuikhkzB12Ae/mcJC9U+Vo8Ej1gWAtgbeGgFsAMHr50BIWOLCbezvhpBFUdY6EJuJ/QDW0XoMX60zZ0AAAAASUVORK5CYII=";
      break;
  }
  const c4ShapeElem = elem.append("g");
  c4ShapeElem.attr("class", "person-man");
  const rect2 = getNoteRect$2();
  switch (c4Shape.typeC4Shape.text) {
    case "person":
    case "external_person":
    case "system":
    case "external_system":
    case "container":
    case "external_container":
    case "component":
    case "external_component":
      rect2.x = c4Shape.x;
      rect2.y = c4Shape.y;
      rect2.fill = fillColor;
      rect2.width = c4Shape.width;
      rect2.height = c4Shape.height;
      rect2.style = "stroke:" + strokeColor + ";stroke-width:0.5;";
      rect2.rx = 2.5;
      rect2.ry = 2.5;
      drawRect$2(c4ShapeElem, rect2);
      break;
    case "system_db":
    case "external_system_db":
    case "container_db":
    case "external_container_db":
    case "component_db":
    case "external_component_db":
      c4ShapeElem.append("path").attr("fill", fillColor).attr("stroke-width", "0.5").attr("stroke", strokeColor).attr(
        "d",
        "Mstartx,startyc0,-10 half,-10 half,-10c0,0 half,0 half,10l0,heightc0,10 -half,10 -half,10c0,0 -half,0 -half,-10l0,-height".replaceAll("startx", c4Shape.x).replaceAll("starty", c4Shape.y).replaceAll("half", c4Shape.width / 2).replaceAll("height", c4Shape.height)
      );
      c4ShapeElem.append("path").attr("fill", "none").attr("stroke-width", "0.5").attr("stroke", strokeColor).attr(
        "d",
        "Mstartx,startyc0,10 half,10 half,10c0,0 half,0 half,-10".replaceAll("startx", c4Shape.x).replaceAll("starty", c4Shape.y).replaceAll("half", c4Shape.width / 2)
      );
      break;
    case "system_queue":
    case "external_system_queue":
    case "container_queue":
    case "external_container_queue":
    case "component_queue":
    case "external_component_queue":
      c4ShapeElem.append("path").attr("fill", fillColor).attr("stroke-width", "0.5").attr("stroke", strokeColor).attr(
        "d",
        "Mstartx,startylwidth,0c5,0 5,half 5,halfc0,0 0,half -5,halfl-width,0c-5,0 -5,-half -5,-halfc0,0 0,-half 5,-half".replaceAll("startx", c4Shape.x).replaceAll("starty", c4Shape.y).replaceAll("width", c4Shape.width).replaceAll("half", c4Shape.height / 2)
      );
      c4ShapeElem.append("path").attr("fill", "none").attr("stroke-width", "0.5").attr("stroke", strokeColor).attr(
        "d",
        "Mstartx,startyc-5,0 -5,half -5,halfc0,half 5,half 5,half".replaceAll("startx", c4Shape.x + c4Shape.width).replaceAll("starty", c4Shape.y).replaceAll("half", c4Shape.height / 2)
      );
      break;
  }
  let c4ShapeFontConf = getC4ShapeFont(conf2, c4Shape.typeC4Shape.text);
  c4ShapeElem.append("text").attr("fill", fontColor).attr("font-family", c4ShapeFontConf.fontFamily).attr("font-size", c4ShapeFontConf.fontSize - 2).attr("font-style", "italic").attr("lengthAdjust", "spacing").attr("textLength", c4Shape.typeC4Shape.width).attr("x", c4Shape.x + c4Shape.width / 2 - c4Shape.typeC4Shape.width / 2).attr("y", c4Shape.y + c4Shape.typeC4Shape.Y).text("<<" + c4Shape.typeC4Shape.text + ">>");
  switch (c4Shape.typeC4Shape.text) {
    case "person":
    case "external_person":
      drawImage$1(
        c4ShapeElem,
        48,
        48,
        c4Shape.x + c4Shape.width / 2 - 24,
        c4Shape.y + c4Shape.image.Y,
        personImg
      );
      break;
  }
  let textFontConf = conf2[c4Shape.typeC4Shape.text + "Font"]();
  textFontConf.fontWeight = "bold";
  textFontConf.fontSize = textFontConf.fontSize + 2;
  textFontConf.fontColor = fontColor;
  _drawTextCandidateFunc$2(conf2)(
    c4Shape.label.text,
    c4ShapeElem,
    c4Shape.x,
    c4Shape.y + c4Shape.label.Y,
    c4Shape.width,
    c4Shape.height,
    { fill: fontColor },
    textFontConf
  );
  textFontConf = conf2[c4Shape.typeC4Shape.text + "Font"]();
  textFontConf.fontColor = fontColor;
  if (c4Shape.thchn && c4Shape.thchn.text !== "") {
    _drawTextCandidateFunc$2(conf2)(
      c4Shape.thchn.text,
      c4ShapeElem,
      c4Shape.x,
      c4Shape.y + c4Shape.thchn.Y,
      c4Shape.width,
      c4Shape.height,
      { fill: fontColor, "font-style": "italic" },
      textFontConf
    );
  } else if (c4Shape.type && c4Shape.type.text !== "") {
    _drawTextCandidateFunc$2(conf2)(
      c4Shape.type.text,
      c4ShapeElem,
      c4Shape.x,
      c4Shape.y + c4Shape.type.Y,
      c4Shape.width,
      c4Shape.height,
      { fill: fontColor, "font-style": "italic" },
      textFontConf
    );
  }
  if (c4Shape.descr && c4Shape.descr.text !== "") {
    textFontConf = conf2.personFont();
    textFontConf.fontColor = fontColor;
    _drawTextCandidateFunc$2(conf2)(
      c4Shape.descr.text,
      c4ShapeElem,
      c4Shape.x,
      c4Shape.y + c4Shape.descr.Y,
      c4Shape.width,
      c4Shape.height,
      { fill: fontColor },
      textFontConf
    );
  }
  return c4Shape.height;
};
const insertDatabaseIcon$1 = function(elem) {
  elem.append("defs").append("symbol").attr("id", "database").attr("fill-rule", "evenodd").attr("clip-rule", "evenodd").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M12.258.001l.256.004.255.005.253.008.251.01.249.012.247.015.246.016.242.019.241.02.239.023.236.024.233.027.231.028.229.031.225.032.223.034.22.036.217.038.214.04.211.041.208.043.205.045.201.046.198.048.194.05.191.051.187.053.183.054.18.056.175.057.172.059.168.06.163.061.16.063.155.064.15.066.074.033.073.033.071.034.07.034.069.035.068.035.067.035.066.035.064.036.064.036.062.036.06.036.06.037.058.037.058.037.055.038.055.038.053.038.052.038.051.039.05.039.048.039.047.039.045.04.044.04.043.04.041.04.04.041.039.041.037.041.036.041.034.041.033.042.032.042.03.042.029.042.027.042.026.043.024.043.023.043.021.043.02.043.018.044.017.043.015.044.013.044.012.044.011.045.009.044.007.045.006.045.004.045.002.045.001.045v17l-.001.045-.002.045-.004.045-.006.045-.007.045-.009.044-.011.045-.012.044-.013.044-.015.044-.017.043-.018.044-.02.043-.021.043-.023.043-.024.043-.026.043-.027.042-.029.042-.03.042-.032.042-.033.042-.034.041-.036.041-.037.041-.039.041-.04.041-.041.04-.043.04-.044.04-.045.04-.047.039-.048.039-.05.039-.051.039-.052.038-.053.038-.055.038-.055.038-.058.037-.058.037-.06.037-.06.036-.062.036-.064.036-.064.036-.066.035-.067.035-.068.035-.069.035-.07.034-.071.034-.073.033-.074.033-.15.066-.155.064-.16.063-.163.061-.168.06-.172.059-.175.057-.18.056-.183.054-.187.053-.191.051-.194.05-.198.048-.201.046-.205.045-.208.043-.211.041-.214.04-.217.038-.22.036-.223.034-.225.032-.229.031-.231.028-.233.027-.236.024-.239.023-.241.02-.242.019-.246.016-.247.015-.249.012-.251.01-.253.008-.255.005-.256.004-.258.001-.258-.001-.256-.004-.255-.005-.253-.008-.251-.01-.249-.012-.247-.015-.245-.016-.243-.019-.241-.02-.238-.023-.236-.024-.234-.027-.231-.028-.228-.031-.226-.032-.223-.034-.22-.036-.217-.038-.214-.04-.211-.041-.208-.043-.204-.045-.201-.046-.198-.048-.195-.05-.19-.051-.187-.053-.184-.054-.179-.056-.176-.057-.172-.059-.167-.06-.164-.061-.159-.063-.155-.064-.151-.066-.074-.033-.072-.033-.072-.034-.07-.034-.069-.035-.068-.035-.067-.035-.066-.035-.064-.036-.063-.036-.062-.036-.061-.036-.06-.037-.058-.037-.057-.037-.056-.038-.055-.038-.053-.038-.052-.038-.051-.039-.049-.039-.049-.039-.046-.039-.046-.04-.044-.04-.043-.04-.041-.04-.04-.041-.039-.041-.037-.041-.036-.041-.034-.041-.033-.042-.032-.042-.03-.042-.029-.042-.027-.042-.026-.043-.024-.043-.023-.043-.021-.043-.02-.043-.018-.044-.017-.043-.015-.044-.013-.044-.012-.044-.011-.045-.009-.044-.007-.045-.006-.045-.004-.045-.002-.045-.001-.045v-17l.001-.045.002-.045.004-.045.006-.045.007-.045.009-.044.011-.045.012-.044.013-.044.015-.044.017-.043.018-.044.02-.043.021-.043.023-.043.024-.043.026-.043.027-.042.029-.042.03-.042.032-.042.033-.042.034-.041.036-.041.037-.041.039-.041.04-.041.041-.04.043-.04.044-.04.046-.04.046-.039.049-.039.049-.039.051-.039.052-.038.053-.038.055-.038.056-.038.057-.037.058-.037.06-.037.061-.036.062-.036.063-.036.064-.036.066-.035.067-.035.068-.035.069-.035.07-.034.072-.034.072-.033.074-.033.151-.066.155-.064.159-.063.164-.061.167-.06.172-.059.176-.057.179-.056.184-.054.187-.053.19-.051.195-.05.198-.048.201-.046.204-.045.208-.043.211-.041.214-.04.217-.038.22-.036.223-.034.226-.032.228-.031.231-.028.234-.027.236-.024.238-.023.241-.02.243-.019.245-.016.247-.015.249-.012.251-.01.253-.008.255-.005.256-.004.258-.001.258.001zm-9.258 20.499v.01l.001.021.003.021.004.022.005.021.006.022.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.023.018.024.019.024.021.024.022.025.023.024.024.025.052.049.056.05.061.051.066.051.07.051.075.051.079.052.084.052.088.052.092.052.097.052.102.051.105.052.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.048.144.049.147.047.152.047.155.047.16.045.163.045.167.043.171.043.176.041.178.041.183.039.187.039.19.037.194.035.197.035.202.033.204.031.209.03.212.029.216.027.219.025.222.024.226.021.23.02.233.018.236.016.24.015.243.012.246.01.249.008.253.005.256.004.259.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.021.224-.024.22-.026.216-.027.212-.028.21-.031.205-.031.202-.034.198-.034.194-.036.191-.037.187-.039.183-.04.179-.04.175-.042.172-.043.168-.044.163-.045.16-.046.155-.046.152-.047.148-.048.143-.049.139-.049.136-.05.131-.05.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.053.083-.051.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.05.023-.024.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.023.01-.022.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.127l-.077.055-.08.053-.083.054-.085.053-.087.052-.09.052-.093.051-.095.05-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.045-.118.044-.12.043-.122.042-.124.042-.126.041-.128.04-.13.04-.132.038-.134.038-.135.037-.138.037-.139.035-.142.035-.143.034-.144.033-.147.032-.148.031-.15.03-.151.03-.153.029-.154.027-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.01-.179.008-.179.008-.181.006-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.006-.179-.008-.179-.008-.178-.01-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.027-.153-.029-.151-.03-.15-.03-.148-.031-.146-.032-.145-.033-.143-.034-.141-.035-.14-.035-.137-.037-.136-.037-.134-.038-.132-.038-.13-.04-.128-.04-.126-.041-.124-.042-.122-.042-.12-.044-.117-.043-.116-.045-.113-.045-.112-.046-.109-.047-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.05-.093-.052-.09-.051-.087-.052-.085-.053-.083-.054-.08-.054-.077-.054v4.127zm0-5.654v.011l.001.021.003.021.004.021.005.022.006.022.007.022.009.022.01.022.011.023.012.023.013.023.015.024.016.023.017.024.018.024.019.024.021.024.022.024.023.025.024.024.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.052.11.051.114.051.119.052.123.05.127.051.131.05.135.049.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.044.171.042.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.022.23.02.233.018.236.016.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.012.241-.015.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.048.139-.05.136-.049.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.051.051-.049.023-.025.023-.024.021-.025.02-.024.019-.024.018-.024.017-.024.015-.023.014-.023.013-.024.012-.022.01-.023.01-.023.008-.022.006-.022.006-.022.004-.021.004-.022.001-.021.001-.021v-4.139l-.077.054-.08.054-.083.054-.085.052-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.044-.118.044-.12.044-.122.042-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.035-.143.033-.144.033-.147.033-.148.031-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.009-.179.009-.179.007-.181.007-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.007-.179-.007-.179-.009-.178-.009-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.031-.146-.033-.145-.033-.143-.033-.141-.035-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.04-.126-.041-.124-.042-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.051-.093-.051-.09-.051-.087-.053-.085-.052-.083-.054-.08-.054-.077-.054v4.139zm0-5.666v.011l.001.02.003.022.004.021.005.022.006.021.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.024.018.023.019.024.021.025.022.024.023.024.024.025.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.051.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.043.171.043.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.021.23.02.233.018.236.017.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.013.241-.014.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.049.139-.049.136-.049.131-.051.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.049.023-.025.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.022.01-.023.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.153l-.077.054-.08.054-.083.053-.085.053-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.048-.105.048-.106.048-.109.046-.111.046-.114.046-.115.044-.118.044-.12.043-.122.043-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.034-.143.034-.144.033-.147.032-.148.032-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.024-.161.024-.162.023-.163.023-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.01-.178.01-.179.009-.179.007-.181.006-.182.006-.182.004-.184.003-.184.001-.185.001-.185-.001-.184-.001-.184-.003-.182-.004-.182-.006-.181-.006-.179-.007-.179-.009-.178-.01-.176-.01-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.023-.162-.023-.161-.024-.159-.024-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.032-.146-.032-.145-.033-.143-.034-.141-.034-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.041-.126-.041-.124-.041-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.048-.105-.048-.102-.048-.1-.05-.097-.049-.095-.051-.093-.051-.09-.052-.087-.052-.085-.053-.083-.053-.08-.054-.077-.054v4.153zm8.74-8.179l-.257.004-.254.005-.25.008-.247.011-.244.012-.241.014-.237.016-.233.018-.231.021-.226.022-.224.023-.22.026-.216.027-.212.028-.21.031-.205.032-.202.033-.198.034-.194.036-.191.038-.187.038-.183.04-.179.041-.175.042-.172.043-.168.043-.163.045-.16.046-.155.046-.152.048-.148.048-.143.048-.139.049-.136.05-.131.05-.126.051-.123.051-.118.051-.114.052-.11.052-.106.052-.101.052-.096.052-.092.052-.088.052-.083.052-.079.052-.074.051-.07.052-.065.051-.06.05-.056.05-.051.05-.023.025-.023.024-.021.024-.02.025-.019.024-.018.024-.017.023-.015.024-.014.023-.013.023-.012.023-.01.023-.01.022-.008.022-.006.023-.006.021-.004.022-.004.021-.001.021-.001.021.001.021.001.021.004.021.004.022.006.021.006.023.008.022.01.022.01.023.012.023.013.023.014.023.015.024.017.023.018.024.019.024.02.025.021.024.023.024.023.025.051.05.056.05.06.05.065.051.07.052.074.051.079.052.083.052.088.052.092.052.096.052.101.052.106.052.11.052.114.052.118.051.123.051.126.051.131.05.136.05.139.049.143.048.148.048.152.048.155.046.16.046.163.045.168.043.172.043.175.042.179.041.183.04.187.038.191.038.194.036.198.034.202.033.205.032.21.031.212.028.216.027.22.026.224.023.226.022.231.021.233.018.237.016.241.014.244.012.247.011.25.008.254.005.257.004.26.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.022.224-.023.22-.026.216-.027.212-.028.21-.031.205-.032.202-.033.198-.034.194-.036.191-.038.187-.038.183-.04.179-.041.175-.042.172-.043.168-.043.163-.045.16-.046.155-.046.152-.048.148-.048.143-.048.139-.049.136-.05.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.05.051-.05.023-.025.023-.024.021-.024.02-.025.019-.024.018-.024.017-.023.015-.024.014-.023.013-.023.012-.023.01-.023.01-.022.008-.022.006-.023.006-.021.004-.022.004-.021.001-.021.001-.021-.001-.021-.001-.021-.004-.021-.004-.022-.006-.021-.006-.023-.008-.022-.01-.022-.01-.023-.012-.023-.013-.023-.014-.023-.015-.024-.017-.023-.018-.024-.019-.024-.02-.025-.021-.024-.023-.024-.023-.025-.051-.05-.056-.05-.06-.05-.065-.051-.07-.052-.074-.051-.079-.052-.083-.052-.088-.052-.092-.052-.096-.052-.101-.052-.106-.052-.11-.052-.114-.052-.118-.051-.123-.051-.126-.051-.131-.05-.136-.05-.139-.049-.143-.048-.148-.048-.152-.048-.155-.046-.16-.046-.163-.045-.168-.043-.172-.043-.175-.042-.179-.041-.183-.04-.187-.038-.191-.038-.194-.036-.198-.034-.202-.033-.205-.032-.21-.031-.212-.028-.216-.027-.22-.026-.224-.023-.226-.022-.231-.021-.233-.018-.237-.016-.241-.014-.244-.012-.247-.011-.25-.008-.254-.005-.257-.004-.26-.001-.26.001z"
  );
};
const insertComputerIcon$1 = function(elem) {
  elem.append("defs").append("symbol").attr("id", "computer").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M2 2v13h20v-13h-20zm18 11h-16v-9h16v9zm-10.228 6l.466-1h3.524l.467 1h-4.457zm14.228 3h-24l2-6h2.104l-1.33 4h18.45l-1.297-4h2.073l2 6zm-5-10h-14v-7h14v7z"
  );
};
const insertClockIcon$1 = function(elem) {
  elem.append("defs").append("symbol").attr("id", "clock").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm5.848 12.459c.202.038.202.333.001.372-1.907.361-6.045 1.111-6.547 1.111-.719 0-1.301-.582-1.301-1.301 0-.512.77-5.447 1.125-7.445.034-.192.312-.181.343.014l.985 6.238 5.394 1.011z"
  );
};
const insertArrowHead$1 = function(elem) {
  elem.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 9).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z");
};
const insertArrowEnd = function(elem) {
  elem.append("defs").append("marker").attr("id", "arrowend").attr("refX", 1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 10 0 L 0 5 L 10 10 z");
};
const insertArrowFilledHead$1 = function(elem) {
  elem.append("defs").append("marker").attr("id", "filled-head").attr("refX", 18).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
};
const insertDynamicNumber = function(elem) {
  elem.append("defs").append("marker").attr("id", "sequencenumber").attr("refX", 15).attr("refY", 15).attr("markerWidth", 60).attr("markerHeight", 40).attr("orient", "auto").append("circle").attr("cx", 15).attr("cy", 15).attr("r", 6);
};
const insertArrowCrossHead$1 = function(elem) {
  const defs = elem.append("defs");
  const marker = defs.append("marker").attr("id", "crosshead").attr("markerWidth", 15).attr("markerHeight", 8).attr("orient", "auto").attr("refX", 16).attr("refY", 4);
  marker.append("path").attr("fill", "black").attr("stroke", "#000000").style("stroke-dasharray", "0, 0").attr("stroke-width", "1px").attr("d", "M 9,2 V 6 L16,4 Z");
  marker.append("path").attr("fill", "none").attr("stroke", "#000000").style("stroke-dasharray", "0, 0").attr("stroke-width", "1px").attr("d", "M 0,1 L 6,7 M 6,1 L 0,7");
};
const getTextObj$2 = function() {
  return {
    x: 0,
    y: 0,
    fill: void 0,
    anchor: void 0,
    style: "#666",
    width: void 0,
    height: void 0,
    textMargin: 0,
    rx: 0,
    ry: 0,
    tspan: true,
    valign: void 0
  };
};
const getNoteRect$2 = function() {
  return {
    x: 0,
    y: 0,
    fill: "#EDF2AE",
    stroke: "#666",
    width: 100,
    anchor: "start",
    height: 100,
    rx: 0,
    ry: 0
  };
};
const getC4ShapeFont = (cnf, typeC4Shape) => {
  return {
    fontFamily: cnf[typeC4Shape + "FontFamily"],
    fontSize: cnf[typeC4Shape + "FontSize"],
    fontWeight: cnf[typeC4Shape + "FontWeight"]
  };
};
const _drawTextCandidateFunc$2 = function() {
  function byText(content2, g2, x2, y2, width2, height2, textAttrs) {
    const text2 = g2.append("text").attr("x", x2 + width2 / 2).attr("y", y2 + height2 / 2 + 5).style("text-anchor", "middle").text(content2);
    _setTextAttrs(text2, textAttrs);
  }
  function byTspan(content2, g2, x2, y2, width2, height2, textAttrs, conf2) {
    const { fontSize, fontFamily, fontWeight } = conf2;
    const lines = content2.split(common.lineBreakRegex);
    for (let i = 0; i < lines.length; i++) {
      const dy = i * fontSize - fontSize * (lines.length - 1) / 2;
      const text2 = g2.append("text").attr("x", x2 + width2 / 2).attr("y", y2).style("text-anchor", "middle").attr("dominant-baseline", "middle").style("font-size", fontSize).style("font-weight", fontWeight).style("font-family", fontFamily);
      text2.append("tspan").attr("dy", dy).text(lines[i]).attr("alignment-baseline", "mathematical");
      _setTextAttrs(text2, textAttrs);
    }
  }
  function byFo(content2, g2, x2, y2, width2, height2, textAttrs, conf2) {
    const s2 = g2.append("switch");
    const f2 = s2.append("foreignObject").attr("x", x2).attr("y", y2).attr("width", width2).attr("height", height2);
    const text2 = f2.append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    text2.append("div").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(content2);
    byTspan(content2, s2, x2, y2, width2, height2, textAttrs, conf2);
    _setTextAttrs(text2, textAttrs);
  }
  function _setTextAttrs(toText, fromTextAttrsDict) {
    for (const key in fromTextAttrsDict) {
      if (fromTextAttrsDict.hasOwnProperty(key)) {
        toText.attr(key, fromTextAttrsDict[key]);
      }
    }
  }
  return function(conf2) {
    return conf2.textPlacement === "fo" ? byFo : conf2.textPlacement === "old" ? byText : byTspan;
  };
}();
const svgDraw$3 = {
  drawRect: drawRect$2,
  drawText: drawText$2,
  drawLabel: drawLabel$2,
  drawBoundary: drawBoundary$1,
  drawC4Shape,
  drawRels: drawRels$1,
  drawImage: drawImage$1,
  drawEmbeddedImage: drawEmbeddedImage$1,
  insertArrowHead: insertArrowHead$1,
  insertArrowEnd,
  insertArrowFilledHead: insertArrowFilledHead$1,
  insertDynamicNumber,
  insertArrowCrossHead: insertArrowCrossHead$1,
  insertDatabaseIcon: insertDatabaseIcon$1,
  insertComputerIcon: insertComputerIcon$1,
  insertClockIcon: insertClockIcon$1,
  getTextObj: getTextObj$2,
  getNoteRect: getNoteRect$2,
  sanitizeUrl: sanitizeUrl_1
};
let globalBoundaryMaxX = 0, globalBoundaryMaxY = 0;
let c4ShapeInRow = 4;
let c4BoundaryInRow = 2;
parser$a.yy = c4Db;
let conf$a = {};
class Bounds {
  constructor(diagObj) {
    this.name = "";
    this.data = {};
    this.data.startx = void 0;
    this.data.stopx = void 0;
    this.data.starty = void 0;
    this.data.stopy = void 0;
    this.data.widthLimit = void 0;
    this.nextData = {};
    this.nextData.startx = void 0;
    this.nextData.stopx = void 0;
    this.nextData.starty = void 0;
    this.nextData.stopy = void 0;
    this.nextData.cnt = 0;
    setConf$a(diagObj.db.getConfig());
  }
  setData(startx, stopx, starty, stopy) {
    this.nextData.startx = this.data.startx = startx;
    this.nextData.stopx = this.data.stopx = stopx;
    this.nextData.starty = this.data.starty = starty;
    this.nextData.stopy = this.data.stopy = stopy;
  }
  updateVal(obj, key, val, fun) {
    if (typeof obj[key] === "undefined") {
      obj[key] = val;
    } else {
      obj[key] = fun(val, obj[key]);
    }
  }
  insert(c4Shape) {
    this.nextData.cnt = this.nextData.cnt + 1;
    let _startx = this.nextData.startx === this.nextData.stopx ? this.nextData.stopx + c4Shape.margin : this.nextData.stopx + c4Shape.margin * 2;
    let _stopx = _startx + c4Shape.width;
    let _starty = this.nextData.starty + c4Shape.margin * 2;
    let _stopy = _starty + c4Shape.height;
    if (_startx >= this.data.widthLimit || _stopx >= this.data.widthLimit || this.nextData.cnt > c4ShapeInRow) {
      _startx = this.nextData.startx + c4Shape.margin + conf$a.nextLinePaddingX;
      _starty = this.nextData.stopy + c4Shape.margin * 2;
      this.nextData.stopx = _stopx = _startx + c4Shape.width;
      this.nextData.starty = this.nextData.stopy;
      this.nextData.stopy = _stopy = _starty + c4Shape.height;
      this.nextData.cnt = 1;
    }
    c4Shape.x = _startx;
    c4Shape.y = _starty;
    this.updateVal(this.data, "startx", _startx, Math.min);
    this.updateVal(this.data, "starty", _starty, Math.min);
    this.updateVal(this.data, "stopx", _stopx, Math.max);
    this.updateVal(this.data, "stopy", _stopy, Math.max);
    this.updateVal(this.nextData, "startx", _startx, Math.min);
    this.updateVal(this.nextData, "starty", _starty, Math.min);
    this.updateVal(this.nextData, "stopx", _stopx, Math.max);
    this.updateVal(this.nextData, "stopy", _stopy, Math.max);
  }
  init(diagObj) {
    this.name = "";
    this.data = {
      startx: void 0,
      stopx: void 0,
      starty: void 0,
      stopy: void 0,
      widthLimit: void 0
    };
    this.nextData = {
      startx: void 0,
      stopx: void 0,
      starty: void 0,
      stopy: void 0,
      cnt: 0
    };
    setConf$a(diagObj.db.getConfig());
  }
  bumpLastMargin(margin) {
    this.data.stopx += margin;
    this.data.stopy += margin;
  }
}
const setConf$a = function(cnf) {
  assignWithDepth(conf$a, cnf);
  if (cnf.fontFamily) {
    conf$a.personFontFamily = conf$a.systemFontFamily = conf$a.messageFontFamily = cnf.fontFamily;
  }
  if (cnf.fontSize) {
    conf$a.personFontSize = conf$a.systemFontSize = conf$a.messageFontSize = cnf.fontSize;
  }
  if (cnf.fontWeight) {
    conf$a.personFontWeight = conf$a.systemFontWeight = conf$a.messageFontWeight = cnf.fontWeight;
  }
};
const c4ShapeFont = (cnf, typeC4Shape) => {
  return {
    fontFamily: cnf[typeC4Shape + "FontFamily"],
    fontSize: cnf[typeC4Shape + "FontSize"],
    fontWeight: cnf[typeC4Shape + "FontWeight"]
  };
};
const boundaryFont = (cnf) => {
  return {
    fontFamily: cnf.boundaryFontFamily,
    fontSize: cnf.boundaryFontSize,
    fontWeight: cnf.boundaryFontWeight
  };
};
const messageFont$1 = (cnf) => {
  return {
    fontFamily: cnf.messageFontFamily,
    fontSize: cnf.messageFontSize,
    fontWeight: cnf.messageFontWeight
  };
};
function calcC4ShapeTextWH(textType, c4Shape, c4ShapeTextWrap, textConf, textLimitWidth) {
  if (!c4Shape[textType].width) {
    if (c4ShapeTextWrap) {
      c4Shape[textType].text = wrapLabel(c4Shape[textType].text, textLimitWidth, textConf);
      c4Shape[textType].textLines = c4Shape[textType].text.split(common.lineBreakRegex).length;
      c4Shape[textType].width = textLimitWidth;
      c4Shape[textType].height = calculateTextHeight(c4Shape[textType].text, textConf);
    } else {
      let lines = c4Shape[textType].text.split(common.lineBreakRegex);
      c4Shape[textType].textLines = lines.length;
      let lineHeight = 0;
      c4Shape[textType].height = 0;
      c4Shape[textType].width = 0;
      for (let i = 0; i < lines.length; i++) {
        c4Shape[textType].width = Math.max(
          calculateTextWidth(lines[i], textConf),
          c4Shape[textType].width
        );
        lineHeight = calculateTextHeight(lines[i], textConf);
        c4Shape[textType].height = c4Shape[textType].height + lineHeight;
      }
    }
  }
}
const drawBoundary = function(diagram, boundary, bounds2) {
  boundary.x = bounds2.data.startx;
  boundary.y = bounds2.data.starty;
  boundary.width = bounds2.data.stopx - bounds2.data.startx;
  boundary.height = bounds2.data.stopy - bounds2.data.starty;
  boundary.label.y = conf$a.c4ShapeMargin - 35;
  let boundaryTextWrap = boundary.wrap && conf$a.wrap;
  let boundaryLabelConf = boundaryFont(conf$a);
  boundaryLabelConf.fontSize = boundaryLabelConf.fontSize + 2;
  boundaryLabelConf.fontWeight = "bold";
  let textLimitWidth = calculateTextWidth(boundary.label.text, boundaryLabelConf);
  calcC4ShapeTextWH("label", boundary, boundaryTextWrap, boundaryLabelConf, textLimitWidth);
  svgDraw$3.drawBoundary(diagram, boundary, conf$a);
};
const drawC4ShapeArray = function(currentBounds, diagram, c4ShapeArray2, c4ShapeKeys) {
  let Y3 = 0;
  for (let i = 0; i < c4ShapeKeys.length; i++) {
    Y3 = 0;
    const c4Shape = c4ShapeArray2[c4ShapeKeys[i]];
    let c4ShapeTypeConf = c4ShapeFont(conf$a, c4Shape.typeC4Shape.text);
    c4ShapeTypeConf.fontSize = c4ShapeTypeConf.fontSize - 2;
    c4Shape.typeC4Shape.width = calculateTextWidth(
      "<<" + c4Shape.typeC4Shape.text + ">>",
      c4ShapeTypeConf
    );
    c4Shape.typeC4Shape.height = c4ShapeTypeConf.fontSize + 2;
    c4Shape.typeC4Shape.Y = conf$a.c4ShapePadding;
    Y3 = c4Shape.typeC4Shape.Y + c4Shape.typeC4Shape.height - 4;
    c4Shape.image = { width: 0, height: 0, Y: 0 };
    switch (c4Shape.typeC4Shape.text) {
      case "person":
      case "external_person":
        c4Shape.image.width = 48;
        c4Shape.image.height = 48;
        c4Shape.image.Y = Y3;
        Y3 = c4Shape.image.Y + c4Shape.image.height;
        break;
    }
    if (c4Shape.sprite) {
      c4Shape.image.width = 48;
      c4Shape.image.height = 48;
      c4Shape.image.Y = Y3;
      Y3 = c4Shape.image.Y + c4Shape.image.height;
    }
    let c4ShapeTextWrap = c4Shape.wrap && conf$a.wrap;
    let textLimitWidth = conf$a.width - conf$a.c4ShapePadding * 2;
    let c4ShapeLabelConf = c4ShapeFont(conf$a, c4Shape.typeC4Shape.text);
    c4ShapeLabelConf.fontSize = c4ShapeLabelConf.fontSize + 2;
    c4ShapeLabelConf.fontWeight = "bold";
    calcC4ShapeTextWH("label", c4Shape, c4ShapeTextWrap, c4ShapeLabelConf, textLimitWidth);
    c4Shape["label"].Y = Y3 + 8;
    Y3 = c4Shape["label"].Y + c4Shape["label"].height;
    if (c4Shape.type && c4Shape.type.text !== "") {
      c4Shape.type.text = "[" + c4Shape.type.text + "]";
      let c4ShapeTypeConf2 = c4ShapeFont(conf$a, c4Shape.typeC4Shape.text);
      calcC4ShapeTextWH("type", c4Shape, c4ShapeTextWrap, c4ShapeTypeConf2, textLimitWidth);
      c4Shape["type"].Y = Y3 + 5;
      Y3 = c4Shape["type"].Y + c4Shape["type"].height;
    } else if (c4Shape.techn && c4Shape.techn.text !== "") {
      c4Shape.techn.text = "[" + c4Shape.techn.text + "]";
      let c4ShapeTechnConf = c4ShapeFont(conf$a, c4Shape.techn.text);
      calcC4ShapeTextWH("techn", c4Shape, c4ShapeTextWrap, c4ShapeTechnConf, textLimitWidth);
      c4Shape["techn"].Y = Y3 + 5;
      Y3 = c4Shape["techn"].Y + c4Shape["techn"].height;
    }
    let rectHeight = Y3;
    let rectWidth = c4Shape.label.width;
    if (c4Shape.descr && c4Shape.descr.text !== "") {
      let c4ShapeDescrConf = c4ShapeFont(conf$a, c4Shape.typeC4Shape.text);
      calcC4ShapeTextWH("descr", c4Shape, c4ShapeTextWrap, c4ShapeDescrConf, textLimitWidth);
      c4Shape["descr"].Y = Y3 + 20;
      Y3 = c4Shape["descr"].Y + c4Shape["descr"].height;
      rectWidth = Math.max(c4Shape.label.width, c4Shape.descr.width);
      rectHeight = Y3 - c4Shape["descr"].textLines * 5;
    }
    rectWidth = rectWidth + conf$a.c4ShapePadding;
    c4Shape.width = Math.max(c4Shape.width || conf$a.width, rectWidth, conf$a.width);
    c4Shape.height = Math.max(c4Shape.height || conf$a.height, rectHeight, conf$a.height);
    c4Shape.margin = c4Shape.margin || conf$a.c4ShapeMargin;
    currentBounds.insert(c4Shape);
    svgDraw$3.drawC4Shape(diagram, c4Shape, conf$a);
  }
  currentBounds.bumpLastMargin(conf$a.c4ShapeMargin);
};
class Point {
  constructor(x2, y2) {
    this.x = x2;
    this.y = y2;
  }
}
let getIntersectPoint = function(fromNode, endPoint) {
  let x12 = fromNode.x;
  let y12 = fromNode.y;
  let x2 = endPoint.x;
  let y2 = endPoint.y;
  let fromCenterX = x12 + fromNode.width / 2;
  let fromCenterY = y12 + fromNode.height / 2;
  let dx = Math.abs(x12 - x2);
  let dy = Math.abs(y12 - y2);
  let tanDYX = dy / dx;
  let fromDYX = fromNode.height / fromNode.width;
  let returnPoint = null;
  if (y12 == y2 && x12 < x2) {
    returnPoint = new Point(x12 + fromNode.width, fromCenterY);
  } else if (y12 == y2 && x12 > x2) {
    returnPoint = new Point(x12, fromCenterY);
  } else if (x12 == x2 && y12 < y2) {
    returnPoint = new Point(fromCenterX, y12 + fromNode.height);
  } else if (x12 == x2 && y12 > y2) {
    returnPoint = new Point(fromCenterX, y12);
  }
  if (x12 > x2 && y12 < y2) {
    if (fromDYX >= tanDYX) {
      returnPoint = new Point(x12, fromCenterY + tanDYX * fromNode.width / 2);
    } else {
      returnPoint = new Point(
        fromCenterX - dx / dy * fromNode.height / 2,
        y12 + fromNode.height
      );
    }
  } else if (x12 < x2 && y12 < y2) {
    if (fromDYX >= tanDYX) {
      returnPoint = new Point(x12 + fromNode.width, fromCenterY + tanDYX * fromNode.width / 2);
    } else {
      returnPoint = new Point(
        fromCenterX + dx / dy * fromNode.height / 2,
        y12 + fromNode.height
      );
    }
  } else if (x12 < x2 && y12 > y2) {
    if (fromDYX >= tanDYX) {
      returnPoint = new Point(x12 + fromNode.width, fromCenterY - tanDYX * fromNode.width / 2);
    } else {
      returnPoint = new Point(fromCenterX + fromNode.height / 2 * dx / dy, y12);
    }
  } else if (x12 > x2 && y12 > y2) {
    if (fromDYX >= tanDYX) {
      returnPoint = new Point(x12, fromCenterY - fromNode.width / 2 * tanDYX);
    } else {
      returnPoint = new Point(fromCenterX - fromNode.height / 2 * dx / dy, y12);
    }
  }
  return returnPoint;
};
let getIntersectPoints = function(fromNode, endNode) {
  let endIntersectPoint = { x: 0, y: 0 };
  endIntersectPoint.x = endNode.x + endNode.width / 2;
  endIntersectPoint.y = endNode.y + endNode.height / 2;
  let startPoint = getIntersectPoint(fromNode, endIntersectPoint);
  endIntersectPoint.x = fromNode.x + fromNode.width / 2;
  endIntersectPoint.y = fromNode.y + fromNode.height / 2;
  let endPoint = getIntersectPoint(endNode, endIntersectPoint);
  return { startPoint, endPoint };
};
const drawRels = function(diagram, rels2, getC4ShapeObj, diagObj) {
  let i = 0;
  for (let rel of rels2) {
    i = i + 1;
    let relTextWrap = rel.wrap && conf$a.wrap;
    let relConf = messageFont$1(conf$a);
    let diagramType = diagObj.db.getC4Type();
    if (diagramType === "C4Dynamic")
      rel.label.text = i + ": " + rel.label.text;
    let textLimitWidth = calculateTextWidth(rel.label.text, relConf);
    calcC4ShapeTextWH("label", rel, relTextWrap, relConf, textLimitWidth);
    if (rel.techn && rel.techn.text !== "") {
      textLimitWidth = calculateTextWidth(rel.techn.text, relConf);
      calcC4ShapeTextWH("techn", rel, relTextWrap, relConf, textLimitWidth);
    }
    if (rel.descr && rel.descr.text !== "") {
      textLimitWidth = calculateTextWidth(rel.descr.text, relConf);
      calcC4ShapeTextWH("descr", rel, relTextWrap, relConf, textLimitWidth);
    }
    let fromNode = getC4ShapeObj(rel.from);
    let endNode = getC4ShapeObj(rel.to);
    let points = getIntersectPoints(fromNode, endNode);
    rel.startPoint = points.startPoint;
    rel.endPoint = points.endPoint;
  }
  svgDraw$3.drawRels(diagram, rels2, conf$a);
};
function drawInsideBoundary(diagram, parentBoundaryAlias, parentBounds, currentBoundarys, diagObj) {
  let currentBounds = new Bounds(diagObj);
  currentBounds.data.widthLimit = parentBounds.data.widthLimit / Math.min(c4BoundaryInRow, currentBoundarys.length);
  for (let i = 0; i < currentBoundarys.length; i++) {
    let currentBoundary = currentBoundarys[i];
    let Y3 = 0;
    currentBoundary.image = { width: 0, height: 0, Y: 0 };
    if (currentBoundary.sprite) {
      currentBoundary.image.width = 48;
      currentBoundary.image.height = 48;
      currentBoundary.image.Y = Y3;
      Y3 = currentBoundary.image.Y + currentBoundary.image.height;
    }
    let currentBoundaryTextWrap = currentBoundary.wrap && conf$a.wrap;
    let currentBoundaryLabelConf = boundaryFont(conf$a);
    currentBoundaryLabelConf.fontSize = currentBoundaryLabelConf.fontSize + 2;
    currentBoundaryLabelConf.fontWeight = "bold";
    calcC4ShapeTextWH(
      "label",
      currentBoundary,
      currentBoundaryTextWrap,
      currentBoundaryLabelConf,
      currentBounds.data.widthLimit
    );
    currentBoundary["label"].Y = Y3 + 8;
    Y3 = currentBoundary["label"].Y + currentBoundary["label"].height;
    if (currentBoundary.type && currentBoundary.type.text !== "") {
      currentBoundary.type.text = "[" + currentBoundary.type.text + "]";
      let currentBoundaryTypeConf = boundaryFont(conf$a);
      calcC4ShapeTextWH(
        "type",
        currentBoundary,
        currentBoundaryTextWrap,
        currentBoundaryTypeConf,
        currentBounds.data.widthLimit
      );
      currentBoundary["type"].Y = Y3 + 5;
      Y3 = currentBoundary["type"].Y + currentBoundary["type"].height;
    }
    if (currentBoundary.descr && currentBoundary.descr.text !== "") {
      let currentBoundaryDescrConf = boundaryFont(conf$a);
      currentBoundaryDescrConf.fontSize = currentBoundaryDescrConf.fontSize - 2;
      calcC4ShapeTextWH(
        "descr",
        currentBoundary,
        currentBoundaryTextWrap,
        currentBoundaryDescrConf,
        currentBounds.data.widthLimit
      );
      currentBoundary["descr"].Y = Y3 + 20;
      Y3 = currentBoundary["descr"].Y + currentBoundary["descr"].height;
    }
    if (i == 0 || i % c4BoundaryInRow === 0) {
      let _x = parentBounds.data.startx + conf$a.diagramMarginX;
      let _y = parentBounds.data.stopy + conf$a.diagramMarginY + Y3;
      currentBounds.setData(_x, _x, _y, _y);
    } else {
      let _x = currentBounds.data.stopx !== currentBounds.data.startx ? currentBounds.data.stopx + conf$a.diagramMarginX : currentBounds.data.startx;
      let _y = currentBounds.data.starty;
      currentBounds.setData(_x, _x, _y, _y);
    }
    currentBounds.name = currentBoundary.alias;
    let currentPersonOrSystemArray = diagObj.db.getC4ShapeArray(currentBoundary.alias);
    let currentPersonOrSystemKeys = diagObj.db.getC4ShapeKeys(currentBoundary.alias);
    if (currentPersonOrSystemKeys.length > 0) {
      drawC4ShapeArray(
        currentBounds,
        diagram,
        currentPersonOrSystemArray,
        currentPersonOrSystemKeys
      );
    }
    parentBoundaryAlias = currentBoundary.alias;
    let nextCurrentBoundarys = diagObj.db.getBoundarys(parentBoundaryAlias);
    if (nextCurrentBoundarys.length > 0) {
      drawInsideBoundary(
        diagram,
        parentBoundaryAlias,
        currentBounds,
        nextCurrentBoundarys,
        diagObj
      );
    }
    if (currentBoundary.alias !== "global")
      drawBoundary(diagram, currentBoundary, currentBounds);
    parentBounds.data.stopy = Math.max(
      currentBounds.data.stopy + conf$a.c4ShapeMargin,
      parentBounds.data.stopy
    );
    parentBounds.data.stopx = Math.max(
      currentBounds.data.stopx + conf$a.c4ShapeMargin,
      parentBounds.data.stopx
    );
    globalBoundaryMaxX = Math.max(globalBoundaryMaxX, parentBounds.data.stopx);
    globalBoundaryMaxY = Math.max(globalBoundaryMaxY, parentBounds.data.stopy);
  }
}
const draw$e = function(_text, id2, _version, diagObj) {
  conf$a = getConfig$1().c4;
  const securityLevel = getConfig$1().securityLevel;
  let sandboxElement;
  if (securityLevel === "sandbox") {
    sandboxElement = select$1("#i" + id2);
  }
  const root2 = securityLevel === "sandbox" ? select$1(sandboxElement.nodes()[0].contentDocument.body) : select$1("body");
  let db = diagObj.db;
  diagObj.db.setWrap(conf$a.wrap);
  c4ShapeInRow = db.getC4ShapeInRow();
  c4BoundaryInRow = db.getC4BoundaryInRow();
  log$1.debug(`C:${JSON.stringify(conf$a, null, 2)}`);
  const diagram = securityLevel === "sandbox" ? root2.select(`[id="${id2}"]`) : select$1(`[id="${id2}"]`);
  svgDraw$3.insertComputerIcon(diagram);
  svgDraw$3.insertDatabaseIcon(diagram);
  svgDraw$3.insertClockIcon(diagram);
  let screenBounds = new Bounds(diagObj);
  screenBounds.setData(
    conf$a.diagramMarginX,
    conf$a.diagramMarginX,
    conf$a.diagramMarginY,
    conf$a.diagramMarginY
  );
  screenBounds.data.widthLimit = screen.availWidth;
  globalBoundaryMaxX = conf$a.diagramMarginX;
  globalBoundaryMaxY = conf$a.diagramMarginY;
  const title2 = diagObj.db.getTitle();
  let currentBoundarys = diagObj.db.getBoundarys("");
  drawInsideBoundary(diagram, "", screenBounds, currentBoundarys, diagObj);
  svgDraw$3.insertArrowHead(diagram);
  svgDraw$3.insertArrowEnd(diagram);
  svgDraw$3.insertArrowCrossHead(diagram);
  svgDraw$3.insertArrowFilledHead(diagram);
  drawRels(diagram, diagObj.db.getRels(), diagObj.db.getC4Shape, diagObj);
  screenBounds.data.stopx = globalBoundaryMaxX;
  screenBounds.data.stopy = globalBoundaryMaxY;
  const box = screenBounds.data;
  let boxHeight = box.stopy - box.starty;
  let height2 = boxHeight + 2 * conf$a.diagramMarginY;
  let boxWidth = box.stopx - box.startx;
  const width2 = boxWidth + 2 * conf$a.diagramMarginX;
  if (title2) {
    diagram.append("text").text(title2).attr("x", (box.stopx - box.startx) / 2 - 4 * conf$a.diagramMarginX).attr("y", box.starty + conf$a.diagramMarginY);
  }
  configureSvgSize(diagram, height2, width2, conf$a.useMaxWidth);
  const extraVertForTitle = title2 ? 60 : 0;
  diagram.attr(
    "viewBox",
    box.startx - conf$a.diagramMarginX + " -" + (conf$a.diagramMarginY + extraVertForTitle) + " " + width2 + " " + (height2 + extraVertForTitle)
  );
  addSVGAccessibilityFields(parser$a.yy, diagram, id2);
  log$1.debug(`models:`, box);
};
const c4Renderer = {
  drawPersonOrSystemArray: drawC4ShapeArray,
  drawBoundary,
  setConf: setConf$a,
  draw: draw$e
};
var parser$9 = function() {
  var o = function(k2, v, o2, l2) {
    for (o2 = o2 || {}, l2 = k2.length; l2--; o2[k2[l2]] = v)
      ;
    return o2;
  }, $V0 = [1, 3], $V1 = [1, 7], $V2 = [1, 8], $V3 = [1, 9], $V4 = [1, 10], $V5 = [1, 13], $V6 = [1, 12], $V7 = [1, 16, 25], $V8 = [1, 20], $V9 = [1, 31], $Va = [1, 32], $Vb = [1, 33], $Vc = [1, 35], $Vd = [1, 38], $Ve = [1, 36], $Vf = [1, 37], $Vg = [1, 39], $Vh = [1, 40], $Vi = [1, 41], $Vj = [1, 42], $Vk = [1, 45], $Vl = [1, 46], $Vm = [1, 47], $Vn = [1, 48], $Vo = [16, 25], $Vp = [1, 62], $Vq = [1, 63], $Vr = [1, 64], $Vs = [1, 65], $Vt = [1, 66], $Vu = [1, 67], $Vv = [1, 68], $Vw = [16, 25, 32, 44, 45, 53, 56, 57, 58, 59, 60, 61, 62, 67, 69], $Vx = [16, 25, 30, 32, 44, 45, 49, 53, 56, 57, 58, 59, 60, 61, 62, 67, 69, 84, 85, 86, 87], $Vy = [5, 8, 9, 10, 11, 16, 19, 23, 25], $Vz = [53, 84, 85, 86, 87], $VA = [53, 61, 62, 84, 85, 86, 87], $VB = [53, 56, 57, 58, 59, 60, 84, 85, 86, 87], $VC = [16, 25, 32], $VD = [1, 100];
  var parser2 = {
    trace: function trace() {
    },
    yy: {},
    symbols_: { "error": 2, "start": 3, "mermaidDoc": 4, "statments": 5, "direction": 6, "directive": 7, "direction_tb": 8, "direction_bt": 9, "direction_rl": 10, "direction_lr": 11, "graphConfig": 12, "openDirective": 13, "typeDirective": 14, "closeDirective": 15, "NEWLINE": 16, ":": 17, "argDirective": 18, "open_directive": 19, "type_directive": 20, "arg_directive": 21, "close_directive": 22, "CLASS_DIAGRAM": 23, "statements": 24, "EOF": 25, "statement": 26, "className": 27, "alphaNumToken": 28, "classLiteralName": 29, "GENERICTYPE": 30, "relationStatement": 31, "LABEL": 32, "classStatement": 33, "methodStatement": 34, "annotationStatement": 35, "clickStatement": 36, "cssClassStatement": 37, "acc_title": 38, "acc_title_value": 39, "acc_descr": 40, "acc_descr_value": 41, "acc_descr_multiline_value": 42, "CLASS": 43, "STYLE_SEPARATOR": 44, "STRUCT_START": 45, "members": 46, "STRUCT_STOP": 47, "ANNOTATION_START": 48, "ANNOTATION_END": 49, "MEMBER": 50, "SEPARATOR": 51, "relation": 52, "STR": 53, "relationType": 54, "lineType": 55, "AGGREGATION": 56, "EXTENSION": 57, "COMPOSITION": 58, "DEPENDENCY": 59, "LOLLIPOP": 60, "LINE": 61, "DOTTED_LINE": 62, "CALLBACK": 63, "LINK": 64, "LINK_TARGET": 65, "CLICK": 66, "CALLBACK_NAME": 67, "CALLBACK_ARGS": 68, "HREF": 69, "CSSCLASS": 70, "commentToken": 71, "textToken": 72, "graphCodeTokens": 73, "textNoTagsToken": 74, "TAGSTART": 75, "TAGEND": 76, "==": 77, "--": 78, "PCT": 79, "DEFAULT": 80, "SPACE": 81, "MINUS": 82, "keywords": 83, "UNICODE_TEXT": 84, "NUM": 85, "ALPHA": 86, "BQUOTE_STR": 87, "$accept": 0, "$end": 1 },
    terminals_: { 2: "error", 5: "statments", 8: "direction_tb", 9: "direction_bt", 10: "direction_rl", 11: "direction_lr", 16: "NEWLINE", 17: ":", 19: "open_directive", 20: "type_directive", 21: "arg_directive", 22: "close_directive", 23: "CLASS_DIAGRAM", 25: "EOF", 30: "GENERICTYPE", 32: "LABEL", 38: "acc_title", 39: "acc_title_value", 40: "acc_descr", 41: "acc_descr_value", 42: "acc_descr_multiline_value", 43: "CLASS", 44: "STYLE_SEPARATOR", 45: "STRUCT_START", 47: "STRUCT_STOP", 48: "ANNOTATION_START", 49: "ANNOTATION_END", 50: "MEMBER", 51: "SEPARATOR", 53: "STR", 56: "AGGREGATION", 57: "EXTENSION", 58: "COMPOSITION", 59: "DEPENDENCY", 60: "LOLLIPOP", 61: "LINE", 62: "DOTTED_LINE", 63: "CALLBACK", 64: "LINK", 65: "LINK_TARGET", 66: "CLICK", 67: "CALLBACK_NAME", 68: "CALLBACK_ARGS", 69: "HREF", 70: "CSSCLASS", 73: "graphCodeTokens", 75: "TAGSTART", 76: "TAGEND", 77: "==", 78: "--", 79: "PCT", 80: "DEFAULT", 81: "SPACE", 82: "MINUS", 83: "keywords", 84: "UNICODE_TEXT", 85: "NUM", 86: "ALPHA", 87: "BQUOTE_STR" },
    productions_: [0, [3, 1], [3, 1], [3, 1], [3, 2], [6, 1], [6, 1], [6, 1], [6, 1], [4, 1], [7, 4], [7, 6], [13, 1], [14, 1], [18, 1], [15, 1], [12, 4], [24, 1], [24, 2], [24, 3], [27, 1], [27, 1], [27, 2], [27, 2], [27, 2], [26, 1], [26, 2], [26, 1], [26, 1], [26, 1], [26, 1], [26, 1], [26, 1], [26, 1], [26, 2], [26, 2], [26, 1], [33, 2], [33, 4], [33, 5], [33, 7], [35, 4], [46, 1], [46, 2], [34, 1], [34, 2], [34, 1], [34, 1], [31, 3], [31, 4], [31, 4], [31, 5], [52, 3], [52, 2], [52, 2], [52, 1], [54, 1], [54, 1], [54, 1], [54, 1], [54, 1], [55, 1], [55, 1], [36, 3], [36, 4], [36, 3], [36, 4], [36, 4], [36, 5], [36, 3], [36, 4], [36, 4], [36, 5], [36, 3], [36, 4], [36, 4], [36, 5], [37, 3], [71, 1], [71, 1], [72, 1], [72, 1], [72, 1], [72, 1], [72, 1], [72, 1], [72, 1], [74, 1], [74, 1], [74, 1], [74, 1], [28, 1], [28, 1], [28, 1], [29, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 5:
          yy.setDirection("TB");
          break;
        case 6:
          yy.setDirection("BT");
          break;
        case 7:
          yy.setDirection("RL");
          break;
        case 8:
          yy.setDirection("LR");
          break;
        case 12:
          yy.parseDirective("%%{", "open_directive");
          break;
        case 13:
          yy.parseDirective($$[$0], "type_directive");
          break;
        case 14:
          $$[$0] = $$[$0].trim().replace(/'/g, '"');
          yy.parseDirective($$[$0], "arg_directive");
          break;
        case 15:
          yy.parseDirective("}%%", "close_directive", "class");
          break;
        case 20:
        case 21:
          this.$ = $$[$0];
          break;
        case 22:
          this.$ = $$[$0 - 1] + $$[$0];
          break;
        case 23:
        case 24:
          this.$ = $$[$0 - 1] + "~" + $$[$0];
          break;
        case 25:
          yy.addRelation($$[$0]);
          break;
        case 26:
          $$[$0 - 1].title = yy.cleanupLabel($$[$0]);
          yy.addRelation($$[$0 - 1]);
          break;
        case 34:
          this.$ = $$[$0].trim();
          yy.setAccTitle(this.$);
          break;
        case 35:
        case 36:
          this.$ = $$[$0].trim();
          yy.setAccDescription(this.$);
          break;
        case 37:
          yy.addClass($$[$0]);
          break;
        case 38:
          yy.addClass($$[$0 - 2]);
          yy.setCssClass($$[$0 - 2], $$[$0]);
          break;
        case 39:
          yy.addClass($$[$0 - 3]);
          yy.addMembers($$[$0 - 3], $$[$0 - 1]);
          break;
        case 40:
          yy.addClass($$[$0 - 5]);
          yy.setCssClass($$[$0 - 5], $$[$0 - 3]);
          yy.addMembers($$[$0 - 5], $$[$0 - 1]);
          break;
        case 41:
          yy.addAnnotation($$[$0], $$[$0 - 2]);
          break;
        case 42:
          this.$ = [$$[$0]];
          break;
        case 43:
          $$[$0].push($$[$0 - 1]);
          this.$ = $$[$0];
          break;
        case 44:
          break;
        case 45:
          yy.addMember($$[$0 - 1], yy.cleanupLabel($$[$0]));
          break;
        case 46:
          break;
        case 47:
          break;
        case 48:
          this.$ = { "id1": $$[$0 - 2], "id2": $$[$0], relation: $$[$0 - 1], relationTitle1: "none", relationTitle2: "none" };
          break;
        case 49:
          this.$ = { id1: $$[$0 - 3], id2: $$[$0], relation: $$[$0 - 1], relationTitle1: $$[$0 - 2], relationTitle2: "none" };
          break;
        case 50:
          this.$ = { id1: $$[$0 - 3], id2: $$[$0], relation: $$[$0 - 2], relationTitle1: "none", relationTitle2: $$[$0 - 1] };
          break;
        case 51:
          this.$ = { id1: $$[$0 - 4], id2: $$[$0], relation: $$[$0 - 2], relationTitle1: $$[$0 - 3], relationTitle2: $$[$0 - 1] };
          break;
        case 52:
          this.$ = { type1: $$[$0 - 2], type2: $$[$0], lineType: $$[$0 - 1] };
          break;
        case 53:
          this.$ = { type1: "none", type2: $$[$0], lineType: $$[$0 - 1] };
          break;
        case 54:
          this.$ = { type1: $$[$0 - 1], type2: "none", lineType: $$[$0] };
          break;
        case 55:
          this.$ = { type1: "none", type2: "none", lineType: $$[$0] };
          break;
        case 56:
          this.$ = yy.relationType.AGGREGATION;
          break;
        case 57:
          this.$ = yy.relationType.EXTENSION;
          break;
        case 58:
          this.$ = yy.relationType.COMPOSITION;
          break;
        case 59:
          this.$ = yy.relationType.DEPENDENCY;
          break;
        case 60:
          this.$ = yy.relationType.LOLLIPOP;
          break;
        case 61:
          this.$ = yy.lineType.LINE;
          break;
        case 62:
          this.$ = yy.lineType.DOTTED_LINE;
          break;
        case 63:
        case 69:
          this.$ = $$[$0 - 2];
          yy.setClickEvent($$[$0 - 1], $$[$0]);
          break;
        case 64:
        case 70:
          this.$ = $$[$0 - 3];
          yy.setClickEvent($$[$0 - 2], $$[$0 - 1]);
          yy.setTooltip($$[$0 - 2], $$[$0]);
          break;
        case 65:
        case 73:
          this.$ = $$[$0 - 2];
          yy.setLink($$[$0 - 1], $$[$0]);
          break;
        case 66:
          this.$ = $$[$0 - 3];
          yy.setLink($$[$0 - 2], $$[$0 - 1], $$[$0]);
          break;
        case 67:
        case 75:
          this.$ = $$[$0 - 3];
          yy.setLink($$[$0 - 2], $$[$0 - 1]);
          yy.setTooltip($$[$0 - 2], $$[$0]);
          break;
        case 68:
        case 76:
          this.$ = $$[$0 - 4];
          yy.setLink($$[$0 - 3], $$[$0 - 2], $$[$0]);
          yy.setTooltip($$[$0 - 3], $$[$0 - 1]);
          break;
        case 71:
          this.$ = $$[$0 - 3];
          yy.setClickEvent($$[$0 - 2], $$[$0 - 1], $$[$0]);
          break;
        case 72:
          this.$ = $$[$0 - 4];
          yy.setClickEvent($$[$0 - 3], $$[$0 - 2], $$[$0 - 1]);
          yy.setTooltip($$[$0 - 3], $$[$0]);
          break;
        case 74:
          this.$ = $$[$0 - 3];
          yy.setLink($$[$0 - 2], $$[$0 - 1], $$[$0]);
          break;
        case 77:
          yy.setCssClass($$[$0 - 1], $$[$0]);
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 5: $V0, 6: 4, 7: 5, 8: $V1, 9: $V2, 10: $V3, 11: $V4, 12: 6, 13: 11, 19: $V5, 23: $V6 }, { 1: [3] }, { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 3] }, { 3: 14, 4: 2, 5: $V0, 6: 4, 7: 5, 8: $V1, 9: $V2, 10: $V3, 11: $V4, 12: 6, 13: 11, 19: $V5, 23: $V6 }, { 1: [2, 9] }, o($V7, [2, 5]), o($V7, [2, 6]), o($V7, [2, 7]), o($V7, [2, 8]), { 14: 15, 20: [1, 16] }, { 16: [1, 17] }, { 20: [2, 12] }, { 1: [2, 4] }, { 15: 18, 17: [1, 19], 22: $V8 }, o([17, 22], [2, 13]), { 6: 30, 7: 29, 8: $V1, 9: $V2, 10: $V3, 11: $V4, 13: 11, 19: $V5, 24: 21, 26: 22, 27: 34, 28: 43, 29: 44, 31: 23, 33: 24, 34: 25, 35: 26, 36: 27, 37: 28, 38: $V9, 40: $Va, 42: $Vb, 43: $Vc, 48: $Vd, 50: $Ve, 51: $Vf, 63: $Vg, 64: $Vh, 66: $Vi, 70: $Vj, 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, { 16: [1, 49] }, { 18: 50, 21: [1, 51] }, { 16: [2, 15] }, { 25: [1, 52] }, { 16: [1, 53], 25: [2, 17] }, o($Vo, [2, 25], { 32: [1, 54] }), o($Vo, [2, 27]), o($Vo, [2, 28]), o($Vo, [2, 29]), o($Vo, [2, 30]), o($Vo, [2, 31]), o($Vo, [2, 32]), o($Vo, [2, 33]), { 39: [1, 55] }, { 41: [1, 56] }, o($Vo, [2, 36]), o($Vo, [2, 44], { 52: 57, 54: 60, 55: 61, 32: [1, 59], 53: [1, 58], 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt, 61: $Vu, 62: $Vv }), { 27: 69, 28: 43, 29: 44, 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, o($Vo, [2, 46]), o($Vo, [2, 47]), { 28: 70, 84: $Vk, 85: $Vl, 86: $Vm }, { 27: 71, 28: 43, 29: 44, 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, { 27: 72, 28: 43, 29: 44, 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, { 27: 73, 28: 43, 29: 44, 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, { 53: [1, 74] }, o($Vw, [2, 20], { 28: 43, 29: 44, 27: 75, 30: [1, 76], 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }), o($Vw, [2, 21], { 30: [1, 77] }), o($Vx, [2, 91]), o($Vx, [2, 92]), o($Vx, [2, 93]), o([16, 25, 30, 32, 44, 45, 53, 56, 57, 58, 59, 60, 61, 62, 67, 69], [2, 94]), o($Vy, [2, 10]), { 15: 78, 22: $V8 }, { 22: [2, 14] }, { 1: [2, 16] }, { 6: 30, 7: 29, 8: $V1, 9: $V2, 10: $V3, 11: $V4, 13: 11, 19: $V5, 24: 79, 25: [2, 18], 26: 22, 27: 34, 28: 43, 29: 44, 31: 23, 33: 24, 34: 25, 35: 26, 36: 27, 37: 28, 38: $V9, 40: $Va, 42: $Vb, 43: $Vc, 48: $Vd, 50: $Ve, 51: $Vf, 63: $Vg, 64: $Vh, 66: $Vi, 70: $Vj, 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, o($Vo, [2, 26]), o($Vo, [2, 34]), o($Vo, [2, 35]), { 27: 80, 28: 43, 29: 44, 53: [1, 81], 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, { 52: 82, 54: 60, 55: 61, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt, 61: $Vu, 62: $Vv }, o($Vo, [2, 45]), { 55: 83, 61: $Vu, 62: $Vv }, o($Vz, [2, 55], { 54: 84, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt }), o($VA, [2, 56]), o($VA, [2, 57]), o($VA, [2, 58]), o($VA, [2, 59]), o($VA, [2, 60]), o($VB, [2, 61]), o($VB, [2, 62]), o($Vo, [2, 37], { 44: [1, 85], 45: [1, 86] }), { 49: [1, 87] }, { 53: [1, 88] }, { 53: [1, 89] }, { 67: [1, 90], 69: [1, 91] }, { 28: 92, 84: $Vk, 85: $Vl, 86: $Vm }, o($Vw, [2, 22]), o($Vw, [2, 23]), o($Vw, [2, 24]), { 16: [1, 93] }, { 25: [2, 19] }, o($VC, [2, 48]), { 27: 94, 28: 43, 29: 44, 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, { 27: 95, 28: 43, 29: 44, 53: [1, 96], 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, o($Vz, [2, 54], { 54: 97, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt }), o($Vz, [2, 53]), { 28: 98, 84: $Vk, 85: $Vl, 86: $Vm }, { 46: 99, 50: $VD }, { 27: 101, 28: 43, 29: 44, 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, o($Vo, [2, 63], { 53: [1, 102] }), o($Vo, [2, 65], { 53: [1, 104], 65: [1, 103] }), o($Vo, [2, 69], { 53: [1, 105], 68: [1, 106] }), o($Vo, [2, 73], { 53: [1, 108], 65: [1, 107] }), o($Vo, [2, 77]), o($Vy, [2, 11]), o($VC, [2, 50]), o($VC, [2, 49]), { 27: 109, 28: 43, 29: 44, 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, o($Vz, [2, 52]), o($Vo, [2, 38], { 45: [1, 110] }), { 47: [1, 111] }, { 46: 112, 47: [2, 42], 50: $VD }, o($Vo, [2, 41]), o($Vo, [2, 64]), o($Vo, [2, 66]), o($Vo, [2, 67], { 65: [1, 113] }), o($Vo, [2, 70]), o($Vo, [2, 71], { 53: [1, 114] }), o($Vo, [2, 74]), o($Vo, [2, 75], { 65: [1, 115] }), o($VC, [2, 51]), { 46: 116, 50: $VD }, o($Vo, [2, 39]), { 47: [2, 43] }, o($Vo, [2, 68]), o($Vo, [2, 72]), o($Vo, [2, 76]), { 47: [1, 117] }, o($Vo, [2, 40])],
    defaultActions: { 2: [2, 1], 3: [2, 2], 4: [2, 3], 6: [2, 9], 13: [2, 12], 14: [2, 4], 20: [2, 15], 51: [2, 14], 52: [2, 16], 79: [2, 19], 112: [2, 43] },
    parseError: function parseError(str, hash2) {
      if (hash2.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash2;
        throw error;
      }
    },
    parse: function parse2(input) {
      var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k2 in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
          sharedState.yy[k2] = this.yy[k2];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges2 = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function lex() {
        var token2;
        token2 = tstack.pop() || lexer2.lex() || EOF2;
        if (typeof token2 !== "number") {
          if (token2 instanceof Array) {
            tstack = token2;
            token2 = tstack.pop();
          }
          token2 = self2.symbols_[token2] || token2;
        }
        return token2;
      }
      var symbol2, state, action, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack2[stack2.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol2 === null || typeof symbol2 == "undefined") {
            symbol2 = lex();
          }
          action = table[state] && table[state][symbol2];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push("'" + this.terminals_[p] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol2] || symbol2) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol2 == EOF2 ? "end of input" : "'" + (this.terminals_[symbol2] || symbol2) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol2] || symbol2,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol2);
        }
        switch (action[0]) {
          case 1:
            stack2.push(symbol2);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack2.push(action[1]);
            symbol2 = null;
            {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges2) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
              ];
            }
            r = this.performAction.apply(yyval, [
              yytext,
              yyleng,
              yylineno,
              sharedState.yy,
              action[1],
              vstack,
              lstack
            ].concat(args));
            if (typeof r !== "undefined") {
              return r;
            }
            if (len) {
              stack2 = stack2.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack2.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
            stack2.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash2) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash2);
        } else {
          throw new Error(str);
        }
      },
      setInput: function(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      input: function() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      unput: function(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      more: function() {
        this._more = true;
        return this;
      },
      reject: function() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      less: function(n) {
        this.unput(this.match.slice(n));
      },
      pastInput: function() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var next2 = this.match;
        if (next2.length < 20) {
          next2 += this._input.substr(0, 20 - next2.length);
        }
        return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var pre = this.pastInput();
        var c2 = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c2 + "^";
      },
      test_match: function(match, indexed_rule) {
        var token2, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token2) {
          return token2;
        } else if (this._backtrack) {
          for (var k2 in backup) {
            this[k2] = backup[k2];
          }
          return false;
        }
        return false;
      },
      next: function() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token2, match, tempMatch, index2;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index2 = i;
            if (this.options.backtrack_lexer) {
              token2 = this.test_match(tempMatch, rules[i]);
              if (token2 !== false) {
                return token2;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token2 = this.test_match(match, rules[index2]);
          if (token2 !== false) {
            return token2;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: {},
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        switch ($avoiding_name_collisions) {
          case 0:
            this.begin("open_directive");
            return 19;
          case 1:
            return 8;
          case 2:
            return 9;
          case 3:
            return 10;
          case 4:
            return 11;
          case 5:
            this.begin("type_directive");
            return 20;
          case 6:
            this.popState();
            this.begin("arg_directive");
            return 17;
          case 7:
            this.popState();
            this.popState();
            return 22;
          case 8:
            return 21;
          case 9:
            break;
          case 10:
            break;
          case 11:
            this.begin("acc_title");
            return 38;
          case 12:
            this.popState();
            return "acc_title_value";
          case 13:
            this.begin("acc_descr");
            return 40;
          case 14:
            this.popState();
            return "acc_descr_value";
          case 15:
            this.begin("acc_descr_multiline");
            break;
          case 16:
            this.popState();
            break;
          case 17:
            return "acc_descr_multiline_value";
          case 18:
            return 16;
          case 19:
            break;
          case 20:
            return 23;
          case 21:
            return 23;
          case 22:
            this.begin("struct");
            return 45;
          case 23:
            return "EDGE_STATE";
          case 24:
            return "EOF_IN_STRUCT";
          case 25:
            return "OPEN_IN_STRUCT";
          case 26:
            this.popState();
            return 47;
          case 27:
            break;
          case 28:
            return "MEMBER";
          case 29:
            return 43;
          case 30:
            return 70;
          case 31:
            return 63;
          case 32:
            return 64;
          case 33:
            return 66;
          case 34:
            return 48;
          case 35:
            return 49;
          case 36:
            this.begin("generic");
            break;
          case 37:
            this.popState();
            break;
          case 38:
            return "GENERICTYPE";
          case 39:
            this.begin("string");
            break;
          case 40:
            this.popState();
            break;
          case 41:
            return "STR";
          case 42:
            this.begin("bqstring");
            break;
          case 43:
            this.popState();
            break;
          case 44:
            return "BQUOTE_STR";
          case 45:
            this.begin("href");
            break;
          case 46:
            this.popState();
            break;
          case 47:
            return 69;
          case 48:
            this.begin("callback_name");
            break;
          case 49:
            this.popState();
            break;
          case 50:
            this.popState();
            this.begin("callback_args");
            break;
          case 51:
            return 67;
          case 52:
            this.popState();
            break;
          case 53:
            return 68;
          case 54:
            return 65;
          case 55:
            return 65;
          case 56:
            return 65;
          case 57:
            return 65;
          case 58:
            return 57;
          case 59:
            return 57;
          case 60:
            return 59;
          case 61:
            return 59;
          case 62:
            return 58;
          case 63:
            return 56;
          case 64:
            return 60;
          case 65:
            return 61;
          case 66:
            return 62;
          case 67:
            return 32;
          case 68:
            return 44;
          case 69:
            return 82;
          case 70:
            return "DOT";
          case 71:
            return "PLUS";
          case 72:
            return 79;
          case 73:
            return "EQUALS";
          case 74:
            return "EQUALS";
          case 75:
            return 86;
          case 76:
            return "PUNCTUATION";
          case 77:
            return 85;
          case 78:
            return 84;
          case 79:
            return 81;
          case 80:
            return 25;
        }
      },
      rules: [/^(?:%%\{)/, /^(?:.*direction\s+TB[^\n]*)/, /^(?:.*direction\s+BT[^\n]*)/, /^(?:.*direction\s+RL[^\n]*)/, /^(?:.*direction\s+LR[^\n]*)/, /^(?:((?:(?!\}%%)[^:.])*))/, /^(?::)/, /^(?:\}%%)/, /^(?:((?:(?!\}%%).|\n)*))/, /^(?:%%(?!\{)*[^\n]*(\r?\n?)+)/, /^(?:%%[^\n]*(\r?\n)*)/, /^(?:accTitle\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*\{\s*)/, /^(?:[\}])/, /^(?:[^\}]*)/, /^(?:\s*(\r?\n)+)/, /^(?:\s+)/, /^(?:classDiagram-v2\b)/, /^(?:classDiagram\b)/, /^(?:[{])/, /^(?:\[\*\])/, /^(?:$)/, /^(?:[{])/, /^(?:[}])/, /^(?:[\n])/, /^(?:[^{}\n]*)/, /^(?:class\b)/, /^(?:cssClass\b)/, /^(?:callback\b)/, /^(?:link\b)/, /^(?:click\b)/, /^(?:<<)/, /^(?:>>)/, /^(?:[~])/, /^(?:[~])/, /^(?:[^~]*)/, /^(?:["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:[`])/, /^(?:[`])/, /^(?:[^`]+)/, /^(?:href[\s]+["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:call[\s]+)/, /^(?:\([\s]*\))/, /^(?:\()/, /^(?:[^(]*)/, /^(?:\))/, /^(?:[^)]*)/, /^(?:_self\b)/, /^(?:_blank\b)/, /^(?:_parent\b)/, /^(?:_top\b)/, /^(?:\s*<\|)/, /^(?:\s*\|>)/, /^(?:\s*>)/, /^(?:\s*<)/, /^(?:\s*\*)/, /^(?:\s*o\b)/, /^(?:\s*\(\))/, /^(?:--)/, /^(?:\.\.)/, /^(?::{1}[^:\n;]+)/, /^(?::{3})/, /^(?:-)/, /^(?:\.)/, /^(?:\+)/, /^(?:%)/, /^(?:=)/, /^(?:=)/, /^(?:\w+)/, /^(?:[!"#$%&'*+,-.`?\\/])/, /^(?:[0-9]+)/, /^(?:[\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6]|[\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377]|[\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5]|[\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA]|[\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE]|[\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA]|[\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0]|[\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977]|[\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2]|[\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A]|[\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39]|[\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8]|[\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C]|[\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C]|[\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99]|[\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0]|[\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D]|[\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3]|[\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10]|[\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1]|[\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81]|[\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3]|[\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6]|[\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A]|[\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081]|[\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D]|[\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0]|[\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310]|[\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C]|[\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711]|[\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7]|[\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C]|[\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16]|[\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF]|[\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC]|[\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D]|[\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D]|[\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3]|[\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F]|[\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128]|[\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184]|[\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3]|[\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6]|[\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE]|[\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C]|[\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D]|[\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC]|[\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B]|[\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788]|[\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805]|[\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB]|[\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28]|[\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5]|[\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4]|[\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E]|[\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D]|[\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36]|[\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D]|[\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC]|[\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF]|[\uFFD2-\uFFD7\uFFDA-\uFFDC])/, /^(?:\s)/, /^(?:$)/],
      conditions: { "acc_descr_multiline": { "rules": [16, 17], "inclusive": false }, "acc_descr": { "rules": [14], "inclusive": false }, "acc_title": { "rules": [12], "inclusive": false }, "arg_directive": { "rules": [7, 8], "inclusive": false }, "type_directive": { "rules": [6, 7], "inclusive": false }, "open_directive": { "rules": [5], "inclusive": false }, "callback_args": { "rules": [52, 53], "inclusive": false }, "callback_name": { "rules": [49, 50, 51], "inclusive": false }, "href": { "rules": [46, 47], "inclusive": false }, "struct": { "rules": [23, 24, 25, 26, 27, 28], "inclusive": false }, "generic": { "rules": [37, 38], "inclusive": false }, "bqstring": { "rules": [43, 44], "inclusive": false }, "string": { "rules": [40, 41], "inclusive": false }, "INITIAL": { "rules": [0, 1, 2, 3, 4, 9, 10, 11, 13, 15, 18, 19, 20, 21, 22, 23, 29, 30, 31, 32, 33, 34, 35, 36, 39, 42, 45, 48, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80], "inclusive": true } }
    };
    return lexer2;
  }();
  parser2.lexer = lexer;
  function Parser2() {
    this.yy = {};
  }
  Parser2.prototype = parser2;
  parser2.Parser = Parser2;
  return new Parser2();
}();
parser$9.parser = parser$9;
const classDetector = (txt, config2) => {
  var _a2;
  if (((_a2 = config2 == null ? void 0 : config2.class) == null ? void 0 : _a2.defaultRenderer) === "dagre-wrapper")
    return false;
  return txt.match(/^\s*classDiagram/) !== null;
};
const classDetectorV2 = (txt, config2) => {
  var _a2;
  if (txt.match(/^\s*classDiagram/) !== null && ((_a2 = config2 == null ? void 0 : config2.class) == null ? void 0 : _a2.defaultRenderer) === "dagre-wrapper")
    return true;
  return txt.match(/^\s*classDiagram-v2/) !== null;
};
const MERMAID_DOM_ID_PREFIX$1 = "classid-";
let relations$1 = [];
let classes$2 = {};
let classCounter = 0;
let funs$2 = [];
const sanitizeText$2 = (txt) => common.sanitizeText(txt, getConfig$1());
const parseDirective$9 = function(statement, context, type2) {
  mermaidAPI.parseDirective(this, statement, context, type2);
};
const splitClassNameAndType = function(id2) {
  let genericType = "";
  let className2 = id2;
  if (id2.indexOf("~") > 0) {
    let split = id2.split("~");
    className2 = split[0];
    genericType = common.sanitizeText(split[1], getConfig$1());
  }
  return { className: className2, type: genericType };
};
const addClass$1 = function(id2) {
  let classId = splitClassNameAndType(id2);
  if (typeof classes$2[classId.className] !== "undefined")
    return;
  classes$2[classId.className] = {
    id: classId.className,
    type: classId.type,
    cssClasses: [],
    methods: [],
    members: [],
    annotations: [],
    domId: MERMAID_DOM_ID_PREFIX$1 + classId.className + "-" + classCounter
  };
  classCounter++;
};
const lookUpDomId$1 = function(id2) {
  const classKeys = Object.keys(classes$2);
  for (let i = 0; i < classKeys.length; i++) {
    if (classes$2[classKeys[i]].id === id2) {
      return classes$2[classKeys[i]].domId;
    }
  }
};
const clear$c = function() {
  relations$1 = [];
  classes$2 = {};
  funs$2 = [];
  funs$2.push(setupToolTips$1);
  clear$g();
};
const getClass = function(id2) {
  return classes$2[id2];
};
const getClasses$5 = function() {
  return classes$2;
};
const getRelations$1 = function() {
  return relations$1;
};
const addRelation$1 = function(relation) {
  log$1.debug("Adding relation: " + JSON.stringify(relation));
  addClass$1(relation.id1);
  addClass$1(relation.id2);
  relation.id1 = splitClassNameAndType(relation.id1).className;
  relation.id2 = splitClassNameAndType(relation.id2).className;
  relation.relationTitle1 = common.sanitizeText(
    relation.relationTitle1.trim(),
    getConfig$1()
  );
  relation.relationTitle2 = common.sanitizeText(
    relation.relationTitle2.trim(),
    getConfig$1()
  );
  relations$1.push(relation);
};
const addAnnotation = function(className2, annotation) {
  const validatedClassName = splitClassNameAndType(className2).className;
  classes$2[validatedClassName].annotations.push(annotation);
};
const addMember = function(className2, member) {
  const validatedClassName = splitClassNameAndType(className2).className;
  const theClass = classes$2[validatedClassName];
  if (typeof member === "string") {
    const memberString = member.trim();
    if (memberString.startsWith("<<") && memberString.endsWith(">>")) {
      theClass.annotations.push(sanitizeText$2(memberString.substring(2, memberString.length - 2)));
    } else if (memberString.indexOf(")") > 0) {
      theClass.methods.push(sanitizeText$2(memberString));
    } else if (memberString) {
      theClass.members.push(sanitizeText$2(memberString));
    }
  }
};
const addMembers = function(className2, members) {
  if (Array.isArray(members)) {
    members.reverse();
    members.forEach((member) => addMember(className2, member));
  }
};
const cleanupLabel$1 = function(label) {
  if (label.substring(0, 1) === ":") {
    return common.sanitizeText(label.substr(1).trim(), getConfig$1());
  } else {
    return sanitizeText$2(label.trim());
  }
};
const setCssClass = function(ids, className2) {
  ids.split(",").forEach(function(_id) {
    let id2 = _id;
    if (_id[0].match(/\d/))
      id2 = MERMAID_DOM_ID_PREFIX$1 + id2;
    if (typeof classes$2[id2] !== "undefined") {
      classes$2[id2].cssClasses.push(className2);
    }
  });
};
const setTooltip$1 = function(ids, tooltip) {
  const config2 = getConfig$1();
  ids.split(",").forEach(function(id2) {
    if (typeof tooltip !== "undefined") {
      classes$2[id2].tooltip = common.sanitizeText(tooltip, config2);
    }
  });
};
const getTooltip$1 = function(id2) {
  return classes$2[id2].tooltip;
};
const setLink$2 = function(ids, linkStr, target) {
  const config2 = getConfig$1();
  ids.split(",").forEach(function(_id) {
    let id2 = _id;
    if (_id[0].match(/\d/))
      id2 = MERMAID_DOM_ID_PREFIX$1 + id2;
    if (typeof classes$2[id2] !== "undefined") {
      classes$2[id2].link = utils.formatUrl(linkStr, config2);
      if (config2.securityLevel === "sandbox") {
        classes$2[id2].linkTarget = "_top";
      } else if (typeof target === "string") {
        classes$2[id2].linkTarget = sanitizeText$2(target);
      } else {
        classes$2[id2].linkTarget = "_blank";
      }
    }
  });
  setCssClass(ids, "clickable");
};
const setClickEvent$2 = function(ids, functionName, functionArgs) {
  ids.split(",").forEach(function(id2) {
    setClickFunc(id2, functionName, functionArgs);
    classes$2[id2].haveCallback = true;
  });
  setCssClass(ids, "clickable");
};
const setClickFunc = function(domId, functionName, functionArgs) {
  const config2 = getConfig$1();
  let id2 = domId;
  let elemId = lookUpDomId$1(id2);
  if (config2.securityLevel !== "loose") {
    return;
  }
  if (typeof functionName === "undefined") {
    return;
  }
  if (typeof classes$2[id2] !== "undefined") {
    let argList = [];
    if (typeof functionArgs === "string") {
      argList = functionArgs.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
      for (let i = 0; i < argList.length; i++) {
        let item = argList[i].trim();
        if (item.charAt(0) === '"' && item.charAt(item.length - 1) === '"') {
          item = item.substr(1, item.length - 2);
        }
        argList[i] = item;
      }
    }
    if (argList.length === 0) {
      argList.push(elemId);
    }
    funs$2.push(function() {
      const elem = document.querySelector(`[id="${elemId}"]`);
      if (elem !== null) {
        elem.addEventListener(
          "click",
          function() {
            utils.runFunc(functionName, ...argList);
          },
          false
        );
      }
    });
  }
};
const bindFunctions$2 = function(element) {
  funs$2.forEach(function(fun) {
    fun(element);
  });
};
const lineType$1 = {
  LINE: 0,
  DOTTED_LINE: 1
};
const relationType$1 = {
  AGGREGATION: 0,
  EXTENSION: 1,
  COMPOSITION: 2,
  DEPENDENCY: 3,
  LOLLIPOP: 4
};
const setupToolTips$1 = function(element) {
  let tooltipElem = select$1(".mermaidTooltip");
  if ((tooltipElem._groups || tooltipElem)[0][0] === null) {
    tooltipElem = select$1("body").append("div").attr("class", "mermaidTooltip").style("opacity", 0);
  }
  const svg2 = select$1(element).select("svg");
  const nodes = svg2.selectAll("g.node");
  nodes.on("mouseover", function() {
    const el = select$1(this);
    const title2 = el.attr("title");
    if (title2 === null) {
      return;
    }
    const rect2 = this.getBoundingClientRect();
    tooltipElem.transition().duration(200).style("opacity", ".9");
    tooltipElem.text(el.attr("title")).style("left", window.scrollX + rect2.left + (rect2.right - rect2.left) / 2 + "px").style("top", window.scrollY + rect2.top - 14 + document.body.scrollTop + "px");
    tooltipElem.html(tooltipElem.html().replace(/&lt;br\/&gt;/g, "<br/>"));
    el.classed("hover", true);
  }).on("mouseout", function() {
    tooltipElem.transition().duration(500).style("opacity", 0);
    const el = select$1(this);
    el.classed("hover", false);
  });
};
funs$2.push(setupToolTips$1);
let direction$2 = "TB";
const getDirection$2 = () => direction$2;
const setDirection$2 = (dir) => {
  direction$2 = dir;
};
const classDb = {
  parseDirective: parseDirective$9,
  setAccTitle,
  getAccTitle,
  getAccDescription,
  setAccDescription,
  getConfig: () => getConfig$1().class,
  addClass: addClass$1,
  bindFunctions: bindFunctions$2,
  clear: clear$c,
  getClass,
  getClasses: getClasses$5,
  addAnnotation,
  getRelations: getRelations$1,
  addRelation: addRelation$1,
  getDirection: getDirection$2,
  setDirection: setDirection$2,
  addMember,
  addMembers,
  cleanupLabel: cleanupLabel$1,
  lineType: lineType$1,
  relationType: relationType$1,
  setClickEvent: setClickEvent$2,
  setCssClass,
  setLink: setLink$2,
  getTooltip: getTooltip$1,
  setTooltip: setTooltip$1,
  lookUpDomId: lookUpDomId$1
};
let edgeCount$1 = 0;
const drawEdge$1 = function(elem, path2, relation, conf2, diagObj) {
  const getRelationType = function(type2) {
    switch (type2) {
      case diagObj.db.relationType.AGGREGATION:
        return "aggregation";
      case diagObj.db.EXTENSION:
        return "extension";
      case diagObj.db.COMPOSITION:
        return "composition";
      case diagObj.db.DEPENDENCY:
        return "dependency";
      case diagObj.db.LOLLIPOP:
        return "lollipop";
    }
  };
  path2.points = path2.points.filter((p) => !Number.isNaN(p.y));
  const lineData = path2.points;
  const lineFunction = line$2().x(function(d) {
    return d.x;
  }).y(function(d) {
    return d.y;
  }).curve(curveBasis);
  const svgPath = elem.append("path").attr("d", lineFunction(lineData)).attr("id", "edge" + edgeCount$1).attr("class", "relation");
  let url = "";
  if (conf2.arrowMarkerAbsolute) {
    url = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search;
    url = url.replace(/\(/g, "\\(");
    url = url.replace(/\)/g, "\\)");
  }
  if (relation.relation.lineType == 1) {
    svgPath.attr("class", "relation dashed-line");
  }
  if (relation.relation.type1 !== "none") {
    svgPath.attr(
      "marker-start",
      "url(" + url + "#" + getRelationType(relation.relation.type1) + "Start)"
    );
  }
  if (relation.relation.type2 !== "none") {
    svgPath.attr(
      "marker-end",
      "url(" + url + "#" + getRelationType(relation.relation.type2) + "End)"
    );
  }
  let x2, y2;
  const l2 = path2.points.length;
  let labelPosition = utils.calcLabelPosition(path2.points);
  x2 = labelPosition.x;
  y2 = labelPosition.y;
  let p1_card_x, p1_card_y;
  let p2_card_x, p2_card_y;
  if (l2 % 2 !== 0 && l2 > 1) {
    let cardinality_1_point = utils.calcCardinalityPosition(
      relation.relation.type1 !== "none",
      path2.points,
      path2.points[0]
    );
    let cardinality_2_point = utils.calcCardinalityPosition(
      relation.relation.type2 !== "none",
      path2.points,
      path2.points[l2 - 1]
    );
    log$1.debug("cardinality_1_point " + JSON.stringify(cardinality_1_point));
    log$1.debug("cardinality_2_point " + JSON.stringify(cardinality_2_point));
    p1_card_x = cardinality_1_point.x;
    p1_card_y = cardinality_1_point.y;
    p2_card_x = cardinality_2_point.x;
    p2_card_y = cardinality_2_point.y;
  }
  if (typeof relation.title !== "undefined") {
    const g2 = elem.append("g").attr("class", "classLabel");
    const label = g2.append("text").attr("class", "label").attr("x", x2).attr("y", y2).attr("fill", "red").attr("text-anchor", "middle").text(relation.title);
    window.label = label;
    const bounds2 = label.node().getBBox();
    g2.insert("rect", ":first-child").attr("class", "box").attr("x", bounds2.x - conf2.padding / 2).attr("y", bounds2.y - conf2.padding / 2).attr("width", bounds2.width + conf2.padding).attr("height", bounds2.height + conf2.padding);
  }
  log$1.info("Rendering relation " + JSON.stringify(relation));
  if (typeof relation.relationTitle1 !== "undefined" && relation.relationTitle1 !== "none") {
    const g2 = elem.append("g").attr("class", "cardinality");
    g2.append("text").attr("class", "type1").attr("x", p1_card_x).attr("y", p1_card_y).attr("fill", "black").attr("font-size", "6").text(relation.relationTitle1);
  }
  if (typeof relation.relationTitle2 !== "undefined" && relation.relationTitle2 !== "none") {
    const g2 = elem.append("g").attr("class", "cardinality");
    g2.append("text").attr("class", "type2").attr("x", p2_card_x).attr("y", p2_card_y).attr("fill", "black").attr("font-size", "6").text(relation.relationTitle2);
  }
  edgeCount$1++;
};
const drawClass = function(elem, classDef, conf2, diagObj) {
  log$1.debug("Rendering class ", classDef, conf2);
  const id2 = classDef.id;
  const classInfo = {
    id: id2,
    label: classDef.id,
    width: 0,
    height: 0
  };
  const g2 = elem.append("g").attr("id", diagObj.db.lookUpDomId(id2)).attr("class", "classGroup");
  let title2;
  if (classDef.link) {
    title2 = g2.append("svg:a").attr("xlink:href", classDef.link).attr("target", classDef.linkTarget).append("text").attr("y", conf2.textHeight + conf2.padding).attr("x", 0);
  } else {
    title2 = g2.append("text").attr("y", conf2.textHeight + conf2.padding).attr("x", 0);
  }
  let isFirst = true;
  classDef.annotations.forEach(function(member) {
    const titleText2 = title2.append("tspan").text("\xAB" + member + "\xBB");
    if (!isFirst)
      titleText2.attr("dy", conf2.textHeight);
    isFirst = false;
  });
  let classTitleString = classDef.id;
  if (classDef.type !== void 0 && classDef.type !== "") {
    classTitleString += "<" + classDef.type + ">";
  }
  const classTitle = title2.append("tspan").text(classTitleString).attr("class", "title");
  if (!isFirst)
    classTitle.attr("dy", conf2.textHeight);
  const titleHeight = title2.node().getBBox().height;
  const membersLine = g2.append("line").attr("x1", 0).attr("y1", conf2.padding + titleHeight + conf2.dividerMargin / 2).attr("y2", conf2.padding + titleHeight + conf2.dividerMargin / 2);
  const members = g2.append("text").attr("x", conf2.padding).attr("y", titleHeight + conf2.dividerMargin + conf2.textHeight).attr("fill", "white").attr("class", "classText");
  isFirst = true;
  classDef.members.forEach(function(member) {
    addTspan(members, member, isFirst, conf2);
    isFirst = false;
  });
  const membersBox = members.node().getBBox();
  const methodsLine = g2.append("line").attr("x1", 0).attr("y1", conf2.padding + titleHeight + conf2.dividerMargin + membersBox.height).attr("y2", conf2.padding + titleHeight + conf2.dividerMargin + membersBox.height);
  const methods = g2.append("text").attr("x", conf2.padding).attr("y", titleHeight + 2 * conf2.dividerMargin + membersBox.height + conf2.textHeight).attr("fill", "white").attr("class", "classText");
  isFirst = true;
  classDef.methods.forEach(function(method) {
    addTspan(methods, method, isFirst, conf2);
    isFirst = false;
  });
  const classBox = g2.node().getBBox();
  var cssClassStr = " ";
  if (classDef.cssClasses.length > 0) {
    cssClassStr = cssClassStr + classDef.cssClasses.join(" ");
  }
  const rect2 = g2.insert("rect", ":first-child").attr("x", 0).attr("y", 0).attr("width", classBox.width + 2 * conf2.padding).attr("height", classBox.height + conf2.padding + 0.5 * conf2.dividerMargin).attr("class", cssClassStr);
  const rectWidth = rect2.node().getBBox().width;
  title2.node().childNodes.forEach(function(x2) {
    x2.setAttribute("x", (rectWidth - x2.getBBox().width) / 2);
  });
  if (classDef.tooltip) {
    title2.insert("title").text(classDef.tooltip);
  }
  membersLine.attr("x2", rectWidth);
  methodsLine.attr("x2", rectWidth);
  classInfo.width = rectWidth;
  classInfo.height = classBox.height + conf2.padding + 0.5 * conf2.dividerMargin;
  return classInfo;
};
const parseMember = function(text2) {
  const fieldRegEx = /^(\+|-|~|#)?(\w+)(~\w+~|\[\])?\s+(\w+) *(\*|\$)?$/;
  const methodRegEx = /^([+|\-|~|#])?(\w+) *\( *(.*)\) *(\*|\$)? *(\w*[~|[\]]*\s*\w*~?)$/;
  let fieldMatch = text2.match(fieldRegEx);
  let methodMatch = text2.match(methodRegEx);
  if (fieldMatch && !methodMatch) {
    return buildFieldDisplay(fieldMatch);
  } else if (methodMatch) {
    return buildMethodDisplay(methodMatch);
  } else {
    return buildLegacyDisplay(text2);
  }
};
const buildFieldDisplay = function(parsedText) {
  let cssStyle = "";
  let displayText = "";
  try {
    let visibility = parsedText[1] ? parsedText[1].trim() : "";
    let fieldType = parsedText[2] ? parsedText[2].trim() : "";
    let genericType = parsedText[3] ? parseGenericTypes(parsedText[3].trim()) : "";
    let fieldName = parsedText[4] ? parsedText[4].trim() : "";
    let classifier = parsedText[5] ? parsedText[5].trim() : "";
    displayText = visibility + fieldType + genericType + " " + fieldName;
    cssStyle = parseClassifier(classifier);
  } catch (err) {
    displayText = parsedText;
  }
  return {
    displayText,
    cssStyle
  };
};
const buildMethodDisplay = function(parsedText) {
  let cssStyle = "";
  let displayText = "";
  try {
    let visibility = parsedText[1] ? parsedText[1].trim() : "";
    let methodName = parsedText[2] ? parsedText[2].trim() : "";
    let parameters = parsedText[3] ? parseGenericTypes(parsedText[3].trim()) : "";
    let classifier = parsedText[4] ? parsedText[4].trim() : "";
    let returnType = parsedText[5] ? " : " + parseGenericTypes(parsedText[5]).trim() : "";
    displayText = visibility + methodName + "(" + parameters + ")" + returnType;
    cssStyle = parseClassifier(classifier);
  } catch (err) {
    displayText = parsedText;
  }
  return {
    displayText,
    cssStyle
  };
};
const buildLegacyDisplay = function(text2) {
  let displayText = "";
  let cssStyle = "";
  let returnType = "";
  let methodStart = text2.indexOf("(");
  let methodEnd = text2.indexOf(")");
  if (methodStart > 1 && methodEnd > methodStart && methodEnd <= text2.length) {
    let visibility = "";
    let methodName = "";
    let firstChar = text2.substring(0, 1);
    if (firstChar.match(/\w/)) {
      methodName = text2.substring(0, methodStart).trim();
    } else {
      if (firstChar.match(/\+|-|~|#/)) {
        visibility = firstChar;
      }
      methodName = text2.substring(1, methodStart).trim();
    }
    const parameters = text2.substring(methodStart + 1, methodEnd);
    text2.substring(methodEnd + 1, 1);
    cssStyle = parseClassifier(text2.substring(methodEnd + 1, methodEnd + 2));
    displayText = visibility + methodName + "(" + parseGenericTypes(parameters.trim()) + ")";
    if (methodEnd < text2.length) {
      returnType = text2.substring(methodEnd + 2).trim();
      if (returnType !== "") {
        returnType = " : " + parseGenericTypes(returnType);
        displayText += returnType;
      }
    }
  } else {
    displayText = parseGenericTypes(text2);
  }
  return {
    displayText,
    cssStyle
  };
};
const addTspan = function(textEl, txt, isFirst, conf2) {
  let member = parseMember(txt);
  const tSpan = textEl.append("tspan").attr("x", conf2.padding).text(member.displayText);
  if (member.cssStyle !== "") {
    tSpan.attr("style", member.cssStyle);
  }
  if (!isFirst) {
    tSpan.attr("dy", conf2.textHeight);
  }
};
const parseClassifier = function(classifier) {
  switch (classifier) {
    case "*":
      return "font-style:italic;";
    case "$":
      return "text-decoration:underline;";
    default:
      return "";
  }
};
const svgDraw$2 = {
  drawClass,
  drawEdge: drawEdge$1,
  parseMember
};
let idCache = {};
const padding = 20;
const getGraphId = function(label) {
  const foundEntry = Object.entries(idCache).find((entry) => entry[1].label === label);
  if (foundEntry) {
    return foundEntry[0];
  }
};
const insertMarkers$3 = function(elem) {
  elem.append("defs").append("marker").attr("id", "extensionStart").attr("class", "extension").attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 1,7 L18,13 V 1 Z");
  elem.append("defs").append("marker").attr("id", "extensionEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 1,1 V 13 L18,7 Z");
  elem.append("defs").append("marker").attr("id", "compositionStart").attr("class", "extension").attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
  elem.append("defs").append("marker").attr("id", "compositionEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
  elem.append("defs").append("marker").attr("id", "aggregationStart").attr("class", "extension").attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
  elem.append("defs").append("marker").attr("id", "aggregationEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
  elem.append("defs").append("marker").attr("id", "dependencyStart").attr("class", "extension").attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 5,7 L9,13 L1,7 L9,1 Z");
  elem.append("defs").append("marker").attr("id", "dependencyEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
};
const draw$d = function(text2, id2, _version, diagObj) {
  const conf2 = getConfig$1().class;
  idCache = {};
  log$1.info("Rendering diagram " + text2);
  const securityLevel = getConfig$1().securityLevel;
  let sandboxElement;
  if (securityLevel === "sandbox") {
    sandboxElement = select$1("#i" + id2);
  }
  const root2 = securityLevel === "sandbox" ? select$1(sandboxElement.nodes()[0].contentDocument.body) : select$1("body");
  const diagram = root2.select(`[id='${id2}']`);
  insertMarkers$3(diagram);
  const g2 = new graphlib$2.Graph({
    multigraph: true
  });
  g2.setGraph({
    isMultiGraph: true
  });
  g2.setDefaultEdgeLabel(function() {
    return {};
  });
  const classes2 = diagObj.db.getClasses();
  const keys2 = Object.keys(classes2);
  for (let i = 0; i < keys2.length; i++) {
    const classDef = classes2[keys2[i]];
    const node2 = svgDraw$2.drawClass(diagram, classDef, conf2, diagObj);
    idCache[node2.id] = node2;
    g2.setNode(node2.id, node2);
    log$1.info("Org height: " + node2.height);
  }
  const relations2 = diagObj.db.getRelations();
  relations2.forEach(function(relation) {
    log$1.info(
      "tjoho" + getGraphId(relation.id1) + getGraphId(relation.id2) + JSON.stringify(relation)
    );
    g2.setEdge(
      getGraphId(relation.id1),
      getGraphId(relation.id2),
      {
        relation
      },
      relation.title || "DEFAULT"
    );
  });
  dagre$1.layout(g2);
  g2.nodes().forEach(function(v) {
    if (typeof v !== "undefined" && typeof g2.node(v) !== "undefined") {
      log$1.debug("Node " + v + ": " + JSON.stringify(g2.node(v)));
      root2.select("#" + diagObj.db.lookUpDomId(v)).attr(
        "transform",
        "translate(" + (g2.node(v).x - g2.node(v).width / 2) + "," + (g2.node(v).y - g2.node(v).height / 2) + " )"
      );
    }
  });
  g2.edges().forEach(function(e) {
    if (typeof e !== "undefined" && typeof g2.edge(e) !== "undefined") {
      log$1.debug("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(g2.edge(e)));
      svgDraw$2.drawEdge(diagram, g2.edge(e), g2.edge(e).relation, conf2, diagObj);
    }
  });
  const svgBounds = diagram.node().getBBox();
  const width2 = svgBounds.width + padding * 2;
  const height2 = svgBounds.height + padding * 2;
  configureSvgSize(diagram, height2, width2, conf2.useMaxWidth);
  const vBox = `${svgBounds.x - padding} ${svgBounds.y - padding} ${width2} ${height2}`;
  log$1.debug(`viewBox ${vBox}`);
  diagram.attr("viewBox", vBox);
  addSVGAccessibilityFields(diagObj.db, diagram, id2);
};
const classRenderer = {
  draw: draw$d
};
const insertMarkers$2 = (elem, markerArray, type2, id2) => {
  markerArray.forEach((markerName) => {
    markers$1[markerName](elem, type2, id2);
  });
};
const extension = (elem, type2, id2) => {
  log$1.trace("Making markers for ", id2);
  elem.append("defs").append("marker").attr("id", type2 + "-extensionStart").attr("class", "marker extension " + type2).attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 1,7 L18,13 V 1 Z");
  elem.append("defs").append("marker").attr("id", type2 + "-extensionEnd").attr("class", "marker extension " + type2).attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 1,1 V 13 L18,7 Z");
};
const composition = (elem, type2) => {
  elem.append("defs").append("marker").attr("id", type2 + "-compositionStart").attr("class", "marker composition " + type2).attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
  elem.append("defs").append("marker").attr("id", type2 + "-compositionEnd").attr("class", "marker composition " + type2).attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
};
const aggregation = (elem, type2) => {
  elem.append("defs").append("marker").attr("id", type2 + "-aggregationStart").attr("class", "marker aggregation " + type2).attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
  elem.append("defs").append("marker").attr("id", type2 + "-aggregationEnd").attr("class", "marker aggregation " + type2).attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
};
const dependency = (elem, type2) => {
  elem.append("defs").append("marker").attr("id", type2 + "-dependencyStart").attr("class", "marker dependency " + type2).attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 5,7 L9,13 L1,7 L9,1 Z");
  elem.append("defs").append("marker").attr("id", type2 + "-dependencyEnd").attr("class", "marker dependency " + type2).attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
};
const lollipop = (elem, type2) => {
  elem.append("defs").append("marker").attr("id", type2 + "-lollipopStart").attr("class", "marker lollipop " + type2).attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "white").attr("cx", 6).attr("cy", 7).attr("r", 6);
};
const point = (elem, type2) => {
  elem.append("marker").attr("id", type2 + "-pointEnd").attr("class", "marker " + type2).attr("viewBox", "0 0 10 10").attr("refX", 10).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
  elem.append("marker").attr("id", type2 + "-pointStart").attr("class", "marker " + type2).attr("viewBox", "0 0 10 10").attr("refX", 0).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 5 L 10 10 L 10 0 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
};
const circle$1 = (elem, type2) => {
  elem.append("marker").attr("id", type2 + "-circleEnd").attr("class", "marker " + type2).attr("viewBox", "0 0 10 10").attr("refX", 11).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
  elem.append("marker").attr("id", type2 + "-circleStart").attr("class", "marker " + type2).attr("viewBox", "0 0 10 10").attr("refX", -1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
};
const cross = (elem, type2) => {
  elem.append("marker").attr("id", type2 + "-crossEnd").attr("class", "marker cross " + type2).attr("viewBox", "0 0 11 11").attr("refX", 12).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0");
  elem.append("marker").attr("id", type2 + "-crossStart").attr("class", "marker cross " + type2).attr("viewBox", "0 0 11 11").attr("refX", -1).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0");
};
const barb = (elem, type2) => {
  elem.append("defs").append("marker").attr("id", type2 + "-barbEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 14).attr("markerUnits", "strokeWidth").attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
};
const markers$1 = {
  extension,
  composition,
  aggregation,
  dependency,
  lollipop,
  point,
  circle: circle$1,
  cross,
  barb
};
function applyStyle$1(dom, styleFn) {
  if (styleFn) {
    dom.attr("style", styleFn);
  }
}
function addHtmlLabel$1(node2) {
  const fo = select$1(document.createElementNS("http://www.w3.org/2000/svg", "foreignObject"));
  const div = fo.append("xhtml:div");
  const label = node2.label;
  const labelClass = node2.isNode ? "nodeLabel" : "edgeLabel";
  div.html(
    '<span class="' + labelClass + '" ' + (node2.labelStyle ? 'style="' + node2.labelStyle + '"' : "") + ">" + label + "</span>"
  );
  applyStyle$1(div, node2.labelStyle);
  div.style("display", "inline-block");
  div.style("white-space", "nowrap");
  div.attr("xmlns", "http://www.w3.org/1999/xhtml");
  return fo.node();
}
const createLabel = (_vertexText, style2, isTitle, isNode) => {
  let vertexText = _vertexText || "";
  if (typeof vertexText === "object")
    vertexText = vertexText[0];
  if (evaluate(getConfig$1().flowchart.htmlLabels)) {
    vertexText = vertexText.replace(/\\n|\n/g, "<br />");
    log$1.info("vertexText" + vertexText);
    const node2 = {
      isNode,
      label: decodeEntities(vertexText).replace(
        /fa[lrsb]?:fa-[\w-]+/g,
        (s2) => `<i class='${s2.replace(":", " ")}'></i>`
      ),
      labelStyle: style2.replace("fill:", "color:")
    };
    let vertexNode = addHtmlLabel$1(node2);
    return vertexNode;
  } else {
    const svgLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
    svgLabel.setAttribute("style", style2.replace("color:", "fill:"));
    let rows = [];
    if (typeof vertexText === "string") {
      rows = vertexText.split(/\\n|\n|<br\s*\/?>/gi);
    } else if (Array.isArray(vertexText)) {
      rows = vertexText;
    } else {
      rows = [];
    }
    for (let j2 = 0; j2 < rows.length; j2++) {
      const tspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
      tspan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
      tspan.setAttribute("dy", "1em");
      tspan.setAttribute("x", "0");
      if (isTitle) {
        tspan.setAttribute("class", "title-row");
      } else {
        tspan.setAttribute("class", "row");
      }
      tspan.textContent = rows[j2].trim();
      svgLabel.appendChild(tspan);
    }
    return svgLabel;
  }
};
const labelHelper = (parent, node2, _classes, isNode) => {
  let classes2;
  if (!_classes) {
    classes2 = "node default";
  } else {
    classes2 = _classes;
  }
  const shapeSvg = parent.insert("g").attr("class", classes2).attr("id", node2.domId || node2.id);
  const label = shapeSvg.insert("g").attr("class", "label").attr("style", node2.labelStyle);
  let labelText;
  if (typeof node2.labelText === "undefined") {
    labelText = "";
  } else {
    labelText = typeof node2.labelText === "string" ? node2.labelText : node2.labelText[0];
  }
  const text2 = label.node().appendChild(
    createLabel(
      sanitizeText$5(decodeEntities(labelText), getConfig$1()),
      node2.labelStyle,
      false,
      isNode
    )
  );
  let bbox = text2.getBBox();
  if (evaluate(getConfig$1().flowchart.htmlLabels)) {
    const div = text2.children[0];
    const dv = select$1(text2);
    bbox = div.getBoundingClientRect();
    dv.attr("width", bbox.width);
    dv.attr("height", bbox.height);
  }
  const halfPadding = node2.padding / 2;
  label.attr("transform", "translate(" + -bbox.width / 2 + ", " + -bbox.height / 2 + ")");
  return { shapeSvg, bbox, halfPadding, label };
};
const updateNodeBounds = (node2, element) => {
  const bbox = element.node().getBBox();
  node2.width = bbox.width;
  node2.height = bbox.height;
};
function insertPolygonShape$1(parent, w2, h2, points) {
  return parent.insert("polygon", ":first-child").attr(
    "points",
    points.map(function(d) {
      return d.x + "," + d.y;
    }).join(" ")
  ).attr("class", "label-container").attr("transform", "translate(" + -w2 / 2 + "," + h2 / 2 + ")");
}
let clusterDb = {};
let decendants = {};
let parents = {};
const clear$b = () => {
  decendants = {};
  parents = {};
  clusterDb = {};
};
const isDecendant = (id2, ancenstorId) => {
  log$1.trace(
    "In isDecendant",
    ancenstorId,
    " ",
    id2,
    " = ",
    decendants[ancenstorId].indexOf(id2) >= 0
  );
  if (decendants[ancenstorId].indexOf(id2) >= 0)
    return true;
  return false;
};
const edgeInCluster = (edge, clusterId) => {
  log$1.info("Decendants of ", clusterId, " is ", decendants[clusterId]);
  log$1.info("Edge is ", edge);
  if (edge.v === clusterId)
    return false;
  if (edge.w === clusterId)
    return false;
  if (!decendants[clusterId]) {
    log$1.debug("Tilt, ", clusterId, ",not in decendants");
    return false;
  }
  if (decendants[clusterId].indexOf(edge.v) >= 0)
    return true;
  if (isDecendant(edge.v, clusterId))
    return true;
  if (isDecendant(edge.w, clusterId))
    return true;
  if (decendants[clusterId].indexOf(edge.w) >= 0)
    return true;
  return false;
};
const copy = (clusterId, graph2, newGraph, rootId) => {
  log$1.warn(
    "Copying children of ",
    clusterId,
    "root",
    rootId,
    "data",
    graph2.node(clusterId),
    rootId
  );
  const nodes = graph2.children(clusterId) || [];
  if (clusterId !== rootId) {
    nodes.push(clusterId);
  }
  log$1.warn("Copying (nodes) clusterId", clusterId, "nodes", nodes);
  nodes.forEach((node2) => {
    if (graph2.children(node2).length > 0) {
      copy(node2, graph2, newGraph, rootId);
    } else {
      const data2 = graph2.node(node2);
      log$1.info("cp ", node2, " to ", rootId, " with parent ", clusterId);
      newGraph.setNode(node2, data2);
      if (rootId !== graph2.parent(node2)) {
        log$1.warn("Setting parent", node2, graph2.parent(node2));
        newGraph.setParent(node2, graph2.parent(node2));
      }
      if (clusterId !== rootId && node2 !== clusterId) {
        log$1.debug("Setting parent", node2, clusterId);
        newGraph.setParent(node2, clusterId);
      } else {
        log$1.info("In copy ", clusterId, "root", rootId, "data", graph2.node(clusterId), rootId);
        log$1.debug(
          "Not Setting parent for node=",
          node2,
          "cluster!==rootId",
          clusterId !== rootId,
          "node!==clusterId",
          node2 !== clusterId
        );
      }
      const edges2 = graph2.edges(node2);
      log$1.debug("Copying Edges", edges2);
      edges2.forEach((edge) => {
        log$1.info("Edge", edge);
        const data22 = graph2.edge(edge.v, edge.w, edge.name);
        log$1.info("Edge data", data22, rootId);
        try {
          if (edgeInCluster(edge, rootId)) {
            log$1.info("Copying as ", edge.v, edge.w, data22, edge.name);
            newGraph.setEdge(edge.v, edge.w, data22, edge.name);
            log$1.info("newGraph edges ", newGraph.edges(), newGraph.edge(newGraph.edges()[0]));
          } else {
            log$1.info(
              "Skipping copy of edge ",
              edge.v,
              "-->",
              edge.w,
              " rootId: ",
              rootId,
              " clusterId:",
              clusterId
            );
          }
        } catch (e) {
          log$1.error(e);
        }
      });
    }
    log$1.debug("Removing node", node2);
    graph2.removeNode(node2);
  });
};
const extractDecendants = (id2, graph2) => {
  const children2 = graph2.children(id2);
  let res = [].concat(children2);
  for (let i = 0; i < children2.length; i++) {
    parents[children2[i]] = id2;
    res = res.concat(extractDecendants(children2[i], graph2));
  }
  return res;
};
const findNonClusterChild = (id2, graph2) => {
  log$1.trace("Searching", id2);
  const children2 = graph2.children(id2);
  log$1.trace("Searching children of id ", id2, children2);
  if (children2.length < 1) {
    log$1.trace("This is a valid node", id2);
    return id2;
  }
  for (let i = 0; i < children2.length; i++) {
    const _id = findNonClusterChild(children2[i], graph2);
    if (_id) {
      log$1.trace("Found replacement for", id2, " => ", _id);
      return _id;
    }
  }
};
const getAnchorId = (id2) => {
  if (!clusterDb[id2]) {
    return id2;
  }
  if (!clusterDb[id2].externalConnections) {
    return id2;
  }
  if (clusterDb[id2]) {
    return clusterDb[id2].id;
  }
  return id2;
};
const adjustClustersAndEdges = (graph2, depth) => {
  if (!graph2 || depth > 10) {
    log$1.debug("Opting out, no graph ");
    return;
  } else {
    log$1.debug("Opting in, graph ");
  }
  graph2.nodes().forEach(function(id2) {
    const children2 = graph2.children(id2);
    if (children2.length > 0) {
      log$1.warn(
        "Cluster identified",
        id2,
        " Replacement id in edges: ",
        findNonClusterChild(id2, graph2)
      );
      decendants[id2] = extractDecendants(id2, graph2);
      clusterDb[id2] = { id: findNonClusterChild(id2, graph2), clusterData: graph2.node(id2) };
    }
  });
  graph2.nodes().forEach(function(id2) {
    const children2 = graph2.children(id2);
    const edges2 = graph2.edges();
    if (children2.length > 0) {
      log$1.debug("Cluster identified", id2, decendants);
      edges2.forEach((edge) => {
        if (edge.v !== id2 && edge.w !== id2) {
          const d1 = isDecendant(edge.v, id2);
          const d2 = isDecendant(edge.w, id2);
          if (d1 ^ d2) {
            log$1.warn("Edge: ", edge, " leaves cluster ", id2);
            log$1.warn("Decendants of XXX ", id2, ": ", decendants[id2]);
            clusterDb[id2].externalConnections = true;
          }
        }
      });
    } else {
      log$1.debug("Not a cluster ", id2, decendants);
    }
  });
  graph2.edges().forEach(function(e) {
    const edge = graph2.edge(e);
    log$1.warn("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(e));
    log$1.warn("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(graph2.edge(e)));
    let v = e.v;
    let w2 = e.w;
    log$1.warn(
      "Fix XXX",
      clusterDb,
      "ids:",
      e.v,
      e.w,
      "Translateing: ",
      clusterDb[e.v],
      " --- ",
      clusterDb[e.w]
    );
    if (clusterDb[e.v] && clusterDb[e.w] && clusterDb[e.v] === clusterDb[e.w]) {
      log$1.warn("Fixing and trixing link to self - removing XXX", e.v, e.w, e.name);
      log$1.warn("Fixing and trixing - removing XXX", e.v, e.w, e.name);
      v = getAnchorId(e.v);
      w2 = getAnchorId(e.w);
      graph2.removeEdge(e.v, e.w, e.name);
      const specialId = e.w + "---" + e.v;
      graph2.setNode(specialId, {
        domId: specialId,
        id: specialId,
        labelStyle: "",
        labelText: edge.label,
        padding: 0,
        shape: "labelRect",
        style: ""
      });
      const edge1 = JSON.parse(JSON.stringify(edge));
      const edge2 = JSON.parse(JSON.stringify(edge));
      edge1.label = "";
      edge1.arrowTypeEnd = "none";
      edge2.label = "";
      edge1.fromCluster = e.v;
      edge2.toCluster = e.v;
      graph2.setEdge(v, specialId, edge1, e.name + "-cyclic-special");
      graph2.setEdge(specialId, w2, edge2, e.name + "-cyclic-special");
    } else if (clusterDb[e.v] || clusterDb[e.w]) {
      log$1.warn("Fixing and trixing - removing XXX", e.v, e.w, e.name);
      v = getAnchorId(e.v);
      w2 = getAnchorId(e.w);
      graph2.removeEdge(e.v, e.w, e.name);
      if (v !== e.v)
        edge.fromCluster = e.v;
      if (w2 !== e.w)
        edge.toCluster = e.w;
      log$1.warn("Fix Replacing with XXX", v, w2, e.name);
      graph2.setEdge(v, w2, edge, e.name);
    }
  });
  log$1.warn("Adjusted Graph", graphlib$2.json.write(graph2));
  extractor(graph2, 0);
  log$1.trace(clusterDb);
};
const extractor = (graph2, depth) => {
  log$1.warn("extractor - ", depth, graphlib$2.json.write(graph2), graph2.children("D"));
  if (depth > 10) {
    log$1.error("Bailing out");
    return;
  }
  let nodes = graph2.nodes();
  let hasChildren = false;
  for (let i = 0; i < nodes.length; i++) {
    const node2 = nodes[i];
    const children2 = graph2.children(node2);
    hasChildren = hasChildren || children2.length > 0;
  }
  if (!hasChildren) {
    log$1.debug("Done, no node has children", graph2.nodes());
    return;
  }
  log$1.debug("Nodes = ", nodes, depth);
  for (let i = 0; i < nodes.length; i++) {
    const node2 = nodes[i];
    log$1.debug(
      "Extracting node",
      node2,
      clusterDb,
      clusterDb[node2] && !clusterDb[node2].externalConnections,
      !graph2.parent(node2),
      graph2.node(node2),
      graph2.children("D"),
      " Depth ",
      depth
    );
    if (!clusterDb[node2]) {
      log$1.debug("Not a cluster", node2, depth);
    } else if (!clusterDb[node2].externalConnections && graph2.children(node2) && graph2.children(node2).length > 0) {
      log$1.warn(
        "Cluster without external connections, without a parent and with children",
        node2,
        depth
      );
      const graphSettings = graph2.graph();
      let dir = graphSettings.rankdir === "TB" ? "LR" : "TB";
      if (clusterDb[node2]) {
        if (clusterDb[node2].clusterData && clusterDb[node2].clusterData.dir) {
          dir = clusterDb[node2].clusterData.dir;
          log$1.warn("Fixing dir", clusterDb[node2].clusterData.dir, dir);
        }
      }
      const clusterGraph = new graphlib$2.Graph({
        multigraph: true,
        compound: true
      }).setGraph({
        rankdir: dir,
        nodesep: 50,
        ranksep: 50,
        marginx: 8,
        marginy: 8
      }).setDefaultEdgeLabel(function() {
        return {};
      });
      log$1.warn("Old graph before copy", graphlib$2.json.write(graph2));
      copy(node2, graph2, clusterGraph, node2);
      graph2.setNode(node2, {
        clusterNode: true,
        id: node2,
        clusterData: clusterDb[node2].clusterData,
        labelText: clusterDb[node2].labelText,
        graph: clusterGraph
      });
      log$1.warn("New graph after copy node: (", node2, ")", graphlib$2.json.write(clusterGraph));
      log$1.debug("Old graph after copy", graphlib$2.json.write(graph2));
    } else {
      log$1.warn(
        "Cluster ** ",
        node2,
        " **not meeting the criteria !externalConnections:",
        !clusterDb[node2].externalConnections,
        " no parent: ",
        !graph2.parent(node2),
        " children ",
        graph2.children(node2) && graph2.children(node2).length > 0,
        graph2.children("D"),
        depth
      );
      log$1.debug(clusterDb);
    }
  }
  nodes = graph2.nodes();
  log$1.warn("New list of nodes", nodes);
  for (let i = 0; i < nodes.length; i++) {
    const node2 = nodes[i];
    const data2 = graph2.node(node2);
    log$1.warn(" Now next level", node2, data2);
    if (data2.clusterNode) {
      extractor(data2.graph, depth + 1);
    }
  }
};
const sorter = (graph2, nodes) => {
  if (nodes.length === 0)
    return [];
  let result = Object.assign(nodes);
  nodes.forEach((node2) => {
    const children2 = graph2.children(node2);
    const sorted = sorter(graph2, children2);
    result = result.concat(sorted);
  });
  return result;
};
const sortNodesByHierarchy = (graph2) => sorter(graph2, graph2.children());
function intersectNode(node2, point2) {
  return node2.intersect(point2);
}
function intersectEllipse(node2, rx, ry, point2) {
  var cx = node2.x;
  var cy = node2.y;
  var px = cx - point2.x;
  var py = cy - point2.y;
  var det = Math.sqrt(rx * rx * py * py + ry * ry * px * px);
  var dx = Math.abs(rx * ry * px / det);
  if (point2.x < cx) {
    dx = -dx;
  }
  var dy = Math.abs(rx * ry * py / det);
  if (point2.y < cy) {
    dy = -dy;
  }
  return { x: cx + dx, y: cy + dy };
}
function intersectCircle(node2, rx, point2) {
  return intersectEllipse(node2, rx, rx, point2);
}
function intersectLine(p1, p2, q1, q2) {
  var a1, a2, b12, b22, c1, c2;
  var r1, r2, r3, r4;
  var denom, offset, num;
  var x2, y2;
  a1 = p2.y - p1.y;
  b12 = p1.x - p2.x;
  c1 = p2.x * p1.y - p1.x * p2.y;
  r3 = a1 * q1.x + b12 * q1.y + c1;
  r4 = a1 * q2.x + b12 * q2.y + c1;
  if (r3 !== 0 && r4 !== 0 && sameSign(r3, r4)) {
    return;
  }
  a2 = q2.y - q1.y;
  b22 = q1.x - q2.x;
  c2 = q2.x * q1.y - q1.x * q2.y;
  r1 = a2 * p1.x + b22 * p1.y + c2;
  r2 = a2 * p2.x + b22 * p2.y + c2;
  if (r1 !== 0 && r2 !== 0 && sameSign(r1, r2)) {
    return;
  }
  denom = a1 * b22 - a2 * b12;
  if (denom === 0) {
    return;
  }
  offset = Math.abs(denom / 2);
  num = b12 * c2 - b22 * c1;
  x2 = num < 0 ? (num - offset) / denom : (num + offset) / denom;
  num = a2 * c1 - a1 * c2;
  y2 = num < 0 ? (num - offset) / denom : (num + offset) / denom;
  return { x: x2, y: y2 };
}
function sameSign(r1, r2) {
  return r1 * r2 > 0;
}
function intersectPolygon(node2, polyPoints, point2) {
  var x12 = node2.x;
  var y12 = node2.y;
  var intersections = [];
  var minX = Number.POSITIVE_INFINITY;
  var minY = Number.POSITIVE_INFINITY;
  if (typeof polyPoints.forEach === "function") {
    polyPoints.forEach(function(entry) {
      minX = Math.min(minX, entry.x);
      minY = Math.min(minY, entry.y);
    });
  } else {
    minX = Math.min(minX, polyPoints.x);
    minY = Math.min(minY, polyPoints.y);
  }
  var left2 = x12 - node2.width / 2 - minX;
  var top2 = y12 - node2.height / 2 - minY;
  for (var i = 0; i < polyPoints.length; i++) {
    var p1 = polyPoints[i];
    var p2 = polyPoints[i < polyPoints.length - 1 ? i + 1 : 0];
    var intersect2 = intersectLine(
      node2,
      point2,
      { x: left2 + p1.x, y: top2 + p1.y },
      { x: left2 + p2.x, y: top2 + p2.y }
    );
    if (intersect2) {
      intersections.push(intersect2);
    }
  }
  if (!intersections.length) {
    return node2;
  }
  if (intersections.length > 1) {
    intersections.sort(function(p, q) {
      var pdx = p.x - point2.x;
      var pdy = p.y - point2.y;
      var distp = Math.sqrt(pdx * pdx + pdy * pdy);
      var qdx = q.x - point2.x;
      var qdy = q.y - point2.y;
      var distq = Math.sqrt(qdx * qdx + qdy * qdy);
      return distp < distq ? -1 : distp === distq ? 0 : 1;
    });
  }
  return intersections[0];
}
const intersectRect = (node2, point2) => {
  var x2 = node2.x;
  var y2 = node2.y;
  var dx = point2.x - x2;
  var dy = point2.y - y2;
  var w2 = node2.width / 2;
  var h2 = node2.height / 2;
  var sx, sy;
  if (Math.abs(dy) * w2 > Math.abs(dx) * h2) {
    if (dy < 0) {
      h2 = -h2;
    }
    sx = dy === 0 ? 0 : h2 * dx / dy;
    sy = h2;
  } else {
    if (dx < 0) {
      w2 = -w2;
    }
    sx = w2;
    sy = dx === 0 ? 0 : w2 * dy / dx;
  }
  return { x: x2 + sx, y: y2 + sy };
};
const intersect = {
  node: intersectNode,
  circle: intersectCircle,
  ellipse: intersectEllipse,
  polygon: intersectPolygon,
  rect: intersectRect
};
const note = (parent, node2) => {
  const { shapeSvg, bbox, halfPadding } = labelHelper(parent, node2, "node " + node2.classes, true);
  log$1.info("Classes = ", node2.classes);
  const rect2 = shapeSvg.insert("rect", ":first-child");
  rect2.attr("rx", node2.rx).attr("ry", node2.ry).attr("x", -bbox.width / 2 - halfPadding).attr("y", -bbox.height / 2 - halfPadding).attr("width", bbox.width + node2.padding).attr("height", bbox.height + node2.padding);
  updateNodeBounds(node2, rect2);
  node2.intersect = function(point2) {
    return intersect.rect(node2, point2);
  };
  return shapeSvg;
};
const question$1 = (parent, node2) => {
  const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
  const w2 = bbox.width + node2.padding;
  const h2 = bbox.height + node2.padding;
  const s2 = w2 + h2;
  const points = [
    { x: s2 / 2, y: 0 },
    { x: s2, y: -s2 / 2 },
    { x: s2 / 2, y: -s2 },
    { x: 0, y: -s2 / 2 }
  ];
  log$1.info("Question main (Circle)");
  const questionElem = insertPolygonShape$1(shapeSvg, s2, s2, points);
  questionElem.attr("style", node2.style);
  updateNodeBounds(node2, questionElem);
  node2.intersect = function(point2) {
    log$1.warn("Intersect called");
    return intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
};
const choice = (parent, node2) => {
  const shapeSvg = parent.insert("g").attr("class", "node default").attr("id", node2.domId || node2.id);
  const s2 = 28;
  const points = [
    { x: 0, y: s2 / 2 },
    { x: s2 / 2, y: 0 },
    { x: 0, y: -s2 / 2 },
    { x: -s2 / 2, y: 0 }
  ];
  const choice2 = shapeSvg.insert("polygon", ":first-child").attr(
    "points",
    points.map(function(d) {
      return d.x + "," + d.y;
    }).join(" ")
  );
  choice2.attr("class", "state-start").attr("r", 7).attr("width", 28).attr("height", 28);
  node2.width = 28;
  node2.height = 28;
  node2.intersect = function(point2) {
    return intersect.circle(node2, 14, point2);
  };
  return shapeSvg;
};
const hexagon$1 = (parent, node2) => {
  const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
  const f2 = 4;
  const h2 = bbox.height + node2.padding;
  const m = h2 / f2;
  const w2 = bbox.width + 2 * m + node2.padding;
  const points = [
    { x: m, y: 0 },
    { x: w2 - m, y: 0 },
    { x: w2, y: -h2 / 2 },
    { x: w2 - m, y: -h2 },
    { x: m, y: -h2 },
    { x: 0, y: -h2 / 2 }
  ];
  const hex2 = insertPolygonShape$1(shapeSvg, w2, h2, points);
  hex2.attr("style", node2.style);
  updateNodeBounds(node2, hex2);
  node2.intersect = function(point2) {
    return intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
};
const rect_left_inv_arrow$1 = (parent, node2) => {
  const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
  const w2 = bbox.width + node2.padding;
  const h2 = bbox.height + node2.padding;
  const points = [
    { x: -h2 / 2, y: 0 },
    { x: w2, y: 0 },
    { x: w2, y: -h2 },
    { x: -h2 / 2, y: -h2 },
    { x: 0, y: -h2 / 2 }
  ];
  const el = insertPolygonShape$1(shapeSvg, w2, h2, points);
  el.attr("style", node2.style);
  node2.width = w2 + h2;
  node2.height = h2;
  node2.intersect = function(point2) {
    return intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
};
const lean_right$1 = (parent, node2) => {
  const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
  const w2 = bbox.width + node2.padding;
  const h2 = bbox.height + node2.padding;
  const points = [
    { x: -2 * h2 / 6, y: 0 },
    { x: w2 - h2 / 6, y: 0 },
    { x: w2 + 2 * h2 / 6, y: -h2 },
    { x: h2 / 6, y: -h2 }
  ];
  const el = insertPolygonShape$1(shapeSvg, w2, h2, points);
  el.attr("style", node2.style);
  updateNodeBounds(node2, el);
  node2.intersect = function(point2) {
    return intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
};
const lean_left$1 = (parent, node2) => {
  const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
  const w2 = bbox.width + node2.padding;
  const h2 = bbox.height + node2.padding;
  const points = [
    { x: 2 * h2 / 6, y: 0 },
    { x: w2 + h2 / 6, y: 0 },
    { x: w2 - 2 * h2 / 6, y: -h2 },
    { x: -h2 / 6, y: -h2 }
  ];
  const el = insertPolygonShape$1(shapeSvg, w2, h2, points);
  el.attr("style", node2.style);
  updateNodeBounds(node2, el);
  node2.intersect = function(point2) {
    return intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
};
const trapezoid$1 = (parent, node2) => {
  const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
  const w2 = bbox.width + node2.padding;
  const h2 = bbox.height + node2.padding;
  const points = [
    { x: -2 * h2 / 6, y: 0 },
    { x: w2 + 2 * h2 / 6, y: 0 },
    { x: w2 - h2 / 6, y: -h2 },
    { x: h2 / 6, y: -h2 }
  ];
  const el = insertPolygonShape$1(shapeSvg, w2, h2, points);
  el.attr("style", node2.style);
  updateNodeBounds(node2, el);
  node2.intersect = function(point2) {
    return intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
};
const inv_trapezoid$1 = (parent, node2) => {
  const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
  const w2 = bbox.width + node2.padding;
  const h2 = bbox.height + node2.padding;
  const points = [
    { x: h2 / 6, y: 0 },
    { x: w2 - h2 / 6, y: 0 },
    { x: w2 + 2 * h2 / 6, y: -h2 },
    { x: -2 * h2 / 6, y: -h2 }
  ];
  const el = insertPolygonShape$1(shapeSvg, w2, h2, points);
  el.attr("style", node2.style);
  updateNodeBounds(node2, el);
  node2.intersect = function(point2) {
    return intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
};
const rect_right_inv_arrow$1 = (parent, node2) => {
  const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
  const w2 = bbox.width + node2.padding;
  const h2 = bbox.height + node2.padding;
  const points = [
    { x: 0, y: 0 },
    { x: w2 + h2 / 2, y: 0 },
    { x: w2, y: -h2 / 2 },
    { x: w2 + h2 / 2, y: -h2 },
    { x: 0, y: -h2 }
  ];
  const el = insertPolygonShape$1(shapeSvg, w2, h2, points);
  el.attr("style", node2.style);
  updateNodeBounds(node2, el);
  node2.intersect = function(point2) {
    return intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
};
const cylinder$1 = (parent, node2) => {
  const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
  const w2 = bbox.width + node2.padding;
  const rx = w2 / 2;
  const ry = rx / (2.5 + w2 / 50);
  const h2 = bbox.height + ry + node2.padding;
  const shape = "M 0," + ry + " a " + rx + "," + ry + " 0,0,0 " + w2 + " 0 a " + rx + "," + ry + " 0,0,0 " + -w2 + " 0 l 0," + h2 + " a " + rx + "," + ry + " 0,0,0 " + w2 + " 0 l 0," + -h2;
  const el = shapeSvg.attr("label-offset-y", ry).insert("path", ":first-child").attr("style", node2.style).attr("d", shape).attr("transform", "translate(" + -w2 / 2 + "," + -(h2 / 2 + ry) + ")");
  updateNodeBounds(node2, el);
  node2.intersect = function(point2) {
    const pos = intersect.rect(node2, point2);
    const x2 = pos.x - node2.x;
    if (rx != 0 && (Math.abs(x2) < node2.width / 2 || Math.abs(x2) == node2.width / 2 && Math.abs(pos.y - node2.y) > node2.height / 2 - ry)) {
      let y2 = ry * ry * (1 - x2 * x2 / (rx * rx));
      if (y2 != 0)
        y2 = Math.sqrt(y2);
      y2 = ry - y2;
      if (point2.y - node2.y > 0)
        y2 = -y2;
      pos.y += y2;
    }
    return pos;
  };
  return shapeSvg;
};
const rect$1 = (parent, node2) => {
  const { shapeSvg, bbox, halfPadding } = labelHelper(parent, node2, "node " + node2.classes, true);
  log$1.trace("Classes = ", node2.classes);
  const rect2 = shapeSvg.insert("rect", ":first-child");
  const totalWidth = bbox.width + node2.padding;
  const totalHeight = bbox.height + node2.padding;
  rect2.attr("class", "basic label-container").attr("style", node2.style).attr("rx", node2.rx).attr("ry", node2.ry).attr("x", -bbox.width / 2 - halfPadding).attr("y", -bbox.height / 2 - halfPadding).attr("width", totalWidth).attr("height", totalHeight);
  if (node2.props) {
    const propKeys = new Set(Object.keys(node2.props));
    if (node2.props.borders) {
      applyNodePropertyBorders(rect2, node2.props.borders, totalWidth, totalHeight);
      propKeys.delete("borders");
    }
    propKeys.forEach((propKey) => {
      log$1.warn(`Unknown node property ${propKey}`);
    });
  }
  updateNodeBounds(node2, rect2);
  node2.intersect = function(point2) {
    return intersect.rect(node2, point2);
  };
  return shapeSvg;
};
const labelRect = (parent, node2) => {
  const { shapeSvg } = labelHelper(parent, node2, "label", true);
  log$1.trace("Classes = ", node2.classes);
  const rect2 = shapeSvg.insert("rect", ":first-child");
  const totalWidth = 0;
  const totalHeight = 0;
  rect2.attr("width", totalWidth).attr("height", totalHeight);
  shapeSvg.attr("class", "label edgeLabel");
  if (node2.props) {
    const propKeys = new Set(Object.keys(node2.props));
    if (node2.props.borders) {
      applyNodePropertyBorders(rect2, node2.props.borders, totalWidth, totalHeight);
      propKeys.delete("borders");
    }
    propKeys.forEach((propKey) => {
      log$1.warn(`Unknown node property ${propKey}`);
    });
  }
  updateNodeBounds(node2, rect2);
  node2.intersect = function(point2) {
    return intersect.rect(node2, point2);
  };
  return shapeSvg;
};
function applyNodePropertyBorders(rect2, borders, totalWidth, totalHeight) {
  const strokeDashArray = [];
  const addBorder = (length2) => {
    strokeDashArray.push(length2);
    strokeDashArray.push(0);
  };
  const skipBorder = (length2) => {
    strokeDashArray.push(0);
    strokeDashArray.push(length2);
  };
  if (borders.includes("t")) {
    log$1.debug("add top border");
    addBorder(totalWidth);
  } else {
    skipBorder(totalWidth);
  }
  if (borders.includes("r")) {
    log$1.debug("add right border");
    addBorder(totalHeight);
  } else {
    skipBorder(totalHeight);
  }
  if (borders.includes("b")) {
    log$1.debug("add bottom border");
    addBorder(totalWidth);
  } else {
    skipBorder(totalWidth);
  }
  if (borders.includes("l")) {
    log$1.debug("add left border");
    addBorder(totalHeight);
  } else {
    skipBorder(totalHeight);
  }
  rect2.attr("stroke-dasharray", strokeDashArray.join(" "));
}
const rectWithTitle = (parent, node2) => {
  let classes2;
  if (!node2.classes) {
    classes2 = "node default";
  } else {
    classes2 = "node " + node2.classes;
  }
  const shapeSvg = parent.insert("g").attr("class", classes2).attr("id", node2.domId || node2.id);
  const rect2 = shapeSvg.insert("rect", ":first-child");
  const innerLine = shapeSvg.insert("line");
  const label = shapeSvg.insert("g").attr("class", "label");
  const text2 = node2.labelText.flat ? node2.labelText.flat() : node2.labelText;
  let title2 = "";
  if (typeof text2 === "object") {
    title2 = text2[0];
  } else {
    title2 = text2;
  }
  log$1.info("Label text abc79", title2, text2, typeof text2 === "object");
  const text3 = label.node().appendChild(createLabel(title2, node2.labelStyle, true, true));
  let bbox = { width: 0, height: 0 };
  if (evaluate(getConfig$1().flowchart.htmlLabels)) {
    const div = text3.children[0];
    const dv = select$1(text3);
    bbox = div.getBoundingClientRect();
    dv.attr("width", bbox.width);
    dv.attr("height", bbox.height);
  }
  log$1.info("Text 2", text2);
  const textRows = text2.slice(1, text2.length);
  let titleBox = text3.getBBox();
  const descr = label.node().appendChild(
    createLabel(textRows.join ? textRows.join("<br/>") : textRows, node2.labelStyle, true, true)
  );
  if (evaluate(getConfig$1().flowchart.htmlLabels)) {
    const div = descr.children[0];
    const dv = select$1(descr);
    bbox = div.getBoundingClientRect();
    dv.attr("width", bbox.width);
    dv.attr("height", bbox.height);
  }
  const halfPadding = node2.padding / 2;
  select$1(descr).attr(
    "transform",
    "translate( " + (bbox.width > titleBox.width ? 0 : (titleBox.width - bbox.width) / 2) + ", " + (titleBox.height + halfPadding + 5) + ")"
  );
  select$1(text3).attr(
    "transform",
    "translate( " + (bbox.width < titleBox.width ? 0 : -(titleBox.width - bbox.width) / 2) + ", " + 0 + ")"
  );
  bbox = label.node().getBBox();
  label.attr(
    "transform",
    "translate(" + -bbox.width / 2 + ", " + (-bbox.height / 2 - halfPadding + 3) + ")"
  );
  rect2.attr("class", "outer title-state").attr("x", -bbox.width / 2 - halfPadding).attr("y", -bbox.height / 2 - halfPadding).attr("width", bbox.width + node2.padding).attr("height", bbox.height + node2.padding);
  innerLine.attr("class", "divider").attr("x1", -bbox.width / 2 - halfPadding).attr("x2", bbox.width / 2 + halfPadding).attr("y1", -bbox.height / 2 - halfPadding + titleBox.height + halfPadding).attr("y2", -bbox.height / 2 - halfPadding + titleBox.height + halfPadding);
  updateNodeBounds(node2, rect2);
  node2.intersect = function(point2) {
    return intersect.rect(node2, point2);
  };
  return shapeSvg;
};
const stadium$1 = (parent, node2) => {
  const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
  const h2 = bbox.height + node2.padding;
  const w2 = bbox.width + h2 / 4 + node2.padding;
  const rect2 = shapeSvg.insert("rect", ":first-child").attr("style", node2.style).attr("rx", h2 / 2).attr("ry", h2 / 2).attr("x", -w2 / 2).attr("y", -h2 / 2).attr("width", w2).attr("height", h2);
  updateNodeBounds(node2, rect2);
  node2.intersect = function(point2) {
    return intersect.rect(node2, point2);
  };
  return shapeSvg;
};
const circle = (parent, node2) => {
  const { shapeSvg, bbox, halfPadding } = labelHelper(parent, node2, void 0, true);
  const circle2 = shapeSvg.insert("circle", ":first-child");
  circle2.attr("style", node2.style).attr("rx", node2.rx).attr("ry", node2.ry).attr("r", bbox.width / 2 + halfPadding).attr("width", bbox.width + node2.padding).attr("height", bbox.height + node2.padding);
  log$1.info("Circle main");
  updateNodeBounds(node2, circle2);
  node2.intersect = function(point2) {
    log$1.info("Circle intersect", node2, bbox.width / 2 + halfPadding, point2);
    return intersect.circle(node2, bbox.width / 2 + halfPadding, point2);
  };
  return shapeSvg;
};
const doublecircle = (parent, node2) => {
  const { shapeSvg, bbox, halfPadding } = labelHelper(parent, node2, void 0, true);
  const gap = 5;
  const circleGroup = shapeSvg.insert("g", ":first-child");
  const outerCircle = circleGroup.insert("circle");
  const innerCircle = circleGroup.insert("circle");
  outerCircle.attr("style", node2.style).attr("rx", node2.rx).attr("ry", node2.ry).attr("r", bbox.width / 2 + halfPadding + gap).attr("width", bbox.width + node2.padding + gap * 2).attr("height", bbox.height + node2.padding + gap * 2);
  innerCircle.attr("style", node2.style).attr("rx", node2.rx).attr("ry", node2.ry).attr("r", bbox.width / 2 + halfPadding).attr("width", bbox.width + node2.padding).attr("height", bbox.height + node2.padding);
  log$1.info("DoubleCircle main");
  updateNodeBounds(node2, outerCircle);
  node2.intersect = function(point2) {
    log$1.info("DoubleCircle intersect", node2, bbox.width / 2 + halfPadding + gap, point2);
    return intersect.circle(node2, bbox.width / 2 + halfPadding + gap, point2);
  };
  return shapeSvg;
};
const subroutine$1 = (parent, node2) => {
  const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
  const w2 = bbox.width + node2.padding;
  const h2 = bbox.height + node2.padding;
  const points = [
    { x: 0, y: 0 },
    { x: w2, y: 0 },
    { x: w2, y: -h2 },
    { x: 0, y: -h2 },
    { x: 0, y: 0 },
    { x: -8, y: 0 },
    { x: w2 + 8, y: 0 },
    { x: w2 + 8, y: -h2 },
    { x: -8, y: -h2 },
    { x: -8, y: 0 }
  ];
  const el = insertPolygonShape$1(shapeSvg, w2, h2, points);
  el.attr("style", node2.style);
  updateNodeBounds(node2, el);
  node2.intersect = function(point2) {
    return intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
};
const start = (parent, node2) => {
  const shapeSvg = parent.insert("g").attr("class", "node default").attr("id", node2.domId || node2.id);
  const circle2 = shapeSvg.insert("circle", ":first-child");
  circle2.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14);
  updateNodeBounds(node2, circle2);
  node2.intersect = function(point2) {
    return intersect.circle(node2, 7, point2);
  };
  return shapeSvg;
};
const forkJoin = (parent, node2, dir) => {
  const shapeSvg = parent.insert("g").attr("class", "node default").attr("id", node2.domId || node2.id);
  let width2 = 70;
  let height2 = 10;
  if (dir === "LR") {
    width2 = 10;
    height2 = 70;
  }
  const shape = shapeSvg.append("rect").attr("x", -1 * width2 / 2).attr("y", -1 * height2 / 2).attr("width", width2).attr("height", height2).attr("class", "fork-join");
  updateNodeBounds(node2, shape);
  node2.height = node2.height + node2.padding / 2;
  node2.width = node2.width + node2.padding / 2;
  node2.intersect = function(point2) {
    return intersect.rect(node2, point2);
  };
  return shapeSvg;
};
const end = (parent, node2) => {
  const shapeSvg = parent.insert("g").attr("class", "node default").attr("id", node2.domId || node2.id);
  const innerCircle = shapeSvg.insert("circle", ":first-child");
  const circle2 = shapeSvg.insert("circle", ":first-child");
  circle2.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14);
  innerCircle.attr("class", "state-end").attr("r", 5).attr("width", 10).attr("height", 10);
  updateNodeBounds(node2, circle2);
  node2.intersect = function(point2) {
    return intersect.circle(node2, 7, point2);
  };
  return shapeSvg;
};
const class_box = (parent, node2) => {
  const halfPadding = node2.padding / 2;
  const rowPadding = 4;
  const lineHeight = 8;
  let classes2;
  if (!node2.classes) {
    classes2 = "node default";
  } else {
    classes2 = "node " + node2.classes;
  }
  const shapeSvg = parent.insert("g").attr("class", classes2).attr("id", node2.domId || node2.id);
  const rect2 = shapeSvg.insert("rect", ":first-child");
  const topLine = shapeSvg.insert("line");
  const bottomLine = shapeSvg.insert("line");
  let maxWidth = 0;
  let maxHeight = rowPadding;
  const labelContainer = shapeSvg.insert("g").attr("class", "label");
  let verticalPos = 0;
  const hasInterface = node2.classData.annotations && node2.classData.annotations[0];
  const interfaceLabelText = node2.classData.annotations[0] ? "\xAB" + node2.classData.annotations[0] + "\xBB" : "";
  const interfaceLabel = labelContainer.node().appendChild(createLabel(interfaceLabelText, node2.labelStyle, true, true));
  let interfaceBBox = interfaceLabel.getBBox();
  if (evaluate(getConfig$1().flowchart.htmlLabels)) {
    const div = interfaceLabel.children[0];
    const dv = select$1(interfaceLabel);
    interfaceBBox = div.getBoundingClientRect();
    dv.attr("width", interfaceBBox.width);
    dv.attr("height", interfaceBBox.height);
  }
  if (node2.classData.annotations[0]) {
    maxHeight += interfaceBBox.height + rowPadding;
    maxWidth += interfaceBBox.width;
  }
  let classTitleString = node2.classData.id;
  if (node2.classData.type !== void 0 && node2.classData.type !== "") {
    if (getConfig$1().flowchart.htmlLabels) {
      classTitleString += "&lt;" + node2.classData.type + "&gt;";
    } else {
      classTitleString += "<" + node2.classData.type + ">";
    }
  }
  const classTitleLabel = labelContainer.node().appendChild(createLabel(classTitleString, node2.labelStyle, true, true));
  select$1(classTitleLabel).attr("class", "classTitle");
  let classTitleBBox = classTitleLabel.getBBox();
  if (evaluate(getConfig$1().flowchart.htmlLabels)) {
    const div = classTitleLabel.children[0];
    const dv = select$1(classTitleLabel);
    classTitleBBox = div.getBoundingClientRect();
    dv.attr("width", classTitleBBox.width);
    dv.attr("height", classTitleBBox.height);
  }
  maxHeight += classTitleBBox.height + rowPadding;
  if (classTitleBBox.width > maxWidth) {
    maxWidth = classTitleBBox.width;
  }
  const classAttributes = [];
  node2.classData.members.forEach((str) => {
    const parsedInfo = parseMember(str);
    let parsedText = parsedInfo.displayText;
    if (getConfig$1().flowchart.htmlLabels) {
      parsedText = parsedText.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    const lbl = labelContainer.node().appendChild(
      createLabel(
        parsedText,
        parsedInfo.cssStyle ? parsedInfo.cssStyle : node2.labelStyle,
        true,
        true
      )
    );
    let bbox = lbl.getBBox();
    if (evaluate(getConfig$1().flowchart.htmlLabels)) {
      const div = lbl.children[0];
      const dv = select$1(lbl);
      bbox = div.getBoundingClientRect();
      dv.attr("width", bbox.width);
      dv.attr("height", bbox.height);
    }
    if (bbox.width > maxWidth) {
      maxWidth = bbox.width;
    }
    maxHeight += bbox.height + rowPadding;
    classAttributes.push(lbl);
  });
  maxHeight += lineHeight;
  const classMethods = [];
  node2.classData.methods.forEach((str) => {
    const parsedInfo = parseMember(str);
    let displayText = parsedInfo.displayText;
    if (getConfig$1().flowchart.htmlLabels) {
      displayText = displayText.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    const lbl = labelContainer.node().appendChild(
      createLabel(
        displayText,
        parsedInfo.cssStyle ? parsedInfo.cssStyle : node2.labelStyle,
        true,
        true
      )
    );
    let bbox = lbl.getBBox();
    if (evaluate(getConfig$1().flowchart.htmlLabels)) {
      const div = lbl.children[0];
      const dv = select$1(lbl);
      bbox = div.getBoundingClientRect();
      dv.attr("width", bbox.width);
      dv.attr("height", bbox.height);
    }
    if (bbox.width > maxWidth) {
      maxWidth = bbox.width;
    }
    maxHeight += bbox.height + rowPadding;
    classMethods.push(lbl);
  });
  maxHeight += lineHeight;
  if (hasInterface) {
    let diffX2 = (maxWidth - interfaceBBox.width) / 2;
    select$1(interfaceLabel).attr(
      "transform",
      "translate( " + (-1 * maxWidth / 2 + diffX2) + ", " + -1 * maxHeight / 2 + ")"
    );
    verticalPos = interfaceBBox.height + rowPadding;
  }
  let diffX = (maxWidth - classTitleBBox.width) / 2;
  select$1(classTitleLabel).attr(
    "transform",
    "translate( " + (-1 * maxWidth / 2 + diffX) + ", " + (-1 * maxHeight / 2 + verticalPos) + ")"
  );
  verticalPos += classTitleBBox.height + rowPadding;
  topLine.attr("class", "divider").attr("x1", -maxWidth / 2 - halfPadding).attr("x2", maxWidth / 2 + halfPadding).attr("y1", -maxHeight / 2 - halfPadding + lineHeight + verticalPos).attr("y2", -maxHeight / 2 - halfPadding + lineHeight + verticalPos);
  verticalPos += lineHeight;
  classAttributes.forEach((lbl) => {
    select$1(lbl).attr(
      "transform",
      "translate( " + -maxWidth / 2 + ", " + (-1 * maxHeight / 2 + verticalPos + lineHeight / 2) + ")"
    );
    verticalPos += classTitleBBox.height + rowPadding;
  });
  verticalPos += lineHeight;
  bottomLine.attr("class", "divider").attr("x1", -maxWidth / 2 - halfPadding).attr("x2", maxWidth / 2 + halfPadding).attr("y1", -maxHeight / 2 - halfPadding + lineHeight + verticalPos).attr("y2", -maxHeight / 2 - halfPadding + lineHeight + verticalPos);
  verticalPos += lineHeight;
  classMethods.forEach((lbl) => {
    select$1(lbl).attr(
      "transform",
      "translate( " + -maxWidth / 2 + ", " + (-1 * maxHeight / 2 + verticalPos) + ")"
    );
    verticalPos += classTitleBBox.height + rowPadding;
  });
  rect2.attr("class", "outer title-state").attr("x", -maxWidth / 2 - halfPadding).attr("y", -(maxHeight / 2) - halfPadding).attr("width", maxWidth + node2.padding).attr("height", maxHeight + node2.padding);
  updateNodeBounds(node2, rect2);
  node2.intersect = function(point2) {
    return intersect.rect(node2, point2);
  };
  return shapeSvg;
};
const shapes$1 = {
  question: question$1,
  rect: rect$1,
  labelRect,
  rectWithTitle,
  choice,
  circle,
  doublecircle,
  stadium: stadium$1,
  hexagon: hexagon$1,
  rect_left_inv_arrow: rect_left_inv_arrow$1,
  lean_right: lean_right$1,
  lean_left: lean_left$1,
  trapezoid: trapezoid$1,
  inv_trapezoid: inv_trapezoid$1,
  rect_right_inv_arrow: rect_right_inv_arrow$1,
  cylinder: cylinder$1,
  start,
  end,
  note,
  subroutine: subroutine$1,
  fork: forkJoin,
  join: forkJoin,
  class_box
};
let nodeElems = {};
const insertNode = (elem, node2, dir) => {
  let newEl;
  let el;
  if (node2.link) {
    let target;
    if (getConfig$1().securityLevel === "sandbox") {
      target = "_top";
    } else if (node2.linkTarget) {
      target = node2.linkTarget || "_blank";
    }
    newEl = elem.insert("svg:a").attr("xlink:href", node2.link).attr("target", target);
    el = shapes$1[node2.shape](newEl, node2, dir);
  } else {
    el = shapes$1[node2.shape](elem, node2, dir);
    newEl = el;
  }
  if (node2.tooltip) {
    el.attr("title", node2.tooltip);
  }
  if (node2.class) {
    el.attr("class", "node default " + node2.class);
  }
  nodeElems[node2.id] = newEl;
  if (node2.haveCallback) {
    nodeElems[node2.id].attr("class", nodeElems[node2.id].attr("class") + " clickable");
  }
};
const setNodeElem = (elem, node2) => {
  nodeElems[node2.id] = elem;
};
const clear$a = () => {
  nodeElems = {};
};
const positionNode = (node2) => {
  const el = nodeElems[node2.id];
  log$1.trace(
    "Transforming node",
    node2.diff,
    node2,
    "translate(" + (node2.x - node2.width / 2 - 5) + ", " + node2.width / 2 + ")"
  );
  const padding2 = 8;
  const diff = node2.diff || 0;
  if (node2.clusterNode) {
    el.attr(
      "transform",
      "translate(" + (node2.x + diff - node2.width / 2) + ", " + (node2.y - node2.height / 2 - padding2) + ")"
    );
  } else {
    el.attr("transform", "translate(" + node2.x + ", " + node2.y + ")");
  }
  return diff;
};
const rect = (parent, node2) => {
  log$1.trace("Creating subgraph rect for ", node2.id, node2);
  const shapeSvg = parent.insert("g").attr("class", "cluster" + (node2.class ? " " + node2.class : "")).attr("id", node2.id);
  const rect2 = shapeSvg.insert("rect", ":first-child");
  const label = shapeSvg.insert("g").attr("class", "cluster-label");
  const text2 = label.node().appendChild(createLabel(node2.labelText, node2.labelStyle, void 0, true));
  let bbox = text2.getBBox();
  if (evaluate(getConfig$1().flowchart.htmlLabels)) {
    const div = text2.children[0];
    const dv = select$1(text2);
    bbox = div.getBoundingClientRect();
    dv.attr("width", bbox.width);
    dv.attr("height", bbox.height);
  }
  const padding2 = 0 * node2.padding;
  const halfPadding = padding2 / 2;
  const width2 = node2.width <= bbox.width + padding2 ? bbox.width + padding2 : node2.width;
  if (node2.width <= bbox.width + padding2) {
    node2.diff = (bbox.width - node2.width) / 2 - node2.padding / 2;
  } else {
    node2.diff = -node2.padding / 2;
  }
  log$1.trace("Data ", node2, JSON.stringify(node2));
  rect2.attr("style", node2.style).attr("rx", node2.rx).attr("ry", node2.ry).attr("x", node2.x - width2 / 2).attr("y", node2.y - node2.height / 2 - halfPadding).attr("width", width2).attr("height", node2.height + padding2);
  label.attr(
    "transform",
    "translate(" + (node2.x - bbox.width / 2) + ", " + (node2.y - node2.height / 2 + node2.padding / 3) + ")"
  );
  const rectBox = rect2.node().getBBox();
  node2.width = rectBox.width;
  node2.height = rectBox.height;
  node2.intersect = function(point2) {
    return intersectRect(node2, point2);
  };
  return shapeSvg;
};
const noteGroup = (parent, node2) => {
  const shapeSvg = parent.insert("g").attr("class", "note-cluster").attr("id", node2.id);
  const rect2 = shapeSvg.insert("rect", ":first-child");
  const padding2 = 0 * node2.padding;
  const halfPadding = padding2 / 2;
  rect2.attr("rx", node2.rx).attr("ry", node2.ry).attr("x", node2.x - node2.width / 2 - halfPadding).attr("y", node2.y - node2.height / 2 - halfPadding).attr("width", node2.width + padding2).attr("height", node2.height + padding2).attr("fill", "none");
  const rectBox = rect2.node().getBBox();
  node2.width = rectBox.width;
  node2.height = rectBox.height;
  node2.intersect = function(point2) {
    return intersectRect(node2, point2);
  };
  return shapeSvg;
};
const roundedWithTitle = (parent, node2) => {
  const shapeSvg = parent.insert("g").attr("class", node2.classes).attr("id", node2.id);
  const rect2 = shapeSvg.insert("rect", ":first-child");
  const label = shapeSvg.insert("g").attr("class", "cluster-label");
  const innerRect = shapeSvg.append("rect");
  const text2 = label.node().appendChild(createLabel(node2.labelText, node2.labelStyle, void 0, true));
  let bbox = text2.getBBox();
  if (evaluate(getConfig$1().flowchart.htmlLabels)) {
    const div = text2.children[0];
    const dv = select$1(text2);
    bbox = div.getBoundingClientRect();
    dv.attr("width", bbox.width);
    dv.attr("height", bbox.height);
  }
  bbox = text2.getBBox();
  const padding2 = 0 * node2.padding;
  const halfPadding = padding2 / 2;
  const width2 = node2.width <= bbox.width + node2.padding ? bbox.width + node2.padding : node2.width;
  if (node2.width <= bbox.width + node2.padding) {
    node2.diff = (bbox.width + node2.padding * 0 - node2.width) / 2;
  } else {
    node2.diff = -node2.padding / 2;
  }
  rect2.attr("class", "outer").attr("x", node2.x - width2 / 2 - halfPadding).attr("y", node2.y - node2.height / 2 - halfPadding).attr("width", width2 + padding2).attr("height", node2.height + padding2);
  innerRect.attr("class", "inner").attr("x", node2.x - width2 / 2 - halfPadding).attr("y", node2.y - node2.height / 2 - halfPadding + bbox.height - 1).attr("width", width2 + padding2).attr("height", node2.height + padding2 - bbox.height - 3);
  label.attr(
    "transform",
    "translate(" + (node2.x - bbox.width / 2) + ", " + (node2.y - node2.height / 2 - node2.padding / 3 + (evaluate(getConfig$1().flowchart.htmlLabels) ? 5 : 3)) + ")"
  );
  const rectBox = rect2.node().getBBox();
  node2.height = rectBox.height;
  node2.intersect = function(point2) {
    return intersectRect(node2, point2);
  };
  return shapeSvg;
};
const divider = (parent, node2) => {
  const shapeSvg = parent.insert("g").attr("class", node2.classes).attr("id", node2.id);
  const rect2 = shapeSvg.insert("rect", ":first-child");
  const padding2 = 0 * node2.padding;
  const halfPadding = padding2 / 2;
  rect2.attr("class", "divider").attr("x", node2.x - node2.width / 2 - halfPadding).attr("y", node2.y - node2.height / 2).attr("width", node2.width + padding2).attr("height", node2.height + padding2);
  const rectBox = rect2.node().getBBox();
  node2.width = rectBox.width;
  node2.height = rectBox.height;
  node2.diff = -node2.padding / 2;
  node2.intersect = function(point2) {
    return intersectRect(node2, point2);
  };
  return shapeSvg;
};
const shapes = { rect, roundedWithTitle, noteGroup, divider };
let clusterElems = {};
const insertCluster = (elem, node2) => {
  log$1.trace("Inserting cluster");
  const shape = node2.shape || "rect";
  clusterElems[node2.id] = shapes[shape](elem, node2);
};
const clear$9 = () => {
  clusterElems = {};
};
let edgeLabels = {};
let terminalLabels = {};
const clear$8 = () => {
  edgeLabels = {};
  terminalLabels = {};
};
const insertEdgeLabel = (elem, edge) => {
  const labelElement = createLabel(edge.label, edge.labelStyle);
  const edgeLabel = elem.insert("g").attr("class", "edgeLabel");
  const label = edgeLabel.insert("g").attr("class", "label");
  label.node().appendChild(labelElement);
  let bbox = labelElement.getBBox();
  if (evaluate(getConfig$1().flowchart.htmlLabels)) {
    const div = labelElement.children[0];
    const dv = select$1(labelElement);
    bbox = div.getBoundingClientRect();
    dv.attr("width", bbox.width);
    dv.attr("height", bbox.height);
  }
  label.attr("transform", "translate(" + -bbox.width / 2 + ", " + -bbox.height / 2 + ")");
  edgeLabels[edge.id] = edgeLabel;
  edge.width = bbox.width;
  edge.height = bbox.height;
  let fo;
  if (edge.startLabelLeft) {
    const startLabelElement = createLabel(edge.startLabelLeft, edge.labelStyle);
    const startEdgeLabelLeft = elem.insert("g").attr("class", "edgeTerminals");
    const inner = startEdgeLabelLeft.insert("g").attr("class", "inner");
    fo = inner.node().appendChild(startLabelElement);
    const slBox = startLabelElement.getBBox();
    inner.attr("transform", "translate(" + -slBox.width / 2 + ", " + -slBox.height / 2 + ")");
    if (!terminalLabels[edge.id]) {
      terminalLabels[edge.id] = {};
    }
    terminalLabels[edge.id].startLeft = startEdgeLabelLeft;
    setTerminalWidth(fo, edge.startLabelLeft);
  }
  if (edge.startLabelRight) {
    const startLabelElement = createLabel(edge.startLabelRight, edge.labelStyle);
    const startEdgeLabelRight = elem.insert("g").attr("class", "edgeTerminals");
    const inner = startEdgeLabelRight.insert("g").attr("class", "inner");
    fo = startEdgeLabelRight.node().appendChild(startLabelElement);
    inner.node().appendChild(startLabelElement);
    const slBox = startLabelElement.getBBox();
    inner.attr("transform", "translate(" + -slBox.width / 2 + ", " + -slBox.height / 2 + ")");
    if (!terminalLabels[edge.id]) {
      terminalLabels[edge.id] = {};
    }
    terminalLabels[edge.id].startRight = startEdgeLabelRight;
    setTerminalWidth(fo, edge.startLabelRight);
  }
  if (edge.endLabelLeft) {
    const endLabelElement = createLabel(edge.endLabelLeft, edge.labelStyle);
    const endEdgeLabelLeft = elem.insert("g").attr("class", "edgeTerminals");
    const inner = endEdgeLabelLeft.insert("g").attr("class", "inner");
    fo = inner.node().appendChild(endLabelElement);
    const slBox = endLabelElement.getBBox();
    inner.attr("transform", "translate(" + -slBox.width / 2 + ", " + -slBox.height / 2 + ")");
    endEdgeLabelLeft.node().appendChild(endLabelElement);
    if (!terminalLabels[edge.id]) {
      terminalLabels[edge.id] = {};
    }
    terminalLabels[edge.id].endLeft = endEdgeLabelLeft;
    setTerminalWidth(fo, edge.endLabelLeft);
  }
  if (edge.endLabelRight) {
    const endLabelElement = createLabel(edge.endLabelRight, edge.labelStyle);
    const endEdgeLabelRight = elem.insert("g").attr("class", "edgeTerminals");
    const inner = endEdgeLabelRight.insert("g").attr("class", "inner");
    fo = inner.node().appendChild(endLabelElement);
    const slBox = endLabelElement.getBBox();
    inner.attr("transform", "translate(" + -slBox.width / 2 + ", " + -slBox.height / 2 + ")");
    endEdgeLabelRight.node().appendChild(endLabelElement);
    if (!terminalLabels[edge.id]) {
      terminalLabels[edge.id] = {};
    }
    terminalLabels[edge.id].endRight = endEdgeLabelRight;
    setTerminalWidth(fo, edge.endLabelRight);
  }
};
function setTerminalWidth(fo, value) {
  if (getConfig$1().flowchart.htmlLabels && fo) {
    fo.style.width = value.length * 9 + "px";
    fo.style.height = "12px";
  }
}
const positionEdgeLabel = (edge, paths) => {
  log$1.info("Moving label abc78 ", edge.id, edge.label, edgeLabels[edge.id]);
  let path2 = paths.updatedPath ? paths.updatedPath : paths.originalPath;
  if (edge.label) {
    const el = edgeLabels[edge.id];
    let x2 = edge.x;
    let y2 = edge.y;
    if (path2) {
      const pos = utils.calcLabelPosition(path2);
      log$1.info("Moving label from (", x2, ",", y2, ") to (", pos.x, ",", pos.y, ") abc78");
    }
    el.attr("transform", "translate(" + x2 + ", " + y2 + ")");
  }
  if (edge.startLabelLeft) {
    const el = terminalLabels[edge.id].startLeft;
    let x2 = edge.x;
    let y2 = edge.y;
    if (path2) {
      const pos = utils.calcTerminalLabelPosition(edge.arrowTypeStart ? 10 : 0, "start_left", path2);
      x2 = pos.x;
      y2 = pos.y;
    }
    el.attr("transform", "translate(" + x2 + ", " + y2 + ")");
  }
  if (edge.startLabelRight) {
    const el = terminalLabels[edge.id].startRight;
    let x2 = edge.x;
    let y2 = edge.y;
    if (path2) {
      const pos = utils.calcTerminalLabelPosition(
        edge.arrowTypeStart ? 10 : 0,
        "start_right",
        path2
      );
      x2 = pos.x;
      y2 = pos.y;
    }
    el.attr("transform", "translate(" + x2 + ", " + y2 + ")");
  }
  if (edge.endLabelLeft) {
    const el = terminalLabels[edge.id].endLeft;
    let x2 = edge.x;
    let y2 = edge.y;
    if (path2) {
      const pos = utils.calcTerminalLabelPosition(edge.arrowTypeEnd ? 10 : 0, "end_left", path2);
      x2 = pos.x;
      y2 = pos.y;
    }
    el.attr("transform", "translate(" + x2 + ", " + y2 + ")");
  }
  if (edge.endLabelRight) {
    const el = terminalLabels[edge.id].endRight;
    let x2 = edge.x;
    let y2 = edge.y;
    if (path2) {
      const pos = utils.calcTerminalLabelPosition(edge.arrowTypeEnd ? 10 : 0, "end_right", path2);
      x2 = pos.x;
      y2 = pos.y;
    }
    el.attr("transform", "translate(" + x2 + ", " + y2 + ")");
  }
};
const outsideNode = (node2, point2) => {
  const x2 = node2.x;
  const y2 = node2.y;
  const dx = Math.abs(point2.x - x2);
  const dy = Math.abs(point2.y - y2);
  const w2 = node2.width / 2;
  const h2 = node2.height / 2;
  if (dx >= w2 || dy >= h2) {
    return true;
  }
  return false;
};
const intersection = (node2, outsidePoint, insidePoint) => {
  log$1.warn(`intersection calc abc89:
  outsidePoint: ${JSON.stringify(outsidePoint)}
  insidePoint : ${JSON.stringify(insidePoint)}
  node        : x:${node2.x} y:${node2.y} w:${node2.width} h:${node2.height}`);
  const x2 = node2.x;
  const y2 = node2.y;
  const dx = Math.abs(x2 - insidePoint.x);
  const w2 = node2.width / 2;
  let r = insidePoint.x < outsidePoint.x ? w2 - dx : w2 + dx;
  const h2 = node2.height / 2;
  const Q = Math.abs(outsidePoint.y - insidePoint.y);
  const R = Math.abs(outsidePoint.x - insidePoint.x);
  if (Math.abs(y2 - outsidePoint.y) * w2 > Math.abs(x2 - outsidePoint.x) * h2) {
    let q = insidePoint.y < outsidePoint.y ? outsidePoint.y - h2 - y2 : y2 - h2 - outsidePoint.y;
    r = R * q / Q;
    const res = {
      x: insidePoint.x < outsidePoint.x ? insidePoint.x + r : insidePoint.x - R + r,
      y: insidePoint.y < outsidePoint.y ? insidePoint.y + Q - q : insidePoint.y - Q + q
    };
    if (r === 0) {
      res.x = outsidePoint.x;
      res.y = outsidePoint.y;
    }
    if (R === 0) {
      res.x = outsidePoint.x;
    }
    if (Q === 0) {
      res.y = outsidePoint.y;
    }
    log$1.warn(`abc89 topp/bott calc, Q ${Q}, q ${q}, R ${R}, r ${r}`, res);
    return res;
  } else {
    if (insidePoint.x < outsidePoint.x) {
      r = outsidePoint.x - w2 - x2;
    } else {
      r = x2 - w2 - outsidePoint.x;
    }
    let q = Q * r / R;
    let _x = insidePoint.x < outsidePoint.x ? insidePoint.x + R - r : insidePoint.x - R + r;
    let _y = insidePoint.y < outsidePoint.y ? insidePoint.y + q : insidePoint.y - q;
    log$1.warn(`sides calc abc89, Q ${Q}, q ${q}, R ${R}, r ${r}`, { _x, _y });
    if (r === 0) {
      _x = outsidePoint.x;
      _y = outsidePoint.y;
    }
    if (R === 0) {
      _x = outsidePoint.x;
    }
    if (Q === 0) {
      _y = outsidePoint.y;
    }
    return { x: _x, y: _y };
  }
};
const cutPathAtIntersect = (_points, boundryNode) => {
  log$1.warn("abc88 cutPathAtIntersect", _points, boundryNode);
  let points = [];
  let lastPointOutside = _points[0];
  let isInside = false;
  _points.forEach((point2) => {
    log$1.info("abc88 checking point", point2, boundryNode);
    if (!outsideNode(boundryNode, point2) && !isInside) {
      const inter = intersection(boundryNode, lastPointOutside, point2);
      log$1.warn("abc88 inside", point2, lastPointOutside, inter);
      log$1.warn("abc88 intersection", inter);
      let pointPresent = false;
      points.forEach((p) => {
        pointPresent = pointPresent || p.x === inter.x && p.y === inter.y;
      });
      if (!points.find((e) => e.x === inter.x && e.y === inter.y)) {
        points.push(inter);
      } else {
        log$1.warn("abc88 no intersect", inter, points);
      }
      isInside = true;
    } else {
      log$1.warn("abc88 outside", point2, lastPointOutside);
      lastPointOutside = point2;
      if (!isInside)
        points.push(point2);
    }
  });
  log$1.warn("abc88 returning points", points);
  return points;
};
const insertEdge = function(elem, e, edge, clusterDb2, diagramType, graph2) {
  let points = edge.points;
  let pointsHasChanged = false;
  const tail = graph2.node(e.v);
  var head2 = graph2.node(e.w);
  log$1.info("abc88 InsertEdge: ", edge);
  if (head2.intersect && tail.intersect) {
    points = points.slice(1, edge.points.length - 1);
    points.unshift(tail.intersect(points[0]));
    log$1.info(
      "Last point",
      points[points.length - 1],
      head2,
      head2.intersect(points[points.length - 1])
    );
    points.push(head2.intersect(points[points.length - 1]));
  }
  if (edge.toCluster) {
    log$1.info("to cluster abc88", clusterDb2[edge.toCluster]);
    points = cutPathAtIntersect(edge.points, clusterDb2[edge.toCluster].node);
    pointsHasChanged = true;
  }
  if (edge.fromCluster) {
    log$1.info("from cluster abc88", clusterDb2[edge.fromCluster]);
    points = cutPathAtIntersect(points.reverse(), clusterDb2[edge.fromCluster].node).reverse();
    pointsHasChanged = true;
  }
  const lineData = points.filter((p) => !Number.isNaN(p.y));
  let curve;
  if (diagramType === "graph" || diagramType === "flowchart") {
    curve = edge.curve || curveBasis;
  } else {
    curve = curveBasis;
  }
  const lineFunction = line$2().x(function(d) {
    return d.x;
  }).y(function(d) {
    return d.y;
  }).curve(curve);
  let strokeClasses;
  switch (edge.thickness) {
    case "normal":
      strokeClasses = "edge-thickness-normal";
      break;
    case "thick":
      strokeClasses = "edge-thickness-thick";
      break;
    case "invisible":
      strokeClasses = "edge-thickness-thick";
      break;
    default:
      strokeClasses = "";
  }
  switch (edge.pattern) {
    case "solid":
      strokeClasses += " edge-pattern-solid";
      break;
    case "dotted":
      strokeClasses += " edge-pattern-dotted";
      break;
    case "dashed":
      strokeClasses += " edge-pattern-dashed";
      break;
  }
  const svgPath = elem.append("path").attr("d", lineFunction(lineData)).attr("id", edge.id).attr("class", " " + strokeClasses + (edge.classes ? " " + edge.classes : "")).attr("style", edge.style);
  let url = "";
  if (getConfig$1().flowchart.arrowMarkerAbsolute || getConfig$1().state.arrowMarkerAbsolute) {
    url = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search;
    url = url.replace(/\(/g, "\\(");
    url = url.replace(/\)/g, "\\)");
  }
  log$1.info("arrowTypeStart", edge.arrowTypeStart);
  log$1.info("arrowTypeEnd", edge.arrowTypeEnd);
  switch (edge.arrowTypeStart) {
    case "arrow_cross":
      svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-crossStart)");
      break;
    case "arrow_point":
      svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-pointStart)");
      break;
    case "arrow_barb":
      svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-barbStart)");
      break;
    case "arrow_circle":
      svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-circleStart)");
      break;
    case "aggregation":
      svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-aggregationStart)");
      break;
    case "extension":
      svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-extensionStart)");
      break;
    case "composition":
      svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-compositionStart)");
      break;
    case "dependency":
      svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-dependencyStart)");
      break;
    case "lollipop":
      svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-lollipopStart)");
      break;
  }
  switch (edge.arrowTypeEnd) {
    case "arrow_cross":
      svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-crossEnd)");
      break;
    case "arrow_point":
      svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-pointEnd)");
      break;
    case "arrow_barb":
      svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-barbEnd)");
      break;
    case "arrow_circle":
      svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-circleEnd)");
      break;
    case "aggregation":
      svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-aggregationEnd)");
      break;
    case "extension":
      svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-extensionEnd)");
      break;
    case "composition":
      svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-compositionEnd)");
      break;
    case "dependency":
      svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-dependencyEnd)");
      break;
    case "lollipop":
      svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-lollipopEnd)");
      break;
  }
  let paths = {};
  if (pointsHasChanged) {
    paths.updatedPath = points;
  }
  paths.originalPath = edge.points;
  return paths;
};
const recursiveRender = (_elem, graph2, diagramtype, parentCluster) => {
  log$1.info("Graph in recursive render: XXX", graphlib$2.json.write(graph2), parentCluster);
  const dir = graph2.graph().rankdir;
  log$1.trace("Dir in recursive render - dir:", dir);
  const elem = _elem.insert("g").attr("class", "root");
  if (!graph2.nodes()) {
    log$1.info("No nodes found for", graph2);
  } else {
    log$1.info("Recursive render XXX", graph2.nodes());
  }
  if (graph2.edges().length > 0) {
    log$1.trace("Recursive edges", graph2.edge(graph2.edges()[0]));
  }
  const clusters = elem.insert("g").attr("class", "clusters");
  const edgePaths = elem.insert("g").attr("class", "edgePaths");
  const edgeLabels2 = elem.insert("g").attr("class", "edgeLabels");
  const nodes = elem.insert("g").attr("class", "nodes");
  graph2.nodes().forEach(function(v) {
    const node2 = graph2.node(v);
    if (typeof parentCluster !== "undefined") {
      const data2 = JSON.parse(JSON.stringify(parentCluster.clusterData));
      log$1.info("Setting data for cluster XXX (", v, ") ", data2, parentCluster);
      graph2.setNode(parentCluster.id, data2);
      if (!graph2.parent(v)) {
        log$1.trace("Setting parent", v, parentCluster.id);
        graph2.setParent(v, parentCluster.id, data2);
      }
    }
    log$1.info("(Insert) Node XXX" + v + ": " + JSON.stringify(graph2.node(v)));
    if (node2 && node2.clusterNode) {
      log$1.info("Cluster identified", v, node2.width, graph2.node(v));
      const o = recursiveRender(nodes, node2.graph, diagramtype, graph2.node(v));
      const newEl = o.elem;
      updateNodeBounds(node2, newEl);
      node2.diff = o.diff || 0;
      log$1.info("Node bounds (abc123)", v, node2, node2.width, node2.x, node2.y);
      setNodeElem(newEl, node2);
      log$1.warn("Recursive render complete ", newEl, node2);
    } else {
      if (graph2.children(v).length > 0) {
        log$1.info("Cluster - the non recursive path XXX", v, node2.id, node2, graph2);
        log$1.info(findNonClusterChild(node2.id, graph2));
        clusterDb[node2.id] = { id: findNonClusterChild(node2.id, graph2), node: node2 };
      } else {
        log$1.info("Node - the non recursive path", v, node2.id, node2);
        insertNode(nodes, graph2.node(v), dir);
      }
    }
  });
  graph2.edges().forEach(function(e) {
    const edge = graph2.edge(e.v, e.w, e.name);
    log$1.info("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(e));
    log$1.info("Edge " + e.v + " -> " + e.w + ": ", e, " ", JSON.stringify(graph2.edge(e)));
    log$1.info("Fix", clusterDb, "ids:", e.v, e.w, "Translateing: ", clusterDb[e.v], clusterDb[e.w]);
    insertEdgeLabel(edgeLabels2, edge);
  });
  graph2.edges().forEach(function(e) {
    log$1.info("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(e));
  });
  log$1.info("#############################################");
  log$1.info("###                Layout                 ###");
  log$1.info("#############################################");
  log$1.info(graph2);
  dagre$1.layout(graph2);
  log$1.info("Graph after layout:", graphlib$2.json.write(graph2));
  let diff = 0;
  sortNodesByHierarchy(graph2).forEach(function(v) {
    const node2 = graph2.node(v);
    log$1.info("Position " + v + ": " + JSON.stringify(graph2.node(v)));
    log$1.info(
      "Position " + v + ": (" + node2.x,
      "," + node2.y,
      ") width: ",
      node2.width,
      " height: ",
      node2.height
    );
    if (node2 && node2.clusterNode) {
      positionNode(node2);
    } else {
      if (graph2.children(v).length > 0) {
        insertCluster(clusters, node2);
        clusterDb[node2.id].node = node2;
      } else {
        positionNode(node2);
      }
    }
  });
  graph2.edges().forEach(function(e) {
    const edge = graph2.edge(e);
    log$1.info("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(edge), edge);
    const paths = insertEdge(edgePaths, e, edge, clusterDb, diagramtype, graph2);
    positionEdgeLabel(edge, paths);
  });
  graph2.nodes().forEach(function(v) {
    const n = graph2.node(v);
    log$1.info(v, n.type, n.diff);
    if (n.type === "group") {
      diff = n.diff;
    }
  });
  return { elem, diff };
};
const render$1 = (elem, graph2, markers2, diagramtype, id2) => {
  insertMarkers$2(elem, markers2, diagramtype, id2);
  clear$a();
  clear$8();
  clear$9();
  clear$b();
  log$1.warn("Graph at first:", graphlib$2.json.write(graph2));
  adjustClustersAndEdges(graph2);
  log$1.warn("Graph after:", graphlib$2.json.write(graph2));
  recursiveRender(elem, graph2, diagramtype);
};
const sanitizeText$1 = (txt) => common.sanitizeText(txt, getConfig$1());
const addClasses = function(classes2, g2, _id, diagObj) {
  const keys2 = Object.keys(classes2);
  log$1.info("keys:", keys2);
  log$1.info(classes2);
  keys2.forEach(function(id2) {
    const vertex = classes2[id2];
    let cssClassStr = "";
    if (vertex.cssClasses.length > 0) {
      cssClassStr = cssClassStr + " " + vertex.cssClasses.join(" ");
    }
    const styles = { labelStyle: "" };
    let vertexText = vertex.text !== void 0 ? vertex.text : vertex.id;
    let radious = 0;
    let _shape = "";
    switch (vertex.type) {
      case "class":
        _shape = "class_box";
        break;
      default:
        _shape = "class_box";
    }
    g2.setNode(vertex.id, {
      labelStyle: styles.labelStyle,
      shape: _shape,
      labelText: sanitizeText$1(vertexText),
      classData: vertex,
      rx: radious,
      ry: radious,
      class: cssClassStr,
      style: styles.style,
      id: vertex.id,
      domId: vertex.domId,
      tooltip: diagObj.db.getTooltip(vertex.id) || "",
      haveCallback: vertex.haveCallback,
      link: vertex.link,
      width: vertex.type === "group" ? 500 : void 0,
      type: vertex.type,
      padding: getConfig$1().flowchart.padding
    });
    log$1.info("setNode", {
      labelStyle: styles.labelStyle,
      shape: _shape,
      labelText: vertexText,
      rx: radious,
      ry: radious,
      class: cssClassStr,
      style: styles.style,
      id: vertex.id,
      width: vertex.type === "group" ? 500 : void 0,
      type: vertex.type,
      padding: getConfig$1().flowchart.padding
    });
  });
};
const addRelations = function(relations2, g2) {
  const conf2 = getConfig$1().flowchart;
  let cnt2 = 0;
  relations2.forEach(function(edge) {
    cnt2++;
    const edgeData = {};
    edgeData.classes = "relation";
    edgeData.pattern = edge.relation.lineType == 1 ? "dashed" : "solid";
    edgeData.id = "id" + cnt2;
    if (edge.type === "arrow_open") {
      edgeData.arrowhead = "none";
    } else {
      edgeData.arrowhead = "normal";
    }
    log$1.info(edgeData, edge);
    edgeData.startLabelRight = edge.relationTitle1 === "none" ? "" : edge.relationTitle1;
    edgeData.endLabelLeft = edge.relationTitle2 === "none" ? "" : edge.relationTitle2;
    edgeData.arrowTypeStart = getArrowMarker(edge.relation.type1);
    edgeData.arrowTypeEnd = getArrowMarker(edge.relation.type2);
    let style2 = "";
    let labelStyle = "";
    if (typeof edge.style !== "undefined") {
      const styles = getStylesFromArray(edge.style);
      style2 = styles.style;
      labelStyle = styles.labelStyle;
    } else {
      style2 = "fill:none";
    }
    edgeData.style = style2;
    edgeData.labelStyle = labelStyle;
    if (typeof edge.interpolate !== "undefined") {
      edgeData.curve = interpolateToCurve(edge.interpolate, curveLinear$1);
    } else if (typeof relations2.defaultInterpolate !== "undefined") {
      edgeData.curve = interpolateToCurve(relations2.defaultInterpolate, curveLinear$1);
    } else {
      edgeData.curve = interpolateToCurve(conf2.curve, curveLinear$1);
    }
    edge.text = edge.title;
    if (typeof edge.text === "undefined") {
      if (typeof edge.style !== "undefined") {
        edgeData.arrowheadStyle = "fill: #333";
      }
    } else {
      edgeData.arrowheadStyle = "fill: #333";
      edgeData.labelpos = "c";
      if (getConfig$1().flowchart.htmlLabels) {
        edgeData.labelType = "html";
        edgeData.label = '<span class="edgeLabel">' + edge.text + "</span>";
      } else {
        edgeData.labelType = "text";
        edgeData.label = edge.text.replace(common.lineBreakRegex, "\n");
        if (typeof edge.style === "undefined") {
          edgeData.style = edgeData.style || "stroke: #333; stroke-width: 1.5px;fill:none";
        }
        edgeData.labelStyle = edgeData.labelStyle.replace("color:", "fill:");
      }
    }
    g2.setEdge(edge.id1, edge.id2, edgeData, cnt2);
  });
};
const setConf$9 = function(cnf) {
  const keys2 = Object.keys(cnf);
  keys2.forEach(function(key) {
    cnf[key];
  });
};
const draw$c = function(text2, id2, _version, diagObj) {
  log$1.info("Drawing class - ", id2);
  const conf2 = getConfig$1().flowchart;
  const securityLevel = getConfig$1().securityLevel;
  log$1.info("config:", conf2);
  const nodeSpacing = conf2.nodeSpacing || 50;
  const rankSpacing = conf2.rankSpacing || 50;
  const g2 = new graphlib$2.Graph({
    multigraph: true,
    compound: true
  }).setGraph({
    rankdir: diagObj.db.getDirection(),
    nodesep: nodeSpacing,
    ranksep: rankSpacing,
    marginx: 8,
    marginy: 8
  }).setDefaultEdgeLabel(function() {
    return {};
  });
  const classes2 = diagObj.db.getClasses();
  const relations2 = diagObj.db.getRelations();
  log$1.info(relations2);
  addClasses(classes2, g2, id2, diagObj);
  addRelations(relations2, g2);
  let sandboxElement;
  if (securityLevel === "sandbox") {
    sandboxElement = select$1("#i" + id2);
  }
  const root2 = securityLevel === "sandbox" ? select$1(sandboxElement.nodes()[0].contentDocument.body) : select$1("body");
  const svg2 = root2.select(`[id="${id2}"]`);
  const element = root2.select("#" + id2 + " g");
  render$1(
    element,
    g2,
    ["aggregation", "extension", "composition", "dependency", "lollipop"],
    "classDiagram",
    id2
  );
  setupGraphViewbox$1(g2, svg2, conf2.diagramPadding, conf2.useMaxWidth);
  if (!conf2.htmlLabels) {
    const doc2 = securityLevel === "sandbox" ? sandboxElement.nodes()[0].contentDocument : document;
    const labels = doc2.querySelectorAll('[id="' + id2 + '"] .edgeLabel .label');
    for (let k2 = 0; k2 < labels.length; k2++) {
      const label = labels[k2];
      const dim = label.getBBox();
      const rect2 = doc2.createElementNS("http://www.w3.org/2000/svg", "rect");
      rect2.setAttribute("rx", 0);
      rect2.setAttribute("ry", 0);
      rect2.setAttribute("width", dim.width);
      rect2.setAttribute("height", dim.height);
      label.insertBefore(rect2, label.firstChild);
    }
  }
  addSVGAccessibilityFields(diagObj.db, svg2, id2);
};
function getArrowMarker(type2) {
  let marker;
  switch (type2) {
    case 0:
      marker = "aggregation";
      break;
    case 1:
      marker = "extension";
      break;
    case 2:
      marker = "composition";
      break;
    case 3:
      marker = "dependency";
      break;
    case 4:
      marker = "lollipop";
      break;
    default:
      marker = "none";
  }
  return marker;
}
const classRendererV2 = {
  setConf: setConf$9,
  draw: draw$c
};
var parser$8 = function() {
  var o = function(k2, v, o2, l2) {
    for (o2 = o2 || {}, l2 = k2.length; l2--; o2[k2[l2]] = v)
      ;
    return o2;
  }, $V0 = [1, 2], $V1 = [1, 5], $V2 = [6, 9, 11, 23, 25, 27, 29, 30, 31, 49], $V3 = [1, 17], $V4 = [1, 18], $V5 = [1, 19], $V6 = [1, 20], $V7 = [1, 21], $V8 = [1, 22], $V9 = [1, 25], $Va = [1, 30], $Vb = [1, 31], $Vc = [1, 32], $Vd = [1, 33], $Ve = [6, 9, 11, 15, 20, 23, 25, 27, 29, 30, 31, 42, 43, 44, 45, 49], $Vf = [1, 45], $Vg = [30, 31, 46, 47], $Vh = [4, 6, 9, 11, 23, 25, 27, 29, 30, 31, 49], $Vi = [42, 43, 44, 45], $Vj = [22, 37], $Vk = [1, 64];
  var parser2 = {
    trace: function trace() {
    },
    yy: {},
    symbols_: { "error": 2, "start": 3, "ER_DIAGRAM": 4, "document": 5, "EOF": 6, "directive": 7, "line": 8, "SPACE": 9, "statement": 10, "NEWLINE": 11, "openDirective": 12, "typeDirective": 13, "closeDirective": 14, ":": 15, "argDirective": 16, "entityName": 17, "relSpec": 18, "role": 19, "BLOCK_START": 20, "attributes": 21, "BLOCK_STOP": 22, "title": 23, "title_value": 24, "acc_title": 25, "acc_title_value": 26, "acc_descr": 27, "acc_descr_value": 28, "acc_descr_multiline_value": 29, "ALPHANUM": 30, "ENTITY_NAME": 31, "attribute": 32, "attributeType": 33, "attributeName": 34, "attributeKeyType": 35, "attributeComment": 36, "ATTRIBUTE_WORD": 37, "ATTRIBUTE_KEY": 38, "COMMENT": 39, "cardinality": 40, "relType": 41, "ZERO_OR_ONE": 42, "ZERO_OR_MORE": 43, "ONE_OR_MORE": 44, "ONLY_ONE": 45, "NON_IDENTIFYING": 46, "IDENTIFYING": 47, "WORD": 48, "open_directive": 49, "type_directive": 50, "arg_directive": 51, "close_directive": 52, "$accept": 0, "$end": 1 },
    terminals_: { 2: "error", 4: "ER_DIAGRAM", 6: "EOF", 9: "SPACE", 11: "NEWLINE", 15: ":", 20: "BLOCK_START", 22: "BLOCK_STOP", 23: "title", 24: "title_value", 25: "acc_title", 26: "acc_title_value", 27: "acc_descr", 28: "acc_descr_value", 29: "acc_descr_multiline_value", 30: "ALPHANUM", 31: "ENTITY_NAME", 37: "ATTRIBUTE_WORD", 38: "ATTRIBUTE_KEY", 39: "COMMENT", 42: "ZERO_OR_ONE", 43: "ZERO_OR_MORE", 44: "ONE_OR_MORE", 45: "ONLY_ONE", 46: "NON_IDENTIFYING", 47: "IDENTIFYING", 48: "WORD", 49: "open_directive", 50: "type_directive", 51: "arg_directive", 52: "close_directive" },
    productions_: [0, [3, 3], [3, 2], [5, 0], [5, 2], [8, 2], [8, 1], [8, 1], [8, 1], [7, 4], [7, 6], [10, 1], [10, 5], [10, 4], [10, 3], [10, 1], [10, 2], [10, 2], [10, 2], [10, 1], [17, 1], [17, 1], [21, 1], [21, 2], [32, 2], [32, 3], [32, 3], [32, 4], [33, 1], [34, 1], [35, 1], [36, 1], [18, 3], [40, 1], [40, 1], [40, 1], [40, 1], [41, 1], [41, 1], [19, 1], [19, 1], [19, 1], [12, 1], [13, 1], [16, 1], [14, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 1:
          break;
        case 3:
          this.$ = [];
          break;
        case 4:
          $$[$0 - 1].push($$[$0]);
          this.$ = $$[$0 - 1];
          break;
        case 5:
        case 6:
          this.$ = $$[$0];
          break;
        case 7:
        case 8:
          this.$ = [];
          break;
        case 12:
          yy.addEntity($$[$0 - 4]);
          yy.addEntity($$[$0 - 2]);
          yy.addRelationship($$[$0 - 4], $$[$0], $$[$0 - 2], $$[$0 - 3]);
          break;
        case 13:
          yy.addEntity($$[$0 - 3]);
          yy.addAttributes($$[$0 - 3], $$[$0 - 1]);
          break;
        case 14:
          yy.addEntity($$[$0 - 2]);
          break;
        case 15:
          yy.addEntity($$[$0]);
          break;
        case 16:
        case 17:
          this.$ = $$[$0].trim();
          yy.setAccTitle(this.$);
          break;
        case 18:
        case 19:
          this.$ = $$[$0].trim();
          yy.setAccDescription(this.$);
          break;
        case 20:
        case 41:
          this.$ = $$[$0];
          break;
        case 21:
        case 39:
        case 40:
          this.$ = $$[$0].replace(/"/g, "");
          break;
        case 22:
          this.$ = [$$[$0]];
          break;
        case 23:
          $$[$0].push($$[$0 - 1]);
          this.$ = $$[$0];
          break;
        case 24:
          this.$ = { attributeType: $$[$0 - 1], attributeName: $$[$0] };
          break;
        case 25:
          this.$ = { attributeType: $$[$0 - 2], attributeName: $$[$0 - 1], attributeKeyType: $$[$0] };
          break;
        case 26:
          this.$ = { attributeType: $$[$0 - 2], attributeName: $$[$0 - 1], attributeComment: $$[$0] };
          break;
        case 27:
          this.$ = { attributeType: $$[$0 - 3], attributeName: $$[$0 - 2], attributeKeyType: $$[$0 - 1], attributeComment: $$[$0] };
          break;
        case 28:
        case 29:
        case 30:
          this.$ = $$[$0];
          break;
        case 31:
          this.$ = $$[$0].replace(/"/g, "");
          break;
        case 32:
          this.$ = { cardA: $$[$0], relType: $$[$0 - 1], cardB: $$[$0 - 2] };
          break;
        case 33:
          this.$ = yy.Cardinality.ZERO_OR_ONE;
          break;
        case 34:
          this.$ = yy.Cardinality.ZERO_OR_MORE;
          break;
        case 35:
          this.$ = yy.Cardinality.ONE_OR_MORE;
          break;
        case 36:
          this.$ = yy.Cardinality.ONLY_ONE;
          break;
        case 37:
          this.$ = yy.Identification.NON_IDENTIFYING;
          break;
        case 38:
          this.$ = yy.Identification.IDENTIFYING;
          break;
        case 42:
          yy.parseDirective("%%{", "open_directive");
          break;
        case 43:
          yy.parseDirective($$[$0], "type_directive");
          break;
        case 44:
          $$[$0] = $$[$0].trim().replace(/'/g, '"');
          yy.parseDirective($$[$0], "arg_directive");
          break;
        case 45:
          yy.parseDirective("}%%", "close_directive", "er");
          break;
      }
    },
    table: [{ 3: 1, 4: $V0, 7: 3, 12: 4, 49: $V1 }, { 1: [3] }, o($V2, [2, 3], { 5: 6 }), { 3: 7, 4: $V0, 7: 3, 12: 4, 49: $V1 }, { 13: 8, 50: [1, 9] }, { 50: [2, 42] }, { 6: [1, 10], 7: 15, 8: 11, 9: [1, 12], 10: 13, 11: [1, 14], 12: 4, 17: 16, 23: $V3, 25: $V4, 27: $V5, 29: $V6, 30: $V7, 31: $V8, 49: $V1 }, { 1: [2, 2] }, { 14: 23, 15: [1, 24], 52: $V9 }, o([15, 52], [2, 43]), o($V2, [2, 8], { 1: [2, 1] }), o($V2, [2, 4]), { 7: 15, 10: 26, 12: 4, 17: 16, 23: $V3, 25: $V4, 27: $V5, 29: $V6, 30: $V7, 31: $V8, 49: $V1 }, o($V2, [2, 6]), o($V2, [2, 7]), o($V2, [2, 11]), o($V2, [2, 15], { 18: 27, 40: 29, 20: [1, 28], 42: $Va, 43: $Vb, 44: $Vc, 45: $Vd }), { 24: [1, 34] }, { 26: [1, 35] }, { 28: [1, 36] }, o($V2, [2, 19]), o($Ve, [2, 20]), o($Ve, [2, 21]), { 11: [1, 37] }, { 16: 38, 51: [1, 39] }, { 11: [2, 45] }, o($V2, [2, 5]), { 17: 40, 30: $V7, 31: $V8 }, { 21: 41, 22: [1, 42], 32: 43, 33: 44, 37: $Vf }, { 41: 46, 46: [1, 47], 47: [1, 48] }, o($Vg, [2, 33]), o($Vg, [2, 34]), o($Vg, [2, 35]), o($Vg, [2, 36]), o($V2, [2, 16]), o($V2, [2, 17]), o($V2, [2, 18]), o($Vh, [2, 9]), { 14: 49, 52: $V9 }, { 52: [2, 44] }, { 15: [1, 50] }, { 22: [1, 51] }, o($V2, [2, 14]), { 21: 52, 22: [2, 22], 32: 43, 33: 44, 37: $Vf }, { 34: 53, 37: [1, 54] }, { 37: [2, 28] }, { 40: 55, 42: $Va, 43: $Vb, 44: $Vc, 45: $Vd }, o($Vi, [2, 37]), o($Vi, [2, 38]), { 11: [1, 56] }, { 19: 57, 30: [1, 60], 31: [1, 59], 48: [1, 58] }, o($V2, [2, 13]), { 22: [2, 23] }, o($Vj, [2, 24], { 35: 61, 36: 62, 38: [1, 63], 39: $Vk }), o([22, 37, 38, 39], [2, 29]), o([30, 31], [2, 32]), o($Vh, [2, 10]), o($V2, [2, 12]), o($V2, [2, 39]), o($V2, [2, 40]), o($V2, [2, 41]), o($Vj, [2, 25], { 36: 65, 39: $Vk }), o($Vj, [2, 26]), o([22, 37, 39], [2, 30]), o($Vj, [2, 31]), o($Vj, [2, 27])],
    defaultActions: { 5: [2, 42], 7: [2, 2], 25: [2, 45], 39: [2, 44], 45: [2, 28], 52: [2, 23] },
    parseError: function parseError(str, hash2) {
      if (hash2.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash2;
        throw error;
      }
    },
    parse: function parse2(input) {
      var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k2 in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
          sharedState.yy[k2] = this.yy[k2];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges2 = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function lex() {
        var token2;
        token2 = tstack.pop() || lexer2.lex() || EOF2;
        if (typeof token2 !== "number") {
          if (token2 instanceof Array) {
            tstack = token2;
            token2 = tstack.pop();
          }
          token2 = self2.symbols_[token2] || token2;
        }
        return token2;
      }
      var symbol2, state, action, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack2[stack2.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol2 === null || typeof symbol2 == "undefined") {
            symbol2 = lex();
          }
          action = table[state] && table[state][symbol2];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push("'" + this.terminals_[p] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol2] || symbol2) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol2 == EOF2 ? "end of input" : "'" + (this.terminals_[symbol2] || symbol2) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol2] || symbol2,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol2);
        }
        switch (action[0]) {
          case 1:
            stack2.push(symbol2);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack2.push(action[1]);
            symbol2 = null;
            {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges2) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
              ];
            }
            r = this.performAction.apply(yyval, [
              yytext,
              yyleng,
              yylineno,
              sharedState.yy,
              action[1],
              vstack,
              lstack
            ].concat(args));
            if (typeof r !== "undefined") {
              return r;
            }
            if (len) {
              stack2 = stack2.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack2.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
            stack2.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash2) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash2);
        } else {
          throw new Error(str);
        }
      },
      setInput: function(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      input: function() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      unput: function(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      more: function() {
        this._more = true;
        return this;
      },
      reject: function() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      less: function(n) {
        this.unput(this.match.slice(n));
      },
      pastInput: function() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var next2 = this.match;
        if (next2.length < 20) {
          next2 += this._input.substr(0, 20 - next2.length);
        }
        return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var pre = this.pastInput();
        var c2 = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c2 + "^";
      },
      test_match: function(match, indexed_rule) {
        var token2, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token2) {
          return token2;
        } else if (this._backtrack) {
          for (var k2 in backup) {
            this[k2] = backup[k2];
          }
          return false;
        }
        return false;
      },
      next: function() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token2, match, tempMatch, index2;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index2 = i;
            if (this.options.backtrack_lexer) {
              token2 = this.test_match(tempMatch, rules[i]);
              if (token2 !== false) {
                return token2;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token2 = this.test_match(match, rules[index2]);
          if (token2 !== false) {
            return token2;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": true },
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        switch ($avoiding_name_collisions) {
          case 0:
            this.begin("acc_title");
            return 25;
          case 1:
            this.popState();
            return "acc_title_value";
          case 2:
            this.begin("acc_descr");
            return 27;
          case 3:
            this.popState();
            return "acc_descr_value";
          case 4:
            this.begin("acc_descr_multiline");
            break;
          case 5:
            this.popState();
            break;
          case 6:
            return "acc_descr_multiline_value";
          case 7:
            this.begin("open_directive");
            return 49;
          case 8:
            this.begin("type_directive");
            return 50;
          case 9:
            this.popState();
            this.begin("arg_directive");
            return 15;
          case 10:
            this.popState();
            this.popState();
            return 52;
          case 11:
            return 51;
          case 12:
            break;
          case 13:
            break;
          case 14:
            return 11;
          case 15:
            break;
          case 16:
            return 9;
          case 17:
            return 31;
          case 18:
            return 48;
          case 19:
            return 4;
          case 20:
            this.begin("block");
            return 20;
          case 21:
            break;
          case 22:
            return 38;
          case 23:
            return 37;
          case 24:
            return 37;
          case 25:
            return 39;
          case 26:
            break;
          case 27:
            this.popState();
            return 22;
          case 28:
            return yy_.yytext[0];
          case 29:
            return 42;
          case 30:
            return 43;
          case 31:
            return 44;
          case 32:
            return 45;
          case 33:
            return 42;
          case 34:
            return 43;
          case 35:
            return 44;
          case 36:
            return 46;
          case 37:
            return 47;
          case 38:
            return 46;
          case 39:
            return 46;
          case 40:
            return 30;
          case 41:
            return yy_.yytext[0];
          case 42:
            return 6;
        }
      },
      rules: [/^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:[\s]+)/i, /^(?:"[^"%\r\n\v\b\\]+")/i, /^(?:"[^"]*")/i, /^(?:erDiagram\b)/i, /^(?:\{)/i, /^(?:\s+)/i, /^(?:\b((?:PK)|(?:FK))\b)/i, /^(?:(.*?)[~](.*?)*[~])/i, /^(?:[A-Za-z][A-Za-z0-9\-_\[\]]*)/i, /^(?:"[^"]*")/i, /^(?:[\n]+)/i, /^(?:\})/i, /^(?:.)/i, /^(?:\|o\b)/i, /^(?:\}o\b)/i, /^(?:\}\|)/i, /^(?:\|\|)/i, /^(?:o\|)/i, /^(?:o\{)/i, /^(?:\|\{)/i, /^(?:\.\.)/i, /^(?:--)/i, /^(?:\.-)/i, /^(?:-\.)/i, /^(?:[A-Za-z][A-Za-z0-9\-_]*)/i, /^(?:.)/i, /^(?:$)/i],
      conditions: { "acc_descr_multiline": { "rules": [5, 6], "inclusive": false }, "acc_descr": { "rules": [3], "inclusive": false }, "acc_title": { "rules": [1], "inclusive": false }, "open_directive": { "rules": [8], "inclusive": false }, "type_directive": { "rules": [9, 10], "inclusive": false }, "arg_directive": { "rules": [10, 11], "inclusive": false }, "block": { "rules": [21, 22, 23, 24, 25, 26, 27, 28], "inclusive": false }, "INITIAL": { "rules": [0, 2, 4, 7, 12, 13, 14, 15, 16, 17, 18, 19, 20, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42], "inclusive": true } }
    };
    return lexer2;
  }();
  parser2.lexer = lexer;
  function Parser2() {
    this.yy = {};
  }
  Parser2.prototype = parser2;
  parser2.Parser = Parser2;
  return new Parser2();
}();
parser$8.parser = parser$8;
const erDetector = (txt) => {
  return txt.match(/^\s*erDiagram/) !== null;
};
let entities = {};
let relationships = [];
const Cardinality = {
  ZERO_OR_ONE: "ZERO_OR_ONE",
  ZERO_OR_MORE: "ZERO_OR_MORE",
  ONE_OR_MORE: "ONE_OR_MORE",
  ONLY_ONE: "ONLY_ONE"
};
const Identification = {
  NON_IDENTIFYING: "NON_IDENTIFYING",
  IDENTIFYING: "IDENTIFYING"
};
const parseDirective$8 = function(statement, context, type2) {
  mermaidAPI.parseDirective(this, statement, context, type2);
};
const addEntity = function(name2) {
  if (typeof entities[name2] === "undefined") {
    entities[name2] = { attributes: [] };
    log$1.info("Added new entity :", name2);
  }
  return entities[name2];
};
const getEntities = () => entities;
const addAttributes = function(entityName, attribs) {
  let entity = addEntity(entityName);
  let i;
  for (i = attribs.length - 1; i >= 0; i--) {
    entity.attributes.push(attribs[i]);
    log$1.debug("Added attribute ", attribs[i].attributeName);
  }
};
const addRelationship$1 = function(entA, rolA, entB, rSpec) {
  let rel = {
    entityA: entA,
    roleA: rolA,
    entityB: entB,
    relSpec: rSpec
  };
  relationships.push(rel);
  log$1.debug("Added new relationship :", rel);
};
const getRelationships$1 = () => relationships;
const clear$7 = function() {
  entities = {};
  relationships = [];
  clear$g();
};
const erDb = {
  Cardinality,
  Identification,
  parseDirective: parseDirective$8,
  getConfig: () => getConfig$1().er,
  addEntity,
  addAttributes,
  getEntities,
  addRelationship: addRelationship$1,
  getRelationships: getRelationships$1,
  clear: clear$7,
  setAccTitle,
  getAccTitle,
  setAccDescription,
  getAccDescription
};
const ERMarkers = {
  ONLY_ONE_START: "ONLY_ONE_START",
  ONLY_ONE_END: "ONLY_ONE_END",
  ZERO_OR_ONE_START: "ZERO_OR_ONE_START",
  ZERO_OR_ONE_END: "ZERO_OR_ONE_END",
  ONE_OR_MORE_START: "ONE_OR_MORE_START",
  ONE_OR_MORE_END: "ONE_OR_MORE_END",
  ZERO_OR_MORE_START: "ZERO_OR_MORE_START",
  ZERO_OR_MORE_END: "ZERO_OR_MORE_END"
};
const insertMarkers$1 = function(elem, conf2) {
  let marker;
  elem.append("defs").append("marker").attr("id", ERMarkers.ONLY_ONE_START).attr("refX", 0).attr("refY", 9).attr("markerWidth", 18).attr("markerHeight", 18).attr("orient", "auto").append("path").attr("stroke", conf2.stroke).attr("fill", "none").attr("d", "M9,0 L9,18 M15,0 L15,18");
  elem.append("defs").append("marker").attr("id", ERMarkers.ONLY_ONE_END).attr("refX", 18).attr("refY", 9).attr("markerWidth", 18).attr("markerHeight", 18).attr("orient", "auto").append("path").attr("stroke", conf2.stroke).attr("fill", "none").attr("d", "M3,0 L3,18 M9,0 L9,18");
  marker = elem.append("defs").append("marker").attr("id", ERMarkers.ZERO_OR_ONE_START).attr("refX", 0).attr("refY", 9).attr("markerWidth", 30).attr("markerHeight", 18).attr("orient", "auto");
  marker.append("circle").attr("stroke", conf2.stroke).attr("fill", "white").attr("cx", 21).attr("cy", 9).attr("r", 6);
  marker.append("path").attr("stroke", conf2.stroke).attr("fill", "none").attr("d", "M9,0 L9,18");
  marker = elem.append("defs").append("marker").attr("id", ERMarkers.ZERO_OR_ONE_END).attr("refX", 30).attr("refY", 9).attr("markerWidth", 30).attr("markerHeight", 18).attr("orient", "auto");
  marker.append("circle").attr("stroke", conf2.stroke).attr("fill", "white").attr("cx", 9).attr("cy", 9).attr("r", 6);
  marker.append("path").attr("stroke", conf2.stroke).attr("fill", "none").attr("d", "M21,0 L21,18");
  elem.append("defs").append("marker").attr("id", ERMarkers.ONE_OR_MORE_START).attr("refX", 18).attr("refY", 18).attr("markerWidth", 45).attr("markerHeight", 36).attr("orient", "auto").append("path").attr("stroke", conf2.stroke).attr("fill", "none").attr("d", "M0,18 Q 18,0 36,18 Q 18,36 0,18 M42,9 L42,27");
  elem.append("defs").append("marker").attr("id", ERMarkers.ONE_OR_MORE_END).attr("refX", 27).attr("refY", 18).attr("markerWidth", 45).attr("markerHeight", 36).attr("orient", "auto").append("path").attr("stroke", conf2.stroke).attr("fill", "none").attr("d", "M3,9 L3,27 M9,18 Q27,0 45,18 Q27,36 9,18");
  marker = elem.append("defs").append("marker").attr("id", ERMarkers.ZERO_OR_MORE_START).attr("refX", 18).attr("refY", 18).attr("markerWidth", 57).attr("markerHeight", 36).attr("orient", "auto");
  marker.append("circle").attr("stroke", conf2.stroke).attr("fill", "white").attr("cx", 48).attr("cy", 18).attr("r", 6);
  marker.append("path").attr("stroke", conf2.stroke).attr("fill", "none").attr("d", "M0,18 Q18,0 36,18 Q18,36 0,18");
  marker = elem.append("defs").append("marker").attr("id", ERMarkers.ZERO_OR_MORE_END).attr("refX", 39).attr("refY", 18).attr("markerWidth", 57).attr("markerHeight", 36).attr("orient", "auto");
  marker.append("circle").attr("stroke", conf2.stroke).attr("fill", "white").attr("cx", 9).attr("cy", 18).attr("r", 6);
  marker.append("path").attr("stroke", conf2.stroke).attr("fill", "none").attr("d", "M21,18 Q39,0 57,18 Q39,36 21,18");
  return;
};
const erMarkers = {
  ERMarkers,
  insertMarkers: insertMarkers$1
};
const BAD_ID_CHARS_REGEXP = /[^A-Za-z0-9]([\W])*/g;
let conf$9 = {};
let entityNameIds = /* @__PURE__ */ new Map();
const setConf$8 = function(cnf) {
  const keys2 = Object.keys(cnf);
  for (let i = 0; i < keys2.length; i++) {
    conf$9[keys2[i]] = cnf[keys2[i]];
  }
};
const drawAttributes = (groupNode, entityTextNode, attributes) => {
  const heightPadding = conf$9.entityPadding / 3;
  const widthPadding = conf$9.entityPadding / 3;
  const attrFontSize = conf$9.fontSize * 0.85;
  const labelBBox = entityTextNode.node().getBBox();
  const attributeNodes = [];
  let hasKeyType = false;
  let hasComment = false;
  let maxTypeWidth = 0;
  let maxNameWidth = 0;
  let maxKeyWidth = 0;
  let maxCommentWidth = 0;
  let cumulativeHeight = labelBBox.height + heightPadding * 2;
  let attrNum = 1;
  attributes.forEach((item) => {
    if (item.attributeKeyType !== void 0) {
      hasKeyType = true;
    }
    if (item.attributeComment !== void 0) {
      hasComment = true;
    }
  });
  attributes.forEach((item) => {
    const attrPrefix = `${entityTextNode.node().id}-attr-${attrNum}`;
    let nodeHeight = 0;
    const attributeType = parseGenericTypes(item.attributeType);
    const typeNode = groupNode.append("text").attr("class", "er entityLabel").attr("id", `${attrPrefix}-type`).attr("x", 0).attr("y", 0).attr("dominant-baseline", "middle").attr("text-anchor", "left").attr(
      "style",
      "font-family: " + getConfig$1().fontFamily + "; font-size: " + attrFontSize + "px"
    ).text(attributeType);
    const nameNode = groupNode.append("text").attr("class", "er entityLabel").attr("id", `${attrPrefix}-name`).attr("x", 0).attr("y", 0).attr("dominant-baseline", "middle").attr("text-anchor", "left").attr(
      "style",
      "font-family: " + getConfig$1().fontFamily + "; font-size: " + attrFontSize + "px"
    ).text(item.attributeName);
    const attributeNode = {};
    attributeNode.tn = typeNode;
    attributeNode.nn = nameNode;
    const typeBBox = typeNode.node().getBBox();
    const nameBBox = nameNode.node().getBBox();
    maxTypeWidth = Math.max(maxTypeWidth, typeBBox.width);
    maxNameWidth = Math.max(maxNameWidth, nameBBox.width);
    nodeHeight = Math.max(typeBBox.height, nameBBox.height);
    if (hasKeyType) {
      const keyTypeNode = groupNode.append("text").attr("class", "er entityLabel").attr("id", `${attrPrefix}-key`).attr("x", 0).attr("y", 0).attr("dominant-baseline", "middle").attr("text-anchor", "left").attr(
        "style",
        "font-family: " + getConfig$1().fontFamily + "; font-size: " + attrFontSize + "px"
      ).text(item.attributeKeyType || "");
      attributeNode.kn = keyTypeNode;
      const keyTypeBBox = keyTypeNode.node().getBBox();
      maxKeyWidth = Math.max(maxKeyWidth, keyTypeBBox.width);
      nodeHeight = Math.max(nodeHeight, keyTypeBBox.height);
    }
    if (hasComment) {
      const commentNode = groupNode.append("text").attr("class", "er entityLabel").attr("id", `${attrPrefix}-comment`).attr("x", 0).attr("y", 0).attr("dominant-baseline", "middle").attr("text-anchor", "left").attr(
        "style",
        "font-family: " + getConfig$1().fontFamily + "; font-size: " + attrFontSize + "px"
      ).text(item.attributeComment || "");
      attributeNode.cn = commentNode;
      const commentNodeBBox = commentNode.node().getBBox();
      maxCommentWidth = Math.max(maxCommentWidth, commentNodeBBox.width);
      nodeHeight = Math.max(nodeHeight, commentNodeBBox.height);
    }
    attributeNode.height = nodeHeight;
    attributeNodes.push(attributeNode);
    cumulativeHeight += nodeHeight + heightPadding * 2;
    attrNum += 1;
  });
  let widthPaddingFactor = 4;
  if (hasKeyType) {
    widthPaddingFactor += 2;
  }
  if (hasComment) {
    widthPaddingFactor += 2;
  }
  const maxWidth = maxTypeWidth + maxNameWidth + maxKeyWidth + maxCommentWidth;
  const bBox = {
    width: Math.max(
      conf$9.minEntityWidth,
      Math.max(
        labelBBox.width + conf$9.entityPadding * 2,
        maxWidth + widthPadding * widthPaddingFactor
      )
    ),
    height: attributes.length > 0 ? cumulativeHeight : Math.max(conf$9.minEntityHeight, labelBBox.height + conf$9.entityPadding * 2)
  };
  if (attributes.length > 0) {
    const spareColumnWidth = Math.max(
      0,
      (bBox.width - maxWidth - widthPadding * widthPaddingFactor) / (widthPaddingFactor / 2)
    );
    entityTextNode.attr(
      "transform",
      "translate(" + bBox.width / 2 + "," + (heightPadding + labelBBox.height / 2) + ")"
    );
    let heightOffset = labelBBox.height + heightPadding * 2;
    let attribStyle = "attributeBoxOdd";
    attributeNodes.forEach((attributeNode) => {
      const alignY = heightOffset + heightPadding + attributeNode.height / 2;
      attributeNode.tn.attr("transform", "translate(" + widthPadding + "," + alignY + ")");
      const typeRect = groupNode.insert("rect", "#" + attributeNode.tn.node().id).attr("class", `er ${attribStyle}`).attr("fill", conf$9.fill).attr("fill-opacity", "100%").attr("stroke", conf$9.stroke).attr("x", 0).attr("y", heightOffset).attr("width", maxTypeWidth + widthPadding * 2 + spareColumnWidth).attr("height", attributeNode.height + heightPadding * 2);
      const nameXOffset = parseFloat(typeRect.attr("x")) + parseFloat(typeRect.attr("width"));
      attributeNode.nn.attr(
        "transform",
        "translate(" + (nameXOffset + widthPadding) + "," + alignY + ")"
      );
      const nameRect = groupNode.insert("rect", "#" + attributeNode.nn.node().id).attr("class", `er ${attribStyle}`).attr("fill", conf$9.fill).attr("fill-opacity", "100%").attr("stroke", conf$9.stroke).attr("x", nameXOffset).attr("y", heightOffset).attr("width", maxNameWidth + widthPadding * 2 + spareColumnWidth).attr("height", attributeNode.height + heightPadding * 2);
      let keyTypeAndCommentXOffset = parseFloat(nameRect.attr("x")) + parseFloat(nameRect.attr("width"));
      if (hasKeyType) {
        attributeNode.kn.attr(
          "transform",
          "translate(" + (keyTypeAndCommentXOffset + widthPadding) + "," + alignY + ")"
        );
        const keyTypeRect = groupNode.insert("rect", "#" + attributeNode.kn.node().id).attr("class", `er ${attribStyle}`).attr("fill", conf$9.fill).attr("fill-opacity", "100%").attr("stroke", conf$9.stroke).attr("x", keyTypeAndCommentXOffset).attr("y", heightOffset).attr("width", maxKeyWidth + widthPadding * 2 + spareColumnWidth).attr("height", attributeNode.height + heightPadding * 2);
        keyTypeAndCommentXOffset = parseFloat(keyTypeRect.attr("x")) + parseFloat(keyTypeRect.attr("width"));
      }
      if (hasComment) {
        attributeNode.cn.attr(
          "transform",
          "translate(" + (keyTypeAndCommentXOffset + widthPadding) + "," + alignY + ")"
        );
        groupNode.insert("rect", "#" + attributeNode.cn.node().id).attr("class", `er ${attribStyle}`).attr("fill", conf$9.fill).attr("fill-opacity", "100%").attr("stroke", conf$9.stroke).attr("x", keyTypeAndCommentXOffset).attr("y", heightOffset).attr("width", maxCommentWidth + widthPadding * 2 + spareColumnWidth).attr("height", attributeNode.height + heightPadding * 2);
      }
      heightOffset += attributeNode.height + heightPadding * 2;
      attribStyle = attribStyle === "attributeBoxOdd" ? "attributeBoxEven" : "attributeBoxOdd";
    });
  } else {
    bBox.height = Math.max(conf$9.minEntityHeight, cumulativeHeight);
    entityTextNode.attr("transform", "translate(" + bBox.width / 2 + "," + bBox.height / 2 + ")");
  }
  return bBox;
};
const drawEntities = function(svgNode2, entities2, graph2) {
  const keys2 = Object.keys(entities2);
  let firstOne;
  keys2.forEach(function(entityName) {
    const entityId = generateId(entityName, "entity");
    entityNameIds.set(entityName, entityId);
    const groupNode = svgNode2.append("g").attr("id", entityId);
    firstOne = firstOne === void 0 ? entityId : firstOne;
    const textId = "text-" + entityId;
    const textNode = groupNode.append("text").attr("class", "er entityLabel").attr("id", textId).attr("x", 0).attr("y", 0).attr("dominant-baseline", "middle").attr("text-anchor", "middle").attr(
      "style",
      "font-family: " + getConfig$1().fontFamily + "; font-size: " + conf$9.fontSize + "px"
    ).text(entityName);
    const { width: entityWidth, height: entityHeight } = drawAttributes(
      groupNode,
      textNode,
      entities2[entityName].attributes
    );
    const rectNode = groupNode.insert("rect", "#" + textId).attr("class", "er entityBox").attr("fill", conf$9.fill).attr("fill-opacity", "100%").attr("stroke", conf$9.stroke).attr("x", 0).attr("y", 0).attr("width", entityWidth).attr("height", entityHeight);
    const rectBBox = rectNode.node().getBBox();
    graph2.setNode(entityId, {
      width: rectBBox.width,
      height: rectBBox.height,
      shape: "rect",
      id: entityId
    });
  });
  return firstOne;
};
const adjustEntities$1 = function(svgNode2, graph2) {
  graph2.nodes().forEach(function(v) {
    if (typeof v !== "undefined" && typeof graph2.node(v) !== "undefined") {
      svgNode2.select("#" + v).attr(
        "transform",
        "translate(" + (graph2.node(v).x - graph2.node(v).width / 2) + "," + (graph2.node(v).y - graph2.node(v).height / 2) + " )"
      );
    }
  });
};
const getEdgeName = function(rel) {
  return (rel.entityA + rel.roleA + rel.entityB).replace(/\s/g, "");
};
const addRelationships$1 = function(relationships2, g2) {
  relationships2.forEach(function(r) {
    g2.setEdge(
      entityNameIds.get(r.entityA),
      entityNameIds.get(r.entityB),
      { relationship: r },
      getEdgeName(r)
    );
  });
  return relationships2;
};
let relCnt$1 = 0;
const drawRelationshipFromLayout$1 = function(svg2, rel, g2, insert2, diagObj) {
  relCnt$1++;
  const edge = g2.edge(
    entityNameIds.get(rel.entityA),
    entityNameIds.get(rel.entityB),
    getEdgeName(rel)
  );
  const lineFunction = line$2().x(function(d) {
    return d.x;
  }).y(function(d) {
    return d.y;
  }).curve(curveBasis);
  const svgPath = svg2.insert("path", "#" + insert2).attr("class", "er relationshipLine").attr("d", lineFunction(edge.points)).attr("stroke", conf$9.stroke).attr("fill", "none");
  if (rel.relSpec.relType === diagObj.db.Identification.NON_IDENTIFYING) {
    svgPath.attr("stroke-dasharray", "8,8");
  }
  let url = "";
  if (conf$9.arrowMarkerAbsolute) {
    url = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search;
    url = url.replace(/\(/g, "\\(");
    url = url.replace(/\)/g, "\\)");
  }
  switch (rel.relSpec.cardA) {
    case diagObj.db.Cardinality.ZERO_OR_ONE:
      svgPath.attr("marker-end", "url(" + url + "#" + erMarkers.ERMarkers.ZERO_OR_ONE_END + ")");
      break;
    case diagObj.db.Cardinality.ZERO_OR_MORE:
      svgPath.attr("marker-end", "url(" + url + "#" + erMarkers.ERMarkers.ZERO_OR_MORE_END + ")");
      break;
    case diagObj.db.Cardinality.ONE_OR_MORE:
      svgPath.attr("marker-end", "url(" + url + "#" + erMarkers.ERMarkers.ONE_OR_MORE_END + ")");
      break;
    case diagObj.db.Cardinality.ONLY_ONE:
      svgPath.attr("marker-end", "url(" + url + "#" + erMarkers.ERMarkers.ONLY_ONE_END + ")");
      break;
  }
  switch (rel.relSpec.cardB) {
    case diagObj.db.Cardinality.ZERO_OR_ONE:
      svgPath.attr(
        "marker-start",
        "url(" + url + "#" + erMarkers.ERMarkers.ZERO_OR_ONE_START + ")"
      );
      break;
    case diagObj.db.Cardinality.ZERO_OR_MORE:
      svgPath.attr(
        "marker-start",
        "url(" + url + "#" + erMarkers.ERMarkers.ZERO_OR_MORE_START + ")"
      );
      break;
    case diagObj.db.Cardinality.ONE_OR_MORE:
      svgPath.attr(
        "marker-start",
        "url(" + url + "#" + erMarkers.ERMarkers.ONE_OR_MORE_START + ")"
      );
      break;
    case diagObj.db.Cardinality.ONLY_ONE:
      svgPath.attr("marker-start", "url(" + url + "#" + erMarkers.ERMarkers.ONLY_ONE_START + ")");
      break;
  }
  const len = svgPath.node().getTotalLength();
  const labelPoint = svgPath.node().getPointAtLength(len * 0.5);
  const labelId = "rel" + relCnt$1;
  const labelNode = svg2.append("text").attr("class", "er relationshipLabel").attr("id", labelId).attr("x", labelPoint.x).attr("y", labelPoint.y).attr("text-anchor", "middle").attr("dominant-baseline", "middle").attr(
    "style",
    "font-family: " + getConfig$1().fontFamily + "; font-size: " + conf$9.fontSize + "px"
  ).text(rel.roleA);
  const labelBBox = labelNode.node().getBBox();
  svg2.insert("rect", "#" + labelId).attr("class", "er relationshipLabelBox").attr("x", labelPoint.x - labelBBox.width / 2).attr("y", labelPoint.y - labelBBox.height / 2).attr("width", labelBBox.width).attr("height", labelBBox.height).attr("fill", "white").attr("fill-opacity", "85%");
};
const draw$b = function(text2, id2, _version, diagObj) {
  conf$9 = getConfig$1().er;
  log$1.info("Drawing ER diagram");
  const securityLevel = getConfig$1().securityLevel;
  let sandboxElement;
  if (securityLevel === "sandbox") {
    sandboxElement = select$1("#i" + id2);
  }
  const root2 = securityLevel === "sandbox" ? select$1(sandboxElement.nodes()[0].contentDocument.body) : select$1("body");
  const svg2 = root2.select(`[id='${id2}']`);
  erMarkers.insertMarkers(svg2, conf$9);
  let g2;
  g2 = new graphlib$2.Graph({
    multigraph: true,
    directed: true,
    compound: false
  }).setGraph({
    rankdir: conf$9.layoutDirection,
    marginx: 20,
    marginy: 20,
    nodesep: 100,
    edgesep: 100,
    ranksep: 100
  }).setDefaultEdgeLabel(function() {
    return {};
  });
  const firstEntity = drawEntities(svg2, diagObj.db.getEntities(), g2);
  const relationships2 = addRelationships$1(diagObj.db.getRelationships(), g2);
  dagre$1.layout(g2);
  adjustEntities$1(svg2, g2);
  relationships2.forEach(function(rel) {
    drawRelationshipFromLayout$1(svg2, rel, g2, firstEntity, diagObj);
  });
  const padding2 = conf$9.diagramPadding;
  const svgBounds = svg2.node().getBBox();
  const width2 = svgBounds.width + padding2 * 2;
  const height2 = svgBounds.height + padding2 * 2;
  configureSvgSize(svg2, height2, width2, conf$9.useMaxWidth);
  svg2.attr("viewBox", `${svgBounds.x - padding2} ${svgBounds.y - padding2} ${width2} ${height2}`);
  addSVGAccessibilityFields(diagObj.db, svg2, id2);
};
function generateId(str = "", prefix2 = "") {
  const simplifiedStr = str.replace(BAD_ID_CHARS_REGEXP, "");
  return `${strWithHyphen(prefix2)}${strWithHyphen(simplifiedStr)}${v4()}`;
}
function strWithHyphen(str = "") {
  return str.length > 0 ? `${str}-` : "";
}
const erRenderer = {
  setConf: setConf$8,
  draw: draw$b
};
var parser$7 = function() {
  var o = function(k2, v, o2, l2) {
    for (o2 = o2 || {}, l2 = k2.length; l2--; o2[k2[l2]] = v)
      ;
    return o2;
  }, $V0 = [1, 9], $V1 = [1, 7], $V2 = [1, 6], $V3 = [1, 8], $V4 = [1, 20, 21, 22, 23, 38, 44, 46, 48, 52, 66, 67, 86, 87, 88, 89, 90, 91, 95, 105, 106, 109, 111, 112, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127], $V5 = [2, 10], $V6 = [1, 20], $V7 = [1, 21], $V8 = [1, 22], $V9 = [1, 23], $Va = [1, 30], $Vb = [1, 32], $Vc = [1, 33], $Vd = [1, 34], $Ve = [1, 62], $Vf = [1, 48], $Vg = [1, 52], $Vh = [1, 36], $Vi = [1, 37], $Vj = [1, 38], $Vk = [1, 39], $Vl = [1, 40], $Vm = [1, 56], $Vn = [1, 63], $Vo = [1, 51], $Vp = [1, 53], $Vq = [1, 55], $Vr = [1, 59], $Vs = [1, 60], $Vt = [1, 41], $Vu = [1, 42], $Vv = [1, 43], $Vw = [1, 44], $Vx = [1, 61], $Vy = [1, 50], $Vz = [1, 54], $VA = [1, 57], $VB = [1, 58], $VC = [1, 49], $VD = [1, 66], $VE = [1, 71], $VF = [1, 20, 21, 22, 23, 38, 42, 44, 46, 48, 52, 66, 67, 86, 87, 88, 89, 90, 91, 95, 105, 106, 109, 111, 112, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127], $VG = [1, 75], $VH = [1, 74], $VI = [1, 76], $VJ = [20, 21, 23, 81, 82], $VK = [1, 99], $VL = [1, 104], $VM = [1, 107], $VN = [1, 108], $VO = [1, 101], $VP = [1, 106], $VQ = [1, 109], $VR = [1, 102], $VS = [1, 114], $VT = [1, 113], $VU = [1, 103], $VV = [1, 105], $VW = [1, 110], $VX = [1, 111], $VY = [1, 112], $VZ = [1, 115], $V_ = [20, 21, 22, 23, 81, 82], $V$ = [20, 21, 22, 23, 53, 81, 82], $V01 = [20, 21, 22, 23, 40, 52, 53, 55, 57, 59, 61, 63, 65, 66, 67, 69, 71, 73, 74, 76, 81, 82, 91, 95, 105, 106, 109, 111, 112, 122, 123, 124, 125, 126, 127], $V11 = [20, 21, 23], $V21 = [20, 21, 23, 52, 66, 67, 81, 82, 91, 95, 105, 106, 109, 111, 112, 122, 123, 124, 125, 126, 127], $V31 = [1, 12, 20, 21, 22, 23, 24, 38, 42, 44, 46, 48, 52, 66, 67, 86, 87, 88, 89, 90, 91, 95, 105, 106, 109, 111, 112, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127], $V41 = [52, 66, 67, 91, 95, 105, 106, 109, 111, 112, 122, 123, 124, 125, 126, 127], $V51 = [1, 149], $V61 = [1, 157], $V71 = [1, 158], $V81 = [1, 159], $V91 = [1, 160], $Va1 = [1, 144], $Vb1 = [1, 145], $Vc1 = [1, 141], $Vd1 = [1, 152], $Ve1 = [1, 153], $Vf1 = [1, 154], $Vg1 = [1, 155], $Vh1 = [1, 156], $Vi1 = [1, 161], $Vj1 = [1, 162], $Vk1 = [1, 147], $Vl1 = [1, 150], $Vm1 = [1, 146], $Vn1 = [1, 143], $Vo1 = [20, 21, 22, 23, 38, 42, 44, 46, 48, 52, 66, 67, 86, 87, 88, 89, 90, 91, 95, 105, 106, 109, 111, 112, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127], $Vp1 = [1, 165], $Vq1 = [20, 21, 22, 23, 26, 52, 66, 67, 91, 105, 106, 109, 111, 112, 122, 123, 124, 125, 126, 127], $Vr1 = [20, 21, 22, 23, 24, 26, 38, 40, 41, 42, 52, 56, 58, 60, 62, 64, 66, 67, 68, 70, 72, 73, 75, 77, 81, 82, 86, 87, 88, 89, 90, 91, 92, 95, 105, 106, 109, 111, 112, 113, 114, 122, 123, 124, 125, 126, 127], $Vs1 = [12, 21, 22, 24], $Vt1 = [22, 106], $Vu1 = [1, 250], $Vv1 = [1, 245], $Vw1 = [1, 246], $Vx1 = [1, 254], $Vy1 = [1, 251], $Vz1 = [1, 248], $VA1 = [1, 247], $VB1 = [1, 249], $VC1 = [1, 252], $VD1 = [1, 253], $VE1 = [1, 255], $VF1 = [1, 273], $VG1 = [20, 21, 23, 106], $VH1 = [20, 21, 22, 23, 66, 67, 86, 102, 105, 106, 109, 110, 111, 112, 113];
  var parser2 = {
    trace: function trace() {
    },
    yy: {},
    symbols_: { "error": 2, "start": 3, "mermaidDoc": 4, "directive": 5, "openDirective": 6, "typeDirective": 7, "closeDirective": 8, "separator": 9, ":": 10, "argDirective": 11, "open_directive": 12, "type_directive": 13, "arg_directive": 14, "close_directive": 15, "graphConfig": 16, "document": 17, "line": 18, "statement": 19, "SEMI": 20, "NEWLINE": 21, "SPACE": 22, "EOF": 23, "GRAPH": 24, "NODIR": 25, "DIR": 26, "FirstStmtSeperator": 27, "ending": 28, "endToken": 29, "spaceList": 30, "spaceListNewline": 31, "verticeStatement": 32, "styleStatement": 33, "linkStyleStatement": 34, "classDefStatement": 35, "classStatement": 36, "clickStatement": 37, "subgraph": 38, "text": 39, "SQS": 40, "SQE": 41, "end": 42, "direction": 43, "acc_title": 44, "acc_title_value": 45, "acc_descr": 46, "acc_descr_value": 47, "acc_descr_multiline_value": 48, "link": 49, "node": 50, "vertex": 51, "AMP": 52, "STYLE_SEPARATOR": 53, "idString": 54, "DOUBLECIRCLESTART": 55, "DOUBLECIRCLEEND": 56, "PS": 57, "PE": 58, "(-": 59, "-)": 60, "STADIUMSTART": 61, "STADIUMEND": 62, "SUBROUTINESTART": 63, "SUBROUTINEEND": 64, "VERTEX_WITH_PROPS_START": 65, "ALPHA": 66, "COLON": 67, "PIPE": 68, "CYLINDERSTART": 69, "CYLINDEREND": 70, "DIAMOND_START": 71, "DIAMOND_STOP": 72, "TAGEND": 73, "TRAPSTART": 74, "TRAPEND": 75, "INVTRAPSTART": 76, "INVTRAPEND": 77, "linkStatement": 78, "arrowText": 79, "TESTSTR": 80, "START_LINK": 81, "LINK": 82, "textToken": 83, "STR": 84, "keywords": 85, "STYLE": 86, "LINKSTYLE": 87, "CLASSDEF": 88, "CLASS": 89, "CLICK": 90, "DOWN": 91, "UP": 92, "textNoTags": 93, "textNoTagsToken": 94, "DEFAULT": 95, "stylesOpt": 96, "alphaNum": 97, "CALLBACKNAME": 98, "CALLBACKARGS": 99, "HREF": 100, "LINK_TARGET": 101, "HEX": 102, "numList": 103, "INTERPOLATE": 104, "NUM": 105, "COMMA": 106, "style": 107, "styleComponent": 108, "MINUS": 109, "UNIT": 110, "BRKT": 111, "DOT": 112, "PCT": 113, "TAGSTART": 114, "alphaNumToken": 115, "idStringToken": 116, "alphaNumStatement": 117, "direction_tb": 118, "direction_bt": 119, "direction_rl": 120, "direction_lr": 121, "PUNCTUATION": 122, "UNICODE_TEXT": 123, "PLUS": 124, "EQUALS": 125, "MULT": 126, "UNDERSCORE": 127, "graphCodeTokens": 128, "ARROW_CROSS": 129, "ARROW_POINT": 130, "ARROW_CIRCLE": 131, "ARROW_OPEN": 132, "QUOTE": 133, "$accept": 0, "$end": 1 },
    terminals_: { 2: "error", 10: ":", 12: "open_directive", 13: "type_directive", 14: "arg_directive", 15: "close_directive", 20: "SEMI", 21: "NEWLINE", 22: "SPACE", 23: "EOF", 24: "GRAPH", 25: "NODIR", 26: "DIR", 38: "subgraph", 40: "SQS", 41: "SQE", 42: "end", 44: "acc_title", 45: "acc_title_value", 46: "acc_descr", 47: "acc_descr_value", 48: "acc_descr_multiline_value", 52: "AMP", 53: "STYLE_SEPARATOR", 55: "DOUBLECIRCLESTART", 56: "DOUBLECIRCLEEND", 57: "PS", 58: "PE", 59: "(-", 60: "-)", 61: "STADIUMSTART", 62: "STADIUMEND", 63: "SUBROUTINESTART", 64: "SUBROUTINEEND", 65: "VERTEX_WITH_PROPS_START", 66: "ALPHA", 67: "COLON", 68: "PIPE", 69: "CYLINDERSTART", 70: "CYLINDEREND", 71: "DIAMOND_START", 72: "DIAMOND_STOP", 73: "TAGEND", 74: "TRAPSTART", 75: "TRAPEND", 76: "INVTRAPSTART", 77: "INVTRAPEND", 80: "TESTSTR", 81: "START_LINK", 82: "LINK", 84: "STR", 86: "STYLE", 87: "LINKSTYLE", 88: "CLASSDEF", 89: "CLASS", 90: "CLICK", 91: "DOWN", 92: "UP", 95: "DEFAULT", 98: "CALLBACKNAME", 99: "CALLBACKARGS", 100: "HREF", 101: "LINK_TARGET", 102: "HEX", 104: "INTERPOLATE", 105: "NUM", 106: "COMMA", 109: "MINUS", 110: "UNIT", 111: "BRKT", 112: "DOT", 113: "PCT", 114: "TAGSTART", 118: "direction_tb", 119: "direction_bt", 120: "direction_rl", 121: "direction_lr", 122: "PUNCTUATION", 123: "UNICODE_TEXT", 124: "PLUS", 125: "EQUALS", 126: "MULT", 127: "UNDERSCORE", 129: "ARROW_CROSS", 130: "ARROW_POINT", 131: "ARROW_CIRCLE", 132: "ARROW_OPEN", 133: "QUOTE" },
    productions_: [0, [3, 1], [3, 2], [5, 4], [5, 6], [6, 1], [7, 1], [11, 1], [8, 1], [4, 2], [17, 0], [17, 2], [18, 1], [18, 1], [18, 1], [18, 1], [18, 1], [16, 2], [16, 2], [16, 2], [16, 3], [28, 2], [28, 1], [29, 1], [29, 1], [29, 1], [27, 1], [27, 1], [27, 2], [31, 2], [31, 2], [31, 1], [31, 1], [30, 2], [30, 1], [19, 2], [19, 2], [19, 2], [19, 2], [19, 2], [19, 2], [19, 9], [19, 6], [19, 4], [19, 1], [19, 2], [19, 2], [19, 1], [9, 1], [9, 1], [9, 1], [32, 3], [32, 4], [32, 2], [32, 1], [50, 1], [50, 5], [50, 3], [51, 4], [51, 4], [51, 6], [51, 4], [51, 4], [51, 4], [51, 8], [51, 4], [51, 4], [51, 4], [51, 6], [51, 4], [51, 4], [51, 4], [51, 4], [51, 4], [51, 1], [49, 2], [49, 3], [49, 3], [49, 1], [49, 3], [78, 1], [79, 3], [39, 1], [39, 2], [39, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [93, 1], [93, 2], [35, 5], [35, 5], [36, 5], [37, 2], [37, 4], [37, 3], [37, 5], [37, 2], [37, 4], [37, 4], [37, 6], [37, 2], [37, 4], [37, 2], [37, 4], [37, 4], [37, 6], [33, 5], [33, 5], [34, 5], [34, 5], [34, 9], [34, 9], [34, 7], [34, 7], [103, 1], [103, 3], [96, 1], [96, 3], [107, 1], [107, 2], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [94, 1], [94, 1], [94, 1], [94, 1], [54, 1], [54, 2], [97, 1], [97, 2], [117, 1], [117, 1], [117, 1], [117, 1], [43, 1], [43, 1], [43, 1], [43, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 5:
          yy.parseDirective("%%{", "open_directive");
          break;
        case 6:
          yy.parseDirective($$[$0], "type_directive");
          break;
        case 7:
          $$[$0] = $$[$0].trim().replace(/'/g, '"');
          yy.parseDirective($$[$0], "arg_directive");
          break;
        case 8:
          yy.parseDirective("}%%", "close_directive", "flowchart");
          break;
        case 10:
          this.$ = [];
          break;
        case 11:
          if (!Array.isArray($$[$0]) || $$[$0].length > 0) {
            $$[$0 - 1].push($$[$0]);
          }
          this.$ = $$[$0 - 1];
          break;
        case 12:
        case 82:
        case 84:
        case 96:
        case 152:
        case 154:
        case 155:
          this.$ = $$[$0];
          break;
        case 19:
          yy.setDirection("TB");
          this.$ = "TB";
          break;
        case 20:
          yy.setDirection($$[$0 - 1]);
          this.$ = $$[$0 - 1];
          break;
        case 35:
          this.$ = $$[$0 - 1].nodes;
          break;
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
          this.$ = [];
          break;
        case 41:
          this.$ = yy.addSubGraph($$[$0 - 6], $$[$0 - 1], $$[$0 - 4]);
          break;
        case 42:
          this.$ = yy.addSubGraph($$[$0 - 3], $$[$0 - 1], $$[$0 - 3]);
          break;
        case 43:
          this.$ = yy.addSubGraph(void 0, $$[$0 - 1], void 0);
          break;
        case 45:
          this.$ = $$[$0].trim();
          yy.setAccTitle(this.$);
          break;
        case 46:
        case 47:
          this.$ = $$[$0].trim();
          yy.setAccDescription(this.$);
          break;
        case 51:
          yy.addLink($$[$0 - 2].stmt, $$[$0], $$[$0 - 1]);
          this.$ = { stmt: $$[$0], nodes: $$[$0].concat($$[$0 - 2].nodes) };
          break;
        case 52:
          yy.addLink($$[$0 - 3].stmt, $$[$0 - 1], $$[$0 - 2]);
          this.$ = { stmt: $$[$0 - 1], nodes: $$[$0 - 1].concat($$[$0 - 3].nodes) };
          break;
        case 53:
          this.$ = { stmt: $$[$0 - 1], nodes: $$[$0 - 1] };
          break;
        case 54:
          this.$ = { stmt: $$[$0], nodes: $$[$0] };
          break;
        case 55:
          this.$ = [$$[$0]];
          break;
        case 56:
          this.$ = $$[$0 - 4].concat($$[$0]);
          break;
        case 57:
          this.$ = [$$[$0 - 2]];
          yy.setClass($$[$0 - 2], $$[$0]);
          break;
        case 58:
          this.$ = $$[$0 - 3];
          yy.addVertex($$[$0 - 3], $$[$0 - 1], "square");
          break;
        case 59:
          this.$ = $$[$0 - 3];
          yy.addVertex($$[$0 - 3], $$[$0 - 1], "doublecircle");
          break;
        case 60:
          this.$ = $$[$0 - 5];
          yy.addVertex($$[$0 - 5], $$[$0 - 2], "circle");
          break;
        case 61:
          this.$ = $$[$0 - 3];
          yy.addVertex($$[$0 - 3], $$[$0 - 1], "ellipse");
          break;
        case 62:
          this.$ = $$[$0 - 3];
          yy.addVertex($$[$0 - 3], $$[$0 - 1], "stadium");
          break;
        case 63:
          this.$ = $$[$0 - 3];
          yy.addVertex($$[$0 - 3], $$[$0 - 1], "subroutine");
          break;
        case 64:
          this.$ = $$[$0 - 7];
          yy.addVertex($$[$0 - 7], $$[$0 - 1], "rect", void 0, void 0, void 0, Object.fromEntries([[$$[$0 - 5], $$[$0 - 3]]]));
          break;
        case 65:
          this.$ = $$[$0 - 3];
          yy.addVertex($$[$0 - 3], $$[$0 - 1], "cylinder");
          break;
        case 66:
          this.$ = $$[$0 - 3];
          yy.addVertex($$[$0 - 3], $$[$0 - 1], "round");
          break;
        case 67:
          this.$ = $$[$0 - 3];
          yy.addVertex($$[$0 - 3], $$[$0 - 1], "diamond");
          break;
        case 68:
          this.$ = $$[$0 - 5];
          yy.addVertex($$[$0 - 5], $$[$0 - 2], "hexagon");
          break;
        case 69:
          this.$ = $$[$0 - 3];
          yy.addVertex($$[$0 - 3], $$[$0 - 1], "odd");
          break;
        case 70:
          this.$ = $$[$0 - 3];
          yy.addVertex($$[$0 - 3], $$[$0 - 1], "trapezoid");
          break;
        case 71:
          this.$ = $$[$0 - 3];
          yy.addVertex($$[$0 - 3], $$[$0 - 1], "inv_trapezoid");
          break;
        case 72:
          this.$ = $$[$0 - 3];
          yy.addVertex($$[$0 - 3], $$[$0 - 1], "lean_right");
          break;
        case 73:
          this.$ = $$[$0 - 3];
          yy.addVertex($$[$0 - 3], $$[$0 - 1], "lean_left");
          break;
        case 74:
          this.$ = $$[$0];
          yy.addVertex($$[$0]);
          break;
        case 75:
          $$[$0 - 1].text = $$[$0];
          this.$ = $$[$0 - 1];
          break;
        case 76:
        case 77:
          $$[$0 - 2].text = $$[$0 - 1];
          this.$ = $$[$0 - 2];
          break;
        case 78:
          this.$ = $$[$0];
          break;
        case 79:
          var inf = yy.destructLink($$[$0], $$[$0 - 2]);
          this.$ = { "type": inf.type, "stroke": inf.stroke, "length": inf.length, "text": $$[$0 - 1] };
          break;
        case 80:
          var inf = yy.destructLink($$[$0]);
          this.$ = { "type": inf.type, "stroke": inf.stroke, "length": inf.length };
          break;
        case 81:
          this.$ = $$[$0 - 1];
          break;
        case 83:
        case 97:
        case 153:
          this.$ = $$[$0 - 1] + "" + $$[$0];
          break;
        case 98:
        case 99:
          this.$ = $$[$0 - 4];
          yy.addClass($$[$0 - 2], $$[$0]);
          break;
        case 100:
          this.$ = $$[$0 - 4];
          yy.setClass($$[$0 - 2], $$[$0]);
          break;
        case 101:
        case 109:
          this.$ = $$[$0 - 1];
          yy.setClickEvent($$[$0 - 1], $$[$0]);
          break;
        case 102:
        case 110:
          this.$ = $$[$0 - 3];
          yy.setClickEvent($$[$0 - 3], $$[$0 - 2]);
          yy.setTooltip($$[$0 - 3], $$[$0]);
          break;
        case 103:
          this.$ = $$[$0 - 2];
          yy.setClickEvent($$[$0 - 2], $$[$0 - 1], $$[$0]);
          break;
        case 104:
          this.$ = $$[$0 - 4];
          yy.setClickEvent($$[$0 - 4], $$[$0 - 3], $$[$0 - 2]);
          yy.setTooltip($$[$0 - 4], $$[$0]);
          break;
        case 105:
        case 111:
          this.$ = $$[$0 - 1];
          yy.setLink($$[$0 - 1], $$[$0]);
          break;
        case 106:
        case 112:
          this.$ = $$[$0 - 3];
          yy.setLink($$[$0 - 3], $$[$0 - 2]);
          yy.setTooltip($$[$0 - 3], $$[$0]);
          break;
        case 107:
        case 113:
          this.$ = $$[$0 - 3];
          yy.setLink($$[$0 - 3], $$[$0 - 2], $$[$0]);
          break;
        case 108:
        case 114:
          this.$ = $$[$0 - 5];
          yy.setLink($$[$0 - 5], $$[$0 - 4], $$[$0]);
          yy.setTooltip($$[$0 - 5], $$[$0 - 2]);
          break;
        case 115:
          this.$ = $$[$0 - 4];
          yy.addVertex($$[$0 - 2], void 0, void 0, $$[$0]);
          break;
        case 116:
        case 118:
          this.$ = $$[$0 - 4];
          yy.updateLink($$[$0 - 2], $$[$0]);
          break;
        case 117:
          this.$ = $$[$0 - 4];
          yy.updateLink([$$[$0 - 2]], $$[$0]);
          break;
        case 119:
          this.$ = $$[$0 - 8];
          yy.updateLinkInterpolate([$$[$0 - 6]], $$[$0 - 2]);
          yy.updateLink([$$[$0 - 6]], $$[$0]);
          break;
        case 120:
          this.$ = $$[$0 - 8];
          yy.updateLinkInterpolate($$[$0 - 6], $$[$0 - 2]);
          yy.updateLink($$[$0 - 6], $$[$0]);
          break;
        case 121:
          this.$ = $$[$0 - 6];
          yy.updateLinkInterpolate([$$[$0 - 4]], $$[$0]);
          break;
        case 122:
          this.$ = $$[$0 - 6];
          yy.updateLinkInterpolate($$[$0 - 4], $$[$0]);
          break;
        case 123:
        case 125:
          this.$ = [$$[$0]];
          break;
        case 124:
        case 126:
          $$[$0 - 2].push($$[$0]);
          this.$ = $$[$0 - 2];
          break;
        case 128:
          this.$ = $$[$0 - 1] + $$[$0];
          break;
        case 150:
          this.$ = $$[$0];
          break;
        case 151:
          this.$ = $$[$0 - 1] + "" + $$[$0];
          break;
        case 156:
          this.$ = "v";
          break;
        case 157:
          this.$ = "-";
          break;
        case 158:
          this.$ = { stmt: "dir", value: "TB" };
          break;
        case 159:
          this.$ = { stmt: "dir", value: "BT" };
          break;
        case 160:
          this.$ = { stmt: "dir", value: "RL" };
          break;
        case 161:
          this.$ = { stmt: "dir", value: "LR" };
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 5: 3, 6: 5, 12: $V0, 16: 4, 21: $V1, 22: $V2, 24: $V3 }, { 1: [3] }, { 1: [2, 1] }, { 3: 10, 4: 2, 5: 3, 6: 5, 12: $V0, 16: 4, 21: $V1, 22: $V2, 24: $V3 }, o($V4, $V5, { 17: 11 }), { 7: 12, 13: [1, 13] }, { 16: 14, 21: $V1, 22: $V2, 24: $V3 }, { 16: 15, 21: $V1, 22: $V2, 24: $V3 }, { 25: [1, 16], 26: [1, 17] }, { 13: [2, 5] }, { 1: [2, 2] }, { 1: [2, 9], 18: 18, 19: 19, 20: $V6, 21: $V7, 22: $V8, 23: $V9, 32: 24, 33: 25, 34: 26, 35: 27, 36: 28, 37: 29, 38: $Va, 43: 31, 44: $Vb, 46: $Vc, 48: $Vd, 50: 35, 51: 45, 52: $Ve, 54: 46, 66: $Vf, 67: $Vg, 86: $Vh, 87: $Vi, 88: $Vj, 89: $Vk, 90: $Vl, 91: $Vm, 95: $Vn, 105: $Vo, 106: $Vp, 109: $Vq, 111: $Vr, 112: $Vs, 116: 47, 118: $Vt, 119: $Vu, 120: $Vv, 121: $Vw, 122: $Vx, 123: $Vy, 124: $Vz, 125: $VA, 126: $VB, 127: $VC }, { 8: 64, 10: [1, 65], 15: $VD }, o([10, 15], [2, 6]), o($V4, [2, 17]), o($V4, [2, 18]), o($V4, [2, 19]), { 20: [1, 68], 21: [1, 69], 22: $VE, 27: 67, 30: 70 }, o($VF, [2, 11]), o($VF, [2, 12]), o($VF, [2, 13]), o($VF, [2, 14]), o($VF, [2, 15]), o($VF, [2, 16]), { 9: 72, 20: $VG, 21: $VH, 23: $VI, 49: 73, 78: 77, 81: [1, 78], 82: [1, 79] }, { 9: 80, 20: $VG, 21: $VH, 23: $VI }, { 9: 81, 20: $VG, 21: $VH, 23: $VI }, { 9: 82, 20: $VG, 21: $VH, 23: $VI }, { 9: 83, 20: $VG, 21: $VH, 23: $VI }, { 9: 84, 20: $VG, 21: $VH, 23: $VI }, { 9: 86, 20: $VG, 21: $VH, 22: [1, 85], 23: $VI }, o($VF, [2, 44]), { 45: [1, 87] }, { 47: [1, 88] }, o($VF, [2, 47]), o($VJ, [2, 54], { 30: 89, 22: $VE }), { 22: [1, 90] }, { 22: [1, 91] }, { 22: [1, 92] }, { 22: [1, 93] }, { 26: $VK, 52: $VL, 66: $VM, 67: $VN, 84: [1, 97], 91: $VO, 97: 96, 98: [1, 94], 100: [1, 95], 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 115: 100, 117: 98, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($VF, [2, 158]), o($VF, [2, 159]), o($VF, [2, 160]), o($VF, [2, 161]), o($V_, [2, 55], { 53: [1, 116] }), o($V$, [2, 74], { 116: 129, 40: [1, 117], 52: $Ve, 55: [1, 118], 57: [1, 119], 59: [1, 120], 61: [1, 121], 63: [1, 122], 65: [1, 123], 66: $Vf, 67: $Vg, 69: [1, 124], 71: [1, 125], 73: [1, 126], 74: [1, 127], 76: [1, 128], 91: $Vm, 95: $Vn, 105: $Vo, 106: $Vp, 109: $Vq, 111: $Vr, 112: $Vs, 122: $Vx, 123: $Vy, 124: $Vz, 125: $VA, 126: $VB, 127: $VC }), o($V01, [2, 150]), o($V01, [2, 175]), o($V01, [2, 176]), o($V01, [2, 177]), o($V01, [2, 178]), o($V01, [2, 179]), o($V01, [2, 180]), o($V01, [2, 181]), o($V01, [2, 182]), o($V01, [2, 183]), o($V01, [2, 184]), o($V01, [2, 185]), o($V01, [2, 186]), o($V01, [2, 187]), o($V01, [2, 188]), o($V01, [2, 189]), o($V01, [2, 190]), { 9: 130, 20: $VG, 21: $VH, 23: $VI }, { 11: 131, 14: [1, 132] }, o($V11, [2, 8]), o($V4, [2, 20]), o($V4, [2, 26]), o($V4, [2, 27]), { 21: [1, 133] }, o($V21, [2, 34], { 30: 134, 22: $VE }), o($VF, [2, 35]), { 50: 135, 51: 45, 52: $Ve, 54: 46, 66: $Vf, 67: $Vg, 91: $Vm, 95: $Vn, 105: $Vo, 106: $Vp, 109: $Vq, 111: $Vr, 112: $Vs, 116: 47, 122: $Vx, 123: $Vy, 124: $Vz, 125: $VA, 126: $VB, 127: $VC }, o($V31, [2, 48]), o($V31, [2, 49]), o($V31, [2, 50]), o($V41, [2, 78], { 79: 136, 68: [1, 138], 80: [1, 137] }), { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 139, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o([52, 66, 67, 68, 80, 91, 95, 105, 106, 109, 111, 112, 122, 123, 124, 125, 126, 127], [2, 80]), o($VF, [2, 36]), o($VF, [2, 37]), o($VF, [2, 38]), o($VF, [2, 39]), o($VF, [2, 40]), { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 163, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($Vo1, $V5, { 17: 164 }), o($VF, [2, 45]), o($VF, [2, 46]), o($VJ, [2, 53], { 52: $Vp1 }), { 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 97: 166, 102: [1, 167], 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 115: 100, 117: 98, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 95: [1, 168], 103: 169, 105: [1, 170] }, { 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 95: [1, 171], 97: 172, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 115: 100, 117: 98, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 97: 173, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 115: 100, 117: 98, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($V11, [2, 101], { 22: [1, 174], 99: [1, 175] }), o($V11, [2, 105], { 22: [1, 176] }), o($V11, [2, 109], { 115: 100, 117: 178, 22: [1, 177], 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }), o($V11, [2, 111], { 22: [1, 179] }), o($Vq1, [2, 152]), o($Vq1, [2, 154]), o($Vq1, [2, 155]), o($Vq1, [2, 156]), o($Vq1, [2, 157]), o($Vr1, [2, 162]), o($Vr1, [2, 163]), o($Vr1, [2, 164]), o($Vr1, [2, 165]), o($Vr1, [2, 166]), o($Vr1, [2, 167]), o($Vr1, [2, 168]), o($Vr1, [2, 169]), o($Vr1, [2, 170]), o($Vr1, [2, 171]), o($Vr1, [2, 172]), o($Vr1, [2, 173]), o($Vr1, [2, 174]), { 52: $Ve, 54: 180, 66: $Vf, 67: $Vg, 91: $Vm, 95: $Vn, 105: $Vo, 106: $Vp, 109: $Vq, 111: $Vr, 112: $Vs, 116: 47, 122: $Vx, 123: $Vy, 124: $Vz, 125: $VA, 126: $VB, 127: $VC }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 181, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 182, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 184, 42: $V91, 52: $VL, 57: [1, 183], 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 185, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 186, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 187, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 66: [1, 188] }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 189, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 190, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 71: [1, 191], 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 192, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 193, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 194, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($V01, [2, 151]), o($Vs1, [2, 3]), { 8: 195, 15: $VD }, { 15: [2, 7] }, o($V4, [2, 28]), o($V21, [2, 33]), o($VJ, [2, 51], { 30: 196, 22: $VE }), o($V41, [2, 75], { 22: [1, 197] }), { 22: [1, 198] }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 199, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 82: [1, 200], 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($Vr1, [2, 82]), o($Vr1, [2, 84]), o($Vr1, [2, 140]), o($Vr1, [2, 141]), o($Vr1, [2, 142]), o($Vr1, [2, 143]), o($Vr1, [2, 144]), o($Vr1, [2, 145]), o($Vr1, [2, 146]), o($Vr1, [2, 147]), o($Vr1, [2, 148]), o($Vr1, [2, 149]), o($Vr1, [2, 85]), o($Vr1, [2, 86]), o($Vr1, [2, 87]), o($Vr1, [2, 88]), o($Vr1, [2, 89]), o($Vr1, [2, 90]), o($Vr1, [2, 91]), o($Vr1, [2, 92]), o($Vr1, [2, 93]), o($Vr1, [2, 94]), o($Vr1, [2, 95]), { 9: 203, 20: $VG, 21: $VH, 22: $V51, 23: $VI, 24: $V61, 26: $V71, 38: $V81, 40: [1, 202], 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 18: 18, 19: 19, 20: $V6, 21: $V7, 22: $V8, 23: $V9, 32: 24, 33: 25, 34: 26, 35: 27, 36: 28, 37: 29, 38: $Va, 42: [1, 204], 43: 31, 44: $Vb, 46: $Vc, 48: $Vd, 50: 35, 51: 45, 52: $Ve, 54: 46, 66: $Vf, 67: $Vg, 86: $Vh, 87: $Vi, 88: $Vj, 89: $Vk, 90: $Vl, 91: $Vm, 95: $Vn, 105: $Vo, 106: $Vp, 109: $Vq, 111: $Vr, 112: $Vs, 116: 47, 118: $Vt, 119: $Vu, 120: $Vv, 121: $Vw, 122: $Vx, 123: $Vy, 124: $Vz, 125: $VA, 126: $VB, 127: $VC }, { 22: $VE, 30: 205 }, { 22: [1, 206], 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 115: 100, 117: 178, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: [1, 207] }, { 22: [1, 208] }, { 22: [1, 209], 106: [1, 210] }, o($Vt1, [2, 123]), { 22: [1, 211] }, { 22: [1, 212], 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 115: 100, 117: 178, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: [1, 213], 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 115: 100, 117: 178, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 84: [1, 214] }, o($V11, [2, 103], { 22: [1, 215] }), { 84: [1, 216], 101: [1, 217] }, { 84: [1, 218] }, o($Vq1, [2, 153]), { 84: [1, 219], 101: [1, 220] }, o($V_, [2, 57], { 116: 129, 52: $Ve, 66: $Vf, 67: $Vg, 91: $Vm, 95: $Vn, 105: $Vo, 106: $Vp, 109: $Vq, 111: $Vr, 112: $Vs, 122: $Vx, 123: $Vy, 124: $Vz, 125: $VA, 126: $VB, 127: $VC }), { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 41: [1, 221], 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 56: [1, 222], 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 223, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 58: [1, 224], 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 60: [1, 225], 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 62: [1, 226], 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 64: [1, 227], 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 67: [1, 228] }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 70: [1, 229], 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 72: [1, 230], 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 231, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 41: [1, 232], 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 75: [1, 233], 77: [1, 234], 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 75: [1, 236], 77: [1, 235], 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 9: 237, 20: $VG, 21: $VH, 23: $VI }, o($VJ, [2, 52], { 52: $Vp1 }), o($V41, [2, 77]), o($V41, [2, 76]), { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 68: [1, 238], 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($V41, [2, 79]), o($Vr1, [2, 83]), { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 239, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($Vo1, $V5, { 17: 240 }), o($VF, [2, 43]), { 51: 241, 52: $Ve, 54: 46, 66: $Vf, 67: $Vg, 91: $Vm, 95: $Vn, 105: $Vo, 106: $Vp, 109: $Vq, 111: $Vr, 112: $Vs, 116: 47, 122: $Vx, 123: $Vy, 124: $Vz, 125: $VA, 126: $VB, 127: $VC }, { 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 96: 242, 102: $Vy1, 105: $Vz1, 107: 243, 108: 244, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }, { 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 96: 256, 102: $Vy1, 105: $Vz1, 107: 243, 108: 244, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }, { 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 96: 257, 102: $Vy1, 104: [1, 258], 105: $Vz1, 107: 243, 108: 244, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }, { 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 96: 259, 102: $Vy1, 104: [1, 260], 105: $Vz1, 107: 243, 108: 244, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }, { 105: [1, 261] }, { 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 96: 262, 102: $Vy1, 105: $Vz1, 107: 243, 108: 244, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }, { 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 96: 263, 102: $Vy1, 105: $Vz1, 107: 243, 108: 244, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }, { 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 97: 264, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 115: 100, 117: 98, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($V11, [2, 102]), { 84: [1, 265] }, o($V11, [2, 106], { 22: [1, 266] }), o($V11, [2, 107]), o($V11, [2, 110]), o($V11, [2, 112], { 22: [1, 267] }), o($V11, [2, 113]), o($V$, [2, 58]), o($V$, [2, 59]), { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 58: [1, 268], 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($V$, [2, 66]), o($V$, [2, 61]), o($V$, [2, 62]), o($V$, [2, 63]), { 66: [1, 269] }, o($V$, [2, 65]), o($V$, [2, 67]), { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 72: [1, 270], 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($V$, [2, 69]), o($V$, [2, 70]), o($V$, [2, 72]), o($V$, [2, 71]), o($V$, [2, 73]), o($Vs1, [2, 4]), o([22, 52, 66, 67, 91, 95, 105, 106, 109, 111, 112, 122, 123, 124, 125, 126, 127], [2, 81]), { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 41: [1, 271], 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 18: 18, 19: 19, 20: $V6, 21: $V7, 22: $V8, 23: $V9, 32: 24, 33: 25, 34: 26, 35: 27, 36: 28, 37: 29, 38: $Va, 42: [1, 272], 43: 31, 44: $Vb, 46: $Vc, 48: $Vd, 50: 35, 51: 45, 52: $Ve, 54: 46, 66: $Vf, 67: $Vg, 86: $Vh, 87: $Vi, 88: $Vj, 89: $Vk, 90: $Vl, 91: $Vm, 95: $Vn, 105: $Vo, 106: $Vp, 109: $Vq, 111: $Vr, 112: $Vs, 116: 47, 118: $Vt, 119: $Vu, 120: $Vv, 121: $Vw, 122: $Vx, 123: $Vy, 124: $Vz, 125: $VA, 126: $VB, 127: $VC }, o($V_, [2, 56]), o($V11, [2, 115], { 106: $VF1 }), o($VG1, [2, 125], { 108: 274, 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 102: $Vy1, 105: $Vz1, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }), o($VH1, [2, 127]), o($VH1, [2, 129]), o($VH1, [2, 130]), o($VH1, [2, 131]), o($VH1, [2, 132]), o($VH1, [2, 133]), o($VH1, [2, 134]), o($VH1, [2, 135]), o($VH1, [2, 136]), o($VH1, [2, 137]), o($VH1, [2, 138]), o($VH1, [2, 139]), o($V11, [2, 116], { 106: $VF1 }), o($V11, [2, 117], { 106: $VF1 }), { 22: [1, 275] }, o($V11, [2, 118], { 106: $VF1 }), { 22: [1, 276] }, o($Vt1, [2, 124]), o($V11, [2, 98], { 106: $VF1 }), o($V11, [2, 99], { 106: $VF1 }), o($V11, [2, 100], { 115: 100, 117: 178, 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }), o($V11, [2, 104]), { 101: [1, 277] }, { 101: [1, 278] }, { 58: [1, 279] }, { 68: [1, 280] }, { 72: [1, 281] }, { 9: 282, 20: $VG, 21: $VH, 23: $VI }, o($VF, [2, 42]), { 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 102: $Vy1, 105: $Vz1, 107: 283, 108: 244, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }, o($VH1, [2, 128]), { 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 97: 284, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 115: 100, 117: 98, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 97: 285, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 115: 100, 117: 98, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($V11, [2, 108]), o($V11, [2, 114]), o($V$, [2, 60]), { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 286, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($V$, [2, 68]), o($Vo1, $V5, { 17: 287 }), o($VG1, [2, 126], { 108: 274, 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 102: $Vy1, 105: $Vz1, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }), o($V11, [2, 121], { 115: 100, 117: 178, 22: [1, 288], 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }), o($V11, [2, 122], { 115: 100, 117: 178, 22: [1, 289], 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }), { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 41: [1, 290], 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 18: 18, 19: 19, 20: $V6, 21: $V7, 22: $V8, 23: $V9, 32: 24, 33: 25, 34: 26, 35: 27, 36: 28, 37: 29, 38: $Va, 42: [1, 291], 43: 31, 44: $Vb, 46: $Vc, 48: $Vd, 50: 35, 51: 45, 52: $Ve, 54: 46, 66: $Vf, 67: $Vg, 86: $Vh, 87: $Vi, 88: $Vj, 89: $Vk, 90: $Vl, 91: $Vm, 95: $Vn, 105: $Vo, 106: $Vp, 109: $Vq, 111: $Vr, 112: $Vs, 116: 47, 118: $Vt, 119: $Vu, 120: $Vv, 121: $Vw, 122: $Vx, 123: $Vy, 124: $Vz, 125: $VA, 126: $VB, 127: $VC }, { 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 96: 292, 102: $Vy1, 105: $Vz1, 107: 243, 108: 244, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }, { 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 96: 293, 102: $Vy1, 105: $Vz1, 107: 243, 108: 244, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }, o($V$, [2, 64]), o($VF, [2, 41]), o($V11, [2, 119], { 106: $VF1 }), o($V11, [2, 120], { 106: $VF1 })],
    defaultActions: { 2: [2, 1], 9: [2, 5], 10: [2, 2], 132: [2, 7] },
    parseError: function parseError(str, hash2) {
      if (hash2.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash2;
        throw error;
      }
    },
    parse: function parse2(input) {
      var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k2 in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
          sharedState.yy[k2] = this.yy[k2];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges2 = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function lex() {
        var token2;
        token2 = tstack.pop() || lexer2.lex() || EOF2;
        if (typeof token2 !== "number") {
          if (token2 instanceof Array) {
            tstack = token2;
            token2 = tstack.pop();
          }
          token2 = self2.symbols_[token2] || token2;
        }
        return token2;
      }
      var symbol2, state, action, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack2[stack2.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol2 === null || typeof symbol2 == "undefined") {
            symbol2 = lex();
          }
          action = table[state] && table[state][symbol2];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push("'" + this.terminals_[p] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol2] || symbol2) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol2 == EOF2 ? "end of input" : "'" + (this.terminals_[symbol2] || symbol2) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol2] || symbol2,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol2);
        }
        switch (action[0]) {
          case 1:
            stack2.push(symbol2);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack2.push(action[1]);
            symbol2 = null;
            {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges2) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
              ];
            }
            r = this.performAction.apply(yyval, [
              yytext,
              yyleng,
              yylineno,
              sharedState.yy,
              action[1],
              vstack,
              lstack
            ].concat(args));
            if (typeof r !== "undefined") {
              return r;
            }
            if (len) {
              stack2 = stack2.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack2.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
            stack2.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash2) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash2);
        } else {
          throw new Error(str);
        }
      },
      setInput: function(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      input: function() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      unput: function(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      more: function() {
        this._more = true;
        return this;
      },
      reject: function() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      less: function(n) {
        this.unput(this.match.slice(n));
      },
      pastInput: function() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var next2 = this.match;
        if (next2.length < 20) {
          next2 += this._input.substr(0, 20 - next2.length);
        }
        return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var pre = this.pastInput();
        var c2 = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c2 + "^";
      },
      test_match: function(match, indexed_rule) {
        var token2, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token2) {
          return token2;
        } else if (this._backtrack) {
          for (var k2 in backup) {
            this[k2] = backup[k2];
          }
          return false;
        }
        return false;
      },
      next: function() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token2, match, tempMatch, index2;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index2 = i;
            if (this.options.backtrack_lexer) {
              token2 = this.test_match(tempMatch, rules[i]);
              if (token2 !== false) {
                return token2;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token2 = this.test_match(match, rules[index2]);
          if (token2 !== false) {
            return token2;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: {},
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        switch ($avoiding_name_collisions) {
          case 0:
            this.begin("open_directive");
            return 12;
          case 1:
            this.begin("type_directive");
            return 13;
          case 2:
            this.popState();
            this.begin("arg_directive");
            return 10;
          case 3:
            this.popState();
            this.popState();
            return 15;
          case 4:
            return 14;
          case 5:
            break;
          case 6:
            break;
          case 7:
            this.begin("acc_title");
            return 44;
          case 8:
            this.popState();
            return "acc_title_value";
          case 9:
            this.begin("acc_descr");
            return 46;
          case 10:
            this.popState();
            return "acc_descr_value";
          case 11:
            this.begin("acc_descr_multiline");
            break;
          case 12:
            this.popState();
            break;
          case 13:
            return "acc_descr_multiline_value";
          case 14:
            this.begin("string");
            break;
          case 15:
            this.popState();
            break;
          case 16:
            return "STR";
          case 17:
            return 86;
          case 18:
            return 95;
          case 19:
            return 87;
          case 20:
            return 104;
          case 21:
            return 88;
          case 22:
            return 89;
          case 23:
            this.begin("href");
            break;
          case 24:
            this.popState();
            break;
          case 25:
            return 100;
          case 26:
            this.begin("callbackname");
            break;
          case 27:
            this.popState();
            break;
          case 28:
            this.popState();
            this.begin("callbackargs");
            break;
          case 29:
            return 98;
          case 30:
            this.popState();
            break;
          case 31:
            return 99;
          case 32:
            this.begin("click");
            break;
          case 33:
            this.popState();
            break;
          case 34:
            return 90;
          case 35:
            if (yy.lex.firstGraph()) {
              this.begin("dir");
            }
            return 24;
          case 36:
            if (yy.lex.firstGraph()) {
              this.begin("dir");
            }
            return 24;
          case 37:
            return 38;
          case 38:
            return 42;
          case 39:
            return 101;
          case 40:
            return 101;
          case 41:
            return 101;
          case 42:
            return 101;
          case 43:
            this.popState();
            return 25;
          case 44:
            this.popState();
            return 26;
          case 45:
            this.popState();
            return 26;
          case 46:
            this.popState();
            return 26;
          case 47:
            this.popState();
            return 26;
          case 48:
            this.popState();
            return 26;
          case 49:
            this.popState();
            return 26;
          case 50:
            this.popState();
            return 26;
          case 51:
            this.popState();
            return 26;
          case 52:
            this.popState();
            return 26;
          case 53:
            this.popState();
            return 26;
          case 54:
            return 118;
          case 55:
            return 119;
          case 56:
            return 120;
          case 57:
            return 121;
          case 58:
            return 105;
          case 59:
            return 111;
          case 60:
            return 53;
          case 61:
            return 67;
          case 62:
            return 52;
          case 63:
            return 20;
          case 64:
            return 106;
          case 65:
            return 126;
          case 66:
            return 82;
          case 67:
            return 82;
          case 68:
            return 82;
          case 69:
            return 82;
          case 70:
            return 81;
          case 71:
            return 81;
          case 72:
            return 81;
          case 73:
            return 59;
          case 74:
            return 60;
          case 75:
            return 61;
          case 76:
            return 62;
          case 77:
            return 63;
          case 78:
            return 64;
          case 79:
            return 65;
          case 80:
            return 69;
          case 81:
            return 70;
          case 82:
            return 55;
          case 83:
            return 56;
          case 84:
            return 109;
          case 85:
            return 112;
          case 86:
            return 127;
          case 87:
            return 124;
          case 88:
            return 113;
          case 89:
            return 125;
          case 90:
            return 125;
          case 91:
            return 114;
          case 92:
            return 73;
          case 93:
            return 92;
          case 94:
            return "SEP";
          case 95:
            return 91;
          case 96:
            return 66;
          case 97:
            return 75;
          case 98:
            return 74;
          case 99:
            return 77;
          case 100:
            return 76;
          case 101:
            return 122;
          case 102:
            return 123;
          case 103:
            return 68;
          case 104:
            return 57;
          case 105:
            return 58;
          case 106:
            return 40;
          case 107:
            return 41;
          case 108:
            return 71;
          case 109:
            return 72;
          case 110:
            return 133;
          case 111:
            return 21;
          case 112:
            return 22;
          case 113:
            return 23;
        }
      },
      rules: [/^(?:%%\{)/, /^(?:((?:(?!\}%%)[^:.])*))/, /^(?::)/, /^(?:\}%%)/, /^(?:((?:(?!\}%%).|\n)*))/, /^(?:%%(?!\{)[^\n]*)/, /^(?:[^\}]%%[^\n]*)/, /^(?:accTitle\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*\{\s*)/, /^(?:[\}])/, /^(?:[^\}]*)/, /^(?:["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:style\b)/, /^(?:default\b)/, /^(?:linkStyle\b)/, /^(?:interpolate\b)/, /^(?:classDef\b)/, /^(?:class\b)/, /^(?:href[\s]+["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:call[\s]+)/, /^(?:\([\s]*\))/, /^(?:\()/, /^(?:[^(]*)/, /^(?:\))/, /^(?:[^)]*)/, /^(?:click[\s]+)/, /^(?:[\s\n])/, /^(?:[^\s\n]*)/, /^(?:graph\b)/, /^(?:flowchart\b)/, /^(?:subgraph\b)/, /^(?:end\b\s*)/, /^(?:_self\b)/, /^(?:_blank\b)/, /^(?:_parent\b)/, /^(?:_top\b)/, /^(?:(\r?\n)*\s*\n)/, /^(?:\s*LR\b)/, /^(?:\s*RL\b)/, /^(?:\s*TB\b)/, /^(?:\s*BT\b)/, /^(?:\s*TD\b)/, /^(?:\s*BR\b)/, /^(?:\s*<)/, /^(?:\s*>)/, /^(?:\s*\^)/, /^(?:\s*v\b)/, /^(?:.*direction\s+TB[^\n]*)/, /^(?:.*direction\s+BT[^\n]*)/, /^(?:.*direction\s+RL[^\n]*)/, /^(?:.*direction\s+LR[^\n]*)/, /^(?:[0-9]+)/, /^(?:#)/, /^(?::::)/, /^(?::)/, /^(?:&)/, /^(?:;)/, /^(?:,)/, /^(?:\*)/, /^(?:\s*[xo<]?--+[-xo>]\s*)/, /^(?:\s*[xo<]?==+[=xo>]\s*)/, /^(?:\s*[xo<]?-?\.+-[xo>]?\s*)/, /^(?:\s*~~[\~]+\s*)/, /^(?:\s*[xo<]?--\s*)/, /^(?:\s*[xo<]?==\s*)/, /^(?:\s*[xo<]?-\.\s*)/, /^(?:\(-)/, /^(?:-\))/, /^(?:\(\[)/, /^(?:\]\))/, /^(?:\[\[)/, /^(?:\]\])/, /^(?:\[\|)/, /^(?:\[\()/, /^(?:\)\])/, /^(?:\(\(\()/, /^(?:\)\)\))/, /^(?:-)/, /^(?:\.)/, /^(?:[\_])/, /^(?:\+)/, /^(?:%)/, /^(?:=)/, /^(?:=)/, /^(?:<)/, /^(?:>)/, /^(?:\^)/, /^(?:\\\|)/, /^(?:v\b)/, /^(?:[A-Za-z]+)/, /^(?:\\\])/, /^(?:\[\/)/, /^(?:\/\])/, /^(?:\[\\)/, /^(?:[!"#$%&'*+,-.`?\\_/])/, /^(?:[\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6]|[\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377]|[\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5]|[\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA]|[\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE]|[\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA]|[\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0]|[\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977]|[\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2]|[\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A]|[\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39]|[\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8]|[\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C]|[\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C]|[\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99]|[\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0]|[\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D]|[\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3]|[\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10]|[\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1]|[\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81]|[\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3]|[\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6]|[\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A]|[\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081]|[\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D]|[\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0]|[\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310]|[\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C]|[\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711]|[\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7]|[\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C]|[\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16]|[\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF]|[\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC]|[\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D]|[\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D]|[\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3]|[\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F]|[\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128]|[\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184]|[\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3]|[\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6]|[\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE]|[\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C]|[\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D]|[\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC]|[\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B]|[\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788]|[\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805]|[\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB]|[\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28]|[\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5]|[\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4]|[\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E]|[\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D]|[\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36]|[\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D]|[\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC]|[\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF]|[\uFFD2-\uFFD7\uFFDA-\uFFDC])/, /^(?:\|)/, /^(?:\()/, /^(?:\))/, /^(?:\[)/, /^(?:\])/, /^(?:\{)/, /^(?:\})/, /^(?:")/, /^(?:(\r?\n)+)/, /^(?:\s)/, /^(?:$)/],
      conditions: { "close_directive": { "rules": [], "inclusive": false }, "arg_directive": { "rules": [3, 4], "inclusive": false }, "type_directive": { "rules": [2, 3], "inclusive": false }, "open_directive": { "rules": [1], "inclusive": false }, "callbackargs": { "rules": [30, 31], "inclusive": false }, "callbackname": { "rules": [27, 28, 29], "inclusive": false }, "href": { "rules": [24, 25], "inclusive": false }, "click": { "rules": [33, 34], "inclusive": false }, "vertex": { "rules": [], "inclusive": false }, "dir": { "rules": [43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53], "inclusive": false }, "acc_descr_multiline": { "rules": [12, 13], "inclusive": false }, "acc_descr": { "rules": [10], "inclusive": false }, "acc_title": { "rules": [8], "inclusive": false }, "string": { "rules": [15, 16], "inclusive": false }, "INITIAL": { "rules": [0, 5, 6, 7, 9, 11, 14, 17, 18, 19, 20, 21, 22, 23, 26, 32, 35, 36, 37, 38, 39, 40, 41, 42, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113], "inclusive": true } }
    };
    return lexer2;
  }();
  parser2.lexer = lexer;
  function Parser2() {
    this.yy = {};
  }
  Parser2.prototype = parser2;
  parser2.Parser = Parser2;
  return new Parser2();
}();
parser$7.parser = parser$7;
const flowDetector = (txt, config2) => {
  var _a2;
  if (((_a2 = config2 == null ? void 0 : config2.flowchart) == null ? void 0 : _a2.defaultRenderer) === "dagre-wrapper")
    return false;
  return txt.match(/^\s*graph/) !== null;
};
const flowDetectorV2 = (txt, config2) => {
  var _a2;
  if (((_a2 = config2 == null ? void 0 : config2.flowchart) == null ? void 0 : _a2.defaultRenderer) === "dagre-wrapper" && txt.match(/^\s*graph/) !== null)
    return true;
  return txt.match(/^\s*flowchart/) !== null;
};
const MERMAID_DOM_ID_PREFIX = "flowchart-";
let vertexCounter = 0;
let config = getConfig$1();
let vertices = {};
let edges = [];
let classes$1 = [];
let subGraphs = [];
let subGraphLookup = {};
let tooltips = {};
let subCount = 0;
let firstGraphFlag = true;
let direction$1;
let version;
let funs$1 = [];
const sanitizeText = (txt) => common.sanitizeText(txt, config);
const parseDirective$7 = function(statement, context, type2) {
  mermaidAPI.parseDirective(this, statement, context, type2);
};
const lookUpDomId = function(id2) {
  const veritceKeys = Object.keys(vertices);
  for (let i = 0; i < veritceKeys.length; i++) {
    if (vertices[veritceKeys[i]].id === id2) {
      return vertices[veritceKeys[i]].domId;
    }
  }
  return id2;
};
const addVertex = function(_id, text2, type2, style2, classes2, dir, props = {}) {
  let txt;
  let id2 = _id;
  if (typeof id2 === "undefined") {
    return;
  }
  if (id2.trim().length === 0) {
    return;
  }
  if (typeof vertices[id2] === "undefined") {
    vertices[id2] = {
      id: id2,
      domId: MERMAID_DOM_ID_PREFIX + id2 + "-" + vertexCounter,
      styles: [],
      classes: []
    };
  }
  vertexCounter++;
  if (typeof text2 !== "undefined") {
    config = getConfig$1();
    txt = sanitizeText(text2.trim());
    if (txt[0] === '"' && txt[txt.length - 1] === '"') {
      txt = txt.substring(1, txt.length - 1);
    }
    vertices[id2].text = txt;
  } else {
    if (typeof vertices[id2].text === "undefined") {
      vertices[id2].text = _id;
    }
  }
  if (typeof type2 !== "undefined") {
    vertices[id2].type = type2;
  }
  if (typeof style2 !== "undefined") {
    if (style2 !== null) {
      style2.forEach(function(s2) {
        vertices[id2].styles.push(s2);
      });
    }
  }
  if (typeof classes2 !== "undefined") {
    if (classes2 !== null) {
      classes2.forEach(function(s2) {
        vertices[id2].classes.push(s2);
      });
    }
  }
  if (typeof dir !== "undefined") {
    vertices[id2].dir = dir;
  }
  vertices[id2].props = props;
};
const addSingleLink = function(_start, _end, type2, linktext) {
  let start2 = _start;
  let end2 = _end;
  const edge = { start: start2, end: end2, type: void 0, text: "" };
  linktext = type2.text;
  if (typeof linktext !== "undefined") {
    edge.text = sanitizeText(linktext.trim());
    if (edge.text[0] === '"' && edge.text[edge.text.length - 1] === '"') {
      edge.text = edge.text.substring(1, edge.text.length - 1);
    }
  }
  if (typeof type2 !== "undefined") {
    edge.type = type2.type;
    edge.stroke = type2.stroke;
    edge.length = type2.length;
  }
  edges.push(edge);
};
const addLink = function(_start, _end, type2, linktext) {
  let i, j2;
  for (i = 0; i < _start.length; i++) {
    for (j2 = 0; j2 < _end.length; j2++) {
      addSingleLink(_start[i], _end[j2], type2, linktext);
    }
  }
};
const updateLinkInterpolate = function(positions, interp) {
  positions.forEach(function(pos) {
    if (pos === "default") {
      edges.defaultInterpolate = interp;
    } else {
      edges[pos].interpolate = interp;
    }
  });
};
const updateLink = function(positions, style2) {
  positions.forEach(function(pos) {
    if (pos === "default") {
      edges.defaultStyle = style2;
    } else {
      if (utils.isSubstringInArray("fill", style2) === -1) {
        style2.push("fill:none");
      }
      edges[pos].style = style2;
    }
  });
};
const addClass = function(id2, style2) {
  if (typeof classes$1[id2] === "undefined") {
    classes$1[id2] = { id: id2, styles: [], textStyles: [] };
  }
  if (typeof style2 !== "undefined") {
    if (style2 !== null) {
      style2.forEach(function(s2) {
        if (s2.match("color")) {
          const newStyle1 = s2.replace("fill", "bgFill");
          const newStyle2 = newStyle1.replace("color", "fill");
          classes$1[id2].textStyles.push(newStyle2);
        }
        classes$1[id2].styles.push(s2);
      });
    }
  }
};
const setDirection$1 = function(dir) {
  direction$1 = dir;
  if (direction$1.match(/.*</)) {
    direction$1 = "RL";
  }
  if (direction$1.match(/.*\^/)) {
    direction$1 = "BT";
  }
  if (direction$1.match(/.*>/)) {
    direction$1 = "LR";
  }
  if (direction$1.match(/.*v/)) {
    direction$1 = "TB";
  }
};
const setClass$1 = function(ids, className2) {
  ids.split(",").forEach(function(_id) {
    let id2 = _id;
    if (typeof vertices[id2] !== "undefined") {
      vertices[id2].classes.push(className2);
    }
    if (typeof subGraphLookup[id2] !== "undefined") {
      subGraphLookup[id2].classes.push(className2);
    }
  });
};
const setTooltip = function(ids, tooltip) {
  ids.split(",").forEach(function(id2) {
    if (typeof tooltip !== "undefined") {
      tooltips[version === "gen-1" ? lookUpDomId(id2) : id2] = sanitizeText(tooltip);
    }
  });
};
const setClickFun$1 = function(id2, functionName, functionArgs) {
  let domId = lookUpDomId(id2);
  if (getConfig$1().securityLevel !== "loose") {
    return;
  }
  if (typeof functionName === "undefined") {
    return;
  }
  let argList = [];
  if (typeof functionArgs === "string") {
    argList = functionArgs.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
    for (let i = 0; i < argList.length; i++) {
      let item = argList[i].trim();
      if (item.charAt(0) === '"' && item.charAt(item.length - 1) === '"') {
        item = item.substr(1, item.length - 2);
      }
      argList[i] = item;
    }
  }
  if (argList.length === 0) {
    argList.push(id2);
  }
  if (typeof vertices[id2] !== "undefined") {
    vertices[id2].haveCallback = true;
    funs$1.push(function() {
      const elem = document.querySelector(`[id="${domId}"]`);
      if (elem !== null) {
        elem.addEventListener(
          "click",
          function() {
            utils.runFunc(functionName, ...argList);
          },
          false
        );
      }
    });
  }
};
const setLink$1 = function(ids, linkStr, target) {
  ids.split(",").forEach(function(id2) {
    if (typeof vertices[id2] !== "undefined") {
      vertices[id2].link = utils.formatUrl(linkStr, config);
      vertices[id2].linkTarget = target;
    }
  });
  setClass$1(ids, "clickable");
};
const getTooltip = function(id2) {
  return tooltips[id2];
};
const setClickEvent$1 = function(ids, functionName, functionArgs) {
  ids.split(",").forEach(function(id2) {
    setClickFun$1(id2, functionName, functionArgs);
  });
  setClass$1(ids, "clickable");
};
const bindFunctions$1 = function(element) {
  funs$1.forEach(function(fun) {
    fun(element);
  });
};
const getDirection$1 = function() {
  return direction$1.trim();
};
const getVertices = function() {
  return vertices;
};
const getEdges = function() {
  return edges;
};
const getClasses$4 = function() {
  return classes$1;
};
const setupToolTips = function(element) {
  let tooltipElem = select$1(".mermaidTooltip");
  if ((tooltipElem._groups || tooltipElem)[0][0] === null) {
    tooltipElem = select$1("body").append("div").attr("class", "mermaidTooltip").style("opacity", 0);
  }
  const svg2 = select$1(element).select("svg");
  const nodes = svg2.selectAll("g.node");
  nodes.on("mouseover", function() {
    const el = select$1(this);
    const title2 = el.attr("title");
    if (title2 === null) {
      return;
    }
    const rect2 = this.getBoundingClientRect();
    tooltipElem.transition().duration(200).style("opacity", ".9");
    tooltipElem.text(el.attr("title")).style("left", window.scrollX + rect2.left + (rect2.right - rect2.left) / 2 + "px").style("top", window.scrollY + rect2.top - 14 + document.body.scrollTop + "px");
    tooltipElem.html(tooltipElem.html().replace(/&lt;br\/&gt;/g, "<br/>"));
    el.classed("hover", true);
  }).on("mouseout", function() {
    tooltipElem.transition().duration(500).style("opacity", 0);
    const el = select$1(this);
    el.classed("hover", false);
  });
};
funs$1.push(setupToolTips);
const clear$6 = function(ver = "gen-1") {
  vertices = {};
  classes$1 = {};
  edges = [];
  funs$1 = [setupToolTips];
  subGraphs = [];
  subGraphLookup = {};
  subCount = 0;
  tooltips = [];
  firstGraphFlag = true;
  version = ver;
  clear$g();
};
const setGen = (ver) => {
  version = ver || "gen-1";
};
const defaultStyle = function() {
  return "fill:#ffa;stroke: #f66; stroke-width: 3px; stroke-dasharray: 5, 5;fill:#ffa;stroke: #666;";
};
const addSubGraph = function(_id, list2, _title) {
  let id2 = _id.trim();
  let title2 = _title.trim();
  if (id2 === title2 && title2.match(/\s/)) {
    id2 = void 0;
  }
  function uniq(a2) {
    const prims = { boolean: {}, number: {}, string: {} };
    const objs = [];
    let dir2;
    const nodeList2 = a2.filter(function(item) {
      const type2 = typeof item;
      if (item.stmt && item.stmt === "dir") {
        dir2 = item.value;
        return false;
      }
      if (item.trim() === "") {
        return false;
      }
      if (type2 in prims) {
        return prims[type2].hasOwnProperty(item) ? false : prims[type2][item] = true;
      } else {
        return objs.indexOf(item) >= 0 ? false : objs.push(item);
      }
    });
    return { nodeList: nodeList2, dir: dir2 };
  }
  let nodeList = [];
  const { nodeList: nl, dir } = uniq(nodeList.concat.apply(nodeList, list2));
  nodeList = nl;
  if (version === "gen-1") {
    for (let i = 0; i < nodeList.length; i++) {
      nodeList[i] = lookUpDomId(nodeList[i]);
    }
  }
  id2 = id2 || "subGraph" + subCount;
  title2 = title2 || "";
  title2 = sanitizeText(title2);
  subCount = subCount + 1;
  const subGraph = { id: id2, nodes: nodeList, title: title2.trim(), classes: [], dir };
  log$1.info("Adding", subGraph.id, subGraph.nodes, subGraph.dir);
  subGraph.nodes = makeUniq(subGraph, subGraphs).nodes;
  subGraphs.push(subGraph);
  subGraphLookup[id2] = subGraph;
  return id2;
};
const getPosForId = function(id2) {
  for (let i = 0; i < subGraphs.length; i++) {
    if (subGraphs[i].id === id2) {
      return i;
    }
  }
  return -1;
};
let secCount = -1;
const posCrossRef = [];
const indexNodes2 = function(id2, pos) {
  const nodes = subGraphs[pos].nodes;
  secCount = secCount + 1;
  if (secCount > 2e3) {
    return;
  }
  posCrossRef[secCount] = pos;
  if (subGraphs[pos].id === id2) {
    return {
      result: true,
      count: 0
    };
  }
  let count2 = 0;
  let posCount = 1;
  while (count2 < nodes.length) {
    const childPos = getPosForId(nodes[count2]);
    if (childPos >= 0) {
      const res = indexNodes2(id2, childPos);
      if (res.result) {
        return {
          result: true,
          count: posCount + res.count
        };
      } else {
        posCount = posCount + res.count;
      }
    }
    count2 = count2 + 1;
  }
  return {
    result: false,
    count: posCount
  };
};
const getDepthFirstPos = function(pos) {
  return posCrossRef[pos];
};
const indexNodes = function() {
  secCount = -1;
  if (subGraphs.length > 0) {
    indexNodes2("none", subGraphs.length - 1);
  }
};
const getSubGraphs = function() {
  return subGraphs;
};
const firstGraph = () => {
  if (firstGraphFlag) {
    firstGraphFlag = false;
    return true;
  }
  return false;
};
const destructStartLink = (_str) => {
  let str = _str.trim();
  let type2 = "arrow_open";
  switch (str[0]) {
    case "<":
      type2 = "arrow_point";
      str = str.slice(1);
      break;
    case "x":
      type2 = "arrow_cross";
      str = str.slice(1);
      break;
    case "o":
      type2 = "arrow_circle";
      str = str.slice(1);
      break;
  }
  let stroke = "normal";
  if (str.indexOf("=") !== -1) {
    stroke = "thick";
  }
  if (str.indexOf(".") !== -1) {
    stroke = "dotted";
  }
  return { type: type2, stroke };
};
const countChar = (char2, str) => {
  const length2 = str.length;
  let count2 = 0;
  for (let i = 0; i < length2; ++i) {
    if (str[i] === char2) {
      ++count2;
    }
  }
  return count2;
};
const destructEndLink = (_str) => {
  const str = _str.trim();
  let line2 = str.slice(0, -1);
  let type2 = "arrow_open";
  switch (str.slice(-1)) {
    case "x":
      type2 = "arrow_cross";
      if (str[0] === "x") {
        type2 = "double_" + type2;
        line2 = line2.slice(1);
      }
      break;
    case ">":
      type2 = "arrow_point";
      if (str[0] === "<") {
        type2 = "double_" + type2;
        line2 = line2.slice(1);
      }
      break;
    case "o":
      type2 = "arrow_circle";
      if (str[0] === "o") {
        type2 = "double_" + type2;
        line2 = line2.slice(1);
      }
      break;
  }
  let stroke = "normal";
  let length2 = line2.length - 1;
  if (line2[0] === "=") {
    stroke = "thick";
  }
  if (line2[0] === "~") {
    stroke = "invisible";
  }
  let dots = countChar(".", line2);
  if (dots) {
    stroke = "dotted";
    length2 = dots;
  }
  return { type: type2, stroke, length: length2 };
};
const destructLink = (_str, _startStr) => {
  const info2 = destructEndLink(_str);
  let startInfo;
  if (_startStr) {
    startInfo = destructStartLink(_startStr);
    if (startInfo.stroke !== info2.stroke) {
      return { type: "INVALID", stroke: "INVALID" };
    }
    if (startInfo.type === "arrow_open") {
      startInfo.type = info2.type;
    } else {
      if (startInfo.type !== info2.type)
        return { type: "INVALID", stroke: "INVALID" };
      startInfo.type = "double_" + startInfo.type;
    }
    if (startInfo.type === "double_arrow") {
      startInfo.type = "double_arrow_point";
    }
    startInfo.length = info2.length;
    return startInfo;
  }
  return info2;
};
const exists = (allSgs, _id) => {
  let res = false;
  allSgs.forEach((sg) => {
    const pos = sg.nodes.indexOf(_id);
    if (pos >= 0) {
      res = true;
    }
  });
  return res;
};
const makeUniq = (sg, allSubgraphs) => {
  const res = [];
  sg.nodes.forEach((_id, pos) => {
    if (!exists(allSubgraphs, _id)) {
      res.push(sg.nodes[pos]);
    }
  });
  return { nodes: res };
};
const flowDb = {
  parseDirective: parseDirective$7,
  defaultConfig: () => defaultConfig.flowchart,
  setAccTitle,
  getAccTitle,
  getAccDescription,
  setAccDescription,
  addVertex,
  lookUpDomId,
  addLink,
  updateLinkInterpolate,
  updateLink,
  addClass,
  setDirection: setDirection$1,
  setClass: setClass$1,
  setTooltip,
  getTooltip,
  setClickEvent: setClickEvent$1,
  setLink: setLink$1,
  bindFunctions: bindFunctions$1,
  getDirection: getDirection$1,
  getVertices,
  getEdges,
  getClasses: getClasses$4,
  clear: clear$6,
  setGen,
  defaultStyle,
  addSubGraph,
  getDepthFirstPos,
  indexNodes,
  getSubGraphs,
  destructLink,
  lex: {
    firstGraph
  },
  exists,
  makeUniq
};
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var identity_1;
var hasRequiredIdentity;
function requireIdentity() {
  if (hasRequiredIdentity)
    return identity_1;
  hasRequiredIdentity = 1;
  function identity2(value) {
    return value;
  }
  identity_1 = identity2;
  return identity_1;
}
var _apply;
var hasRequired_apply;
function require_apply() {
  if (hasRequired_apply)
    return _apply;
  hasRequired_apply = 1;
  function apply2(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  _apply = apply2;
  return _apply;
}
var _overRest;
var hasRequired_overRest;
function require_overRest() {
  if (hasRequired_overRest)
    return _overRest;
  hasRequired_overRest = 1;
  var apply2 = require_apply();
  var nativeMax = Math.max;
  function overRest(func, start2, transform2) {
    start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
    return function() {
      var args = arguments, index2 = -1, length2 = nativeMax(args.length - start2, 0), array2 = Array(length2);
      while (++index2 < length2) {
        array2[index2] = args[start2 + index2];
      }
      index2 = -1;
      var otherArgs = Array(start2 + 1);
      while (++index2 < start2) {
        otherArgs[index2] = args[index2];
      }
      otherArgs[start2] = transform2(array2);
      return apply2(func, this, otherArgs);
    };
  }
  _overRest = overRest;
  return _overRest;
}
var constant_1;
var hasRequiredConstant;
function requireConstant() {
  if (hasRequiredConstant)
    return constant_1;
  hasRequiredConstant = 1;
  function constant2(value) {
    return function() {
      return value;
    };
  }
  constant_1 = constant2;
  return constant_1;
}
var _defineProperty;
var hasRequired_defineProperty;
function require_defineProperty() {
  if (hasRequired_defineProperty)
    return _defineProperty;
  hasRequired_defineProperty = 1;
  var getNative2 = _getNative;
  var defineProperty = function() {
    try {
      var func = getNative2(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e) {
    }
  }();
  _defineProperty = defineProperty;
  return _defineProperty;
}
var _baseSetToString;
var hasRequired_baseSetToString;
function require_baseSetToString() {
  if (hasRequired_baseSetToString)
    return _baseSetToString;
  hasRequired_baseSetToString = 1;
  var constant2 = requireConstant(), defineProperty = require_defineProperty(), identity2 = requireIdentity();
  var baseSetToString = !defineProperty ? identity2 : function(func, string2) {
    return defineProperty(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant2(string2),
      "writable": true
    });
  };
  _baseSetToString = baseSetToString;
  return _baseSetToString;
}
var _shortOut;
var hasRequired_shortOut;
function require_shortOut() {
  if (hasRequired_shortOut)
    return _shortOut;
  hasRequired_shortOut = 1;
  var HOT_COUNT = 800, HOT_SPAN = 16;
  var nativeNow = Date.now;
  function shortOut(func) {
    var count2 = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count2 >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count2 = 0;
      }
      return func.apply(void 0, arguments);
    };
  }
  _shortOut = shortOut;
  return _shortOut;
}
var _setToString;
var hasRequired_setToString;
function require_setToString() {
  if (hasRequired_setToString)
    return _setToString;
  hasRequired_setToString = 1;
  var baseSetToString = require_baseSetToString(), shortOut = require_shortOut();
  var setToString = shortOut(baseSetToString);
  _setToString = setToString;
  return _setToString;
}
var _baseRest;
var hasRequired_baseRest;
function require_baseRest() {
  if (hasRequired_baseRest)
    return _baseRest;
  hasRequired_baseRest = 1;
  var identity2 = requireIdentity(), overRest = require_overRest(), setToString = require_setToString();
  function baseRest(func, start2) {
    return setToString(overRest(func, start2, identity2), func + "");
  }
  _baseRest = baseRest;
  return _baseRest;
}
var isLength_1;
var hasRequiredIsLength;
function requireIsLength() {
  if (hasRequiredIsLength)
    return isLength_1;
  hasRequiredIsLength = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  isLength_1 = isLength;
  return isLength_1;
}
var isArrayLike_1;
var hasRequiredIsArrayLike;
function requireIsArrayLike() {
  if (hasRequiredIsArrayLike)
    return isArrayLike_1;
  hasRequiredIsArrayLike = 1;
  var isFunction2 = requireIsFunction(), isLength = requireIsLength();
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
  }
  isArrayLike_1 = isArrayLike;
  return isArrayLike_1;
}
var _isIndex;
var hasRequired_isIndex;
function require_isIndex() {
  if (hasRequired_isIndex)
    return _isIndex;
  hasRequired_isIndex = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length2) {
    var type2 = typeof value;
    length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
    return !!length2 && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
  }
  _isIndex = isIndex;
  return _isIndex;
}
var _isIterateeCall;
var hasRequired_isIterateeCall;
function require_isIterateeCall() {
  if (hasRequired_isIterateeCall)
    return _isIterateeCall;
  hasRequired_isIterateeCall = 1;
  var eq2 = requireEq(), isArrayLike = requireIsArrayLike(), isIndex = require_isIndex(), isObject2 = requireIsObject();
  function isIterateeCall(value, index2, object2) {
    if (!isObject2(object2)) {
      return false;
    }
    var type2 = typeof index2;
    if (type2 == "number" ? isArrayLike(object2) && isIndex(index2, object2.length) : type2 == "string" && index2 in object2) {
      return eq2(object2[index2], value);
    }
    return false;
  }
  _isIterateeCall = isIterateeCall;
  return _isIterateeCall;
}
var _baseTimes;
var hasRequired_baseTimes;
function require_baseTimes() {
  if (hasRequired_baseTimes)
    return _baseTimes;
  hasRequired_baseTimes = 1;
  function baseTimes(n, iteratee) {
    var index2 = -1, result = Array(n);
    while (++index2 < n) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  _baseTimes = baseTimes;
  return _baseTimes;
}
var isObjectLike_1;
var hasRequiredIsObjectLike;
function requireIsObjectLike() {
  if (hasRequiredIsObjectLike)
    return isObjectLike_1;
  hasRequiredIsObjectLike = 1;
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  isObjectLike_1 = isObjectLike;
  return isObjectLike_1;
}
var _baseIsArguments;
var hasRequired_baseIsArguments;
function require_baseIsArguments() {
  if (hasRequired_baseIsArguments)
    return _baseIsArguments;
  hasRequired_baseIsArguments = 1;
  var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();
  var argsTag = "[object Arguments]";
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }
  _baseIsArguments = baseIsArguments;
  return _baseIsArguments;
}
var isArguments_1;
var hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments)
    return isArguments_1;
  hasRequiredIsArguments = 1;
  var baseIsArguments = require_baseIsArguments(), isObjectLike = requireIsObjectLike();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var propertyIsEnumerable = objectProto2.propertyIsEnumerable;
  var isArguments = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  isArguments_1 = isArguments;
  return isArguments_1;
}
var isArray_1;
var hasRequiredIsArray;
function requireIsArray() {
  if (hasRequiredIsArray)
    return isArray_1;
  hasRequiredIsArray = 1;
  var isArray = Array.isArray;
  isArray_1 = isArray;
  return isArray_1;
}
var isBuffer = { exports: {} };
var stubFalse_1;
var hasRequiredStubFalse;
function requireStubFalse() {
  if (hasRequiredStubFalse)
    return stubFalse_1;
  hasRequiredStubFalse = 1;
  function stubFalse() {
    return false;
  }
  stubFalse_1 = stubFalse;
  return stubFalse_1;
}
var hasRequiredIsBuffer;
function requireIsBuffer() {
  if (hasRequiredIsBuffer)
    return isBuffer.exports;
  hasRequiredIsBuffer = 1;
  (function(module2, exports2) {
    var root2 = _root, stubFalse = requireStubFalse();
    var freeExports = exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root2.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer2 = nativeIsBuffer || stubFalse;
    module2.exports = isBuffer2;
  })(isBuffer, isBuffer.exports);
  return isBuffer.exports;
}
var _baseIsTypedArray;
var hasRequired_baseIsTypedArray;
function require_baseIsTypedArray() {
  if (hasRequired_baseIsTypedArray)
    return _baseIsTypedArray;
  hasRequired_baseIsTypedArray = 1;
  var baseGetTag = require_baseGetTag(), isLength = requireIsLength(), isObjectLike = requireIsObjectLike();
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  _baseIsTypedArray = baseIsTypedArray;
  return _baseIsTypedArray;
}
var _baseUnary;
var hasRequired_baseUnary;
function require_baseUnary() {
  if (hasRequired_baseUnary)
    return _baseUnary;
  hasRequired_baseUnary = 1;
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  _baseUnary = baseUnary;
  return _baseUnary;
}
var _nodeUtil = { exports: {} };
var hasRequired_nodeUtil;
function require_nodeUtil() {
  if (hasRequired_nodeUtil)
    return _nodeUtil.exports;
  hasRequired_nodeUtil = 1;
  (function(module2, exports2) {
    var freeGlobal2 = _freeGlobal;
    var freeExports = exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal2.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module2.exports = nodeUtil;
  })(_nodeUtil, _nodeUtil.exports);
  return _nodeUtil.exports;
}
var isTypedArray_1;
var hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray)
    return isTypedArray_1;
  hasRequiredIsTypedArray = 1;
  var baseIsTypedArray = require_baseIsTypedArray(), baseUnary = require_baseUnary(), nodeUtil = require_nodeUtil();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  isTypedArray_1 = isTypedArray;
  return isTypedArray_1;
}
var _arrayLikeKeys;
var hasRequired_arrayLikeKeys;
function require_arrayLikeKeys() {
  if (hasRequired_arrayLikeKeys)
    return _arrayLikeKeys;
  hasRequired_arrayLikeKeys = 1;
  var baseTimes = require_baseTimes(), isArguments = requireIsArguments(), isArray = requireIsArray(), isBuffer2 = requireIsBuffer(), isIndex = require_isIndex(), isTypedArray = requireIsTypedArray();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length2)))) {
        result.push(key);
      }
    }
    return result;
  }
  _arrayLikeKeys = arrayLikeKeys;
  return _arrayLikeKeys;
}
var _isPrototype;
var hasRequired_isPrototype;
function require_isPrototype() {
  if (hasRequired_isPrototype)
    return _isPrototype;
  hasRequired_isPrototype = 1;
  var objectProto2 = Object.prototype;
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto2;
    return value === proto2;
  }
  _isPrototype = isPrototype;
  return _isPrototype;
}
var _nativeKeysIn;
var hasRequired_nativeKeysIn;
function require_nativeKeysIn() {
  if (hasRequired_nativeKeysIn)
    return _nativeKeysIn;
  hasRequired_nativeKeysIn = 1;
  function nativeKeysIn(object2) {
    var result = [];
    if (object2 != null) {
      for (var key in Object(object2)) {
        result.push(key);
      }
    }
    return result;
  }
  _nativeKeysIn = nativeKeysIn;
  return _nativeKeysIn;
}
var _baseKeysIn;
var hasRequired_baseKeysIn;
function require_baseKeysIn() {
  if (hasRequired_baseKeysIn)
    return _baseKeysIn;
  hasRequired_baseKeysIn = 1;
  var isObject2 = requireIsObject(), isPrototype = require_isPrototype(), nativeKeysIn = require_nativeKeysIn();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function baseKeysIn(object2) {
    if (!isObject2(object2)) {
      return nativeKeysIn(object2);
    }
    var isProto = isPrototype(object2), result = [];
    for (var key in object2) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object2, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  _baseKeysIn = baseKeysIn;
  return _baseKeysIn;
}
var keysIn_1;
var hasRequiredKeysIn;
function requireKeysIn() {
  if (hasRequiredKeysIn)
    return keysIn_1;
  hasRequiredKeysIn = 1;
  var arrayLikeKeys = require_arrayLikeKeys(), baseKeysIn = require_baseKeysIn(), isArrayLike = requireIsArrayLike();
  function keysIn(object2) {
    return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
  }
  keysIn_1 = keysIn;
  return keysIn_1;
}
var defaults_1;
var hasRequiredDefaults;
function requireDefaults() {
  if (hasRequiredDefaults)
    return defaults_1;
  hasRequiredDefaults = 1;
  var baseRest = require_baseRest(), eq2 = requireEq(), isIterateeCall = require_isIterateeCall(), keysIn = requireKeysIn();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var defaults2 = baseRest(function(object2, sources) {
    object2 = Object(object2);
    var index2 = -1;
    var length2 = sources.length;
    var guard = length2 > 2 ? sources[2] : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      length2 = 1;
    }
    while (++index2 < length2) {
      var source = sources[index2];
      var props = keysIn(source);
      var propsIndex = -1;
      var propsLength = props.length;
      while (++propsIndex < propsLength) {
        var key = props[propsIndex];
        var value = object2[key];
        if (value === void 0 || eq2(value, objectProto2[key]) && !hasOwnProperty2.call(object2, key)) {
          object2[key] = source[key];
        }
      }
    }
    return object2;
  });
  defaults_1 = defaults2;
  return defaults_1;
}
var each = { exports: {} };
var _arrayEach;
var hasRequired_arrayEach;
function require_arrayEach() {
  if (hasRequired_arrayEach)
    return _arrayEach;
  hasRequired_arrayEach = 1;
  function arrayEach(array2, iteratee) {
    var index2 = -1, length2 = array2 == null ? 0 : array2.length;
    while (++index2 < length2) {
      if (iteratee(array2[index2], index2, array2) === false) {
        break;
      }
    }
    return array2;
  }
  _arrayEach = arrayEach;
  return _arrayEach;
}
var _createBaseFor;
var hasRequired_createBaseFor;
function require_createBaseFor() {
  if (hasRequired_createBaseFor)
    return _createBaseFor;
  hasRequired_createBaseFor = 1;
  function createBaseFor(fromRight) {
    return function(object2, iteratee, keysFunc) {
      var index2 = -1, iterable = Object(object2), props = keysFunc(object2), length2 = props.length;
      while (length2--) {
        var key = props[fromRight ? length2 : ++index2];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object2;
    };
  }
  _createBaseFor = createBaseFor;
  return _createBaseFor;
}
var _baseFor;
var hasRequired_baseFor;
function require_baseFor() {
  if (hasRequired_baseFor)
    return _baseFor;
  hasRequired_baseFor = 1;
  var createBaseFor = require_createBaseFor();
  var baseFor = createBaseFor();
  _baseFor = baseFor;
  return _baseFor;
}
var _overArg;
var hasRequired_overArg;
function require_overArg() {
  if (hasRequired_overArg)
    return _overArg;
  hasRequired_overArg = 1;
  function overArg(func, transform2) {
    return function(arg) {
      return func(transform2(arg));
    };
  }
  _overArg = overArg;
  return _overArg;
}
var _nativeKeys;
var hasRequired_nativeKeys;
function require_nativeKeys() {
  if (hasRequired_nativeKeys)
    return _nativeKeys;
  hasRequired_nativeKeys = 1;
  var overArg = require_overArg();
  var nativeKeys = overArg(Object.keys, Object);
  _nativeKeys = nativeKeys;
  return _nativeKeys;
}
var _baseKeys;
var hasRequired_baseKeys;
function require_baseKeys() {
  if (hasRequired_baseKeys)
    return _baseKeys;
  hasRequired_baseKeys = 1;
  var isPrototype = require_isPrototype(), nativeKeys = require_nativeKeys();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function baseKeys(object2) {
    if (!isPrototype(object2)) {
      return nativeKeys(object2);
    }
    var result = [];
    for (var key in Object(object2)) {
      if (hasOwnProperty2.call(object2, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  _baseKeys = baseKeys;
  return _baseKeys;
}
var keys_1;
var hasRequiredKeys;
function requireKeys() {
  if (hasRequiredKeys)
    return keys_1;
  hasRequiredKeys = 1;
  var arrayLikeKeys = require_arrayLikeKeys(), baseKeys = require_baseKeys(), isArrayLike = requireIsArrayLike();
  function keys2(object2) {
    return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
  }
  keys_1 = keys2;
  return keys_1;
}
var _baseForOwn;
var hasRequired_baseForOwn;
function require_baseForOwn() {
  if (hasRequired_baseForOwn)
    return _baseForOwn;
  hasRequired_baseForOwn = 1;
  var baseFor = require_baseFor(), keys2 = requireKeys();
  function baseForOwn(object2, iteratee) {
    return object2 && baseFor(object2, iteratee, keys2);
  }
  _baseForOwn = baseForOwn;
  return _baseForOwn;
}
var _createBaseEach;
var hasRequired_createBaseEach;
function require_createBaseEach() {
  if (hasRequired_createBaseEach)
    return _createBaseEach;
  hasRequired_createBaseEach = 1;
  var isArrayLike = requireIsArrayLike();
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length2 = collection.length, index2 = fromRight ? length2 : -1, iterable = Object(collection);
      while (fromRight ? index2-- : ++index2 < length2) {
        if (iteratee(iterable[index2], index2, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }
  _createBaseEach = createBaseEach;
  return _createBaseEach;
}
var _baseEach;
var hasRequired_baseEach;
function require_baseEach() {
  if (hasRequired_baseEach)
    return _baseEach;
  hasRequired_baseEach = 1;
  var baseForOwn = require_baseForOwn(), createBaseEach = require_createBaseEach();
  var baseEach = createBaseEach(baseForOwn);
  _baseEach = baseEach;
  return _baseEach;
}
var _castFunction;
var hasRequired_castFunction;
function require_castFunction() {
  if (hasRequired_castFunction)
    return _castFunction;
  hasRequired_castFunction = 1;
  var identity2 = requireIdentity();
  function castFunction(value) {
    return typeof value == "function" ? value : identity2;
  }
  _castFunction = castFunction;
  return _castFunction;
}
var forEach_1;
var hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach)
    return forEach_1;
  hasRequiredForEach = 1;
  var arrayEach = require_arrayEach(), baseEach = require_baseEach(), castFunction = require_castFunction(), isArray = requireIsArray();
  function forEach(collection, iteratee) {
    var func = isArray(collection) ? arrayEach : baseEach;
    return func(collection, castFunction(iteratee));
  }
  forEach_1 = forEach;
  return forEach_1;
}
var hasRequiredEach;
function requireEach() {
  if (hasRequiredEach)
    return each.exports;
  hasRequiredEach = 1;
  (function(module2) {
    module2.exports = requireForEach();
  })(each);
  return each.exports;
}
var _getPrototype;
var hasRequired_getPrototype;
function require_getPrototype() {
  if (hasRequired_getPrototype)
    return _getPrototype;
  hasRequired_getPrototype = 1;
  var overArg = require_overArg();
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  _getPrototype = getPrototype;
  return _getPrototype;
}
var isPlainObject_1;
var hasRequiredIsPlainObject;
function requireIsPlainObject() {
  if (hasRequiredIsPlainObject)
    return isPlainObject_1;
  hasRequiredIsPlainObject = 1;
  var baseGetTag = require_baseGetTag(), getPrototype = require_getPrototype(), isObjectLike = requireIsObjectLike();
  var objectTag = "[object Object]";
  var funcProto2 = Function.prototype, objectProto2 = Object.prototype;
  var funcToString2 = funcProto2.toString;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var objectCtorString = funcToString2.call(Object);
  function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
      return false;
    }
    var proto2 = getPrototype(value);
    if (proto2 === null) {
      return true;
    }
    var Ctor = hasOwnProperty2.call(proto2, "constructor") && proto2.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString2.call(Ctor) == objectCtorString;
  }
  isPlainObject_1 = isPlainObject;
  return isPlainObject_1;
}
var isSymbol_1;
var hasRequiredIsSymbol;
function requireIsSymbol() {
  if (hasRequiredIsSymbol)
    return isSymbol_1;
  hasRequiredIsSymbol = 1;
  var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();
  var symbolTag = "[object Symbol]";
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
  }
  isSymbol_1 = isSymbol;
  return isSymbol_1;
}
var _isKey;
var hasRequired_isKey;
function require_isKey() {
  if (hasRequired_isKey)
    return _isKey;
  hasRequired_isKey = 1;
  var isArray = requireIsArray(), isSymbol = requireIsSymbol();
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
  function isKey(value, object2) {
    if (isArray(value)) {
      return false;
    }
    var type2 = typeof value;
    if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
  }
  _isKey = isKey;
  return _isKey;
}
var _memoizeCapped;
var hasRequired_memoizeCapped;
function require_memoizeCapped() {
  if (hasRequired_memoizeCapped)
    return _memoizeCapped;
  hasRequired_memoizeCapped = 1;
  var memoize2 = memoize_1;
  var MAX_MEMOIZE_SIZE = 500;
  function memoizeCapped(func) {
    var result = memoize2(func, function(key) {
      if (cache2.size === MAX_MEMOIZE_SIZE) {
        cache2.clear();
      }
      return key;
    });
    var cache2 = result.cache;
    return result;
  }
  _memoizeCapped = memoizeCapped;
  return _memoizeCapped;
}
var _stringToPath;
var hasRequired_stringToPath;
function require_stringToPath() {
  if (hasRequired_stringToPath)
    return _stringToPath;
  hasRequired_stringToPath = 1;
  var memoizeCapped = require_memoizeCapped();
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped(function(string2) {
    var result = [];
    if (string2.charCodeAt(0) === 46) {
      result.push("");
    }
    string2.replace(rePropName, function(match, number3, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number3 || match);
    });
    return result;
  });
  _stringToPath = stringToPath;
  return _stringToPath;
}
var _arrayMap;
var hasRequired_arrayMap;
function require_arrayMap() {
  if (hasRequired_arrayMap)
    return _arrayMap;
  hasRequired_arrayMap = 1;
  function arrayMap(array2, iteratee) {
    var index2 = -1, length2 = array2 == null ? 0 : array2.length, result = Array(length2);
    while (++index2 < length2) {
      result[index2] = iteratee(array2[index2], index2, array2);
    }
    return result;
  }
  _arrayMap = arrayMap;
  return _arrayMap;
}
var _baseToString;
var hasRequired_baseToString;
function require_baseToString() {
  if (hasRequired_baseToString)
    return _baseToString;
  hasRequired_baseToString = 1;
  var Symbol2 = require_Symbol(), arrayMap = require_arrayMap(), isArray = requireIsArray(), isSymbol = requireIsSymbol();
  var INFINITY = 1 / 0;
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray(value)) {
      return arrayMap(value, baseToString) + "";
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  _baseToString = baseToString;
  return _baseToString;
}
var toString_1;
var hasRequiredToString;
function requireToString() {
  if (hasRequiredToString)
    return toString_1;
  hasRequiredToString = 1;
  var baseToString = require_baseToString();
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  toString_1 = toString;
  return toString_1;
}
var _castPath;
var hasRequired_castPath;
function require_castPath() {
  if (hasRequired_castPath)
    return _castPath;
  hasRequired_castPath = 1;
  var isArray = requireIsArray(), isKey = require_isKey(), stringToPath = require_stringToPath(), toString = requireToString();
  function castPath(value, object2) {
    if (isArray(value)) {
      return value;
    }
    return isKey(value, object2) ? [value] : stringToPath(toString(value));
  }
  _castPath = castPath;
  return _castPath;
}
var _toKey;
var hasRequired_toKey;
function require_toKey() {
  if (hasRequired_toKey)
    return _toKey;
  hasRequired_toKey = 1;
  var isSymbol = requireIsSymbol();
  var INFINITY = 1 / 0;
  function toKey(value) {
    if (typeof value == "string" || isSymbol(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  _toKey = toKey;
  return _toKey;
}
var _baseGet;
var hasRequired_baseGet;
function require_baseGet() {
  if (hasRequired_baseGet)
    return _baseGet;
  hasRequired_baseGet = 1;
  var castPath = require_castPath(), toKey = require_toKey();
  function baseGet(object2, path2) {
    path2 = castPath(path2, object2);
    var index2 = 0, length2 = path2.length;
    while (object2 != null && index2 < length2) {
      object2 = object2[toKey(path2[index2++])];
    }
    return index2 && index2 == length2 ? object2 : void 0;
  }
  _baseGet = baseGet;
  return _baseGet;
}
var _baseAssignValue;
var hasRequired_baseAssignValue;
function require_baseAssignValue() {
  if (hasRequired_baseAssignValue)
    return _baseAssignValue;
  hasRequired_baseAssignValue = 1;
  var defineProperty = require_defineProperty();
  function baseAssignValue(object2, key, value) {
    if (key == "__proto__" && defineProperty) {
      defineProperty(object2, key, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object2[key] = value;
    }
  }
  _baseAssignValue = baseAssignValue;
  return _baseAssignValue;
}
var _assignValue;
var hasRequired_assignValue;
function require_assignValue() {
  if (hasRequired_assignValue)
    return _assignValue;
  hasRequired_assignValue = 1;
  var baseAssignValue = require_baseAssignValue(), eq2 = requireEq();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function assignValue(object2, key, value) {
    var objValue = object2[key];
    if (!(hasOwnProperty2.call(object2, key) && eq2(objValue, value)) || value === void 0 && !(key in object2)) {
      baseAssignValue(object2, key, value);
    }
  }
  _assignValue = assignValue;
  return _assignValue;
}
var _baseSet;
var hasRequired_baseSet;
function require_baseSet() {
  if (hasRequired_baseSet)
    return _baseSet;
  hasRequired_baseSet = 1;
  var assignValue = require_assignValue(), castPath = require_castPath(), isIndex = require_isIndex(), isObject2 = requireIsObject(), toKey = require_toKey();
  function baseSet(object2, path2, value, customizer) {
    if (!isObject2(object2)) {
      return object2;
    }
    path2 = castPath(path2, object2);
    var index2 = -1, length2 = path2.length, lastIndex = length2 - 1, nested = object2;
    while (nested != null && ++index2 < length2) {
      var key = toKey(path2[index2]), newValue = value;
      if (key === "__proto__" || key === "constructor" || key === "prototype") {
        return object2;
      }
      if (index2 != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : void 0;
        if (newValue === void 0) {
          newValue = isObject2(objValue) ? objValue : isIndex(path2[index2 + 1]) ? [] : {};
        }
      }
      assignValue(nested, key, newValue);
      nested = nested[key];
    }
    return object2;
  }
  _baseSet = baseSet;
  return _baseSet;
}
var _basePickBy;
var hasRequired_basePickBy;
function require_basePickBy() {
  if (hasRequired_basePickBy)
    return _basePickBy;
  hasRequired_basePickBy = 1;
  var baseGet = require_baseGet(), baseSet = require_baseSet(), castPath = require_castPath();
  function basePickBy(object2, paths, predicate) {
    var index2 = -1, length2 = paths.length, result = {};
    while (++index2 < length2) {
      var path2 = paths[index2], value = baseGet(object2, path2);
      if (predicate(value, path2)) {
        baseSet(result, castPath(path2, object2), value);
      }
    }
    return result;
  }
  _basePickBy = basePickBy;
  return _basePickBy;
}
var _baseHasIn;
var hasRequired_baseHasIn;
function require_baseHasIn() {
  if (hasRequired_baseHasIn)
    return _baseHasIn;
  hasRequired_baseHasIn = 1;
  function baseHasIn(object2, key) {
    return object2 != null && key in Object(object2);
  }
  _baseHasIn = baseHasIn;
  return _baseHasIn;
}
var _hasPath;
var hasRequired_hasPath;
function require_hasPath() {
  if (hasRequired_hasPath)
    return _hasPath;
  hasRequired_hasPath = 1;
  var castPath = require_castPath(), isArguments = requireIsArguments(), isArray = requireIsArray(), isIndex = require_isIndex(), isLength = requireIsLength(), toKey = require_toKey();
  function hasPath(object2, path2, hasFunc) {
    path2 = castPath(path2, object2);
    var index2 = -1, length2 = path2.length, result = false;
    while (++index2 < length2) {
      var key = toKey(path2[index2]);
      if (!(result = object2 != null && hasFunc(object2, key))) {
        break;
      }
      object2 = object2[key];
    }
    if (result || ++index2 != length2) {
      return result;
    }
    length2 = object2 == null ? 0 : object2.length;
    return !!length2 && isLength(length2) && isIndex(key, length2) && (isArray(object2) || isArguments(object2));
  }
  _hasPath = hasPath;
  return _hasPath;
}
var hasIn_1;
var hasRequiredHasIn;
function requireHasIn() {
  if (hasRequiredHasIn)
    return hasIn_1;
  hasRequiredHasIn = 1;
  var baseHasIn = require_baseHasIn(), hasPath = require_hasPath();
  function hasIn(object2, path2) {
    return object2 != null && hasPath(object2, path2, baseHasIn);
  }
  hasIn_1 = hasIn;
  return hasIn_1;
}
var _basePick;
var hasRequired_basePick;
function require_basePick() {
  if (hasRequired_basePick)
    return _basePick;
  hasRequired_basePick = 1;
  var basePickBy = require_basePickBy(), hasIn = requireHasIn();
  function basePick(object2, paths) {
    return basePickBy(object2, paths, function(value, path2) {
      return hasIn(object2, path2);
    });
  }
  _basePick = basePick;
  return _basePick;
}
var _arrayPush;
var hasRequired_arrayPush;
function require_arrayPush() {
  if (hasRequired_arrayPush)
    return _arrayPush;
  hasRequired_arrayPush = 1;
  function arrayPush2(array2, values2) {
    var index2 = -1, length2 = values2.length, offset = array2.length;
    while (++index2 < length2) {
      array2[offset + index2] = values2[index2];
    }
    return array2;
  }
  _arrayPush = arrayPush2;
  return _arrayPush;
}
var _isFlattenable;
var hasRequired_isFlattenable;
function require_isFlattenable() {
  if (hasRequired_isFlattenable)
    return _isFlattenable;
  hasRequired_isFlattenable = 1;
  var Symbol2 = require_Symbol(), isArguments = requireIsArguments(), isArray = requireIsArray();
  var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
  function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  _isFlattenable = isFlattenable;
  return _isFlattenable;
}
var _baseFlatten;
var hasRequired_baseFlatten;
function require_baseFlatten() {
  if (hasRequired_baseFlatten)
    return _baseFlatten;
  hasRequired_baseFlatten = 1;
  var arrayPush2 = require_arrayPush(), isFlattenable = require_isFlattenable();
  function baseFlatten(array2, depth, predicate, isStrict, result) {
    var index2 = -1, length2 = array2.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index2 < length2) {
      var value = array2[index2];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush2(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }
  _baseFlatten = baseFlatten;
  return _baseFlatten;
}
var flatten_1;
var hasRequiredFlatten;
function requireFlatten() {
  if (hasRequiredFlatten)
    return flatten_1;
  hasRequiredFlatten = 1;
  var baseFlatten = require_baseFlatten();
  function flatten2(array2) {
    var length2 = array2 == null ? 0 : array2.length;
    return length2 ? baseFlatten(array2, 1) : [];
  }
  flatten_1 = flatten2;
  return flatten_1;
}
var _flatRest;
var hasRequired_flatRest;
function require_flatRest() {
  if (hasRequired_flatRest)
    return _flatRest;
  hasRequired_flatRest = 1;
  var flatten2 = requireFlatten(), overRest = require_overRest(), setToString = require_setToString();
  function flatRest(func) {
    return setToString(overRest(func, void 0, flatten2), func + "");
  }
  _flatRest = flatRest;
  return _flatRest;
}
var pick_1;
var hasRequiredPick;
function requirePick() {
  if (hasRequiredPick)
    return pick_1;
  hasRequiredPick = 1;
  var basePick = require_basePick(), flatRest = require_flatRest();
  var pick = flatRest(function(object2, paths) {
    return object2 == null ? {} : basePick(object2, paths);
  });
  pick_1 = pick;
  return pick_1;
}
var _baseHas;
var hasRequired_baseHas;
function require_baseHas() {
  if (hasRequired_baseHas)
    return _baseHas;
  hasRequired_baseHas = 1;
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function baseHas(object2, key) {
    return object2 != null && hasOwnProperty2.call(object2, key);
  }
  _baseHas = baseHas;
  return _baseHas;
}
var has_1;
var hasRequiredHas;
function requireHas() {
  if (hasRequiredHas)
    return has_1;
  hasRequiredHas = 1;
  var baseHas = require_baseHas(), hasPath = require_hasPath();
  function has(object2, path2) {
    return object2 != null && hasPath(object2, path2, baseHas);
  }
  has_1 = has;
  return has_1;
}
var _baseRange;
var hasRequired_baseRange;
function require_baseRange() {
  if (hasRequired_baseRange)
    return _baseRange;
  hasRequired_baseRange = 1;
  var nativeCeil = Math.ceil, nativeMax = Math.max;
  function baseRange(start2, end2, step2, fromRight) {
    var index2 = -1, length2 = nativeMax(nativeCeil((end2 - start2) / (step2 || 1)), 0), result = Array(length2);
    while (length2--) {
      result[fromRight ? length2 : ++index2] = start2;
      start2 += step2;
    }
    return result;
  }
  _baseRange = baseRange;
  return _baseRange;
}
var _trimmedEndIndex;
var hasRequired_trimmedEndIndex;
function require_trimmedEndIndex() {
  if (hasRequired_trimmedEndIndex)
    return _trimmedEndIndex;
  hasRequired_trimmedEndIndex = 1;
  var reWhitespace = /\s/;
  function trimmedEndIndex(string2) {
    var index2 = string2.length;
    while (index2-- && reWhitespace.test(string2.charAt(index2))) {
    }
    return index2;
  }
  _trimmedEndIndex = trimmedEndIndex;
  return _trimmedEndIndex;
}
var _baseTrim;
var hasRequired_baseTrim;
function require_baseTrim() {
  if (hasRequired_baseTrim)
    return _baseTrim;
  hasRequired_baseTrim = 1;
  var trimmedEndIndex = require_trimmedEndIndex();
  var reTrimStart = /^\s+/;
  function baseTrim(string2) {
    return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
  }
  _baseTrim = baseTrim;
  return _baseTrim;
}
var toNumber_1;
var hasRequiredToNumber;
function requireToNumber() {
  if (hasRequiredToNumber)
    return toNumber_1;
  hasRequiredToNumber = 1;
  var baseTrim = require_baseTrim(), isObject2 = requireIsObject(), isSymbol = requireIsSymbol();
  var NAN = 0 / 0;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject2(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject2(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  toNumber_1 = toNumber;
  return toNumber_1;
}
var toFinite_1;
var hasRequiredToFinite;
function requireToFinite() {
  if (hasRequiredToFinite)
    return toFinite_1;
  hasRequiredToFinite = 1;
  var toNumber = requireToNumber();
  var INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292;
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign2 = value < 0 ? -1 : 1;
      return sign2 * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  toFinite_1 = toFinite;
  return toFinite_1;
}
var _createRange;
var hasRequired_createRange;
function require_createRange() {
  if (hasRequired_createRange)
    return _createRange;
  hasRequired_createRange = 1;
  var baseRange = require_baseRange(), isIterateeCall = require_isIterateeCall(), toFinite = requireToFinite();
  function createRange(fromRight) {
    return function(start2, end2, step2) {
      if (step2 && typeof step2 != "number" && isIterateeCall(start2, end2, step2)) {
        end2 = step2 = void 0;
      }
      start2 = toFinite(start2);
      if (end2 === void 0) {
        end2 = start2;
        start2 = 0;
      } else {
        end2 = toFinite(end2);
      }
      step2 = step2 === void 0 ? start2 < end2 ? 1 : -1 : toFinite(step2);
      return baseRange(start2, end2, step2, fromRight);
    };
  }
  _createRange = createRange;
  return _createRange;
}
var range_1;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange)
    return range_1;
  hasRequiredRange = 1;
  var createRange = require_createRange();
  var range2 = createRange();
  range_1 = range2;
  return range_1;
}
var uniqueId_1;
var hasRequiredUniqueId;
function requireUniqueId() {
  if (hasRequiredUniqueId)
    return uniqueId_1;
  hasRequiredUniqueId = 1;
  var toString = requireToString();
  var idCounter = 0;
  function uniqueId(prefix2) {
    var id2 = ++idCounter;
    return toString(prefix2) + id2;
  }
  uniqueId_1 = uniqueId;
  return uniqueId_1;
}
var lodash;
if (typeof commonjsRequire === "function") {
  try {
    lodash = {
      defaults: requireDefaults(),
      each: requireEach(),
      isFunction: requireIsFunction(),
      isPlainObject: requireIsPlainObject(),
      pick: requirePick(),
      has: requireHas(),
      range: requireRange(),
      uniqueId: requireUniqueId()
    };
  } catch (e) {
  }
}
if (!lodash) {
  lodash = window._;
}
var lodash_1 = lodash;
var _ = lodash_1;
var util$1 = {
  isSubgraph,
  edgeToId,
  applyStyle,
  applyClass,
  applyTransition
};
function isSubgraph(g2, v) {
  return !!g2.children(v).length;
}
function edgeToId(e) {
  return escapeId(e.v) + ":" + escapeId(e.w) + ":" + escapeId(e.name);
}
var ID_DELIM = /:/g;
function escapeId(str) {
  return str ? String(str).replace(ID_DELIM, "\\:") : "";
}
function applyStyle(dom, styleFn) {
  if (styleFn) {
    dom.attr("style", styleFn);
  }
}
function applyClass(dom, classFn, otherClasses) {
  if (classFn) {
    dom.attr("class", classFn).attr("class", otherClasses + " " + dom.attr("class"));
  }
}
function applyTransition(selection2, g2) {
  var graph2 = g2.graph();
  if (_.isPlainObject(graph2)) {
    var transition2 = graph2.transition;
    if (_.isFunction(transition2)) {
      return transition2(selection2);
    }
  }
  return selection2;
}
var util = util$1;
var addHtmlLabel_1 = addHtmlLabel;
function addHtmlLabel(root2, node2) {
  var fo = root2.append("foreignObject").attr("width", "100000");
  var div = fo.append("xhtml:div");
  div.attr("xmlns", "http://www.w3.org/1999/xhtml");
  var label = node2.label;
  switch (typeof label) {
    case "function":
      div.insert(label);
      break;
    case "object":
      div.insert(function() {
        return label;
      });
      break;
    default:
      div.html(label);
  }
  util.applyStyle(div, node2.labelStyle);
  div.style("display", "inline-block");
  div.style("white-space", "nowrap");
  var client = div.node().getBoundingClientRect();
  fo.attr("width", client.width).attr("height", client.height);
  return fo;
}
function question(parent, bbox, node2) {
  const w2 = bbox.width;
  const h2 = bbox.height;
  const s2 = (w2 + h2) * 0.9;
  const points = [
    { x: s2 / 2, y: 0 },
    { x: s2, y: -s2 / 2 },
    { x: s2 / 2, y: -s2 },
    { x: 0, y: -s2 / 2 }
  ];
  const shapeSvg = insertPolygonShape(parent, s2, s2, points);
  node2.intersect = function(point2) {
    return dagreD3.intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
}
function hexagon(parent, bbox, node2) {
  const f2 = 4;
  const h2 = bbox.height;
  const m = h2 / f2;
  const w2 = bbox.width + 2 * m;
  const points = [
    { x: m, y: 0 },
    { x: w2 - m, y: 0 },
    { x: w2, y: -h2 / 2 },
    { x: w2 - m, y: -h2 },
    { x: m, y: -h2 },
    { x: 0, y: -h2 / 2 }
  ];
  const shapeSvg = insertPolygonShape(parent, w2, h2, points);
  node2.intersect = function(point2) {
    return dagreD3.intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
}
function rect_left_inv_arrow(parent, bbox, node2) {
  const w2 = bbox.width;
  const h2 = bbox.height;
  const points = [
    { x: -h2 / 2, y: 0 },
    { x: w2, y: 0 },
    { x: w2, y: -h2 },
    { x: -h2 / 2, y: -h2 },
    { x: 0, y: -h2 / 2 }
  ];
  const shapeSvg = insertPolygonShape(parent, w2, h2, points);
  node2.intersect = function(point2) {
    return dagreD3.intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
}
function lean_right(parent, bbox, node2) {
  const w2 = bbox.width;
  const h2 = bbox.height;
  const points = [
    { x: -2 * h2 / 6, y: 0 },
    { x: w2 - h2 / 6, y: 0 },
    { x: w2 + 2 * h2 / 6, y: -h2 },
    { x: h2 / 6, y: -h2 }
  ];
  const shapeSvg = insertPolygonShape(parent, w2, h2, points);
  node2.intersect = function(point2) {
    return dagreD3.intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
}
function lean_left(parent, bbox, node2) {
  const w2 = bbox.width;
  const h2 = bbox.height;
  const points = [
    { x: 2 * h2 / 6, y: 0 },
    { x: w2 + h2 / 6, y: 0 },
    { x: w2 - 2 * h2 / 6, y: -h2 },
    { x: -h2 / 6, y: -h2 }
  ];
  const shapeSvg = insertPolygonShape(parent, w2, h2, points);
  node2.intersect = function(point2) {
    return dagreD3.intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
}
function trapezoid(parent, bbox, node2) {
  const w2 = bbox.width;
  const h2 = bbox.height;
  const points = [
    { x: -2 * h2 / 6, y: 0 },
    { x: w2 + 2 * h2 / 6, y: 0 },
    { x: w2 - h2 / 6, y: -h2 },
    { x: h2 / 6, y: -h2 }
  ];
  const shapeSvg = insertPolygonShape(parent, w2, h2, points);
  node2.intersect = function(point2) {
    return dagreD3.intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
}
function inv_trapezoid(parent, bbox, node2) {
  const w2 = bbox.width;
  const h2 = bbox.height;
  const points = [
    { x: h2 / 6, y: 0 },
    { x: w2 - h2 / 6, y: 0 },
    { x: w2 + 2 * h2 / 6, y: -h2 },
    { x: -2 * h2 / 6, y: -h2 }
  ];
  const shapeSvg = insertPolygonShape(parent, w2, h2, points);
  node2.intersect = function(point2) {
    return dagreD3.intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
}
function rect_right_inv_arrow(parent, bbox, node2) {
  const w2 = bbox.width;
  const h2 = bbox.height;
  const points = [
    { x: 0, y: 0 },
    { x: w2 + h2 / 2, y: 0 },
    { x: w2, y: -h2 / 2 },
    { x: w2 + h2 / 2, y: -h2 },
    { x: 0, y: -h2 }
  ];
  const shapeSvg = insertPolygonShape(parent, w2, h2, points);
  node2.intersect = function(point2) {
    return dagreD3.intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
}
function stadium(parent, bbox, node2) {
  const h2 = bbox.height;
  const w2 = bbox.width + h2 / 4;
  const shapeSvg = parent.insert("rect", ":first-child").attr("rx", h2 / 2).attr("ry", h2 / 2).attr("x", -w2 / 2).attr("y", -h2 / 2).attr("width", w2).attr("height", h2);
  node2.intersect = function(point2) {
    return dagreD3.intersect.rect(node2, point2);
  };
  return shapeSvg;
}
function subroutine(parent, bbox, node2) {
  const w2 = bbox.width;
  const h2 = bbox.height;
  const points = [
    { x: 0, y: 0 },
    { x: w2, y: 0 },
    { x: w2, y: -h2 },
    { x: 0, y: -h2 },
    { x: 0, y: 0 },
    { x: -8, y: 0 },
    { x: w2 + 8, y: 0 },
    { x: w2 + 8, y: -h2 },
    { x: -8, y: -h2 },
    { x: -8, y: 0 }
  ];
  const shapeSvg = insertPolygonShape(parent, w2, h2, points);
  node2.intersect = function(point2) {
    return dagreD3.intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
}
function cylinder(parent, bbox, node2) {
  const w2 = bbox.width;
  const rx = w2 / 2;
  const ry = rx / (2.5 + w2 / 50);
  const h2 = bbox.height + ry;
  const shape = "M 0," + ry + " a " + rx + "," + ry + " 0,0,0 " + w2 + " 0 a " + rx + "," + ry + " 0,0,0 " + -w2 + " 0 l 0," + h2 + " a " + rx + "," + ry + " 0,0,0 " + w2 + " 0 l 0," + -h2;
  const shapeSvg = parent.attr("label-offset-y", ry).insert("path", ":first-child").attr("d", shape).attr("transform", "translate(" + -w2 / 2 + "," + -(h2 / 2 + ry) + ")");
  node2.intersect = function(point2) {
    const pos = dagreD3.intersect.rect(node2, point2);
    const x2 = pos.x - node2.x;
    if (rx != 0 && (Math.abs(x2) < node2.width / 2 || Math.abs(x2) == node2.width / 2 && Math.abs(pos.y - node2.y) > node2.height / 2 - ry)) {
      let y2 = ry * ry * (1 - x2 * x2 / (rx * rx));
      if (y2 != 0)
        y2 = Math.sqrt(y2);
      y2 = ry - y2;
      if (point2.y - node2.y > 0)
        y2 = -y2;
      pos.y += y2;
    }
    return pos;
  };
  return shapeSvg;
}
function addToRender(render2) {
  render2.shapes().question = question;
  render2.shapes().hexagon = hexagon;
  render2.shapes().stadium = stadium;
  render2.shapes().subroutine = subroutine;
  render2.shapes().cylinder = cylinder;
  render2.shapes().rect_left_inv_arrow = rect_left_inv_arrow;
  render2.shapes().lean_right = lean_right;
  render2.shapes().lean_left = lean_left;
  render2.shapes().trapezoid = trapezoid;
  render2.shapes().inv_trapezoid = inv_trapezoid;
  render2.shapes().rect_right_inv_arrow = rect_right_inv_arrow;
}
function addToRenderV2(addShape) {
  addShape({ question });
  addShape({ hexagon });
  addShape({ stadium });
  addShape({ subroutine });
  addShape({ cylinder });
  addShape({ rect_left_inv_arrow });
  addShape({ lean_right });
  addShape({ lean_left });
  addShape({ trapezoid });
  addShape({ inv_trapezoid });
  addShape({ rect_right_inv_arrow });
}
function insertPolygonShape(parent, w2, h2, points) {
  return parent.insert("polygon", ":first-child").attr(
    "points",
    points.map(function(d) {
      return d.x + "," + d.y;
    }).join(" ")
  ).attr("transform", "translate(" + -w2 / 2 + "," + h2 / 2 + ")");
}
const flowChartShapes = {
  addToRender,
  addToRenderV2
};
const conf$8 = {};
const setConf$7 = function(cnf) {
  const keys2 = Object.keys(cnf);
  for (let i = 0; i < keys2.length; i++) {
    conf$8[keys2[i]] = cnf[keys2[i]];
  }
};
const addVertices$1 = function(vert, g2, svgId, root2, _doc, diagObj) {
  const svg2 = !root2 ? select$1(`[id="${svgId}"]`) : root2.select(`[id="${svgId}"]`);
  const doc2 = !_doc ? document : _doc;
  const keys2 = Object.keys(vert);
  keys2.forEach(function(id2) {
    const vertex = vert[id2];
    let classStr = "default";
    if (vertex.classes.length > 0) {
      classStr = vertex.classes.join(" ");
    }
    const styles = getStylesFromArray(vertex.styles);
    let vertexText = vertex.text !== void 0 ? vertex.text : vertex.id;
    let vertexNode;
    if (evaluate(getConfig$1().flowchart.htmlLabels)) {
      const node2 = {
        label: vertexText.replace(
          /fa[lrsb]?:fa-[\w-]+/g,
          (s2) => `<i class='${s2.replace(":", " ")}'></i>`
        )
      };
      vertexNode = addHtmlLabel_1(svg2, node2).node();
      vertexNode.parentNode.removeChild(vertexNode);
    } else {
      const svgLabel = doc2.createElementNS("http://www.w3.org/2000/svg", "text");
      svgLabel.setAttribute("style", styles.labelStyle.replace("color:", "fill:"));
      const rows = vertexText.split(common.lineBreakRegex);
      for (let j2 = 0; j2 < rows.length; j2++) {
        const tspan = doc2.createElementNS("http://www.w3.org/2000/svg", "tspan");
        tspan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
        tspan.setAttribute("dy", "1em");
        tspan.setAttribute("x", "1");
        tspan.textContent = rows[j2];
        svgLabel.appendChild(tspan);
      }
      vertexNode = svgLabel;
    }
    let radious = 0;
    let _shape = "";
    switch (vertex.type) {
      case "round":
        radious = 5;
        _shape = "rect";
        break;
      case "square":
        _shape = "rect";
        break;
      case "diamond":
        _shape = "question";
        break;
      case "hexagon":
        _shape = "hexagon";
        break;
      case "odd":
        _shape = "rect_left_inv_arrow";
        break;
      case "lean_right":
        _shape = "lean_right";
        break;
      case "lean_left":
        _shape = "lean_left";
        break;
      case "trapezoid":
        _shape = "trapezoid";
        break;
      case "inv_trapezoid":
        _shape = "inv_trapezoid";
        break;
      case "odd_right":
        _shape = "rect_left_inv_arrow";
        break;
      case "circle":
        _shape = "circle";
        break;
      case "ellipse":
        _shape = "ellipse";
        break;
      case "stadium":
        _shape = "stadium";
        break;
      case "subroutine":
        _shape = "subroutine";
        break;
      case "cylinder":
        _shape = "cylinder";
        break;
      case "group":
        _shape = "rect";
        break;
      default:
        _shape = "rect";
    }
    log$1.warn("Adding node", vertex.id, vertex.domId);
    g2.setNode(diagObj.db.lookUpDomId(vertex.id), {
      labelType: "svg",
      labelStyle: styles.labelStyle,
      shape: _shape,
      label: vertexNode,
      rx: radious,
      ry: radious,
      class: classStr,
      style: styles.style,
      id: diagObj.db.lookUpDomId(vertex.id)
    });
  });
};
const addEdges$1 = function(edges2, g2, diagObj) {
  let cnt2 = 0;
  let defaultStyle2;
  let defaultLabelStyle;
  if (typeof edges2.defaultStyle !== "undefined") {
    const defaultStyles = getStylesFromArray(edges2.defaultStyle);
    defaultStyle2 = defaultStyles.style;
    defaultLabelStyle = defaultStyles.labelStyle;
  }
  edges2.forEach(function(edge) {
    cnt2++;
    var linkId = "L-" + edge.start + "-" + edge.end;
    var linkNameStart = "LS-" + edge.start;
    var linkNameEnd = "LE-" + edge.end;
    const edgeData = {};
    if (edge.type === "arrow_open") {
      edgeData.arrowhead = "none";
    } else {
      edgeData.arrowhead = "normal";
    }
    let style2 = "";
    let labelStyle = "";
    if (typeof edge.style !== "undefined") {
      const styles = getStylesFromArray(edge.style);
      style2 = styles.style;
      labelStyle = styles.labelStyle;
    } else {
      switch (edge.stroke) {
        case "normal":
          style2 = "fill:none";
          if (typeof defaultStyle2 !== "undefined") {
            style2 = defaultStyle2;
          }
          if (typeof defaultLabelStyle !== "undefined") {
            labelStyle = defaultLabelStyle;
          }
          break;
        case "dotted":
          style2 = "fill:none;stroke-width:2px;stroke-dasharray:3;";
          break;
        case "thick":
          style2 = " stroke-width: 3.5px;fill:none";
          break;
      }
    }
    edgeData.style = style2;
    edgeData.labelStyle = labelStyle;
    if (typeof edge.interpolate !== "undefined") {
      edgeData.curve = interpolateToCurve(edge.interpolate, curveLinear$1);
    } else if (typeof edges2.defaultInterpolate !== "undefined") {
      edgeData.curve = interpolateToCurve(edges2.defaultInterpolate, curveLinear$1);
    } else {
      edgeData.curve = interpolateToCurve(conf$8.curve, curveLinear$1);
    }
    if (typeof edge.text === "undefined") {
      if (typeof edge.style !== "undefined") {
        edgeData.arrowheadStyle = "fill: #333";
      }
    } else {
      edgeData.arrowheadStyle = "fill: #333";
      edgeData.labelpos = "c";
      if (evaluate(getConfig$1().flowchart.htmlLabels)) {
        edgeData.labelType = "html";
        edgeData.label = `<span id="L-${linkId}" class="edgeLabel L-${linkNameStart}' L-${linkNameEnd}" style="${edgeData.labelStyle}">${edge.text.replace(
          /fa[lrsb]?:fa-[\w-]+/g,
          (s2) => `<i class='${s2.replace(":", " ")}'></i>`
        )}</span>`;
      } else {
        edgeData.labelType = "text";
        edgeData.label = edge.text.replace(common.lineBreakRegex, "\n");
        if (typeof edge.style === "undefined") {
          edgeData.style = edgeData.style || "stroke: #333; stroke-width: 1.5px;fill:none";
        }
        edgeData.labelStyle = edgeData.labelStyle.replace("color:", "fill:");
      }
    }
    edgeData.id = linkId;
    edgeData.class = linkNameStart + " " + linkNameEnd;
    edgeData.minlen = edge.length || 1;
    g2.setEdge(diagObj.db.lookUpDomId(edge.start), diagObj.db.lookUpDomId(edge.end), edgeData, cnt2);
  });
};
const getClasses$3 = function(text2, diagObj) {
  log$1.info("Extracting classes");
  diagObj.db.clear();
  try {
    diagObj.parse(text2);
    return diagObj.db.getClasses();
  } catch (e) {
    return;
  }
};
const draw$a = function(text2, id2, _version, diagObj) {
  log$1.info("Drawing flowchart");
  diagObj.db.clear();
  const { securityLevel, flowchart: conf2 } = getConfig$1();
  let sandboxElement;
  if (securityLevel === "sandbox") {
    sandboxElement = select$1("#i" + id2);
  }
  const root2 = securityLevel === "sandbox" ? select$1(sandboxElement.nodes()[0].contentDocument.body) : select$1("body");
  const doc2 = securityLevel === "sandbox" ? sandboxElement.nodes()[0].contentDocument : document;
  try {
    diagObj.parser.parse(text2);
  } catch (err) {
    log$1.debug("Parsing failed");
  }
  let dir = diagObj.db.getDirection();
  if (typeof dir === "undefined") {
    dir = "TD";
  }
  const nodeSpacing = conf2.nodeSpacing || 50;
  const rankSpacing = conf2.rankSpacing || 50;
  const g2 = new graphlib$2.Graph({
    multigraph: true,
    compound: true
  }).setGraph({
    rankdir: dir,
    nodesep: nodeSpacing,
    ranksep: rankSpacing,
    marginx: 8,
    marginy: 8
  }).setDefaultEdgeLabel(function() {
    return {};
  });
  let subG;
  const subGraphs2 = diagObj.db.getSubGraphs();
  for (let i2 = subGraphs2.length - 1; i2 >= 0; i2--) {
    subG = subGraphs2[i2];
    diagObj.db.addVertex(subG.id, subG.title, "group", void 0, subG.classes);
  }
  const vert = diagObj.db.getVertices();
  log$1.warn("Get vertices", vert);
  const edges2 = diagObj.db.getEdges();
  let i = 0;
  for (i = subGraphs2.length - 1; i >= 0; i--) {
    subG = subGraphs2[i];
    selectAll$1("cluster").append("text");
    for (let j2 = 0; j2 < subG.nodes.length; j2++) {
      log$1.warn(
        "Setting subgraph",
        subG.nodes[j2],
        diagObj.db.lookUpDomId(subG.nodes[j2]),
        diagObj.db.lookUpDomId(subG.id)
      );
      g2.setParent(diagObj.db.lookUpDomId(subG.nodes[j2]), diagObj.db.lookUpDomId(subG.id));
    }
  }
  addVertices$1(vert, g2, id2, root2, doc2, diagObj);
  addEdges$1(edges2, g2, diagObj);
  const Render = dagreD3.render;
  const render2 = new Render();
  flowChartShapes.addToRender(render2);
  render2.arrows().none = function normal2(parent, id22, edge, type2) {
    const marker = parent.append("marker").attr("id", id22).attr("viewBox", "0 0 10 10").attr("refX", 9).attr("refY", 5).attr("markerUnits", "strokeWidth").attr("markerWidth", 8).attr("markerHeight", 6).attr("orient", "auto");
    const path2 = marker.append("path").attr("d", "M 0 0 L 0 0 L 0 0 z");
    dagreD3.util.applyStyle(path2, edge[type2 + "Style"]);
  };
  render2.arrows().normal = function normal2(parent, id22) {
    const marker = parent.append("marker").attr("id", id22).attr("viewBox", "0 0 10 10").attr("refX", 9).attr("refY", 5).attr("markerUnits", "strokeWidth").attr("markerWidth", 8).attr("markerHeight", 6).attr("orient", "auto");
    marker.append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").attr("class", "arrowheadPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
  };
  const svg2 = root2.select(`[id="${id2}"]`);
  addSVGAccessibilityFields(diagObj.db, svg2, id2);
  const element = root2.select("#" + id2 + " g");
  render2(element, g2);
  element.selectAll("g.node").attr("title", function() {
    return diagObj.db.getTooltip(this.id);
  });
  diagObj.db.indexNodes("subGraph" + i);
  for (i = 0; i < subGraphs2.length; i++) {
    subG = subGraphs2[i];
    if (subG.title !== "undefined") {
      const clusterRects = doc2.querySelectorAll(
        "#" + id2 + ' [id="' + diagObj.db.lookUpDomId(subG.id) + '"] rect'
      );
      const clusterEl = doc2.querySelectorAll(
        "#" + id2 + ' [id="' + diagObj.db.lookUpDomId(subG.id) + '"]'
      );
      const xPos = clusterRects[0].x.baseVal.value;
      const yPos = clusterRects[0].y.baseVal.value;
      const _width = clusterRects[0].width.baseVal.value;
      const cluster2 = select$1(clusterEl[0]);
      const te = cluster2.select(".label");
      te.attr("transform", `translate(${xPos + _width / 2}, ${yPos + 14})`);
      te.attr("id", id2 + "Text");
      for (let j2 = 0; j2 < subG.classes.length; j2++) {
        clusterEl[0].classList.add(subG.classes[j2]);
      }
    }
  }
  if (!conf2.htmlLabels) {
    const labels = doc2.querySelectorAll('[id="' + id2 + '"] .edgeLabel .label');
    for (let k2 = 0; k2 < labels.length; k2++) {
      const label = labels[k2];
      const dim = label.getBBox();
      const rect2 = doc2.createElementNS("http://www.w3.org/2000/svg", "rect");
      rect2.setAttribute("rx", 0);
      rect2.setAttribute("ry", 0);
      rect2.setAttribute("width", dim.width);
      rect2.setAttribute("height", dim.height);
      label.insertBefore(rect2, label.firstChild);
    }
  }
  setupGraphViewbox$1(g2, svg2, conf2.diagramPadding, conf2.useMaxWidth);
  const keys2 = Object.keys(vert);
  keys2.forEach(function(key) {
    const vertex = vert[key];
    if (vertex.link) {
      const node2 = root2.select("#" + id2 + ' [id="' + diagObj.db.lookUpDomId(key) + '"]');
      if (node2) {
        const link2 = doc2.createElementNS("http://www.w3.org/2000/svg", "a");
        link2.setAttributeNS("http://www.w3.org/2000/svg", "class", vertex.classes.join(" "));
        link2.setAttributeNS("http://www.w3.org/2000/svg", "href", vertex.link);
        link2.setAttributeNS("http://www.w3.org/2000/svg", "rel", "noopener");
        if (securityLevel === "sandbox") {
          link2.setAttributeNS("http://www.w3.org/2000/svg", "target", "_top");
        } else if (vertex.linkTarget) {
          link2.setAttributeNS("http://www.w3.org/2000/svg", "target", vertex.linkTarget);
        }
        const linkNode = node2.insert(function() {
          return link2;
        }, ":first-child");
        const shape = node2.select(".label-container");
        if (shape) {
          linkNode.append(function() {
            return shape.node();
          });
        }
        const label = node2.select(".label");
        if (label) {
          linkNode.append(function() {
            return label.node();
          });
        }
      }
    }
  });
};
const flowRenderer = {
  setConf: setConf$7,
  addVertices: addVertices$1,
  addEdges: addEdges$1,
  getClasses: getClasses$3,
  draw: draw$a
};
const conf$7 = {};
const setConf$6 = function(cnf) {
  const keys2 = Object.keys(cnf);
  for (let i = 0; i < keys2.length; i++) {
    conf$7[keys2[i]] = cnf[keys2[i]];
  }
};
const addVertices = function(vert, g2, svgId, root2, doc2, diagObj) {
  const svg2 = root2.select(`[id="${svgId}"]`);
  const keys2 = Object.keys(vert);
  keys2.forEach(function(id2) {
    const vertex = vert[id2];
    let classStr = "default";
    if (vertex.classes.length > 0) {
      classStr = vertex.classes.join(" ");
    }
    const styles = getStylesFromArray(vertex.styles);
    let vertexText = vertex.text !== void 0 ? vertex.text : vertex.id;
    let vertexNode;
    if (evaluate(getConfig$1().flowchart.htmlLabels)) {
      const node2 = {
        label: vertexText.replace(
          /fa[lrsb]?:fa-[\w-]+/g,
          (s2) => `<i class='${s2.replace(":", " ")}'></i>`
        )
      };
      vertexNode = addHtmlLabel_1(svg2, node2).node();
      vertexNode.parentNode.removeChild(vertexNode);
    } else {
      const svgLabel = doc2.createElementNS("http://www.w3.org/2000/svg", "text");
      svgLabel.setAttribute("style", styles.labelStyle.replace("color:", "fill:"));
      const rows = vertexText.split(common.lineBreakRegex);
      for (let j2 = 0; j2 < rows.length; j2++) {
        const tspan = doc2.createElementNS("http://www.w3.org/2000/svg", "tspan");
        tspan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
        tspan.setAttribute("dy", "1em");
        tspan.setAttribute("x", "1");
        tspan.textContent = rows[j2];
        svgLabel.appendChild(tspan);
      }
      vertexNode = svgLabel;
    }
    let radious = 0;
    let _shape = "";
    switch (vertex.type) {
      case "round":
        radious = 5;
        _shape = "rect";
        break;
      case "square":
        _shape = "rect";
        break;
      case "diamond":
        _shape = "question";
        break;
      case "hexagon":
        _shape = "hexagon";
        break;
      case "odd":
        _shape = "rect_left_inv_arrow";
        break;
      case "lean_right":
        _shape = "lean_right";
        break;
      case "lean_left":
        _shape = "lean_left";
        break;
      case "trapezoid":
        _shape = "trapezoid";
        break;
      case "inv_trapezoid":
        _shape = "inv_trapezoid";
        break;
      case "odd_right":
        _shape = "rect_left_inv_arrow";
        break;
      case "circle":
        _shape = "circle";
        break;
      case "ellipse":
        _shape = "ellipse";
        break;
      case "stadium":
        _shape = "stadium";
        break;
      case "subroutine":
        _shape = "subroutine";
        break;
      case "cylinder":
        _shape = "cylinder";
        break;
      case "group":
        _shape = "rect";
        break;
      case "doublecircle":
        _shape = "doublecircle";
        break;
      default:
        _shape = "rect";
    }
    g2.setNode(vertex.id, {
      labelStyle: styles.labelStyle,
      shape: _shape,
      labelText: vertexText,
      rx: radious,
      ry: radious,
      class: classStr,
      style: styles.style,
      id: vertex.id,
      link: vertex.link,
      linkTarget: vertex.linkTarget,
      tooltip: diagObj.db.getTooltip(vertex.id) || "",
      domId: diagObj.db.lookUpDomId(vertex.id),
      haveCallback: vertex.haveCallback,
      width: vertex.type === "group" ? 500 : void 0,
      dir: vertex.dir,
      type: vertex.type,
      props: vertex.props,
      padding: getConfig$1().flowchart.padding
    });
    log$1.info("setNode", {
      labelStyle: styles.labelStyle,
      shape: _shape,
      labelText: vertexText,
      rx: radious,
      ry: radious,
      class: classStr,
      style: styles.style,
      id: vertex.id,
      domId: diagObj.db.lookUpDomId(vertex.id),
      width: vertex.type === "group" ? 500 : void 0,
      type: vertex.type,
      dir: vertex.dir,
      props: vertex.props,
      padding: getConfig$1().flowchart.padding
    });
  });
};
const addEdges = function(edges2, g2, diagObj) {
  log$1.info("abc78 edges = ", edges2);
  let cnt2 = 0;
  let linkIdCnt = {};
  let defaultStyle2;
  let defaultLabelStyle;
  if (typeof edges2.defaultStyle !== "undefined") {
    const defaultStyles = getStylesFromArray(edges2.defaultStyle);
    defaultStyle2 = defaultStyles.style;
    defaultLabelStyle = defaultStyles.labelStyle;
  }
  edges2.forEach(function(edge) {
    cnt2++;
    var linkIdBase = "L-" + edge.start + "-" + edge.end;
    if (typeof linkIdCnt[linkIdBase] === "undefined") {
      linkIdCnt[linkIdBase] = 0;
      log$1.info("abc78 new entry", linkIdBase, linkIdCnt[linkIdBase]);
    } else {
      linkIdCnt[linkIdBase]++;
      log$1.info("abc78 new entry", linkIdBase, linkIdCnt[linkIdBase]);
    }
    let linkId = linkIdBase + "-" + linkIdCnt[linkIdBase];
    log$1.info("abc78 new link id to be used is", linkIdBase, linkId, linkIdCnt[linkIdBase]);
    var linkNameStart = "LS-" + edge.start;
    var linkNameEnd = "LE-" + edge.end;
    const edgeData = { style: "", labelStyle: "" };
    edgeData.minlen = edge.length || 1;
    if (edge.type === "arrow_open") {
      edgeData.arrowhead = "none";
    } else {
      edgeData.arrowhead = "normal";
    }
    edgeData.arrowTypeStart = "arrow_open";
    edgeData.arrowTypeEnd = "arrow_open";
    switch (edge.type) {
      case "double_arrow_cross":
        edgeData.arrowTypeStart = "arrow_cross";
      case "arrow_cross":
        edgeData.arrowTypeEnd = "arrow_cross";
        break;
      case "double_arrow_point":
        edgeData.arrowTypeStart = "arrow_point";
      case "arrow_point":
        edgeData.arrowTypeEnd = "arrow_point";
        break;
      case "double_arrow_circle":
        edgeData.arrowTypeStart = "arrow_circle";
      case "arrow_circle":
        edgeData.arrowTypeEnd = "arrow_circle";
        break;
    }
    let style2 = "";
    let labelStyle = "";
    switch (edge.stroke) {
      case "normal":
        style2 = "fill:none;";
        if (typeof defaultStyle2 !== "undefined") {
          style2 = defaultStyle2;
        }
        if (typeof defaultLabelStyle !== "undefined") {
          labelStyle = defaultLabelStyle;
        }
        edgeData.thickness = "normal";
        edgeData.pattern = "solid";
        break;
      case "dotted":
        edgeData.thickness = "normal";
        edgeData.pattern = "dotted";
        edgeData.style = "fill:none;stroke-width:2px;stroke-dasharray:3;";
        break;
      case "thick":
        edgeData.thickness = "thick";
        edgeData.pattern = "solid";
        edgeData.style = "stroke-width: 3.5px;fill:none;";
        break;
      case "invisible":
        edgeData.thickness = "invisible";
        edgeData.pattern = "solid";
        edgeData.style = "stroke-width: 0;fill:none;";
        break;
    }
    if (typeof edge.style !== "undefined") {
      const styles = getStylesFromArray(edge.style);
      style2 = styles.style;
      labelStyle = styles.labelStyle;
    }
    edgeData.style = edgeData.style += style2;
    edgeData.labelStyle = edgeData.labelStyle += labelStyle;
    if (typeof edge.interpolate !== "undefined") {
      edgeData.curve = interpolateToCurve(edge.interpolate, curveLinear$1);
    } else if (typeof edges2.defaultInterpolate !== "undefined") {
      edgeData.curve = interpolateToCurve(edges2.defaultInterpolate, curveLinear$1);
    } else {
      edgeData.curve = interpolateToCurve(conf$7.curve, curveLinear$1);
    }
    if (typeof edge.text === "undefined") {
      if (typeof edge.style !== "undefined") {
        edgeData.arrowheadStyle = "fill: #333";
      }
    } else {
      edgeData.arrowheadStyle = "fill: #333";
      edgeData.labelpos = "c";
    }
    edgeData.labelType = "text";
    edgeData.label = edge.text.replace(common.lineBreakRegex, "\n");
    if (typeof edge.style === "undefined") {
      edgeData.style = edgeData.style || "stroke: #333; stroke-width: 1.5px;fill:none;";
    }
    edgeData.labelStyle = edgeData.labelStyle.replace("color:", "fill:");
    edgeData.id = linkId;
    edgeData.classes = "flowchart-link " + linkNameStart + " " + linkNameEnd;
    g2.setEdge(edge.start, edge.end, edgeData, cnt2);
  });
};
const getClasses$2 = function(text2, diagObj) {
  log$1.info("Extracting classes");
  diagObj.db.clear();
  try {
    diagObj.parse(text2);
    return diagObj.db.getClasses();
  } catch (e) {
    return;
  }
};
const draw$9 = function(text2, id2, _version, diagObj) {
  log$1.info("Drawing flowchart");
  diagObj.db.clear();
  flowDb.setGen("gen-2");
  diagObj.parser.parse(text2);
  let dir = diagObj.db.getDirection();
  if (typeof dir === "undefined") {
    dir = "TD";
  }
  const { securityLevel, flowchart: conf2 } = getConfig$1();
  const nodeSpacing = conf2.nodeSpacing || 50;
  const rankSpacing = conf2.rankSpacing || 50;
  let sandboxElement;
  if (securityLevel === "sandbox") {
    sandboxElement = select$1("#i" + id2);
  }
  const root2 = securityLevel === "sandbox" ? select$1(sandboxElement.nodes()[0].contentDocument.body) : select$1("body");
  const doc2 = securityLevel === "sandbox" ? sandboxElement.nodes()[0].contentDocument : document;
  const g2 = new graphlib$2.Graph({
    multigraph: true,
    compound: true
  }).setGraph({
    rankdir: dir,
    nodesep: nodeSpacing,
    ranksep: rankSpacing,
    marginx: 0,
    marginy: 0
  }).setDefaultEdgeLabel(function() {
    return {};
  });
  let subG;
  const subGraphs2 = diagObj.db.getSubGraphs();
  log$1.info("Subgraphs - ", subGraphs2);
  for (let i2 = subGraphs2.length - 1; i2 >= 0; i2--) {
    subG = subGraphs2[i2];
    log$1.info("Subgraph - ", subG);
    diagObj.db.addVertex(subG.id, subG.title, "group", void 0, subG.classes, subG.dir);
  }
  const vert = diagObj.db.getVertices();
  const edges2 = diagObj.db.getEdges();
  log$1.info(edges2);
  let i = 0;
  for (i = subGraphs2.length - 1; i >= 0; i--) {
    subG = subGraphs2[i];
    selectAll$1("cluster").append("text");
    for (let j2 = 0; j2 < subG.nodes.length; j2++) {
      log$1.info("Setting up subgraphs", subG.nodes[j2], subG.id);
      g2.setParent(subG.nodes[j2], subG.id);
    }
  }
  addVertices(vert, g2, id2, root2, doc2, diagObj);
  addEdges(edges2, g2);
  const svg2 = root2.select(`[id="${id2}"]`);
  addSVGAccessibilityFields(diagObj.db, svg2, id2);
  const element = root2.select("#" + id2 + " g");
  render$1(element, g2, ["point", "circle", "cross"], "flowchart", id2);
  setupGraphViewbox$1(g2, svg2, conf2.diagramPadding, conf2.useMaxWidth);
  diagObj.db.indexNodes("subGraph" + i);
  if (!conf2.htmlLabels) {
    const labels = doc2.querySelectorAll('[id="' + id2 + '"] .edgeLabel .label');
    for (let k2 = 0; k2 < labels.length; k2++) {
      const label = labels[k2];
      const dim = label.getBBox();
      const rect2 = doc2.createElementNS("http://www.w3.org/2000/svg", "rect");
      rect2.setAttribute("rx", 0);
      rect2.setAttribute("ry", 0);
      rect2.setAttribute("width", dim.width);
      rect2.setAttribute("height", dim.height);
      label.insertBefore(rect2, label.firstChild);
    }
  }
  const keys2 = Object.keys(vert);
  keys2.forEach(function(key) {
    const vertex = vert[key];
    if (vertex.link) {
      const node2 = select$1("#" + id2 + ' [id="' + key + '"]');
      if (node2) {
        const link2 = doc2.createElementNS("http://www.w3.org/2000/svg", "a");
        link2.setAttributeNS("http://www.w3.org/2000/svg", "class", vertex.classes.join(" "));
        link2.setAttributeNS("http://www.w3.org/2000/svg", "href", vertex.link);
        link2.setAttributeNS("http://www.w3.org/2000/svg", "rel", "noopener");
        if (securityLevel === "sandbox") {
          link2.setAttributeNS("http://www.w3.org/2000/svg", "target", "_top");
        } else if (vertex.linkTarget) {
          link2.setAttributeNS("http://www.w3.org/2000/svg", "target", vertex.linkTarget);
        }
        const linkNode = node2.insert(function() {
          return link2;
        }, ":first-child");
        const shape = node2.select(".label-container");
        if (shape) {
          linkNode.append(function() {
            return shape.node();
          });
        }
        const label = node2.select(".label");
        if (label) {
          linkNode.append(function() {
            return label.node();
          });
        }
      }
    }
  });
};
const flowRendererV2 = {
  setConf: setConf$6,
  addVertices,
  addEdges,
  getClasses: getClasses$2,
  draw: draw$9
};
var parser$6 = function() {
  var o = function(k2, v, o2, l2) {
    for (o2 = o2 || {}, l2 = k2.length; l2--; o2[k2[l2]] = v)
      ;
    return o2;
  }, $V0 = [1, 3], $V1 = [1, 5], $V2 = [7, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 22, 24, 25, 27, 34, 39], $V3 = [1, 15], $V4 = [1, 16], $V5 = [1, 17], $V6 = [1, 18], $V7 = [1, 19], $V8 = [1, 20], $V9 = [1, 21], $Va = [1, 22], $Vb = [1, 23], $Vc = [1, 24], $Vd = [1, 25], $Ve = [1, 26], $Vf = [1, 28], $Vg = [1, 30], $Vh = [1, 33], $Vi = [5, 7, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 22, 24, 25, 27, 34, 39];
  var parser2 = {
    trace: function trace() {
    },
    yy: {},
    symbols_: { "error": 2, "start": 3, "directive": 4, "gantt": 5, "document": 6, "EOF": 7, "line": 8, "SPACE": 9, "statement": 10, "NL": 11, "dateFormat": 12, "inclusiveEndDates": 13, "topAxis": 14, "axisFormat": 15, "excludes": 16, "includes": 17, "todayMarker": 18, "title": 19, "acc_title": 20, "acc_title_value": 21, "acc_descr": 22, "acc_descr_value": 23, "acc_descr_multiline_value": 24, "section": 25, "clickStatement": 26, "taskTxt": 27, "taskData": 28, "openDirective": 29, "typeDirective": 30, "closeDirective": 31, ":": 32, "argDirective": 33, "click": 34, "callbackname": 35, "callbackargs": 36, "href": 37, "clickStatementDebug": 38, "open_directive": 39, "type_directive": 40, "arg_directive": 41, "close_directive": 42, "$accept": 0, "$end": 1 },
    terminals_: { 2: "error", 5: "gantt", 7: "EOF", 9: "SPACE", 11: "NL", 12: "dateFormat", 13: "inclusiveEndDates", 14: "topAxis", 15: "axisFormat", 16: "excludes", 17: "includes", 18: "todayMarker", 19: "title", 20: "acc_title", 21: "acc_title_value", 22: "acc_descr", 23: "acc_descr_value", 24: "acc_descr_multiline_value", 25: "section", 27: "taskTxt", 28: "taskData", 32: ":", 34: "click", 35: "callbackname", 36: "callbackargs", 37: "href", 39: "open_directive", 40: "type_directive", 41: "arg_directive", 42: "close_directive" },
    productions_: [0, [3, 2], [3, 3], [6, 0], [6, 2], [8, 2], [8, 1], [8, 1], [8, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 2], [10, 2], [10, 1], [10, 1], [10, 1], [10, 2], [10, 1], [4, 4], [4, 6], [26, 2], [26, 3], [26, 3], [26, 4], [26, 3], [26, 4], [26, 2], [38, 2], [38, 3], [38, 3], [38, 4], [38, 3], [38, 4], [38, 2], [29, 1], [30, 1], [33, 1], [31, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 2:
          return $$[$0 - 1];
        case 3:
          this.$ = [];
          break;
        case 4:
          $$[$0 - 1].push($$[$0]);
          this.$ = $$[$0 - 1];
          break;
        case 5:
        case 6:
          this.$ = $$[$0];
          break;
        case 7:
        case 8:
          this.$ = [];
          break;
        case 9:
          yy.setDateFormat($$[$0].substr(11));
          this.$ = $$[$0].substr(11);
          break;
        case 10:
          yy.enableInclusiveEndDates();
          this.$ = $$[$0].substr(18);
          break;
        case 11:
          yy.TopAxis();
          this.$ = $$[$0].substr(8);
          break;
        case 12:
          yy.setAxisFormat($$[$0].substr(11));
          this.$ = $$[$0].substr(11);
          break;
        case 13:
          yy.setExcludes($$[$0].substr(9));
          this.$ = $$[$0].substr(9);
          break;
        case 14:
          yy.setIncludes($$[$0].substr(9));
          this.$ = $$[$0].substr(9);
          break;
        case 15:
          yy.setTodayMarker($$[$0].substr(12));
          this.$ = $$[$0].substr(12);
          break;
        case 16:
          yy.setDiagramTitle($$[$0].substr(6));
          this.$ = $$[$0].substr(6);
          break;
        case 17:
          this.$ = $$[$0].trim();
          yy.setAccTitle(this.$);
          break;
        case 18:
        case 19:
          this.$ = $$[$0].trim();
          yy.setAccDescription(this.$);
          break;
        case 20:
          yy.addSection($$[$0].substr(8));
          this.$ = $$[$0].substr(8);
          break;
        case 22:
          yy.addTask($$[$0 - 1], $$[$0]);
          this.$ = "task";
          break;
        case 26:
          this.$ = $$[$0 - 1];
          yy.setClickEvent($$[$0 - 1], $$[$0], null);
          break;
        case 27:
          this.$ = $$[$0 - 2];
          yy.setClickEvent($$[$0 - 2], $$[$0 - 1], $$[$0]);
          break;
        case 28:
          this.$ = $$[$0 - 2];
          yy.setClickEvent($$[$0 - 2], $$[$0 - 1], null);
          yy.setLink($$[$0 - 2], $$[$0]);
          break;
        case 29:
          this.$ = $$[$0 - 3];
          yy.setClickEvent($$[$0 - 3], $$[$0 - 2], $$[$0 - 1]);
          yy.setLink($$[$0 - 3], $$[$0]);
          break;
        case 30:
          this.$ = $$[$0 - 2];
          yy.setClickEvent($$[$0 - 2], $$[$0], null);
          yy.setLink($$[$0 - 2], $$[$0 - 1]);
          break;
        case 31:
          this.$ = $$[$0 - 3];
          yy.setClickEvent($$[$0 - 3], $$[$0 - 1], $$[$0]);
          yy.setLink($$[$0 - 3], $$[$0 - 2]);
          break;
        case 32:
          this.$ = $$[$0 - 1];
          yy.setLink($$[$0 - 1], $$[$0]);
          break;
        case 33:
        case 39:
          this.$ = $$[$0 - 1] + " " + $$[$0];
          break;
        case 34:
        case 35:
        case 37:
          this.$ = $$[$0 - 2] + " " + $$[$0 - 1] + " " + $$[$0];
          break;
        case 36:
        case 38:
          this.$ = $$[$0 - 3] + " " + $$[$0 - 2] + " " + $$[$0 - 1] + " " + $$[$0];
          break;
        case 40:
          yy.parseDirective("%%{", "open_directive");
          break;
        case 41:
          yy.parseDirective($$[$0], "type_directive");
          break;
        case 42:
          $$[$0] = $$[$0].trim().replace(/'/g, '"');
          yy.parseDirective($$[$0], "arg_directive");
          break;
        case 43:
          yy.parseDirective("}%%", "close_directive", "gantt");
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 5: $V0, 29: 4, 39: $V1 }, { 1: [3] }, { 3: 6, 4: 2, 5: $V0, 29: 4, 39: $V1 }, o($V2, [2, 3], { 6: 7 }), { 30: 8, 40: [1, 9] }, { 40: [2, 40] }, { 1: [2, 1] }, { 4: 29, 7: [1, 10], 8: 11, 9: [1, 12], 10: 13, 11: [1, 14], 12: $V3, 13: $V4, 14: $V5, 15: $V6, 16: $V7, 17: $V8, 18: $V9, 19: $Va, 20: $Vb, 22: $Vc, 24: $Vd, 25: $Ve, 26: 27, 27: $Vf, 29: 4, 34: $Vg, 39: $V1 }, { 31: 31, 32: [1, 32], 42: $Vh }, o([32, 42], [2, 41]), o($V2, [2, 8], { 1: [2, 2] }), o($V2, [2, 4]), { 4: 29, 10: 34, 12: $V3, 13: $V4, 14: $V5, 15: $V6, 16: $V7, 17: $V8, 18: $V9, 19: $Va, 20: $Vb, 22: $Vc, 24: $Vd, 25: $Ve, 26: 27, 27: $Vf, 29: 4, 34: $Vg, 39: $V1 }, o($V2, [2, 6]), o($V2, [2, 7]), o($V2, [2, 9]), o($V2, [2, 10]), o($V2, [2, 11]), o($V2, [2, 12]), o($V2, [2, 13]), o($V2, [2, 14]), o($V2, [2, 15]), o($V2, [2, 16]), { 21: [1, 35] }, { 23: [1, 36] }, o($V2, [2, 19]), o($V2, [2, 20]), o($V2, [2, 21]), { 28: [1, 37] }, o($V2, [2, 23]), { 35: [1, 38], 37: [1, 39] }, { 11: [1, 40] }, { 33: 41, 41: [1, 42] }, { 11: [2, 43] }, o($V2, [2, 5]), o($V2, [2, 17]), o($V2, [2, 18]), o($V2, [2, 22]), o($V2, [2, 26], { 36: [1, 43], 37: [1, 44] }), o($V2, [2, 32], { 35: [1, 45] }), o($Vi, [2, 24]), { 31: 46, 42: $Vh }, { 42: [2, 42] }, o($V2, [2, 27], { 37: [1, 47] }), o($V2, [2, 28]), o($V2, [2, 30], { 36: [1, 48] }), { 11: [1, 49] }, o($V2, [2, 29]), o($V2, [2, 31]), o($Vi, [2, 25])],
    defaultActions: { 5: [2, 40], 6: [2, 1], 33: [2, 43], 42: [2, 42] },
    parseError: function parseError(str, hash2) {
      if (hash2.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash2;
        throw error;
      }
    },
    parse: function parse2(input) {
      var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k2 in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
          sharedState.yy[k2] = this.yy[k2];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges2 = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function lex() {
        var token2;
        token2 = tstack.pop() || lexer2.lex() || EOF2;
        if (typeof token2 !== "number") {
          if (token2 instanceof Array) {
            tstack = token2;
            token2 = tstack.pop();
          }
          token2 = self2.symbols_[token2] || token2;
        }
        return token2;
      }
      var symbol2, state, action, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack2[stack2.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol2 === null || typeof symbol2 == "undefined") {
            symbol2 = lex();
          }
          action = table[state] && table[state][symbol2];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push("'" + this.terminals_[p] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol2] || symbol2) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol2 == EOF2 ? "end of input" : "'" + (this.terminals_[symbol2] || symbol2) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol2] || symbol2,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol2);
        }
        switch (action[0]) {
          case 1:
            stack2.push(symbol2);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack2.push(action[1]);
            symbol2 = null;
            {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges2) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
              ];
            }
            r = this.performAction.apply(yyval, [
              yytext,
              yyleng,
              yylineno,
              sharedState.yy,
              action[1],
              vstack,
              lstack
            ].concat(args));
            if (typeof r !== "undefined") {
              return r;
            }
            if (len) {
              stack2 = stack2.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack2.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
            stack2.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash2) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash2);
        } else {
          throw new Error(str);
        }
      },
      setInput: function(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      input: function() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      unput: function(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      more: function() {
        this._more = true;
        return this;
      },
      reject: function() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      less: function(n) {
        this.unput(this.match.slice(n));
      },
      pastInput: function() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var next2 = this.match;
        if (next2.length < 20) {
          next2 += this._input.substr(0, 20 - next2.length);
        }
        return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var pre = this.pastInput();
        var c2 = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c2 + "^";
      },
      test_match: function(match, indexed_rule) {
        var token2, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token2) {
          return token2;
        } else if (this._backtrack) {
          for (var k2 in backup) {
            this[k2] = backup[k2];
          }
          return false;
        }
        return false;
      },
      next: function() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token2, match, tempMatch, index2;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index2 = i;
            if (this.options.backtrack_lexer) {
              token2 = this.test_match(tempMatch, rules[i]);
              if (token2 !== false) {
                return token2;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token2 = this.test_match(match, rules[index2]);
          if (token2 !== false) {
            return token2;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": true },
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        switch ($avoiding_name_collisions) {
          case 0:
            this.begin("open_directive");
            return 39;
          case 1:
            this.begin("type_directive");
            return 40;
          case 2:
            this.popState();
            this.begin("arg_directive");
            return 32;
          case 3:
            this.popState();
            this.popState();
            return 42;
          case 4:
            return 41;
          case 5:
            this.begin("acc_title");
            return 20;
          case 6:
            this.popState();
            return "acc_title_value";
          case 7:
            this.begin("acc_descr");
            return 22;
          case 8:
            this.popState();
            return "acc_descr_value";
          case 9:
            this.begin("acc_descr_multiline");
            break;
          case 10:
            this.popState();
            break;
          case 11:
            return "acc_descr_multiline_value";
          case 12:
            break;
          case 13:
            break;
          case 14:
            break;
          case 15:
            return 11;
          case 16:
            break;
          case 17:
            break;
          case 18:
            break;
          case 19:
            this.begin("href");
            break;
          case 20:
            this.popState();
            break;
          case 21:
            return 37;
          case 22:
            this.begin("callbackname");
            break;
          case 23:
            this.popState();
            break;
          case 24:
            this.popState();
            this.begin("callbackargs");
            break;
          case 25:
            return 35;
          case 26:
            this.popState();
            break;
          case 27:
            return 36;
          case 28:
            this.begin("click");
            break;
          case 29:
            this.popState();
            break;
          case 30:
            return 34;
          case 31:
            return 5;
          case 32:
            return 12;
          case 33:
            return 13;
          case 34:
            return 14;
          case 35:
            return 15;
          case 36:
            return 17;
          case 37:
            return 16;
          case 38:
            return 18;
          case 39:
            return "date";
          case 40:
            return 19;
          case 41:
            return "accDescription";
          case 42:
            return 25;
          case 43:
            return 27;
          case 44:
            return 28;
          case 45:
            return 32;
          case 46:
            return 7;
          case 47:
            return "INVALID";
        }
      },
      rules: [/^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:%%(?!\{)*[^\n]*)/i, /^(?:[^\}]%%*[^\n]*)/i, /^(?:%%*[^\n]*[\n]*)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:#[^\n]*)/i, /^(?:%[^\n]*)/i, /^(?:href[\s]+["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:call[\s]+)/i, /^(?:\([\s]*\))/i, /^(?:\()/i, /^(?:[^(]*)/i, /^(?:\))/i, /^(?:[^)]*)/i, /^(?:click[\s]+)/i, /^(?:[\s\n])/i, /^(?:[^\s\n]*)/i, /^(?:gantt\b)/i, /^(?:dateFormat\s[^#\n;]+)/i, /^(?:inclusiveEndDates\b)/i, /^(?:topAxis\b)/i, /^(?:axisFormat\s[^#\n;]+)/i, /^(?:includes\s[^#\n;]+)/i, /^(?:excludes\s[^#\n;]+)/i, /^(?:todayMarker\s[^\n;]+)/i, /^(?:\d\d\d\d-\d\d-\d\d\b)/i, /^(?:title\s[^#\n;]+)/i, /^(?:accDescription\s[^#\n;]+)/i, /^(?:section\s[^#:\n;]+)/i, /^(?:[^#:\n;]+)/i, /^(?::[^#\n;]+)/i, /^(?::)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { "acc_descr_multiline": { "rules": [10, 11], "inclusive": false }, "acc_descr": { "rules": [8], "inclusive": false }, "acc_title": { "rules": [6], "inclusive": false }, "close_directive": { "rules": [], "inclusive": false }, "arg_directive": { "rules": [3, 4], "inclusive": false }, "type_directive": { "rules": [2, 3], "inclusive": false }, "open_directive": { "rules": [1], "inclusive": false }, "callbackargs": { "rules": [26, 27], "inclusive": false }, "callbackname": { "rules": [23, 24, 25], "inclusive": false }, "href": { "rules": [20, 21], "inclusive": false }, "click": { "rules": [29, 30], "inclusive": false }, "INITIAL": { "rules": [0, 5, 7, 9, 12, 13, 14, 15, 16, 17, 18, 19, 22, 28, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47], "inclusive": true } }
    };
    return lexer2;
  }();
  parser2.lexer = lexer;
  function Parser2() {
    this.yy = {};
  }
  Parser2.prototype = parser2;
  parser2.Parser = Parser2;
  return new Parser2();
}();
parser$6.parser = parser$6;
const ganttDetector = (txt) => {
  return txt.match(/^\s*gantt/) !== null;
};
let dateFormat = "";
let axisFormat = "";
let todayMarker = "";
let includes = [];
let excludes = [];
let links = {};
let sections$2 = [];
let tasks$1 = [];
let currentSection$1 = "";
const tags$2 = ["active", "done", "crit", "milestone"];
let funs = [];
let inclusiveEndDates = false;
let topAxis = false;
let lastOrder = 0;
const parseDirective$6 = function(statement, context, type2) {
  mermaidAPI.parseDirective(this, statement, context, type2);
};
const clear$5 = function() {
  sections$2 = [];
  tasks$1 = [];
  currentSection$1 = "";
  funs = [];
  taskCnt = 0;
  lastTask = void 0;
  lastTaskID = void 0;
  rawTasks$1 = [];
  dateFormat = "";
  axisFormat = "";
  todayMarker = "";
  includes = [];
  excludes = [];
  inclusiveEndDates = false;
  topAxis = false;
  lastOrder = 0;
  links = {};
  clear$g();
};
const setAxisFormat = function(txt) {
  axisFormat = txt;
};
const getAxisFormat = function() {
  return axisFormat;
};
const setTodayMarker = function(txt) {
  todayMarker = txt;
};
const getTodayMarker = function() {
  return todayMarker;
};
const setDateFormat = function(txt) {
  dateFormat = txt;
};
const enableInclusiveEndDates = function() {
  inclusiveEndDates = true;
};
const endDatesAreInclusive = function() {
  return inclusiveEndDates;
};
const enableTopAxis = function() {
  topAxis = true;
};
const topAxisEnabled = function() {
  return topAxis;
};
const getDateFormat = function() {
  return dateFormat;
};
const setIncludes = function(txt) {
  includes = txt.toLowerCase().split(/[\s,]+/);
};
const getIncludes = function() {
  return includes;
};
const setExcludes = function(txt) {
  excludes = txt.toLowerCase().split(/[\s,]+/);
};
const getExcludes = function() {
  return excludes;
};
const getLinks = function() {
  return links;
};
const addSection$2 = function(txt) {
  currentSection$1 = txt;
  sections$2.push(txt);
};
const getSections$2 = function() {
  return sections$2;
};
const getTasks$1 = function() {
  let allItemsPricessed = compileTasks$1();
  const maxDepth2 = 10;
  let iterationCount = 0;
  while (!allItemsPricessed && iterationCount < maxDepth2) {
    allItemsPricessed = compileTasks$1();
    iterationCount++;
  }
  tasks$1 = rawTasks$1;
  return tasks$1;
};
const isInvalidDate = function(date2, dateFormat2, excludes2, includes2) {
  if (includes2.indexOf(date2.format(dateFormat2.trim())) >= 0) {
    return false;
  }
  if (date2.isoWeekday() >= 6 && excludes2.indexOf("weekends") >= 0) {
    return true;
  }
  if (excludes2.indexOf(date2.format("dddd").toLowerCase()) >= 0) {
    return true;
  }
  return excludes2.indexOf(date2.format(dateFormat2.trim())) >= 0;
};
const checkTaskDates = function(task, dateFormat2, excludes2, includes2) {
  if (!excludes2.length || task.manualEndTime)
    return;
  let startTime = moment(task.startTime, dateFormat2, true);
  startTime.add(1, "d");
  let endTime = moment(task.endTime, dateFormat2, true);
  let renderEndTime = fixTaskDates(startTime, endTime, dateFormat2, excludes2, includes2);
  task.endTime = endTime.toDate();
  task.renderEndTime = renderEndTime;
};
const fixTaskDates = function(startTime, endTime, dateFormat2, excludes2, includes2) {
  let invalid = false;
  let renderEndTime = null;
  while (startTime <= endTime) {
    if (!invalid) {
      renderEndTime = endTime.toDate();
    }
    invalid = isInvalidDate(startTime, dateFormat2, excludes2, includes2);
    if (invalid) {
      endTime.add(1, "d");
    }
    startTime.add(1, "d");
  }
  return renderEndTime;
};
const getStartDate = function(prevTime, dateFormat2, str) {
  str = str.trim();
  const re2 = /^after\s+([\d\w- ]+)/;
  const afterStatement = re2.exec(str.trim());
  if (afterStatement !== null) {
    let latestEndingTask = null;
    afterStatement[1].split(" ").forEach(function(id2) {
      let task = findTaskById(id2);
      if (typeof task !== "undefined") {
        if (!latestEndingTask) {
          latestEndingTask = task;
        } else {
          if (task.endTime > latestEndingTask.endTime) {
            latestEndingTask = task;
          }
        }
      }
    });
    if (!latestEndingTask) {
      const dt = new Date();
      dt.setHours(0, 0, 0, 0);
      return dt;
    } else {
      return latestEndingTask.endTime;
    }
  }
  let mDate = moment(str, dateFormat2.trim(), true);
  if (mDate.isValid()) {
    return mDate.toDate();
  } else {
    log$1.debug("Invalid date:" + str);
    log$1.debug("With date format:" + dateFormat2.trim());
    const d = new Date(str);
    if (typeof d === "undefined" || isNaN(d.getTime())) {
      throw new Error("Invalid date:" + str);
    }
    return d;
  }
};
const parseDuration = function(str) {
  const statement = /^(\d+(?:\.\d+)?)([yMwdhms]|ms)$/.exec(str.trim());
  if (statement !== null) {
    return moment.duration(Number.parseFloat(statement[1]), statement[2]);
  }
  return moment.duration.invalid();
};
const getEndDate = function(prevTime, dateFormat2, str, inclusive) {
  inclusive = inclusive || false;
  str = str.trim();
  let mDate = moment(str, dateFormat2.trim(), true);
  if (mDate.isValid()) {
    if (inclusive) {
      mDate.add(1, "d");
    }
    return mDate.toDate();
  }
  const endTime = moment(prevTime);
  const duration = parseDuration(str);
  if (duration.isValid()) {
    endTime.add(duration);
  }
  return endTime.toDate();
};
let taskCnt = 0;
const parseId = function(idStr) {
  if (typeof idStr === "undefined") {
    taskCnt = taskCnt + 1;
    return "task" + taskCnt;
  }
  return idStr;
};
const compileData = function(prevTask, dataStr) {
  let ds;
  if (dataStr.substr(0, 1) === ":") {
    ds = dataStr.substr(1, dataStr.length);
  } else {
    ds = dataStr;
  }
  const data2 = ds.split(",");
  const task = {};
  getTaskTags(data2, task, tags$2);
  for (let i = 0; i < data2.length; i++) {
    data2[i] = data2[i].trim();
  }
  let endTimeData = "";
  switch (data2.length) {
    case 1:
      task.id = parseId();
      task.startTime = prevTask.endTime;
      endTimeData = data2[0];
      break;
    case 2:
      task.id = parseId();
      task.startTime = getStartDate(void 0, dateFormat, data2[0]);
      endTimeData = data2[1];
      break;
    case 3:
      task.id = parseId(data2[0]);
      task.startTime = getStartDate(void 0, dateFormat, data2[1]);
      endTimeData = data2[2];
      break;
  }
  if (endTimeData) {
    task.endTime = getEndDate(task.startTime, dateFormat, endTimeData, inclusiveEndDates);
    task.manualEndTime = moment(endTimeData, "YYYY-MM-DD", true).isValid();
    checkTaskDates(task, dateFormat, excludes, includes);
  }
  return task;
};
const parseData = function(prevTaskId, dataStr) {
  let ds;
  if (dataStr.substr(0, 1) === ":") {
    ds = dataStr.substr(1, dataStr.length);
  } else {
    ds = dataStr;
  }
  const data2 = ds.split(",");
  const task = {};
  getTaskTags(data2, task, tags$2);
  for (let i = 0; i < data2.length; i++) {
    data2[i] = data2[i].trim();
  }
  switch (data2.length) {
    case 1:
      task.id = parseId();
      task.startTime = {
        type: "prevTaskEnd",
        id: prevTaskId
      };
      task.endTime = {
        data: data2[0]
      };
      break;
    case 2:
      task.id = parseId();
      task.startTime = {
        type: "getStartDate",
        startData: data2[0]
      };
      task.endTime = {
        data: data2[1]
      };
      break;
    case 3:
      task.id = parseId(data2[0]);
      task.startTime = {
        type: "getStartDate",
        startData: data2[1]
      };
      task.endTime = {
        data: data2[2]
      };
      break;
  }
  return task;
};
let lastTask;
let lastTaskID;
let rawTasks$1 = [];
const taskDb = {};
const addTask$1 = function(descr, data2) {
  const rawTask = {
    section: currentSection$1,
    type: currentSection$1,
    processed: false,
    manualEndTime: false,
    renderEndTime: null,
    raw: { data: data2 },
    task: descr,
    classes: []
  };
  const taskInfo = parseData(lastTaskID, data2);
  rawTask.raw.startTime = taskInfo.startTime;
  rawTask.raw.endTime = taskInfo.endTime;
  rawTask.id = taskInfo.id;
  rawTask.prevTaskId = lastTaskID;
  rawTask.active = taskInfo.active;
  rawTask.done = taskInfo.done;
  rawTask.crit = taskInfo.crit;
  rawTask.milestone = taskInfo.milestone;
  rawTask.order = lastOrder;
  lastOrder++;
  const pos = rawTasks$1.push(rawTask);
  lastTaskID = rawTask.id;
  taskDb[rawTask.id] = pos - 1;
};
const findTaskById = function(id2) {
  const pos = taskDb[id2];
  return rawTasks$1[pos];
};
const addTaskOrg$1 = function(descr, data2) {
  const newTask = {
    section: currentSection$1,
    type: currentSection$1,
    description: descr,
    task: descr,
    classes: []
  };
  const taskInfo = compileData(lastTask, data2);
  newTask.startTime = taskInfo.startTime;
  newTask.endTime = taskInfo.endTime;
  newTask.id = taskInfo.id;
  newTask.active = taskInfo.active;
  newTask.done = taskInfo.done;
  newTask.crit = taskInfo.crit;
  newTask.milestone = taskInfo.milestone;
  lastTask = newTask;
  tasks$1.push(newTask);
};
const compileTasks$1 = function() {
  const compileTask = function(pos) {
    const task = rawTasks$1[pos];
    let startTime = "";
    switch (rawTasks$1[pos].raw.startTime.type) {
      case "prevTaskEnd": {
        const prevTask = findTaskById(task.prevTaskId);
        task.startTime = prevTask.endTime;
        break;
      }
      case "getStartDate":
        startTime = getStartDate(void 0, dateFormat, rawTasks$1[pos].raw.startTime.startData);
        if (startTime) {
          rawTasks$1[pos].startTime = startTime;
        }
        break;
    }
    if (rawTasks$1[pos].startTime) {
      rawTasks$1[pos].endTime = getEndDate(
        rawTasks$1[pos].startTime,
        dateFormat,
        rawTasks$1[pos].raw.endTime.data,
        inclusiveEndDates
      );
      if (rawTasks$1[pos].endTime) {
        rawTasks$1[pos].processed = true;
        rawTasks$1[pos].manualEndTime = moment(
          rawTasks$1[pos].raw.endTime.data,
          "YYYY-MM-DD",
          true
        ).isValid();
        checkTaskDates(rawTasks$1[pos], dateFormat, excludes, includes);
      }
    }
    return rawTasks$1[pos].processed;
  };
  let allProcessed = true;
  for (let i = 0; i < rawTasks$1.length; i++) {
    compileTask(i);
    allProcessed = allProcessed && rawTasks$1[i].processed;
  }
  return allProcessed;
};
const setLink = function(ids, _linkStr) {
  let linkStr = _linkStr;
  if (getConfig$1().securityLevel !== "loose") {
    linkStr = sanitizeUrl_1(_linkStr);
  }
  ids.split(",").forEach(function(id2) {
    let rawTask = findTaskById(id2);
    if (typeof rawTask !== "undefined") {
      pushFun(id2, () => {
        window.open(linkStr, "_self");
      });
      links[id2] = linkStr;
    }
  });
  setClass(ids, "clickable");
};
const setClass = function(ids, className2) {
  ids.split(",").forEach(function(id2) {
    let rawTask = findTaskById(id2);
    if (typeof rawTask !== "undefined") {
      rawTask.classes.push(className2);
    }
  });
};
const setClickFun = function(id2, functionName, functionArgs) {
  if (getConfig$1().securityLevel !== "loose") {
    return;
  }
  if (typeof functionName === "undefined") {
    return;
  }
  let argList = [];
  if (typeof functionArgs === "string") {
    argList = functionArgs.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
    for (let i = 0; i < argList.length; i++) {
      let item = argList[i].trim();
      if (item.charAt(0) === '"' && item.charAt(item.length - 1) === '"') {
        item = item.substr(1, item.length - 2);
      }
      argList[i] = item;
    }
  }
  if (argList.length === 0) {
    argList.push(id2);
  }
  let rawTask = findTaskById(id2);
  if (typeof rawTask !== "undefined") {
    pushFun(id2, () => {
      utils.runFunc(functionName, ...argList);
    });
  }
};
const pushFun = function(id2, callbackFunction) {
  funs.push(function() {
    const elem = document.querySelector(`[id="${id2}"]`);
    if (elem !== null) {
      elem.addEventListener("click", function() {
        callbackFunction();
      });
    }
  });
  funs.push(function() {
    const elem = document.querySelector(`[id="${id2}-text"]`);
    if (elem !== null) {
      elem.addEventListener("click", function() {
        callbackFunction();
      });
    }
  });
};
const setClickEvent = function(ids, functionName, functionArgs) {
  ids.split(",").forEach(function(id2) {
    setClickFun(id2, functionName, functionArgs);
  });
  setClass(ids, "clickable");
};
const bindFunctions = function(element) {
  funs.forEach(function(fun) {
    fun(element);
  });
};
const ganttDb = {
  parseDirective: parseDirective$6,
  getConfig: () => getConfig$1().gantt,
  clear: clear$5,
  setDateFormat,
  getDateFormat,
  enableInclusiveEndDates,
  endDatesAreInclusive,
  enableTopAxis,
  topAxisEnabled,
  setAxisFormat,
  getAxisFormat,
  setTodayMarker,
  getTodayMarker,
  setAccTitle,
  getAccTitle,
  setDiagramTitle,
  getDiagramTitle,
  setAccDescription,
  getAccDescription,
  addSection: addSection$2,
  getSections: getSections$2,
  getTasks: getTasks$1,
  addTask: addTask$1,
  findTaskById,
  addTaskOrg: addTaskOrg$1,
  setIncludes,
  getIncludes,
  setExcludes,
  getExcludes,
  setClickEvent,
  setLink,
  getLinks,
  bindFunctions,
  parseDuration,
  isInvalidDate
};
function getTaskTags(data2, task, tags2) {
  let matchFound = true;
  while (matchFound) {
    matchFound = false;
    tags2.forEach(function(t4) {
      const pattern = "^\\s*" + t4 + "\\s*$";
      const regex = new RegExp(pattern);
      if (data2[0].match(regex)) {
        task[t4] = true;
        data2.shift(1);
        matchFound = true;
      }
    });
  }
}
const setConf$5 = function() {
  log$1.debug("Something is calling, setConf, remove the call");
};
let w;
const draw$8 = function(text2, id2, version2, diagObj) {
  const conf2 = getConfig$1().gantt;
  const securityLevel = getConfig$1().securityLevel;
  let sandboxElement;
  if (securityLevel === "sandbox") {
    sandboxElement = select$1("#i" + id2);
  }
  const root2 = securityLevel === "sandbox" ? select$1(sandboxElement.nodes()[0].contentDocument.body) : select$1("body");
  const doc2 = securityLevel === "sandbox" ? sandboxElement.nodes()[0].contentDocument : document;
  const elem = doc2.getElementById(id2);
  w = elem.parentElement.offsetWidth;
  if (typeof w === "undefined") {
    w = 1200;
  }
  if (typeof conf2.useWidth !== "undefined") {
    w = conf2.useWidth;
  }
  const taskArray = diagObj.db.getTasks();
  const h2 = taskArray.length * (conf2.barHeight + conf2.barGap) + 2 * conf2.topPadding;
  elem.setAttribute("viewBox", "0 0 " + w + " " + h2);
  const svg2 = root2.select(`[id="${id2}"]`);
  const timeScale = time$2().domain([
    min$3(taskArray, function(d) {
      return d.startTime;
    }),
    max$4(taskArray, function(d) {
      return d.endTime;
    })
  ]).rangeRound([0, w - conf2.leftPadding - conf2.rightPadding]);
  let categories = [];
  for (let i = 0; i < taskArray.length; i++) {
    categories.push(taskArray[i].type);
  }
  const catsUnfiltered = categories;
  categories = checkUnique(categories);
  function taskCompare(a2, b) {
    const taskA = a2.startTime;
    const taskB = b.startTime;
    let result = 0;
    if (taskA > taskB) {
      result = 1;
    } else if (taskA < taskB) {
      result = -1;
    }
    return result;
  }
  taskArray.sort(taskCompare);
  makeGant(taskArray, w, h2);
  configureSvgSize(svg2, h2, w, conf2.useMaxWidth);
  svg2.append("text").text(diagObj.db.getDiagramTitle()).attr("x", w / 2).attr("y", conf2.titleTopMargin).attr("class", "titleText");
  addSVGAccessibilityFields(diagObj.db, svg2, id2);
  function makeGant(tasks2, pageWidth, pageHeight2) {
    const barHeight = conf2.barHeight;
    const gap = barHeight + conf2.barGap;
    const topPadding = conf2.topPadding;
    const leftPadding = conf2.leftPadding;
    const colorScale = linear$3().domain([0, categories.length]).range(["#00B9FA", "#F95002"]).interpolate(interpolateHcl);
    drawExcludeDays(
      gap,
      topPadding,
      leftPadding,
      pageWidth,
      pageHeight2,
      tasks2,
      diagObj.db.getExcludes(),
      diagObj.db.getIncludes()
    );
    makeGrid(leftPadding, topPadding, pageWidth, pageHeight2);
    drawRects(tasks2, gap, topPadding, leftPadding, barHeight, colorScale, pageWidth);
    vertLabels(gap, topPadding);
    drawToday(leftPadding, topPadding, pageWidth, pageHeight2);
  }
  function drawRects(theArray, theGap, theTopPad, theSidePad, theBarHeight, theColorScale, w2) {
    svg2.append("g").selectAll("rect").data(theArray).enter().append("rect").attr("x", 0).attr("y", function(d, i) {
      i = d.order;
      return i * theGap + theTopPad - 2;
    }).attr("width", function() {
      return w2 - conf2.rightPadding / 2;
    }).attr("height", theGap).attr("class", function(d) {
      for (let i = 0; i < categories.length; i++) {
        if (d.type === categories[i]) {
          return "section section" + i % conf2.numberSectionStyles;
        }
      }
      return "section section0";
    });
    const rectangles = svg2.append("g").selectAll("rect").data(theArray).enter();
    const links2 = diagObj.db.getLinks();
    rectangles.append("rect").attr("id", function(d) {
      return d.id;
    }).attr("rx", 3).attr("ry", 3).attr("x", function(d) {
      if (d.milestone) {
        return timeScale(d.startTime) + theSidePad + 0.5 * (timeScale(d.endTime) - timeScale(d.startTime)) - 0.5 * theBarHeight;
      }
      return timeScale(d.startTime) + theSidePad;
    }).attr("y", function(d, i) {
      i = d.order;
      return i * theGap + theTopPad;
    }).attr("width", function(d) {
      if (d.milestone) {
        return theBarHeight;
      }
      return timeScale(d.renderEndTime || d.endTime) - timeScale(d.startTime);
    }).attr("height", theBarHeight).attr("transform-origin", function(d, i) {
      i = d.order;
      return (timeScale(d.startTime) + theSidePad + 0.5 * (timeScale(d.endTime) - timeScale(d.startTime))).toString() + "px " + (i * theGap + theTopPad + 0.5 * theBarHeight).toString() + "px";
    }).attr("class", function(d) {
      const res = "task";
      let classStr = "";
      if (d.classes.length > 0) {
        classStr = d.classes.join(" ");
      }
      let secNum = 0;
      for (let i = 0; i < categories.length; i++) {
        if (d.type === categories[i]) {
          secNum = i % conf2.numberSectionStyles;
        }
      }
      let taskClass = "";
      if (d.active) {
        if (d.crit) {
          taskClass += " activeCrit";
        } else {
          taskClass = " active";
        }
      } else if (d.done) {
        if (d.crit) {
          taskClass = " doneCrit";
        } else {
          taskClass = " done";
        }
      } else {
        if (d.crit) {
          taskClass += " crit";
        }
      }
      if (taskClass.length === 0) {
        taskClass = " task";
      }
      if (d.milestone) {
        taskClass = " milestone " + taskClass;
      }
      taskClass += secNum;
      taskClass += " " + classStr;
      return res + taskClass;
    });
    rectangles.append("text").attr("id", function(d) {
      return d.id + "-text";
    }).text(function(d) {
      return d.task;
    }).attr("font-size", conf2.fontSize).attr("x", function(d) {
      let startX = timeScale(d.startTime);
      let endX = timeScale(d.renderEndTime || d.endTime);
      if (d.milestone) {
        startX += 0.5 * (timeScale(d.endTime) - timeScale(d.startTime)) - 0.5 * theBarHeight;
      }
      if (d.milestone) {
        endX = startX + theBarHeight;
      }
      const textWidth = this.getBBox().width;
      if (textWidth > endX - startX) {
        if (endX + textWidth + 1.5 * conf2.leftPadding > w2) {
          return startX + theSidePad - 5;
        } else {
          return endX + theSidePad + 5;
        }
      } else {
        return (endX - startX) / 2 + startX + theSidePad;
      }
    }).attr("y", function(d, i) {
      i = d.order;
      return i * theGap + conf2.barHeight / 2 + (conf2.fontSize / 2 - 2) + theTopPad;
    }).attr("text-height", theBarHeight).attr("class", function(d) {
      const startX = timeScale(d.startTime);
      let endX = timeScale(d.endTime);
      if (d.milestone) {
        endX = startX + theBarHeight;
      }
      const textWidth = this.getBBox().width;
      let classStr = "";
      if (d.classes.length > 0) {
        classStr = d.classes.join(" ");
      }
      let secNum = 0;
      for (let i = 0; i < categories.length; i++) {
        if (d.type === categories[i]) {
          secNum = i % conf2.numberSectionStyles;
        }
      }
      let taskType = "";
      if (d.active) {
        if (d.crit) {
          taskType = "activeCritText" + secNum;
        } else {
          taskType = "activeText" + secNum;
        }
      }
      if (d.done) {
        if (d.crit) {
          taskType = taskType + " doneCritText" + secNum;
        } else {
          taskType = taskType + " doneText" + secNum;
        }
      } else {
        if (d.crit) {
          taskType = taskType + " critText" + secNum;
        }
      }
      if (d.milestone) {
        taskType += " milestoneText";
      }
      if (textWidth > endX - startX) {
        if (endX + textWidth + 1.5 * conf2.leftPadding > w2) {
          return classStr + " taskTextOutsideLeft taskTextOutside" + secNum + " " + taskType;
        } else {
          return classStr + " taskTextOutsideRight taskTextOutside" + secNum + " " + taskType + " width-" + textWidth;
        }
      } else {
        return classStr + " taskText taskText" + secNum + " " + taskType + " width-" + textWidth;
      }
    });
    const securityLevel2 = getConfig$1().securityLevel;
    if (securityLevel2 === "sandbox") {
      let sandboxElement2;
      sandboxElement2 = select$1("#i" + id2);
      const doc22 = sandboxElement2.nodes()[0].contentDocument;
      rectangles.filter(function(d) {
        return typeof links2[d.id] !== "undefined";
      }).each(function(o) {
        var taskRect = doc22.querySelector("#" + o.id);
        var taskText = doc22.querySelector("#" + o.id + "-text");
        const oldParent = taskRect.parentNode;
        var Link = doc22.createElement("a");
        Link.setAttribute("xlink:href", links2[o.id]);
        Link.setAttribute("target", "_top");
        oldParent.appendChild(Link);
        Link.appendChild(taskRect);
        Link.appendChild(taskText);
      });
    }
  }
  function drawExcludeDays(theGap, theTopPad, theSidePad, w2, h22, tasks2, excludes2, includes2) {
    const minTime = tasks2.reduce(
      (min2, { startTime }) => min2 ? Math.min(min2, startTime) : startTime,
      0
    );
    const maxTime = tasks2.reduce((max2, { endTime }) => max2 ? Math.max(max2, endTime) : endTime, 0);
    const dateFormat2 = diagObj.db.getDateFormat();
    if (!minTime || !maxTime)
      return;
    const excludeRanges = [];
    let range2 = null;
    let d = moment(minTime);
    while (d.valueOf() <= maxTime) {
      if (diagObj.db.isInvalidDate(d, dateFormat2, excludes2, includes2)) {
        if (!range2) {
          range2 = {
            start: d.clone(),
            end: d.clone()
          };
        } else {
          range2.end = d.clone();
        }
      } else {
        if (range2) {
          excludeRanges.push(range2);
          range2 = null;
        }
      }
      d.add(1, "d");
    }
    const rectangles = svg2.append("g").selectAll("rect").data(excludeRanges).enter();
    rectangles.append("rect").attr("id", function(d2) {
      return "exclude-" + d2.start.format("YYYY-MM-DD");
    }).attr("x", function(d2) {
      return timeScale(d2.start) + theSidePad;
    }).attr("y", conf2.gridLineStartPadding).attr("width", function(d2) {
      const renderEnd = d2.end.clone().add(1, "day");
      return timeScale(renderEnd) - timeScale(d2.start);
    }).attr("height", h22 - theTopPad - conf2.gridLineStartPadding).attr("transform-origin", function(d2, i) {
      return (timeScale(d2.start) + theSidePad + 0.5 * (timeScale(d2.end) - timeScale(d2.start))).toString() + "px " + (i * theGap + 0.5 * h22).toString() + "px";
    }).attr("class", "exclude-range");
  }
  function makeGrid(theSidePad, theTopPad, w2, h22) {
    let bottomXAxis = axisBottom$1(timeScale).tickSize(-h22 + theTopPad + conf2.gridLineStartPadding).tickFormat(timeFormat$1(diagObj.db.getAxisFormat() || conf2.axisFormat || "%Y-%m-%d"));
    svg2.append("g").attr("class", "grid").attr("transform", "translate(" + theSidePad + ", " + (h22 - 50) + ")").call(bottomXAxis).selectAll("text").style("text-anchor", "middle").attr("fill", "#000").attr("stroke", "none").attr("font-size", 10).attr("dy", "1em");
    if (diagObj.db.topAxisEnabled() || conf2.topAxis) {
      let topXAxis = axisTop$1(timeScale).tickSize(-h22 + theTopPad + conf2.gridLineStartPadding).tickFormat(timeFormat$1(diagObj.db.getAxisFormat() || conf2.axisFormat || "%Y-%m-%d"));
      svg2.append("g").attr("class", "grid").attr("transform", "translate(" + theSidePad + ", " + theTopPad + ")").call(topXAxis).selectAll("text").style("text-anchor", "middle").attr("fill", "#000").attr("stroke", "none").attr("font-size", 10);
    }
  }
  function vertLabels(theGap, theTopPad) {
    const numOccurances = [];
    let prevGap = 0;
    for (let i = 0; i < categories.length; i++) {
      numOccurances[i] = [categories[i], getCount(categories[i], catsUnfiltered)];
    }
    svg2.append("g").selectAll("text").data(numOccurances).enter().append(function(d) {
      const rows = d[0].split(common.lineBreakRegex);
      const dy = -(rows.length - 1) / 2;
      const svgLabel = doc2.createElementNS("http://www.w3.org/2000/svg", "text");
      svgLabel.setAttribute("dy", dy + "em");
      for (let j2 = 0; j2 < rows.length; j2++) {
        const tspan = doc2.createElementNS("http://www.w3.org/2000/svg", "tspan");
        tspan.setAttribute("alignment-baseline", "central");
        tspan.setAttribute("x", "10");
        if (j2 > 0)
          tspan.setAttribute("dy", "1em");
        tspan.textContent = rows[j2];
        svgLabel.appendChild(tspan);
      }
      return svgLabel;
    }).attr("x", 10).attr("y", function(d, i) {
      if (i > 0) {
        for (let j2 = 0; j2 < i; j2++) {
          prevGap += numOccurances[i - 1][1];
          return d[1] * theGap / 2 + prevGap * theGap + theTopPad;
        }
      } else {
        return d[1] * theGap / 2 + theTopPad;
      }
    }).attr("font-size", conf2.sectionFontSize).attr("font-size", conf2.sectionFontSize).attr("class", function(d) {
      for (let i = 0; i < categories.length; i++) {
        if (d[0] === categories[i]) {
          return "sectionTitle sectionTitle" + i % conf2.numberSectionStyles;
        }
      }
      return "sectionTitle";
    });
  }
  function drawToday(theSidePad, theTopPad, w2, h22) {
    const todayMarker2 = diagObj.db.getTodayMarker();
    if (todayMarker2 === "off") {
      return;
    }
    const todayG = svg2.append("g").attr("class", "today");
    const today = new Date();
    const todayLine = todayG.append("line");
    todayLine.attr("x1", timeScale(today) + theSidePad).attr("x2", timeScale(today) + theSidePad).attr("y1", conf2.titleTopMargin).attr("y2", h22 - conf2.titleTopMargin).attr("class", "today");
    if (todayMarker2 !== "") {
      todayLine.attr("style", todayMarker2.replace(/,/g, ";"));
    }
  }
  function checkUnique(arr) {
    const hash2 = {};
    const result = [];
    for (let i = 0, l2 = arr.length; i < l2; ++i) {
      if (!Object.prototype.hasOwnProperty.call(hash2, arr[i])) {
        hash2[arr[i]] = true;
        result.push(arr[i]);
      }
    }
    return result;
  }
  function getCounts(arr) {
    let i = arr.length;
    const obj = {};
    while (i) {
      obj[arr[--i]] = (obj[arr[i]] || 0) + 1;
    }
    return obj;
  }
  function getCount(word, arr) {
    return getCounts(arr)[word] || 0;
  }
};
const ganttRenderer = {
  setConf: setConf$5,
  draw: draw$8
};
var parser$5 = function() {
  var o = function(k2, v, o2, l2) {
    for (o2 = o2 || {}, l2 = k2.length; l2--; o2[k2[l2]] = v)
      ;
    return o2;
  }, $V0 = [6, 9, 10];
  var parser2 = {
    trace: function trace() {
    },
    yy: {},
    symbols_: { "error": 2, "start": 3, "info": 4, "document": 5, "EOF": 6, "line": 7, "statement": 8, "NL": 9, "showInfo": 10, "$accept": 0, "$end": 1 },
    terminals_: { 2: "error", 4: "info", 6: "EOF", 9: "NL", 10: "showInfo" },
    productions_: [0, [3, 3], [5, 0], [5, 2], [7, 1], [7, 1], [8, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      $$.length - 1;
      switch (yystate) {
        case 1:
          return yy;
        case 4:
          break;
        case 6:
          yy.setInfo(true);
          break;
      }
    },
    table: [{ 3: 1, 4: [1, 2] }, { 1: [3] }, o($V0, [2, 2], { 5: 3 }), { 6: [1, 4], 7: 5, 8: 6, 9: [1, 7], 10: [1, 8] }, { 1: [2, 1] }, o($V0, [2, 3]), o($V0, [2, 4]), o($V0, [2, 5]), o($V0, [2, 6])],
    defaultActions: { 4: [2, 1] },
    parseError: function parseError(str, hash2) {
      if (hash2.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash2;
        throw error;
      }
    },
    parse: function parse2(input) {
      var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k2 in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
          sharedState.yy[k2] = this.yy[k2];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges2 = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function lex() {
        var token2;
        token2 = tstack.pop() || lexer2.lex() || EOF2;
        if (typeof token2 !== "number") {
          if (token2 instanceof Array) {
            tstack = token2;
            token2 = tstack.pop();
          }
          token2 = self2.symbols_[token2] || token2;
        }
        return token2;
      }
      var symbol2, state, action, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack2[stack2.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol2 === null || typeof symbol2 == "undefined") {
            symbol2 = lex();
          }
          action = table[state] && table[state][symbol2];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push("'" + this.terminals_[p] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol2] || symbol2) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol2 == EOF2 ? "end of input" : "'" + (this.terminals_[symbol2] || symbol2) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol2] || symbol2,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol2);
        }
        switch (action[0]) {
          case 1:
            stack2.push(symbol2);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack2.push(action[1]);
            symbol2 = null;
            {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges2) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
              ];
            }
            r = this.performAction.apply(yyval, [
              yytext,
              yyleng,
              yylineno,
              sharedState.yy,
              action[1],
              vstack,
              lstack
            ].concat(args));
            if (typeof r !== "undefined") {
              return r;
            }
            if (len) {
              stack2 = stack2.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack2.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
            stack2.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash2) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash2);
        } else {
          throw new Error(str);
        }
      },
      setInput: function(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      input: function() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      unput: function(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      more: function() {
        this._more = true;
        return this;
      },
      reject: function() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      less: function(n) {
        this.unput(this.match.slice(n));
      },
      pastInput: function() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var next2 = this.match;
        if (next2.length < 20) {
          next2 += this._input.substr(0, 20 - next2.length);
        }
        return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var pre = this.pastInput();
        var c2 = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c2 + "^";
      },
      test_match: function(match, indexed_rule) {
        var token2, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token2) {
          return token2;
        } else if (this._backtrack) {
          for (var k2 in backup) {
            this[k2] = backup[k2];
          }
          return false;
        }
        return false;
      },
      next: function() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token2, match, tempMatch, index2;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index2 = i;
            if (this.options.backtrack_lexer) {
              token2 = this.test_match(tempMatch, rules[i]);
              if (token2 !== false) {
                return token2;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token2 = this.test_match(match, rules[index2]);
          if (token2 !== false) {
            return token2;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": true },
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        switch ($avoiding_name_collisions) {
          case 0:
            return 4;
          case 1:
            return 9;
          case 2:
            return "space";
          case 3:
            return 10;
          case 4:
            return 6;
          case 5:
            return "TXT";
        }
      },
      rules: [/^(?:info\b)/i, /^(?:[\s\n\r]+)/i, /^(?:[\s]+)/i, /^(?:showInfo\b)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { "INITIAL": { "rules": [0, 1, 2, 3, 4, 5], "inclusive": true } }
    };
    return lexer2;
  }();
  parser2.lexer = lexer;
  function Parser2() {
    this.yy = {};
  }
  Parser2.prototype = parser2;
  parser2.Parser = Parser2;
  return new Parser2();
}();
parser$5.parser = parser$5;
var message = "";
var info = false;
const setMessage = (txt) => {
  log$1.debug("Setting message to: " + txt);
  message = txt;
};
const getMessage = () => {
  return message;
};
const setInfo = (inf) => {
  info = inf;
};
const getInfo = () => {
  return info;
};
const infoDb = {
  setMessage,
  getMessage,
  setInfo,
  getInfo,
  clear: clear$g
};
const draw$7 = (text2, id2, version2, diagObj) => {
  try {
    log$1.debug("Rendering info diagram\n" + text2);
    const securityLevel = getConfig$1().securityLevel;
    let sandboxElement;
    if (securityLevel === "sandbox") {
      sandboxElement = select$1("#i" + id2);
    }
    const root2 = securityLevel === "sandbox" ? select$1(sandboxElement.nodes()[0].contentDocument.body) : select$1("body");
    const svg2 = root2.select("#" + id2);
    const g2 = svg2.append("g");
    g2.append("text").attr("x", 100).attr("y", 40).attr("class", "version").attr("font-size", "32px").style("text-anchor", "middle").text("v " + version2);
    svg2.attr("height", 100);
    svg2.attr("width", 400);
  } catch (e) {
    log$1.error("Error while rendering info diagram");
    log$1.error(e.message);
  }
};
const infoRenderer = {
  draw: draw$7
};
const infoDetector = (txt) => {
  return txt.match(/^\s*info/) !== null;
};
var parser$4 = function() {
  var o = function(k2, v, o2, l2) {
    for (o2 = o2 || {}, l2 = k2.length; l2--; o2[k2[l2]] = v)
      ;
    return o2;
  }, $V0 = [1, 4], $V1 = [1, 5], $V2 = [1, 6], $V3 = [1, 7], $V4 = [1, 9], $V5 = [1, 11, 13, 15, 17, 19, 20, 26, 27, 28, 29], $V6 = [2, 5], $V7 = [1, 6, 11, 13, 15, 17, 19, 20, 26, 27, 28, 29], $V8 = [26, 27, 28], $V9 = [2, 8], $Va = [1, 18], $Vb = [1, 19], $Vc = [1, 20], $Vd = [1, 21], $Ve = [1, 22], $Vf = [1, 23], $Vg = [1, 28], $Vh = [6, 26, 27, 28, 29];
  var parser2 = {
    trace: function trace() {
    },
    yy: {},
    symbols_: { "error": 2, "start": 3, "eol": 4, "directive": 5, "PIE": 6, "document": 7, "showData": 8, "line": 9, "statement": 10, "txt": 11, "value": 12, "title": 13, "title_value": 14, "acc_title": 15, "acc_title_value": 16, "acc_descr": 17, "acc_descr_value": 18, "acc_descr_multiline_value": 19, "section": 20, "openDirective": 21, "typeDirective": 22, "closeDirective": 23, ":": 24, "argDirective": 25, "NEWLINE": 26, ";": 27, "EOF": 28, "open_directive": 29, "type_directive": 30, "arg_directive": 31, "close_directive": 32, "$accept": 0, "$end": 1 },
    terminals_: { 2: "error", 6: "PIE", 8: "showData", 11: "txt", 12: "value", 13: "title", 14: "title_value", 15: "acc_title", 16: "acc_title_value", 17: "acc_descr", 18: "acc_descr_value", 19: "acc_descr_multiline_value", 20: "section", 24: ":", 26: "NEWLINE", 27: ";", 28: "EOF", 29: "open_directive", 30: "type_directive", 31: "arg_directive", 32: "close_directive" },
    productions_: [0, [3, 2], [3, 2], [3, 2], [3, 3], [7, 0], [7, 2], [9, 2], [10, 0], [10, 2], [10, 2], [10, 2], [10, 2], [10, 1], [10, 1], [10, 1], [5, 3], [5, 5], [4, 1], [4, 1], [4, 1], [21, 1], [22, 1], [25, 1], [23, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 4:
          yy.setShowData(true);
          break;
        case 7:
          this.$ = $$[$0 - 1];
          break;
        case 9:
          yy.addSection($$[$0 - 1], yy.cleanupValue($$[$0]));
          break;
        case 10:
          this.$ = $$[$0].trim();
          yy.setDiagramTitle(this.$);
          break;
        case 11:
          this.$ = $$[$0].trim();
          yy.setAccTitle(this.$);
          break;
        case 12:
        case 13:
          this.$ = $$[$0].trim();
          yy.setAccDescription(this.$);
          break;
        case 14:
          yy.addSection($$[$0].substr(8));
          this.$ = $$[$0].substr(8);
          break;
        case 21:
          yy.parseDirective("%%{", "open_directive");
          break;
        case 22:
          yy.parseDirective($$[$0], "type_directive");
          break;
        case 23:
          $$[$0] = $$[$0].trim().replace(/'/g, '"');
          yy.parseDirective($$[$0], "arg_directive");
          break;
        case 24:
          yy.parseDirective("}%%", "close_directive", "pie");
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 5: 3, 6: $V0, 21: 8, 26: $V1, 27: $V2, 28: $V3, 29: $V4 }, { 1: [3] }, { 3: 10, 4: 2, 5: 3, 6: $V0, 21: 8, 26: $V1, 27: $V2, 28: $V3, 29: $V4 }, { 3: 11, 4: 2, 5: 3, 6: $V0, 21: 8, 26: $V1, 27: $V2, 28: $V3, 29: $V4 }, o($V5, $V6, { 7: 12, 8: [1, 13] }), o($V7, [2, 18]), o($V7, [2, 19]), o($V7, [2, 20]), { 22: 14, 30: [1, 15] }, { 30: [2, 21] }, { 1: [2, 1] }, { 1: [2, 2] }, o($V8, $V9, { 21: 8, 9: 16, 10: 17, 5: 24, 1: [2, 3], 11: $Va, 13: $Vb, 15: $Vc, 17: $Vd, 19: $Ve, 20: $Vf, 29: $V4 }), o($V5, $V6, { 7: 25 }), { 23: 26, 24: [1, 27], 32: $Vg }, o([24, 32], [2, 22]), o($V5, [2, 6]), { 4: 29, 26: $V1, 27: $V2, 28: $V3 }, { 12: [1, 30] }, { 14: [1, 31] }, { 16: [1, 32] }, { 18: [1, 33] }, o($V8, [2, 13]), o($V8, [2, 14]), o($V8, [2, 15]), o($V8, $V9, { 21: 8, 9: 16, 10: 17, 5: 24, 1: [2, 4], 11: $Va, 13: $Vb, 15: $Vc, 17: $Vd, 19: $Ve, 20: $Vf, 29: $V4 }), o($Vh, [2, 16]), { 25: 34, 31: [1, 35] }, o($Vh, [2, 24]), o($V5, [2, 7]), o($V8, [2, 9]), o($V8, [2, 10]), o($V8, [2, 11]), o($V8, [2, 12]), { 23: 36, 32: $Vg }, { 32: [2, 23] }, o($Vh, [2, 17])],
    defaultActions: { 9: [2, 21], 10: [2, 1], 11: [2, 2], 35: [2, 23] },
    parseError: function parseError(str, hash2) {
      if (hash2.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash2;
        throw error;
      }
    },
    parse: function parse2(input) {
      var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k2 in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
          sharedState.yy[k2] = this.yy[k2];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges2 = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function lex() {
        var token2;
        token2 = tstack.pop() || lexer2.lex() || EOF2;
        if (typeof token2 !== "number") {
          if (token2 instanceof Array) {
            tstack = token2;
            token2 = tstack.pop();
          }
          token2 = self2.symbols_[token2] || token2;
        }
        return token2;
      }
      var symbol2, state, action, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack2[stack2.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol2 === null || typeof symbol2 == "undefined") {
            symbol2 = lex();
          }
          action = table[state] && table[state][symbol2];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push("'" + this.terminals_[p] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol2] || symbol2) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol2 == EOF2 ? "end of input" : "'" + (this.terminals_[symbol2] || symbol2) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol2] || symbol2,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol2);
        }
        switch (action[0]) {
          case 1:
            stack2.push(symbol2);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack2.push(action[1]);
            symbol2 = null;
            {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges2) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
              ];
            }
            r = this.performAction.apply(yyval, [
              yytext,
              yyleng,
              yylineno,
              sharedState.yy,
              action[1],
              vstack,
              lstack
            ].concat(args));
            if (typeof r !== "undefined") {
              return r;
            }
            if (len) {
              stack2 = stack2.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack2.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
            stack2.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash2) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash2);
        } else {
          throw new Error(str);
        }
      },
      setInput: function(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      input: function() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      unput: function(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      more: function() {
        this._more = true;
        return this;
      },
      reject: function() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      less: function(n) {
        this.unput(this.match.slice(n));
      },
      pastInput: function() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var next2 = this.match;
        if (next2.length < 20) {
          next2 += this._input.substr(0, 20 - next2.length);
        }
        return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var pre = this.pastInput();
        var c2 = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c2 + "^";
      },
      test_match: function(match, indexed_rule) {
        var token2, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token2) {
          return token2;
        } else if (this._backtrack) {
          for (var k2 in backup) {
            this[k2] = backup[k2];
          }
          return false;
        }
        return false;
      },
      next: function() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token2, match, tempMatch, index2;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index2 = i;
            if (this.options.backtrack_lexer) {
              token2 = this.test_match(tempMatch, rules[i]);
              if (token2 !== false) {
                return token2;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token2 = this.test_match(match, rules[index2]);
          if (token2 !== false) {
            return token2;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": true },
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        switch ($avoiding_name_collisions) {
          case 0:
            this.begin("open_directive");
            return 29;
          case 1:
            this.begin("type_directive");
            return 30;
          case 2:
            this.popState();
            this.begin("arg_directive");
            return 24;
          case 3:
            this.popState();
            this.popState();
            return 32;
          case 4:
            return 31;
          case 5:
            break;
          case 6:
            break;
          case 7:
            return 26;
          case 8:
            break;
          case 9:
            break;
          case 10:
            this.begin("title");
            return 13;
          case 11:
            this.popState();
            return "title_value";
          case 12:
            this.begin("acc_title");
            return 15;
          case 13:
            this.popState();
            return "acc_title_value";
          case 14:
            this.begin("acc_descr");
            return 17;
          case 15:
            this.popState();
            return "acc_descr_value";
          case 16:
            this.begin("acc_descr_multiline");
            break;
          case 17:
            this.popState();
            break;
          case 18:
            return "acc_descr_multiline_value";
          case 19:
            this.begin("string");
            break;
          case 20:
            this.popState();
            break;
          case 21:
            return "txt";
          case 22:
            return 6;
          case 23:
            return 8;
          case 24:
            return "value";
          case 25:
            return 28;
        }
      },
      rules: [/^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:%%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n\r]+)/i, /^(?:%%[^\n]*)/i, /^(?:[\s]+)/i, /^(?:title\b)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:pie\b)/i, /^(?:showData\b)/i, /^(?::[\s]*[\d]+(?:\.[\d]+)?)/i, /^(?:$)/i],
      conditions: { "acc_descr_multiline": { "rules": [17, 18], "inclusive": false }, "acc_descr": { "rules": [15], "inclusive": false }, "acc_title": { "rules": [13], "inclusive": false }, "close_directive": { "rules": [], "inclusive": false }, "arg_directive": { "rules": [3, 4], "inclusive": false }, "type_directive": { "rules": [2, 3], "inclusive": false }, "open_directive": { "rules": [1], "inclusive": false }, "title": { "rules": [11], "inclusive": false }, "string": { "rules": [20, 21], "inclusive": false }, "INITIAL": { "rules": [0, 5, 6, 7, 8, 9, 10, 12, 14, 16, 19, 22, 23, 24, 25], "inclusive": true } }
    };
    return lexer2;
  }();
  parser2.lexer = lexer;
  function Parser2() {
    this.yy = {};
  }
  Parser2.prototype = parser2;
  parser2.Parser = Parser2;
  return new Parser2();
}();
parser$4.parser = parser$4;
const pieDetector = (txt) => {
  return txt.match(/^\s*pie/) !== null;
};
let sections$1 = {};
let showData = false;
const parseDirective$5 = function(statement, context, type2) {
  mermaidAPI.parseDirective(this, statement, context, type2);
};
const addSection$1 = function(id2, value) {
  id2 = common.sanitizeText(id2, getConfig$1());
  if (typeof sections$1[id2] === "undefined") {
    sections$1[id2] = value;
    log$1.debug("Added new section :", id2);
  }
};
const getSections$1 = () => sections$1;
const setShowData = function(toggle) {
  showData = toggle;
};
const getShowData = function() {
  return showData;
};
const cleanupValue = function(value) {
  if (value.substring(0, 1) === ":") {
    value = value.substring(1).trim();
    return Number(value.trim());
  } else {
    return Number(value.trim());
  }
};
const clear$4 = function() {
  sections$1 = {};
  showData = false;
  clear$g();
};
const pieDb = {
  parseDirective: parseDirective$5,
  getConfig: () => getConfig$1().pie,
  addSection: addSection$1,
  getSections: getSections$1,
  cleanupValue,
  clear: clear$4,
  setAccTitle,
  getAccTitle,
  setDiagramTitle,
  getDiagramTitle,
  setShowData,
  getShowData,
  getAccDescription,
  setAccDescription
};
let conf$6 = getConfig$1();
let width;
const height = 450;
const draw$6 = (txt, id2, _version, diagObj) => {
  try {
    conf$6 = getConfig$1();
    log$1.debug("Rendering info diagram\n" + txt);
    const securityLevel = getConfig$1().securityLevel;
    let sandboxElement;
    if (securityLevel === "sandbox") {
      sandboxElement = select$1("#i" + id2);
    }
    const root2 = securityLevel === "sandbox" ? select$1(sandboxElement.nodes()[0].contentDocument.body) : select$1("body");
    const doc2 = securityLevel === "sandbox" ? sandboxElement.nodes()[0].contentDocument : document;
    diagObj.db.clear();
    diagObj.parser.parse(txt);
    log$1.debug("Parsed info diagram");
    const elem = doc2.getElementById(id2);
    width = elem.parentElement.offsetWidth;
    if (typeof width === "undefined") {
      width = 1200;
    }
    if (typeof conf$6.useWidth !== "undefined") {
      width = conf$6.useWidth;
    }
    if (typeof conf$6.pie.useWidth !== "undefined") {
      width = conf$6.pie.useWidth;
    }
    const diagram = root2.select("#" + id2);
    configureSvgSize(diagram, height, width, conf$6.pie.useMaxWidth);
    addSVGAccessibilityFields(diagObj.db, diagram, id2);
    elem.setAttribute("viewBox", "0 0 " + width + " " + height);
    var margin = 40;
    var legendRectSize = 18;
    var legendSpacing = 4;
    var radius = Math.min(width, height) / 2 - margin;
    var svg2 = diagram.append("g").attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");
    var data2 = diagObj.db.getSections();
    var sum2 = 0;
    Object.keys(data2).forEach(function(key) {
      sum2 += data2[key];
    });
    const themeVariables = conf$6.themeVariables;
    var myGeneratedColors = [
      themeVariables.pie1,
      themeVariables.pie2,
      themeVariables.pie3,
      themeVariables.pie4,
      themeVariables.pie5,
      themeVariables.pie6,
      themeVariables.pie7,
      themeVariables.pie8,
      themeVariables.pie9,
      themeVariables.pie10,
      themeVariables.pie11,
      themeVariables.pie12
    ];
    var color2 = ordinal$1().range(myGeneratedColors);
    var pie$1$1 = pie$1().value(function(d) {
      return d[1];
    });
    var dataReady = pie$1$1(Object.entries(data2));
    var arcGenerator = arc$1().innerRadius(0).outerRadius(radius);
    svg2.selectAll("mySlices").data(dataReady).enter().append("path").attr("d", arcGenerator).attr("fill", function(d) {
      return color2(d.data[0]);
    }).attr("class", "pieCircle");
    svg2.selectAll("mySlices").data(dataReady).enter().append("text").text(function(d) {
      return (d.data[1] / sum2 * 100).toFixed(0) + "%";
    }).attr("transform", function(d) {
      return "translate(" + arcGenerator.centroid(d) + ")";
    }).style("text-anchor", "middle").attr("class", "slice");
    svg2.append("text").text(diagObj.db.getDiagramTitle()).attr("x", 0).attr("y", -(height - 50) / 2).attr("class", "pieTitleText");
    var legend = svg2.selectAll(".legend").data(color2.domain()).enter().append("g").attr("class", "legend").attr("transform", function(d, i) {
      var height2 = legendRectSize + legendSpacing;
      var offset = height2 * color2.domain().length / 2;
      var horz = 12 * legendRectSize;
      var vert = i * height2 - offset;
      return "translate(" + horz + "," + vert + ")";
    });
    legend.append("rect").attr("width", legendRectSize).attr("height", legendRectSize).style("fill", color2).style("stroke", color2);
    legend.data(dataReady).append("text").attr("x", legendRectSize + legendSpacing).attr("y", legendRectSize - legendSpacing).text(function(d) {
      if (diagObj.db.getShowData() || conf$6.showData || conf$6.pie.showData) {
        return d.data[0] + " [" + d.data[1] + "]";
      } else {
        return d.data[0];
      }
    });
  } catch (e) {
    log$1.error("Error while rendering info diagram");
    log$1.error(e);
  }
};
const pieRenderer = {
  draw: draw$6
};
var parser$3 = function() {
  var o = function(k2, v, o2, l2) {
    for (o2 = o2 || {}, l2 = k2.length; l2--; o2[k2[l2]] = v)
      ;
    return o2;
  }, $V0 = [1, 3], $V1 = [1, 5], $V2 = [1, 6], $V3 = [1, 7], $V4 = [1, 8], $V5 = [5, 6, 8, 14, 16, 18, 19, 40, 41, 42, 43, 44, 45, 53, 71, 72], $V6 = [1, 22], $V7 = [2, 13], $V8 = [1, 26], $V9 = [1, 27], $Va = [1, 28], $Vb = [1, 29], $Vc = [1, 30], $Vd = [1, 31], $Ve = [1, 24], $Vf = [1, 32], $Vg = [1, 33], $Vh = [1, 36], $Vi = [71, 72], $Vj = [5, 8, 14, 16, 18, 19, 40, 41, 42, 43, 44, 45, 53, 60, 62, 71, 72], $Vk = [1, 56], $Vl = [1, 57], $Vm = [1, 58], $Vn = [1, 59], $Vo = [1, 60], $Vp = [1, 61], $Vq = [1, 62], $Vr = [62, 63], $Vs = [1, 74], $Vt = [1, 70], $Vu = [1, 71], $Vv = [1, 72], $Vw = [1, 73], $Vx = [1, 75], $Vy = [1, 79], $Vz = [1, 80], $VA = [1, 77], $VB = [1, 78], $VC = [5, 8, 14, 16, 18, 19, 40, 41, 42, 43, 44, 45, 53, 71, 72];
  var parser2 = {
    trace: function trace() {
    },
    yy: {},
    symbols_: { "error": 2, "start": 3, "directive": 4, "NEWLINE": 5, "RD": 6, "diagram": 7, "EOF": 8, "openDirective": 9, "typeDirective": 10, "closeDirective": 11, ":": 12, "argDirective": 13, "acc_title": 14, "acc_title_value": 15, "acc_descr": 16, "acc_descr_value": 17, "acc_descr_multiline_value": 18, "open_directive": 19, "type_directive": 20, "arg_directive": 21, "close_directive": 22, "requirementDef": 23, "elementDef": 24, "relationshipDef": 25, "requirementType": 26, "requirementName": 27, "STRUCT_START": 28, "requirementBody": 29, "ID": 30, "COLONSEP": 31, "id": 32, "TEXT": 33, "text": 34, "RISK": 35, "riskLevel": 36, "VERIFYMTHD": 37, "verifyType": 38, "STRUCT_STOP": 39, "REQUIREMENT": 40, "FUNCTIONAL_REQUIREMENT": 41, "INTERFACE_REQUIREMENT": 42, "PERFORMANCE_REQUIREMENT": 43, "PHYSICAL_REQUIREMENT": 44, "DESIGN_CONSTRAINT": 45, "LOW_RISK": 46, "MED_RISK": 47, "HIGH_RISK": 48, "VERIFY_ANALYSIS": 49, "VERIFY_DEMONSTRATION": 50, "VERIFY_INSPECTION": 51, "VERIFY_TEST": 52, "ELEMENT": 53, "elementName": 54, "elementBody": 55, "TYPE": 56, "type": 57, "DOCREF": 58, "ref": 59, "END_ARROW_L": 60, "relationship": 61, "LINE": 62, "END_ARROW_R": 63, "CONTAINS": 64, "COPIES": 65, "DERIVES": 66, "SATISFIES": 67, "VERIFIES": 68, "REFINES": 69, "TRACES": 70, "unqString": 71, "qString": 72, "$accept": 0, "$end": 1 },
    terminals_: { 2: "error", 5: "NEWLINE", 6: "RD", 8: "EOF", 12: ":", 14: "acc_title", 15: "acc_title_value", 16: "acc_descr", 17: "acc_descr_value", 18: "acc_descr_multiline_value", 19: "open_directive", 20: "type_directive", 21: "arg_directive", 22: "close_directive", 28: "STRUCT_START", 30: "ID", 31: "COLONSEP", 33: "TEXT", 35: "RISK", 37: "VERIFYMTHD", 39: "STRUCT_STOP", 40: "REQUIREMENT", 41: "FUNCTIONAL_REQUIREMENT", 42: "INTERFACE_REQUIREMENT", 43: "PERFORMANCE_REQUIREMENT", 44: "PHYSICAL_REQUIREMENT", 45: "DESIGN_CONSTRAINT", 46: "LOW_RISK", 47: "MED_RISK", 48: "HIGH_RISK", 49: "VERIFY_ANALYSIS", 50: "VERIFY_DEMONSTRATION", 51: "VERIFY_INSPECTION", 52: "VERIFY_TEST", 53: "ELEMENT", 56: "TYPE", 58: "DOCREF", 60: "END_ARROW_L", 62: "LINE", 63: "END_ARROW_R", 64: "CONTAINS", 65: "COPIES", 66: "DERIVES", 67: "SATISFIES", 68: "VERIFIES", 69: "REFINES", 70: "TRACES", 71: "unqString", 72: "qString" },
    productions_: [0, [3, 3], [3, 2], [3, 4], [4, 3], [4, 5], [4, 2], [4, 2], [4, 1], [9, 1], [10, 1], [13, 1], [11, 1], [7, 0], [7, 2], [7, 2], [7, 2], [7, 2], [7, 2], [23, 5], [29, 5], [29, 5], [29, 5], [29, 5], [29, 2], [29, 1], [26, 1], [26, 1], [26, 1], [26, 1], [26, 1], [26, 1], [36, 1], [36, 1], [36, 1], [38, 1], [38, 1], [38, 1], [38, 1], [24, 5], [55, 5], [55, 5], [55, 2], [55, 1], [25, 5], [25, 5], [61, 1], [61, 1], [61, 1], [61, 1], [61, 1], [61, 1], [61, 1], [27, 1], [27, 1], [32, 1], [32, 1], [34, 1], [34, 1], [54, 1], [54, 1], [57, 1], [57, 1], [59, 1], [59, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 6:
          this.$ = $$[$0].trim();
          yy.setAccTitle(this.$);
          break;
        case 7:
        case 8:
          this.$ = $$[$0].trim();
          yy.setAccDescription(this.$);
          break;
        case 9:
          yy.parseDirective("%%{", "open_directive");
          break;
        case 10:
          yy.parseDirective($$[$0], "type_directive");
          break;
        case 11:
          $$[$0] = $$[$0].trim().replace(/'/g, '"');
          yy.parseDirective($$[$0], "arg_directive");
          break;
        case 12:
          yy.parseDirective("}%%", "close_directive", "pie");
          break;
        case 13:
          this.$ = [];
          break;
        case 19:
          yy.addRequirement($$[$0 - 3], $$[$0 - 4]);
          break;
        case 20:
          yy.setNewReqId($$[$0 - 2]);
          break;
        case 21:
          yy.setNewReqText($$[$0 - 2]);
          break;
        case 22:
          yy.setNewReqRisk($$[$0 - 2]);
          break;
        case 23:
          yy.setNewReqVerifyMethod($$[$0 - 2]);
          break;
        case 26:
          this.$ = yy.RequirementType.REQUIREMENT;
          break;
        case 27:
          this.$ = yy.RequirementType.FUNCTIONAL_REQUIREMENT;
          break;
        case 28:
          this.$ = yy.RequirementType.INTERFACE_REQUIREMENT;
          break;
        case 29:
          this.$ = yy.RequirementType.PERFORMANCE_REQUIREMENT;
          break;
        case 30:
          this.$ = yy.RequirementType.PHYSICAL_REQUIREMENT;
          break;
        case 31:
          this.$ = yy.RequirementType.DESIGN_CONSTRAINT;
          break;
        case 32:
          this.$ = yy.RiskLevel.LOW_RISK;
          break;
        case 33:
          this.$ = yy.RiskLevel.MED_RISK;
          break;
        case 34:
          this.$ = yy.RiskLevel.HIGH_RISK;
          break;
        case 35:
          this.$ = yy.VerifyType.VERIFY_ANALYSIS;
          break;
        case 36:
          this.$ = yy.VerifyType.VERIFY_DEMONSTRATION;
          break;
        case 37:
          this.$ = yy.VerifyType.VERIFY_INSPECTION;
          break;
        case 38:
          this.$ = yy.VerifyType.VERIFY_TEST;
          break;
        case 39:
          yy.addElement($$[$0 - 3]);
          break;
        case 40:
          yy.setNewElementType($$[$0 - 2]);
          break;
        case 41:
          yy.setNewElementDocRef($$[$0 - 2]);
          break;
        case 44:
          yy.addRelationship($$[$0 - 2], $$[$0], $$[$0 - 4]);
          break;
        case 45:
          yy.addRelationship($$[$0 - 2], $$[$0 - 4], $$[$0]);
          break;
        case 46:
          this.$ = yy.Relationships.CONTAINS;
          break;
        case 47:
          this.$ = yy.Relationships.COPIES;
          break;
        case 48:
          this.$ = yy.Relationships.DERIVES;
          break;
        case 49:
          this.$ = yy.Relationships.SATISFIES;
          break;
        case 50:
          this.$ = yy.Relationships.VERIFIES;
          break;
        case 51:
          this.$ = yy.Relationships.REFINES;
          break;
        case 52:
          this.$ = yy.Relationships.TRACES;
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 6: $V0, 9: 4, 14: $V1, 16: $V2, 18: $V3, 19: $V4 }, { 1: [3] }, { 3: 10, 4: 2, 5: [1, 9], 6: $V0, 9: 4, 14: $V1, 16: $V2, 18: $V3, 19: $V4 }, { 5: [1, 11] }, { 10: 12, 20: [1, 13] }, { 15: [1, 14] }, { 17: [1, 15] }, o($V5, [2, 8]), { 20: [2, 9] }, { 3: 16, 4: 2, 6: $V0, 9: 4, 14: $V1, 16: $V2, 18: $V3, 19: $V4 }, { 1: [2, 2] }, { 4: 21, 5: $V6, 7: 17, 8: $V7, 9: 4, 14: $V1, 16: $V2, 18: $V3, 19: $V4, 23: 18, 24: 19, 25: 20, 26: 23, 32: 25, 40: $V8, 41: $V9, 42: $Va, 43: $Vb, 44: $Vc, 45: $Vd, 53: $Ve, 71: $Vf, 72: $Vg }, { 11: 34, 12: [1, 35], 22: $Vh }, o([12, 22], [2, 10]), o($V5, [2, 6]), o($V5, [2, 7]), { 1: [2, 1] }, { 8: [1, 37] }, { 4: 21, 5: $V6, 7: 38, 8: $V7, 9: 4, 14: $V1, 16: $V2, 18: $V3, 19: $V4, 23: 18, 24: 19, 25: 20, 26: 23, 32: 25, 40: $V8, 41: $V9, 42: $Va, 43: $Vb, 44: $Vc, 45: $Vd, 53: $Ve, 71: $Vf, 72: $Vg }, { 4: 21, 5: $V6, 7: 39, 8: $V7, 9: 4, 14: $V1, 16: $V2, 18: $V3, 19: $V4, 23: 18, 24: 19, 25: 20, 26: 23, 32: 25, 40: $V8, 41: $V9, 42: $Va, 43: $Vb, 44: $Vc, 45: $Vd, 53: $Ve, 71: $Vf, 72: $Vg }, { 4: 21, 5: $V6, 7: 40, 8: $V7, 9: 4, 14: $V1, 16: $V2, 18: $V3, 19: $V4, 23: 18, 24: 19, 25: 20, 26: 23, 32: 25, 40: $V8, 41: $V9, 42: $Va, 43: $Vb, 44: $Vc, 45: $Vd, 53: $Ve, 71: $Vf, 72: $Vg }, { 4: 21, 5: $V6, 7: 41, 8: $V7, 9: 4, 14: $V1, 16: $V2, 18: $V3, 19: $V4, 23: 18, 24: 19, 25: 20, 26: 23, 32: 25, 40: $V8, 41: $V9, 42: $Va, 43: $Vb, 44: $Vc, 45: $Vd, 53: $Ve, 71: $Vf, 72: $Vg }, { 4: 21, 5: $V6, 7: 42, 8: $V7, 9: 4, 14: $V1, 16: $V2, 18: $V3, 19: $V4, 23: 18, 24: 19, 25: 20, 26: 23, 32: 25, 40: $V8, 41: $V9, 42: $Va, 43: $Vb, 44: $Vc, 45: $Vd, 53: $Ve, 71: $Vf, 72: $Vg }, { 27: 43, 71: [1, 44], 72: [1, 45] }, { 54: 46, 71: [1, 47], 72: [1, 48] }, { 60: [1, 49], 62: [1, 50] }, o($Vi, [2, 26]), o($Vi, [2, 27]), o($Vi, [2, 28]), o($Vi, [2, 29]), o($Vi, [2, 30]), o($Vi, [2, 31]), o($Vj, [2, 55]), o($Vj, [2, 56]), o($V5, [2, 4]), { 13: 51, 21: [1, 52] }, o($V5, [2, 12]), { 1: [2, 3] }, { 8: [2, 14] }, { 8: [2, 15] }, { 8: [2, 16] }, { 8: [2, 17] }, { 8: [2, 18] }, { 28: [1, 53] }, { 28: [2, 53] }, { 28: [2, 54] }, { 28: [1, 54] }, { 28: [2, 59] }, { 28: [2, 60] }, { 61: 55, 64: $Vk, 65: $Vl, 66: $Vm, 67: $Vn, 68: $Vo, 69: $Vp, 70: $Vq }, { 61: 63, 64: $Vk, 65: $Vl, 66: $Vm, 67: $Vn, 68: $Vo, 69: $Vp, 70: $Vq }, { 11: 64, 22: $Vh }, { 22: [2, 11] }, { 5: [1, 65] }, { 5: [1, 66] }, { 62: [1, 67] }, o($Vr, [2, 46]), o($Vr, [2, 47]), o($Vr, [2, 48]), o($Vr, [2, 49]), o($Vr, [2, 50]), o($Vr, [2, 51]), o($Vr, [2, 52]), { 63: [1, 68] }, o($V5, [2, 5]), { 5: $Vs, 29: 69, 30: $Vt, 33: $Vu, 35: $Vv, 37: $Vw, 39: $Vx }, { 5: $Vy, 39: $Vz, 55: 76, 56: $VA, 58: $VB }, { 32: 81, 71: $Vf, 72: $Vg }, { 32: 82, 71: $Vf, 72: $Vg }, o($VC, [2, 19]), { 31: [1, 83] }, { 31: [1, 84] }, { 31: [1, 85] }, { 31: [1, 86] }, { 5: $Vs, 29: 87, 30: $Vt, 33: $Vu, 35: $Vv, 37: $Vw, 39: $Vx }, o($VC, [2, 25]), o($VC, [2, 39]), { 31: [1, 88] }, { 31: [1, 89] }, { 5: $Vy, 39: $Vz, 55: 90, 56: $VA, 58: $VB }, o($VC, [2, 43]), o($VC, [2, 44]), o($VC, [2, 45]), { 32: 91, 71: $Vf, 72: $Vg }, { 34: 92, 71: [1, 93], 72: [1, 94] }, { 36: 95, 46: [1, 96], 47: [1, 97], 48: [1, 98] }, { 38: 99, 49: [1, 100], 50: [1, 101], 51: [1, 102], 52: [1, 103] }, o($VC, [2, 24]), { 57: 104, 71: [1, 105], 72: [1, 106] }, { 59: 107, 71: [1, 108], 72: [1, 109] }, o($VC, [2, 42]), { 5: [1, 110] }, { 5: [1, 111] }, { 5: [2, 57] }, { 5: [2, 58] }, { 5: [1, 112] }, { 5: [2, 32] }, { 5: [2, 33] }, { 5: [2, 34] }, { 5: [1, 113] }, { 5: [2, 35] }, { 5: [2, 36] }, { 5: [2, 37] }, { 5: [2, 38] }, { 5: [1, 114] }, { 5: [2, 61] }, { 5: [2, 62] }, { 5: [1, 115] }, { 5: [2, 63] }, { 5: [2, 64] }, { 5: $Vs, 29: 116, 30: $Vt, 33: $Vu, 35: $Vv, 37: $Vw, 39: $Vx }, { 5: $Vs, 29: 117, 30: $Vt, 33: $Vu, 35: $Vv, 37: $Vw, 39: $Vx }, { 5: $Vs, 29: 118, 30: $Vt, 33: $Vu, 35: $Vv, 37: $Vw, 39: $Vx }, { 5: $Vs, 29: 119, 30: $Vt, 33: $Vu, 35: $Vv, 37: $Vw, 39: $Vx }, { 5: $Vy, 39: $Vz, 55: 120, 56: $VA, 58: $VB }, { 5: $Vy, 39: $Vz, 55: 121, 56: $VA, 58: $VB }, o($VC, [2, 20]), o($VC, [2, 21]), o($VC, [2, 22]), o($VC, [2, 23]), o($VC, [2, 40]), o($VC, [2, 41])],
    defaultActions: { 8: [2, 9], 10: [2, 2], 16: [2, 1], 37: [2, 3], 38: [2, 14], 39: [2, 15], 40: [2, 16], 41: [2, 17], 42: [2, 18], 44: [2, 53], 45: [2, 54], 47: [2, 59], 48: [2, 60], 52: [2, 11], 93: [2, 57], 94: [2, 58], 96: [2, 32], 97: [2, 33], 98: [2, 34], 100: [2, 35], 101: [2, 36], 102: [2, 37], 103: [2, 38], 105: [2, 61], 106: [2, 62], 108: [2, 63], 109: [2, 64] },
    parseError: function parseError(str, hash2) {
      if (hash2.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash2;
        throw error;
      }
    },
    parse: function parse2(input) {
      var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k2 in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
          sharedState.yy[k2] = this.yy[k2];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges2 = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function lex() {
        var token2;
        token2 = tstack.pop() || lexer2.lex() || EOF2;
        if (typeof token2 !== "number") {
          if (token2 instanceof Array) {
            tstack = token2;
            token2 = tstack.pop();
          }
          token2 = self2.symbols_[token2] || token2;
        }
        return token2;
      }
      var symbol2, state, action, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack2[stack2.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol2 === null || typeof symbol2 == "undefined") {
            symbol2 = lex();
          }
          action = table[state] && table[state][symbol2];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push("'" + this.terminals_[p] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol2] || symbol2) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol2 == EOF2 ? "end of input" : "'" + (this.terminals_[symbol2] || symbol2) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol2] || symbol2,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol2);
        }
        switch (action[0]) {
          case 1:
            stack2.push(symbol2);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack2.push(action[1]);
            symbol2 = null;
            {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges2) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
              ];
            }
            r = this.performAction.apply(yyval, [
              yytext,
              yyleng,
              yylineno,
              sharedState.yy,
              action[1],
              vstack,
              lstack
            ].concat(args));
            if (typeof r !== "undefined") {
              return r;
            }
            if (len) {
              stack2 = stack2.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack2.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
            stack2.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash2) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash2);
        } else {
          throw new Error(str);
        }
      },
      setInput: function(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      input: function() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      unput: function(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      more: function() {
        this._more = true;
        return this;
      },
      reject: function() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      less: function(n) {
        this.unput(this.match.slice(n));
      },
      pastInput: function() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var next2 = this.match;
        if (next2.length < 20) {
          next2 += this._input.substr(0, 20 - next2.length);
        }
        return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var pre = this.pastInput();
        var c2 = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c2 + "^";
      },
      test_match: function(match, indexed_rule) {
        var token2, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token2) {
          return token2;
        } else if (this._backtrack) {
          for (var k2 in backup) {
            this[k2] = backup[k2];
          }
          return false;
        }
        return false;
      },
      next: function() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token2, match, tempMatch, index2;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index2 = i;
            if (this.options.backtrack_lexer) {
              token2 = this.test_match(tempMatch, rules[i]);
              if (token2 !== false) {
                return token2;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token2 = this.test_match(match, rules[index2]);
          if (token2 !== false) {
            return token2;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": true },
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        switch ($avoiding_name_collisions) {
          case 0:
            this.begin("open_directive");
            return 19;
          case 1:
            this.begin("type_directive");
            return 20;
          case 2:
            this.popState();
            this.begin("arg_directive");
            return 12;
          case 3:
            this.popState();
            this.popState();
            return 22;
          case 4:
            return 21;
          case 5:
            return "title";
          case 6:
            this.begin("acc_title");
            return 14;
          case 7:
            this.popState();
            return "acc_title_value";
          case 8:
            this.begin("acc_descr");
            return 16;
          case 9:
            this.popState();
            return "acc_descr_value";
          case 10:
            this.begin("acc_descr_multiline");
            break;
          case 11:
            this.popState();
            break;
          case 12:
            return "acc_descr_multiline_value";
          case 13:
            return 5;
          case 14:
            break;
          case 15:
            break;
          case 16:
            break;
          case 17:
            return 8;
          case 18:
            return 6;
          case 19:
            return 28;
          case 20:
            return 39;
          case 21:
            return 31;
          case 22:
            return 30;
          case 23:
            return 33;
          case 24:
            return 35;
          case 25:
            return 37;
          case 26:
            return 40;
          case 27:
            return 41;
          case 28:
            return 42;
          case 29:
            return 43;
          case 30:
            return 44;
          case 31:
            return 45;
          case 32:
            return 46;
          case 33:
            return 47;
          case 34:
            return 48;
          case 35:
            return 49;
          case 36:
            return 50;
          case 37:
            return 51;
          case 38:
            return 52;
          case 39:
            return 53;
          case 40:
            return 64;
          case 41:
            return 65;
          case 42:
            return 66;
          case 43:
            return 67;
          case 44:
            return 68;
          case 45:
            return 69;
          case 46:
            return 70;
          case 47:
            return 56;
          case 48:
            return 58;
          case 49:
            return 60;
          case 50:
            return 63;
          case 51:
            return 62;
          case 52:
            this.begin("string");
            break;
          case 53:
            this.popState();
            break;
          case 54:
            return "qString";
          case 55:
            yy_.yytext = yy_.yytext.trim();
            return 71;
        }
      },
      rules: [/^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:title\s[^#\n;]+)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:(\r?\n)+)/i, /^(?:\s+)/i, /^(?:#[^\n]*)/i, /^(?:%[^\n]*)/i, /^(?:$)/i, /^(?:requirementDiagram\b)/i, /^(?:\{)/i, /^(?:\})/i, /^(?::)/i, /^(?:id\b)/i, /^(?:text\b)/i, /^(?:risk\b)/i, /^(?:verifyMethod\b)/i, /^(?:requirement\b)/i, /^(?:functionalRequirement\b)/i, /^(?:interfaceRequirement\b)/i, /^(?:performanceRequirement\b)/i, /^(?:physicalRequirement\b)/i, /^(?:designConstraint\b)/i, /^(?:low\b)/i, /^(?:medium\b)/i, /^(?:high\b)/i, /^(?:analysis\b)/i, /^(?:demonstration\b)/i, /^(?:inspection\b)/i, /^(?:test\b)/i, /^(?:element\b)/i, /^(?:contains\b)/i, /^(?:copies\b)/i, /^(?:derives\b)/i, /^(?:satisfies\b)/i, /^(?:verifies\b)/i, /^(?:refines\b)/i, /^(?:traces\b)/i, /^(?:type\b)/i, /^(?:docref\b)/i, /^(?:<-)/i, /^(?:->)/i, /^(?:-)/i, /^(?:["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:[\w][^\r\n\{\<\>\-\=]*)/i],
      conditions: { "acc_descr_multiline": { "rules": [11, 12], "inclusive": false }, "acc_descr": { "rules": [9], "inclusive": false }, "acc_title": { "rules": [7], "inclusive": false }, "close_directive": { "rules": [], "inclusive": false }, "arg_directive": { "rules": [3, 4], "inclusive": false }, "type_directive": { "rules": [2, 3], "inclusive": false }, "open_directive": { "rules": [1], "inclusive": false }, "unqString": { "rules": [], "inclusive": false }, "token": { "rules": [], "inclusive": false }, "string": { "rules": [53, 54], "inclusive": false }, "INITIAL": { "rules": [0, 5, 6, 8, 10, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 55], "inclusive": true } }
    };
    return lexer2;
  }();
  parser2.lexer = lexer;
  function Parser2() {
    this.yy = {};
  }
  Parser2.prototype = parser2;
  parser2.Parser = Parser2;
  return new Parser2();
}();
parser$3.parser = parser$3;
const requirementDetector = (txt) => {
  return txt.match(/^\s*requirement(Diagram)?/) !== null;
};
let relations = [];
let latestRequirement = {};
let requirements = {};
let latestElement = {};
let elements = {};
const RequirementType = {
  REQUIREMENT: "Requirement",
  FUNCTIONAL_REQUIREMENT: "Functional Requirement",
  INTERFACE_REQUIREMENT: "Interface Requirement",
  PERFORMANCE_REQUIREMENT: "Performance Requirement",
  PHYSICAL_REQUIREMENT: "Physical Requirement",
  DESIGN_CONSTRAINT: "Design Constraint"
};
const RiskLevel = {
  LOW_RISK: "Low",
  MED_RISK: "Medium",
  HIGH_RISK: "High"
};
const VerifyType = {
  VERIFY_ANALYSIS: "Analysis",
  VERIFY_DEMONSTRATION: "Demonstration",
  VERIFY_INSPECTION: "Inspection",
  VERIFY_TEST: "Test"
};
const Relationships = {
  CONTAINS: "contains",
  COPIES: "copies",
  DERIVES: "derives",
  SATISFIES: "satisfies",
  VERIFIES: "verifies",
  REFINES: "refines",
  TRACES: "traces"
};
const parseDirective$4 = function(statement, context, type2) {
  mermaidAPI.parseDirective(this, statement, context, type2);
};
const addRequirement = (name2, type2) => {
  if (typeof requirements[name2] === "undefined") {
    requirements[name2] = {
      name: name2,
      type: type2,
      id: latestRequirement.id,
      text: latestRequirement.text,
      risk: latestRequirement.risk,
      verifyMethod: latestRequirement.verifyMethod
    };
  }
  latestRequirement = {};
  return requirements[name2];
};
const getRequirements = () => requirements;
const setNewReqId = (id2) => {
  if (typeof latestRequirement != "undefined") {
    latestRequirement.id = id2;
  }
};
const setNewReqText = (text2) => {
  if (typeof latestRequirement != "undefined") {
    latestRequirement.text = text2;
  }
};
const setNewReqRisk = (risk) => {
  if (typeof latestRequirement != "undefined") {
    latestRequirement.risk = risk;
  }
};
const setNewReqVerifyMethod = (verifyMethod) => {
  if (typeof latestRequirement != "undefined") {
    latestRequirement.verifyMethod = verifyMethod;
  }
};
const addElement = (name2) => {
  if (typeof elements[name2] === "undefined") {
    elements[name2] = {
      name: name2,
      type: latestElement.type,
      docRef: latestElement.docRef
    };
    log$1.info("Added new requirement: ", name2);
  }
  latestElement = {};
  return elements[name2];
};
const getElements = () => elements;
const setNewElementType = (type2) => {
  if (typeof latestElement != "undefined") {
    latestElement.type = type2;
  }
};
const setNewElementDocRef = (docRef) => {
  if (typeof latestElement != "undefined") {
    latestElement.docRef = docRef;
  }
};
const addRelationship = (type2, src, dst) => {
  relations.push({
    type: type2,
    src,
    dst
  });
};
const getRelationships = () => relations;
const clear$3 = () => {
  relations = [];
  latestRequirement = {};
  requirements = {};
  latestElement = {};
  elements = {};
  clear$g();
};
const requirementDb = {
  RequirementType,
  RiskLevel,
  VerifyType,
  Relationships,
  parseDirective: parseDirective$4,
  getConfig: () => getConfig$1().req,
  addRequirement,
  getRequirements,
  setNewReqId,
  setNewReqText,
  setNewReqRisk,
  setNewReqVerifyMethod,
  setAccTitle,
  getAccTitle,
  setAccDescription,
  getAccDescription,
  addElement,
  getElements,
  setNewElementType,
  setNewElementDocRef,
  addRelationship,
  getRelationships,
  clear: clear$3
};
const ReqMarkers = {
  CONTAINS: "contains",
  ARROW: "arrow"
};
const insertLineEndings = (parentNode, conf2) => {
  let containsNode = parentNode.append("defs").append("marker").attr("id", ReqMarkers.CONTAINS + "_line_ending").attr("refX", 0).attr("refY", conf2.line_height / 2).attr("markerWidth", conf2.line_height).attr("markerHeight", conf2.line_height).attr("orient", "auto").append("g");
  containsNode.append("circle").attr("cx", conf2.line_height / 2).attr("cy", conf2.line_height / 2).attr("r", conf2.line_height / 2).attr("fill", "none");
  containsNode.append("line").attr("x1", 0).attr("x2", conf2.line_height).attr("y1", conf2.line_height / 2).attr("y2", conf2.line_height / 2).attr("stroke-width", 1);
  containsNode.append("line").attr("y1", 0).attr("y2", conf2.line_height).attr("x1", conf2.line_height / 2).attr("x2", conf2.line_height / 2).attr("stroke-width", 1);
  parentNode.append("defs").append("marker").attr("id", ReqMarkers.ARROW + "_line_ending").attr("refX", conf2.line_height).attr("refY", 0.5 * conf2.line_height).attr("markerWidth", conf2.line_height).attr("markerHeight", conf2.line_height).attr("orient", "auto").append("path").attr(
    "d",
    `M0,0
      L${conf2.line_height},${conf2.line_height / 2}
      M${conf2.line_height},${conf2.line_height / 2}
      L0,${conf2.line_height}`
  ).attr("stroke-width", 1);
};
const markers = {
  ReqMarkers,
  insertLineEndings
};
let conf$5 = {};
let relCnt = 0;
const newRectNode = (parentNode, id2) => {
  return parentNode.insert("rect", "#" + id2).attr("class", "req reqBox").attr("x", 0).attr("y", 0).attr("width", conf$5.rect_min_width + "px").attr("height", conf$5.rect_min_height + "px");
};
const newTitleNode = (parentNode, id2, txts) => {
  let x2 = conf$5.rect_min_width / 2;
  let title2 = parentNode.append("text").attr("class", "req reqLabel reqTitle").attr("id", id2).attr("x", x2).attr("y", conf$5.rect_padding).attr("dominant-baseline", "hanging");
  let i = 0;
  txts.forEach((textStr) => {
    if (i == 0) {
      title2.append("tspan").attr("text-anchor", "middle").attr("x", conf$5.rect_min_width / 2).attr("dy", 0).text(textStr);
    } else {
      title2.append("tspan").attr("text-anchor", "middle").attr("x", conf$5.rect_min_width / 2).attr("dy", conf$5.line_height * 0.75).text(textStr);
    }
    i++;
  });
  let yPadding = 1.5 * conf$5.rect_padding;
  let linePadding = i * conf$5.line_height * 0.75;
  let totalY = yPadding + linePadding;
  parentNode.append("line").attr("class", "req-title-line").attr("x1", "0").attr("x2", conf$5.rect_min_width).attr("y1", totalY).attr("y2", totalY);
  return {
    titleNode: title2,
    y: totalY
  };
};
const newBodyNode = (parentNode, id2, txts, yStart) => {
  let body = parentNode.append("text").attr("class", "req reqLabel").attr("id", id2).attr("x", conf$5.rect_padding).attr("y", yStart).attr("dominant-baseline", "hanging");
  let currentRow = 0;
  const charLimit = 30;
  let wrappedTxts = [];
  txts.forEach((textStr) => {
    let currentTextLen = textStr.length;
    while (currentTextLen > charLimit && currentRow < 3) {
      let firstPart = textStr.substring(0, charLimit);
      textStr = textStr.substring(charLimit, textStr.length);
      currentTextLen = textStr.length;
      wrappedTxts[wrappedTxts.length] = firstPart;
      currentRow++;
    }
    if (currentRow == 3) {
      let lastStr = wrappedTxts[wrappedTxts.length - 1];
      wrappedTxts[wrappedTxts.length - 1] = lastStr.substring(0, lastStr.length - 4) + "...";
    } else {
      wrappedTxts[wrappedTxts.length] = textStr;
    }
    currentRow = 0;
  });
  wrappedTxts.forEach((textStr) => {
    body.append("tspan").attr("x", conf$5.rect_padding).attr("dy", conf$5.line_height).text(textStr);
  });
  return body;
};
const addEdgeLabel = (parentNode, svgPath, conf2, txt) => {
  const len = svgPath.node().getTotalLength();
  const labelPoint = svgPath.node().getPointAtLength(len * 0.5);
  const labelId = "rel" + relCnt;
  relCnt++;
  const labelNode = parentNode.append("text").attr("class", "req relationshipLabel").attr("id", labelId).attr("x", labelPoint.x).attr("y", labelPoint.y).attr("text-anchor", "middle").attr("dominant-baseline", "middle").text(txt);
  const labelBBox = labelNode.node().getBBox();
  parentNode.insert("rect", "#" + labelId).attr("class", "req reqLabelBox").attr("x", labelPoint.x - labelBBox.width / 2).attr("y", labelPoint.y - labelBBox.height / 2).attr("width", labelBBox.width).attr("height", labelBBox.height).attr("fill", "white").attr("fill-opacity", "85%");
};
const drawRelationshipFromLayout = function(svg2, rel, g2, insert2, diagObj) {
  const edge = g2.edge(elementString(rel.src), elementString(rel.dst));
  const lineFunction = line$2().x(function(d) {
    return d.x;
  }).y(function(d) {
    return d.y;
  });
  const svgPath = svg2.insert("path", "#" + insert2).attr("class", "er relationshipLine").attr("d", lineFunction(edge.points)).attr("fill", "none");
  if (rel.type == diagObj.db.Relationships.CONTAINS) {
    svgPath.attr(
      "marker-start",
      "url(" + common.getUrl(conf$5.arrowMarkerAbsolute) + "#" + rel.type + "_line_ending)"
    );
  } else {
    svgPath.attr("stroke-dasharray", "10,7");
    svgPath.attr(
      "marker-end",
      "url(" + common.getUrl(conf$5.arrowMarkerAbsolute) + "#" + markers.ReqMarkers.ARROW + "_line_ending)"
    );
  }
  addEdgeLabel(svg2, svgPath, conf$5, `<<${rel.type}>>`);
  return;
};
const drawReqs = (reqs, graph2, svgNode2) => {
  Object.keys(reqs).forEach((reqName) => {
    let req = reqs[reqName];
    reqName = elementString(reqName);
    log$1.info("Added new requirement: ", reqName);
    const groupNode = svgNode2.append("g").attr("id", reqName);
    const textId = "req-" + reqName;
    const rectNode = newRectNode(groupNode, textId);
    let titleNodeInfo = newTitleNode(groupNode, reqName + "_title", [
      `<<${req.type}>>`,
      `${req.name}`
    ]);
    newBodyNode(
      groupNode,
      reqName + "_body",
      [
        `Id: ${req.id}`,
        `Text: ${req.text}`,
        `Risk: ${req.risk}`,
        `Verification: ${req.verifyMethod}`
      ],
      titleNodeInfo.y
    );
    const rectBBox = rectNode.node().getBBox();
    graph2.setNode(reqName, {
      width: rectBBox.width,
      height: rectBBox.height,
      shape: "rect",
      id: reqName
    });
  });
};
const drawElements = (els, graph2, svgNode2) => {
  Object.keys(els).forEach((elName) => {
    let el = els[elName];
    const id2 = elementString(elName);
    const groupNode = svgNode2.append("g").attr("id", id2);
    const textId = "element-" + id2;
    const rectNode = newRectNode(groupNode, textId);
    let titleNodeInfo = newTitleNode(groupNode, textId + "_title", [`<<Element>>`, `${elName}`]);
    newBodyNode(
      groupNode,
      textId + "_body",
      [`Type: ${el.type || "Not Specified"}`, `Doc Ref: ${el.docRef || "None"}`],
      titleNodeInfo.y
    );
    const rectBBox = rectNode.node().getBBox();
    graph2.setNode(id2, {
      width: rectBBox.width,
      height: rectBBox.height,
      shape: "rect",
      id: id2
    });
  });
};
const addRelationships = (relationships2, g2) => {
  relationships2.forEach(function(r) {
    let src = elementString(r.src);
    let dst = elementString(r.dst);
    g2.setEdge(src, dst, { relationship: r });
  });
  return relationships2;
};
const adjustEntities = function(svgNode2, graph2) {
  graph2.nodes().forEach(function(v) {
    if (typeof v !== "undefined" && typeof graph2.node(v) !== "undefined") {
      svgNode2.select("#" + v);
      svgNode2.select("#" + v).attr(
        "transform",
        "translate(" + (graph2.node(v).x - graph2.node(v).width / 2) + "," + (graph2.node(v).y - graph2.node(v).height / 2) + " )"
      );
    }
  });
  return;
};
const elementString = (str) => {
  return str.replace(/\s/g, "").replace(/\./g, "_");
};
const draw$5 = (text2, id2, _version, diagObj) => {
  conf$5 = getConfig$1().requirement;
  diagObj.db.clear();
  diagObj.parser.parse(text2);
  const securityLevel = conf$5.securityLevel;
  let sandboxElement;
  if (securityLevel === "sandbox") {
    sandboxElement = select$1("#i" + id2);
  }
  const root2 = securityLevel === "sandbox" ? select$1(sandboxElement.nodes()[0].contentDocument.body) : select$1("body");
  const svg2 = root2.select(`[id='${id2}']`);
  markers.insertLineEndings(svg2, conf$5);
  const g2 = new graphlib$2.Graph({
    multigraph: false,
    compound: false,
    directed: true
  }).setGraph({
    rankdir: conf$5.layoutDirection,
    marginx: 20,
    marginy: 20,
    nodesep: 100,
    edgesep: 100,
    ranksep: 100
  }).setDefaultEdgeLabel(function() {
    return {};
  });
  let requirements2 = diagObj.db.getRequirements();
  let elements2 = diagObj.db.getElements();
  let relationships2 = diagObj.db.getRelationships();
  drawReqs(requirements2, g2, svg2);
  drawElements(elements2, g2, svg2);
  addRelationships(relationships2, g2);
  dagre$1.layout(g2);
  adjustEntities(svg2, g2);
  relationships2.forEach(function(rel) {
    drawRelationshipFromLayout(svg2, rel, g2, id2, diagObj);
  });
  const padding2 = conf$5.rect_padding;
  const svgBounds = svg2.node().getBBox();
  const width2 = svgBounds.width + padding2 * 2;
  const height2 = svgBounds.height + padding2 * 2;
  configureSvgSize(svg2, height2, width2, conf$5.useMaxWidth);
  svg2.attr("viewBox", `${svgBounds.x - padding2} ${svgBounds.y - padding2} ${width2} ${height2}`);
  addSVGAccessibilityFields(diagObj.db, svg2, id2);
};
const requirementRenderer = {
  draw: draw$5
};
var parser$2 = function() {
  var o = function(k2, v, o2, l2) {
    for (o2 = o2 || {}, l2 = k2.length; l2--; o2[k2[l2]] = v)
      ;
    return o2;
  }, $V0 = [1, 2], $V1 = [1, 3], $V2 = [1, 5], $V3 = [1, 7], $V4 = [2, 5], $V5 = [1, 15], $V6 = [1, 17], $V7 = [1, 18], $V8 = [1, 19], $V9 = [1, 21], $Va = [1, 22], $Vb = [1, 23], $Vc = [1, 29], $Vd = [1, 30], $Ve = [1, 31], $Vf = [1, 32], $Vg = [1, 33], $Vh = [1, 34], $Vi = [1, 35], $Vj = [1, 36], $Vk = [1, 37], $Vl = [1, 38], $Vm = [1, 39], $Vn = [1, 40], $Vo = [1, 43], $Vp = [1, 44], $Vq = [1, 45], $Vr = [1, 46], $Vs = [1, 47], $Vt = [1, 48], $Vu = [1, 51], $Vv = [1, 4, 5, 16, 20, 22, 25, 26, 32, 33, 34, 36, 38, 39, 40, 41, 42, 43, 45, 47, 49, 50, 51, 52, 53, 58, 59, 60, 61, 69, 79], $Vw = [4, 5, 16, 20, 22, 25, 26, 32, 33, 34, 36, 38, 39, 40, 41, 42, 43, 45, 47, 49, 53, 58, 59, 60, 61, 69, 79], $Vx = [4, 5, 16, 20, 22, 25, 26, 32, 33, 34, 36, 38, 39, 40, 41, 42, 43, 45, 47, 49, 52, 53, 58, 59, 60, 61, 69, 79], $Vy = [4, 5, 16, 20, 22, 25, 26, 32, 33, 34, 36, 38, 39, 40, 41, 42, 43, 45, 47, 49, 51, 53, 58, 59, 60, 61, 69, 79], $Vz = [4, 5, 16, 20, 22, 25, 26, 32, 33, 34, 36, 38, 39, 40, 41, 42, 43, 45, 47, 49, 50, 53, 58, 59, 60, 61, 69, 79], $VA = [67, 68, 69], $VB = [1, 121], $VC = [1, 4, 5, 7, 16, 20, 22, 25, 26, 32, 33, 34, 36, 38, 39, 40, 41, 42, 43, 45, 47, 49, 50, 51, 52, 53, 58, 59, 60, 61, 69, 79];
  var parser2 = {
    trace: function trace() {
    },
    yy: {},
    symbols_: { "error": 2, "start": 3, "SPACE": 4, "NEWLINE": 5, "directive": 6, "SD": 7, "document": 8, "line": 9, "statement": 10, "openDirective": 11, "typeDirective": 12, "closeDirective": 13, ":": 14, "argDirective": 15, "participant": 16, "actor": 17, "AS": 18, "restOfLine": 19, "participant_actor": 20, "signal": 21, "autonumber": 22, "NUM": 23, "off": 24, "activate": 25, "deactivate": 26, "note_statement": 27, "links_statement": 28, "link_statement": 29, "properties_statement": 30, "details_statement": 31, "title": 32, "legacy_title": 33, "acc_title": 34, "acc_title_value": 35, "acc_descr": 36, "acc_descr_value": 37, "acc_descr_multiline_value": 38, "loop": 39, "end": 40, "rect": 41, "opt": 42, "alt": 43, "else_sections": 44, "par": 45, "par_sections": 46, "critical": 47, "option_sections": 48, "break": 49, "option": 50, "and": 51, "else": 52, "note": 53, "placement": 54, "text2": 55, "over": 56, "actor_pair": 57, "links": 58, "link": 59, "properties": 60, "details": 61, "spaceList": 62, ",": 63, "left_of": 64, "right_of": 65, "signaltype": 66, "+": 67, "-": 68, "ACTOR": 69, "SOLID_OPEN_ARROW": 70, "DOTTED_OPEN_ARROW": 71, "SOLID_ARROW": 72, "DOTTED_ARROW": 73, "SOLID_CROSS": 74, "DOTTED_CROSS": 75, "SOLID_POINT": 76, "DOTTED_POINT": 77, "TXT": 78, "open_directive": 79, "type_directive": 80, "arg_directive": 81, "close_directive": 82, "$accept": 0, "$end": 1 },
    terminals_: { 2: "error", 4: "SPACE", 5: "NEWLINE", 7: "SD", 14: ":", 16: "participant", 18: "AS", 19: "restOfLine", 20: "participant_actor", 22: "autonumber", 23: "NUM", 24: "off", 25: "activate", 26: "deactivate", 32: "title", 33: "legacy_title", 34: "acc_title", 35: "acc_title_value", 36: "acc_descr", 37: "acc_descr_value", 38: "acc_descr_multiline_value", 39: "loop", 40: "end", 41: "rect", 42: "opt", 43: "alt", 45: "par", 47: "critical", 49: "break", 50: "option", 51: "and", 52: "else", 53: "note", 56: "over", 58: "links", 59: "link", 60: "properties", 61: "details", 63: ",", 64: "left_of", 65: "right_of", 67: "+", 68: "-", 69: "ACTOR", 70: "SOLID_OPEN_ARROW", 71: "DOTTED_OPEN_ARROW", 72: "SOLID_ARROW", 73: "DOTTED_ARROW", 74: "SOLID_CROSS", 75: "DOTTED_CROSS", 76: "SOLID_POINT", 77: "DOTTED_POINT", 78: "TXT", 79: "open_directive", 80: "type_directive", 81: "arg_directive", 82: "close_directive" },
    productions_: [0, [3, 2], [3, 2], [3, 2], [3, 2], [8, 0], [8, 2], [9, 2], [9, 1], [9, 1], [6, 4], [6, 6], [10, 5], [10, 3], [10, 5], [10, 3], [10, 2], [10, 4], [10, 3], [10, 3], [10, 2], [10, 3], [10, 3], [10, 2], [10, 2], [10, 2], [10, 2], [10, 2], [10, 1], [10, 1], [10, 2], [10, 2], [10, 1], [10, 4], [10, 4], [10, 4], [10, 4], [10, 4], [10, 4], [10, 4], [10, 1], [48, 1], [48, 4], [46, 1], [46, 4], [44, 1], [44, 4], [27, 4], [27, 4], [28, 3], [29, 3], [30, 3], [31, 3], [62, 2], [62, 1], [57, 3], [57, 1], [54, 1], [54, 1], [21, 5], [21, 5], [21, 4], [17, 1], [66, 1], [66, 1], [66, 1], [66, 1], [66, 1], [66, 1], [66, 1], [66, 1], [55, 1], [11, 1], [12, 1], [15, 1], [13, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 4:
          yy.apply($$[$0]);
          return $$[$0];
        case 5:
          this.$ = [];
          break;
        case 6:
          $$[$0 - 1].push($$[$0]);
          this.$ = $$[$0 - 1];
          break;
        case 7:
        case 8:
          this.$ = $$[$0];
          break;
        case 9:
          this.$ = [];
          break;
        case 12:
          $$[$0 - 3].type = "addParticipant";
          $$[$0 - 3].description = yy.parseMessage($$[$0 - 1]);
          this.$ = $$[$0 - 3];
          break;
        case 13:
          $$[$0 - 1].type = "addParticipant";
          this.$ = $$[$0 - 1];
          break;
        case 14:
          $$[$0 - 3].type = "addActor";
          $$[$0 - 3].description = yy.parseMessage($$[$0 - 1]);
          this.$ = $$[$0 - 3];
          break;
        case 15:
          $$[$0 - 1].type = "addActor";
          this.$ = $$[$0 - 1];
          break;
        case 17:
          this.$ = { type: "sequenceIndex", sequenceIndex: Number($$[$0 - 2]), sequenceIndexStep: Number($$[$0 - 1]), sequenceVisible: true, signalType: yy.LINETYPE.AUTONUMBER };
          break;
        case 18:
          this.$ = { type: "sequenceIndex", sequenceIndex: Number($$[$0 - 1]), sequenceIndexStep: 1, sequenceVisible: true, signalType: yy.LINETYPE.AUTONUMBER };
          break;
        case 19:
          this.$ = { type: "sequenceIndex", sequenceVisible: false, signalType: yy.LINETYPE.AUTONUMBER };
          break;
        case 20:
          this.$ = { type: "sequenceIndex", sequenceVisible: true, signalType: yy.LINETYPE.AUTONUMBER };
          break;
        case 21:
          this.$ = { type: "activeStart", signalType: yy.LINETYPE.ACTIVE_START, actor: $$[$0 - 1] };
          break;
        case 22:
          this.$ = { type: "activeEnd", signalType: yy.LINETYPE.ACTIVE_END, actor: $$[$0 - 1] };
          break;
        case 28:
          yy.setDiagramTitle($$[$0].substring(6));
          this.$ = $$[$0].substring(6);
          break;
        case 29:
          yy.setDiagramTitle($$[$0].substring(7));
          this.$ = $$[$0].substring(7);
          break;
        case 30:
          this.$ = $$[$0].trim();
          yy.setAccTitle(this.$);
          break;
        case 31:
        case 32:
          this.$ = $$[$0].trim();
          yy.setAccDescription(this.$);
          break;
        case 33:
          $$[$0 - 1].unshift({ type: "loopStart", loopText: yy.parseMessage($$[$0 - 2]), signalType: yy.LINETYPE.LOOP_START });
          $$[$0 - 1].push({ type: "loopEnd", loopText: $$[$0 - 2], signalType: yy.LINETYPE.LOOP_END });
          this.$ = $$[$0 - 1];
          break;
        case 34:
          $$[$0 - 1].unshift({ type: "rectStart", color: yy.parseMessage($$[$0 - 2]), signalType: yy.LINETYPE.RECT_START });
          $$[$0 - 1].push({ type: "rectEnd", color: yy.parseMessage($$[$0 - 2]), signalType: yy.LINETYPE.RECT_END });
          this.$ = $$[$0 - 1];
          break;
        case 35:
          $$[$0 - 1].unshift({ type: "optStart", optText: yy.parseMessage($$[$0 - 2]), signalType: yy.LINETYPE.OPT_START });
          $$[$0 - 1].push({ type: "optEnd", optText: yy.parseMessage($$[$0 - 2]), signalType: yy.LINETYPE.OPT_END });
          this.$ = $$[$0 - 1];
          break;
        case 36:
          $$[$0 - 1].unshift({ type: "altStart", altText: yy.parseMessage($$[$0 - 2]), signalType: yy.LINETYPE.ALT_START });
          $$[$0 - 1].push({ type: "altEnd", signalType: yy.LINETYPE.ALT_END });
          this.$ = $$[$0 - 1];
          break;
        case 37:
          $$[$0 - 1].unshift({ type: "parStart", parText: yy.parseMessage($$[$0 - 2]), signalType: yy.LINETYPE.PAR_START });
          $$[$0 - 1].push({ type: "parEnd", signalType: yy.LINETYPE.PAR_END });
          this.$ = $$[$0 - 1];
          break;
        case 38:
          $$[$0 - 1].unshift({ type: "criticalStart", criticalText: yy.parseMessage($$[$0 - 2]), signalType: yy.LINETYPE.CRITICAL_START });
          $$[$0 - 1].push({ type: "criticalEnd", signalType: yy.LINETYPE.CRITICAL_END });
          this.$ = $$[$0 - 1];
          break;
        case 39:
          $$[$0 - 1].unshift({ type: "breakStart", breakText: yy.parseMessage($$[$0 - 2]), signalType: yy.LINETYPE.BREAK_START });
          $$[$0 - 1].push({ type: "breakEnd", optText: yy.parseMessage($$[$0 - 2]), signalType: yy.LINETYPE.BREAK_END });
          this.$ = $$[$0 - 1];
          break;
        case 42:
          this.$ = $$[$0 - 3].concat([{ type: "option", optionText: yy.parseMessage($$[$0 - 1]), signalType: yy.LINETYPE.CRITICAL_OPTION }, $$[$0]]);
          break;
        case 44:
          this.$ = $$[$0 - 3].concat([{ type: "and", parText: yy.parseMessage($$[$0 - 1]), signalType: yy.LINETYPE.PAR_AND }, $$[$0]]);
          break;
        case 46:
          this.$ = $$[$0 - 3].concat([{ type: "else", altText: yy.parseMessage($$[$0 - 1]), signalType: yy.LINETYPE.ALT_ELSE }, $$[$0]]);
          break;
        case 47:
          this.$ = [$$[$0 - 1], { type: "addNote", placement: $$[$0 - 2], actor: $$[$0 - 1].actor, text: $$[$0] }];
          break;
        case 48:
          $$[$0 - 2] = [].concat($$[$0 - 1], $$[$0 - 1]).slice(0, 2);
          $$[$0 - 2][0] = $$[$0 - 2][0].actor;
          $$[$0 - 2][1] = $$[$0 - 2][1].actor;
          this.$ = [$$[$0 - 1], { type: "addNote", placement: yy.PLACEMENT.OVER, actor: $$[$0 - 2].slice(0, 2), text: $$[$0] }];
          break;
        case 49:
          this.$ = [$$[$0 - 1], { type: "addLinks", actor: $$[$0 - 1].actor, text: $$[$0] }];
          break;
        case 50:
          this.$ = [$$[$0 - 1], { type: "addALink", actor: $$[$0 - 1].actor, text: $$[$0] }];
          break;
        case 51:
          this.$ = [$$[$0 - 1], { type: "addProperties", actor: $$[$0 - 1].actor, text: $$[$0] }];
          break;
        case 52:
          this.$ = [$$[$0 - 1], { type: "addDetails", actor: $$[$0 - 1].actor, text: $$[$0] }];
          break;
        case 55:
          this.$ = [$$[$0 - 2], $$[$0]];
          break;
        case 56:
          this.$ = $$[$0];
          break;
        case 57:
          this.$ = yy.PLACEMENT.LEFTOF;
          break;
        case 58:
          this.$ = yy.PLACEMENT.RIGHTOF;
          break;
        case 59:
          this.$ = [
            $$[$0 - 4],
            $$[$0 - 1],
            { type: "addMessage", from: $$[$0 - 4].actor, to: $$[$0 - 1].actor, signalType: $$[$0 - 3], msg: $$[$0] },
            { type: "activeStart", signalType: yy.LINETYPE.ACTIVE_START, actor: $$[$0 - 1] }
          ];
          break;
        case 60:
          this.$ = [
            $$[$0 - 4],
            $$[$0 - 1],
            { type: "addMessage", from: $$[$0 - 4].actor, to: $$[$0 - 1].actor, signalType: $$[$0 - 3], msg: $$[$0] },
            { type: "activeEnd", signalType: yy.LINETYPE.ACTIVE_END, actor: $$[$0 - 4] }
          ];
          break;
        case 61:
          this.$ = [$$[$0 - 3], $$[$0 - 1], { type: "addMessage", from: $$[$0 - 3].actor, to: $$[$0 - 1].actor, signalType: $$[$0 - 2], msg: $$[$0] }];
          break;
        case 62:
          this.$ = { type: "addParticipant", actor: $$[$0] };
          break;
        case 63:
          this.$ = yy.LINETYPE.SOLID_OPEN;
          break;
        case 64:
          this.$ = yy.LINETYPE.DOTTED_OPEN;
          break;
        case 65:
          this.$ = yy.LINETYPE.SOLID;
          break;
        case 66:
          this.$ = yy.LINETYPE.DOTTED;
          break;
        case 67:
          this.$ = yy.LINETYPE.SOLID_CROSS;
          break;
        case 68:
          this.$ = yy.LINETYPE.DOTTED_CROSS;
          break;
        case 69:
          this.$ = yy.LINETYPE.SOLID_POINT;
          break;
        case 70:
          this.$ = yy.LINETYPE.DOTTED_POINT;
          break;
        case 71:
          this.$ = yy.parseMessage($$[$0].trim().substring(1));
          break;
        case 72:
          yy.parseDirective("%%{", "open_directive");
          break;
        case 73:
          yy.parseDirective($$[$0], "type_directive");
          break;
        case 74:
          $$[$0] = $$[$0].trim().replace(/'/g, '"');
          yy.parseDirective($$[$0], "arg_directive");
          break;
        case 75:
          yy.parseDirective("}%%", "close_directive", "sequence");
          break;
      }
    },
    table: [{ 3: 1, 4: $V0, 5: $V1, 6: 4, 7: $V2, 11: 6, 79: $V3 }, { 1: [3] }, { 3: 8, 4: $V0, 5: $V1, 6: 4, 7: $V2, 11: 6, 79: $V3 }, { 3: 9, 4: $V0, 5: $V1, 6: 4, 7: $V2, 11: 6, 79: $V3 }, { 3: 10, 4: $V0, 5: $V1, 6: 4, 7: $V2, 11: 6, 79: $V3 }, o([1, 4, 5, 16, 20, 22, 25, 26, 32, 33, 34, 36, 38, 39, 41, 42, 43, 45, 47, 49, 53, 58, 59, 60, 61, 69, 79], $V4, { 8: 11 }), { 12: 12, 80: [1, 13] }, { 80: [2, 72] }, { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 3] }, { 1: [2, 4], 4: $V5, 5: $V6, 6: 41, 9: 14, 10: 16, 11: 6, 16: $V7, 17: 42, 20: $V8, 21: 20, 22: $V9, 25: $Va, 26: $Vb, 27: 24, 28: 25, 29: 26, 30: 27, 31: 28, 32: $Vc, 33: $Vd, 34: $Ve, 36: $Vf, 38: $Vg, 39: $Vh, 41: $Vi, 42: $Vj, 43: $Vk, 45: $Vl, 47: $Vm, 49: $Vn, 53: $Vo, 58: $Vp, 59: $Vq, 60: $Vr, 61: $Vs, 69: $Vt, 79: $V3 }, { 13: 49, 14: [1, 50], 82: $Vu }, o([14, 82], [2, 73]), o($Vv, [2, 6]), { 6: 41, 10: 52, 11: 6, 16: $V7, 17: 42, 20: $V8, 21: 20, 22: $V9, 25: $Va, 26: $Vb, 27: 24, 28: 25, 29: 26, 30: 27, 31: 28, 32: $Vc, 33: $Vd, 34: $Ve, 36: $Vf, 38: $Vg, 39: $Vh, 41: $Vi, 42: $Vj, 43: $Vk, 45: $Vl, 47: $Vm, 49: $Vn, 53: $Vo, 58: $Vp, 59: $Vq, 60: $Vr, 61: $Vs, 69: $Vt, 79: $V3 }, o($Vv, [2, 8]), o($Vv, [2, 9]), { 17: 53, 69: $Vt }, { 17: 54, 69: $Vt }, { 5: [1, 55] }, { 5: [1, 58], 23: [1, 56], 24: [1, 57] }, { 17: 59, 69: $Vt }, { 17: 60, 69: $Vt }, { 5: [1, 61] }, { 5: [1, 62] }, { 5: [1, 63] }, { 5: [1, 64] }, { 5: [1, 65] }, o($Vv, [2, 28]), o($Vv, [2, 29]), { 35: [1, 66] }, { 37: [1, 67] }, o($Vv, [2, 32]), { 19: [1, 68] }, { 19: [1, 69] }, { 19: [1, 70] }, { 19: [1, 71] }, { 19: [1, 72] }, { 19: [1, 73] }, { 19: [1, 74] }, o($Vv, [2, 40]), { 66: 75, 70: [1, 76], 71: [1, 77], 72: [1, 78], 73: [1, 79], 74: [1, 80], 75: [1, 81], 76: [1, 82], 77: [1, 83] }, { 54: 84, 56: [1, 85], 64: [1, 86], 65: [1, 87] }, { 17: 88, 69: $Vt }, { 17: 89, 69: $Vt }, { 17: 90, 69: $Vt }, { 17: 91, 69: $Vt }, o([5, 18, 63, 70, 71, 72, 73, 74, 75, 76, 77, 78], [2, 62]), { 5: [1, 92] }, { 15: 93, 81: [1, 94] }, { 5: [2, 75] }, o($Vv, [2, 7]), { 5: [1, 96], 18: [1, 95] }, { 5: [1, 98], 18: [1, 97] }, o($Vv, [2, 16]), { 5: [1, 100], 23: [1, 99] }, { 5: [1, 101] }, o($Vv, [2, 20]), { 5: [1, 102] }, { 5: [1, 103] }, o($Vv, [2, 23]), o($Vv, [2, 24]), o($Vv, [2, 25]), o($Vv, [2, 26]), o($Vv, [2, 27]), o($Vv, [2, 30]), o($Vv, [2, 31]), o($Vw, $V4, { 8: 104 }), o($Vw, $V4, { 8: 105 }), o($Vw, $V4, { 8: 106 }), o($Vx, $V4, { 44: 107, 8: 108 }), o($Vy, $V4, { 46: 109, 8: 110 }), o($Vz, $V4, { 48: 111, 8: 112 }), o($Vw, $V4, { 8: 113 }), { 17: 116, 67: [1, 114], 68: [1, 115], 69: $Vt }, o($VA, [2, 63]), o($VA, [2, 64]), o($VA, [2, 65]), o($VA, [2, 66]), o($VA, [2, 67]), o($VA, [2, 68]), o($VA, [2, 69]), o($VA, [2, 70]), { 17: 117, 69: $Vt }, { 17: 119, 57: 118, 69: $Vt }, { 69: [2, 57] }, { 69: [2, 58] }, { 55: 120, 78: $VB }, { 55: 122, 78: $VB }, { 55: 123, 78: $VB }, { 55: 124, 78: $VB }, o($VC, [2, 10]), { 13: 125, 82: $Vu }, { 82: [2, 74] }, { 19: [1, 126] }, o($Vv, [2, 13]), { 19: [1, 127] }, o($Vv, [2, 15]), { 5: [1, 128] }, o($Vv, [2, 18]), o($Vv, [2, 19]), o($Vv, [2, 21]), o($Vv, [2, 22]), { 4: $V5, 5: $V6, 6: 41, 9: 14, 10: 16, 11: 6, 16: $V7, 17: 42, 20: $V8, 21: 20, 22: $V9, 25: $Va, 26: $Vb, 27: 24, 28: 25, 29: 26, 30: 27, 31: 28, 32: $Vc, 33: $Vd, 34: $Ve, 36: $Vf, 38: $Vg, 39: $Vh, 40: [1, 129], 41: $Vi, 42: $Vj, 43: $Vk, 45: $Vl, 47: $Vm, 49: $Vn, 53: $Vo, 58: $Vp, 59: $Vq, 60: $Vr, 61: $Vs, 69: $Vt, 79: $V3 }, { 4: $V5, 5: $V6, 6: 41, 9: 14, 10: 16, 11: 6, 16: $V7, 17: 42, 20: $V8, 21: 20, 22: $V9, 25: $Va, 26: $Vb, 27: 24, 28: 25, 29: 26, 30: 27, 31: 28, 32: $Vc, 33: $Vd, 34: $Ve, 36: $Vf, 38: $Vg, 39: $Vh, 40: [1, 130], 41: $Vi, 42: $Vj, 43: $Vk, 45: $Vl, 47: $Vm, 49: $Vn, 53: $Vo, 58: $Vp, 59: $Vq, 60: $Vr, 61: $Vs, 69: $Vt, 79: $V3 }, { 4: $V5, 5: $V6, 6: 41, 9: 14, 10: 16, 11: 6, 16: $V7, 17: 42, 20: $V8, 21: 20, 22: $V9, 25: $Va, 26: $Vb, 27: 24, 28: 25, 29: 26, 30: 27, 31: 28, 32: $Vc, 33: $Vd, 34: $Ve, 36: $Vf, 38: $Vg, 39: $Vh, 40: [1, 131], 41: $Vi, 42: $Vj, 43: $Vk, 45: $Vl, 47: $Vm, 49: $Vn, 53: $Vo, 58: $Vp, 59: $Vq, 60: $Vr, 61: $Vs, 69: $Vt, 79: $V3 }, { 40: [1, 132] }, { 4: $V5, 5: $V6, 6: 41, 9: 14, 10: 16, 11: 6, 16: $V7, 17: 42, 20: $V8, 21: 20, 22: $V9, 25: $Va, 26: $Vb, 27: 24, 28: 25, 29: 26, 30: 27, 31: 28, 32: $Vc, 33: $Vd, 34: $Ve, 36: $Vf, 38: $Vg, 39: $Vh, 40: [2, 45], 41: $Vi, 42: $Vj, 43: $Vk, 45: $Vl, 47: $Vm, 49: $Vn, 52: [1, 133], 53: $Vo, 58: $Vp, 59: $Vq, 60: $Vr, 61: $Vs, 69: $Vt, 79: $V3 }, { 40: [1, 134] }, { 4: $V5, 5: $V6, 6: 41, 9: 14, 10: 16, 11: 6, 16: $V7, 17: 42, 20: $V8, 21: 20, 22: $V9, 25: $Va, 26: $Vb, 27: 24, 28: 25, 29: 26, 30: 27, 31: 28, 32: $Vc, 33: $Vd, 34: $Ve, 36: $Vf, 38: $Vg, 39: $Vh, 40: [2, 43], 41: $Vi, 42: $Vj, 43: $Vk, 45: $Vl, 47: $Vm, 49: $Vn, 51: [1, 135], 53: $Vo, 58: $Vp, 59: $Vq, 60: $Vr, 61: $Vs, 69: $Vt, 79: $V3 }, { 40: [1, 136] }, { 4: $V5, 5: $V6, 6: 41, 9: 14, 10: 16, 11: 6, 16: $V7, 17: 42, 20: $V8, 21: 20, 22: $V9, 25: $Va, 26: $Vb, 27: 24, 28: 25, 29: 26, 30: 27, 31: 28, 32: $Vc, 33: $Vd, 34: $Ve, 36: $Vf, 38: $Vg, 39: $Vh, 40: [2, 41], 41: $Vi, 42: $Vj, 43: $Vk, 45: $Vl, 47: $Vm, 49: $Vn, 50: [1, 137], 53: $Vo, 58: $Vp, 59: $Vq, 60: $Vr, 61: $Vs, 69: $Vt, 79: $V3 }, { 4: $V5, 5: $V6, 6: 41, 9: 14, 10: 16, 11: 6, 16: $V7, 17: 42, 20: $V8, 21: 20, 22: $V9, 25: $Va, 26: $Vb, 27: 24, 28: 25, 29: 26, 30: 27, 31: 28, 32: $Vc, 33: $Vd, 34: $Ve, 36: $Vf, 38: $Vg, 39: $Vh, 40: [1, 138], 41: $Vi, 42: $Vj, 43: $Vk, 45: $Vl, 47: $Vm, 49: $Vn, 53: $Vo, 58: $Vp, 59: $Vq, 60: $Vr, 61: $Vs, 69: $Vt, 79: $V3 }, { 17: 139, 69: $Vt }, { 17: 140, 69: $Vt }, { 55: 141, 78: $VB }, { 55: 142, 78: $VB }, { 55: 143, 78: $VB }, { 63: [1, 144], 78: [2, 56] }, { 5: [2, 49] }, { 5: [2, 71] }, { 5: [2, 50] }, { 5: [2, 51] }, { 5: [2, 52] }, { 5: [1, 145] }, { 5: [1, 146] }, { 5: [1, 147] }, o($Vv, [2, 17]), o($Vv, [2, 33]), o($Vv, [2, 34]), o($Vv, [2, 35]), o($Vv, [2, 36]), { 19: [1, 148] }, o($Vv, [2, 37]), { 19: [1, 149] }, o($Vv, [2, 38]), { 19: [1, 150] }, o($Vv, [2, 39]), { 55: 151, 78: $VB }, { 55: 152, 78: $VB }, { 5: [2, 61] }, { 5: [2, 47] }, { 5: [2, 48] }, { 17: 153, 69: $Vt }, o($VC, [2, 11]), o($Vv, [2, 12]), o($Vv, [2, 14]), o($Vx, $V4, { 8: 108, 44: 154 }), o($Vy, $V4, { 8: 110, 46: 155 }), o($Vz, $V4, { 8: 112, 48: 156 }), { 5: [2, 59] }, { 5: [2, 60] }, { 78: [2, 55] }, { 40: [2, 46] }, { 40: [2, 44] }, { 40: [2, 42] }],
    defaultActions: { 7: [2, 72], 8: [2, 1], 9: [2, 2], 10: [2, 3], 51: [2, 75], 86: [2, 57], 87: [2, 58], 94: [2, 74], 120: [2, 49], 121: [2, 71], 122: [2, 50], 123: [2, 51], 124: [2, 52], 141: [2, 61], 142: [2, 47], 143: [2, 48], 151: [2, 59], 152: [2, 60], 153: [2, 55], 154: [2, 46], 155: [2, 44], 156: [2, 42] },
    parseError: function parseError(str, hash2) {
      if (hash2.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash2;
        throw error;
      }
    },
    parse: function parse2(input) {
      var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k2 in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
          sharedState.yy[k2] = this.yy[k2];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges2 = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function lex() {
        var token2;
        token2 = tstack.pop() || lexer2.lex() || EOF2;
        if (typeof token2 !== "number") {
          if (token2 instanceof Array) {
            tstack = token2;
            token2 = tstack.pop();
          }
          token2 = self2.symbols_[token2] || token2;
        }
        return token2;
      }
      var symbol2, state, action, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack2[stack2.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol2 === null || typeof symbol2 == "undefined") {
            symbol2 = lex();
          }
          action = table[state] && table[state][symbol2];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push("'" + this.terminals_[p] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol2] || symbol2) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol2 == EOF2 ? "end of input" : "'" + (this.terminals_[symbol2] || symbol2) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol2] || symbol2,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol2);
        }
        switch (action[0]) {
          case 1:
            stack2.push(symbol2);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack2.push(action[1]);
            symbol2 = null;
            {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges2) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
              ];
            }
            r = this.performAction.apply(yyval, [
              yytext,
              yyleng,
              yylineno,
              sharedState.yy,
              action[1],
              vstack,
              lstack
            ].concat(args));
            if (typeof r !== "undefined") {
              return r;
            }
            if (len) {
              stack2 = stack2.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack2.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
            stack2.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash2) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash2);
        } else {
          throw new Error(str);
        }
      },
      setInput: function(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      input: function() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      unput: function(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      more: function() {
        this._more = true;
        return this;
      },
      reject: function() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      less: function(n) {
        this.unput(this.match.slice(n));
      },
      pastInput: function() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var next2 = this.match;
        if (next2.length < 20) {
          next2 += this._input.substr(0, 20 - next2.length);
        }
        return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var pre = this.pastInput();
        var c2 = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c2 + "^";
      },
      test_match: function(match, indexed_rule) {
        var token2, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token2) {
          return token2;
        } else if (this._backtrack) {
          for (var k2 in backup) {
            this[k2] = backup[k2];
          }
          return false;
        }
        return false;
      },
      next: function() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token2, match, tempMatch, index2;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index2 = i;
            if (this.options.backtrack_lexer) {
              token2 = this.test_match(tempMatch, rules[i]);
              if (token2 !== false) {
                return token2;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token2 = this.test_match(match, rules[index2]);
          if (token2 !== false) {
            return token2;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": true },
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        switch ($avoiding_name_collisions) {
          case 0:
            this.begin("open_directive");
            return 79;
          case 1:
            this.begin("type_directive");
            return 80;
          case 2:
            this.popState();
            this.begin("arg_directive");
            return 14;
          case 3:
            this.popState();
            this.popState();
            return 82;
          case 4:
            return 81;
          case 5:
            return 5;
          case 6:
            break;
          case 7:
            break;
          case 8:
            break;
          case 9:
            break;
          case 10:
            break;
          case 11:
            return 23;
          case 12:
            this.begin("ID");
            return 16;
          case 13:
            this.begin("ID");
            return 20;
          case 14:
            yy_.yytext = yy_.yytext.trim();
            this.begin("ALIAS");
            return 69;
          case 15:
            this.popState();
            this.popState();
            this.begin("LINE");
            return 18;
          case 16:
            this.popState();
            this.popState();
            return 5;
          case 17:
            this.begin("LINE");
            return 39;
          case 18:
            this.begin("LINE");
            return 41;
          case 19:
            this.begin("LINE");
            return 42;
          case 20:
            this.begin("LINE");
            return 43;
          case 21:
            this.begin("LINE");
            return 52;
          case 22:
            this.begin("LINE");
            return 45;
          case 23:
            this.begin("LINE");
            return 51;
          case 24:
            this.begin("LINE");
            return 47;
          case 25:
            this.begin("LINE");
            return 50;
          case 26:
            this.begin("LINE");
            return 49;
          case 27:
            this.popState();
            return 19;
          case 28:
            return 40;
          case 29:
            return 64;
          case 30:
            return 65;
          case 31:
            return 58;
          case 32:
            return 59;
          case 33:
            return 60;
          case 34:
            return 61;
          case 35:
            return 56;
          case 36:
            return 53;
          case 37:
            this.begin("ID");
            return 25;
          case 38:
            this.begin("ID");
            return 26;
          case 39:
            return 32;
          case 40:
            return 33;
          case 41:
            this.begin("acc_title");
            return 34;
          case 42:
            this.popState();
            return "acc_title_value";
          case 43:
            this.begin("acc_descr");
            return 36;
          case 44:
            this.popState();
            return "acc_descr_value";
          case 45:
            this.begin("acc_descr_multiline");
            break;
          case 46:
            this.popState();
            break;
          case 47:
            return "acc_descr_multiline_value";
          case 48:
            return 7;
          case 49:
            return 22;
          case 50:
            return 24;
          case 51:
            return 63;
          case 52:
            return 5;
          case 53:
            yy_.yytext = yy_.yytext.trim();
            return 69;
          case 54:
            return 72;
          case 55:
            return 73;
          case 56:
            return 70;
          case 57:
            return 71;
          case 58:
            return 74;
          case 59:
            return 75;
          case 60:
            return 76;
          case 61:
            return 77;
          case 62:
            return 78;
          case 63:
            return 67;
          case 64:
            return 68;
          case 65:
            return 5;
          case 66:
            return "INVALID";
        }
      },
      rules: [/^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:((?!\n)\s)+)/i, /^(?:#[^\n]*)/i, /^(?:%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[0-9]+(?=[ \n]+))/i, /^(?:participant\b)/i, /^(?:actor\b)/i, /^(?:[^\->:\n,;]+?([\-]*[^\->:\n,;]+?)*?(?=((?!\n)\s)+as(?!\n)\s|[#\n;]|$))/i, /^(?:as\b)/i, /^(?:(?:))/i, /^(?:loop\b)/i, /^(?:rect\b)/i, /^(?:opt\b)/i, /^(?:alt\b)/i, /^(?:else\b)/i, /^(?:par\b)/i, /^(?:and\b)/i, /^(?:critical\b)/i, /^(?:option\b)/i, /^(?:break\b)/i, /^(?:(?:[:]?(?:no)?wrap)?[^#\n;]*)/i, /^(?:end\b)/i, /^(?:left of\b)/i, /^(?:right of\b)/i, /^(?:links\b)/i, /^(?:link\b)/i, /^(?:properties\b)/i, /^(?:details\b)/i, /^(?:over\b)/i, /^(?:note\b)/i, /^(?:activate\b)/i, /^(?:deactivate\b)/i, /^(?:title\s[^#\n;]+)/i, /^(?:title:\s[^#\n;]+)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:sequenceDiagram\b)/i, /^(?:autonumber\b)/i, /^(?:off\b)/i, /^(?:,)/i, /^(?:;)/i, /^(?:[^\+\->:\n,;]+((?!(-x|--x|-\)|--\)))[\-]*[^\+\->:\n,;]+)*)/i, /^(?:->>)/i, /^(?:-->>)/i, /^(?:->)/i, /^(?:-->)/i, /^(?:-[x])/i, /^(?:--[x])/i, /^(?:-[\)])/i, /^(?:--[\)])/i, /^(?::(?:(?:no)?wrap)?[^#\n;]+)/i, /^(?:\+)/i, /^(?:-)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { "acc_descr_multiline": { "rules": [46, 47], "inclusive": false }, "acc_descr": { "rules": [44], "inclusive": false }, "acc_title": { "rules": [42], "inclusive": false }, "open_directive": { "rules": [1, 8], "inclusive": false }, "type_directive": { "rules": [2, 3, 8], "inclusive": false }, "arg_directive": { "rules": [3, 4, 8], "inclusive": false }, "ID": { "rules": [7, 8, 14], "inclusive": false }, "ALIAS": { "rules": [7, 8, 15, 16], "inclusive": false }, "LINE": { "rules": [7, 8, 27], "inclusive": false }, "INITIAL": { "rules": [0, 5, 6, 8, 9, 10, 11, 12, 13, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 43, 45, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66], "inclusive": true } }
    };
    return lexer2;
  }();
  parser2.lexer = lexer;
  function Parser2() {
    this.yy = {};
  }
  Parser2.prototype = parser2;
  parser2.Parser = Parser2;
  return new Parser2();
}();
parser$2.parser = parser$2;
const sequenceDetector = (txt) => {
  return txt.match(/^\s*sequenceDiagram/) !== null;
};
let prevActor = void 0;
let actors$1 = {};
let messages = [];
let sequenceNumbersEnabled = false;
let wrapEnabled;
const parseDirective$3 = function(statement, context, type2) {
  mermaidAPI.parseDirective(this, statement, context, type2);
};
const addActor = function(id2, name2, description2, type2) {
  const old = actors$1[id2];
  if (old && name2 === old.name && description2 == null)
    return;
  if (description2 == null || description2.text == null) {
    description2 = { text: name2, wrap: null, type: type2 };
  }
  if (type2 == null || description2.text == null) {
    description2 = { text: name2, wrap: null, type: type2 };
  }
  actors$1[id2] = {
    name: name2,
    description: description2.text,
    wrap: description2.wrap === void 0 && autoWrap() || !!description2.wrap,
    prevActor,
    links: {},
    properties: {},
    actorCnt: null,
    rectData: null,
    type: type2 || "participant"
  };
  if (prevActor && actors$1[prevActor]) {
    actors$1[prevActor].nextActor = id2;
  }
  prevActor = id2;
};
const activationCount = (part) => {
  let i;
  let count2 = 0;
  for (i = 0; i < messages.length; i++) {
    if (messages[i].type === LINETYPE.ACTIVE_START) {
      if (messages[i].from.actor === part) {
        count2++;
      }
    }
    if (messages[i].type === LINETYPE.ACTIVE_END) {
      if (messages[i].from.actor === part) {
        count2--;
      }
    }
  }
  return count2;
};
const addMessage = function(idFrom, idTo, message2, answer) {
  messages.push({
    from: idFrom,
    to: idTo,
    message: message2.text,
    wrap: message2.wrap === void 0 && autoWrap() || !!message2.wrap,
    answer
  });
};
const addSignal = function(idFrom, idTo, message2 = { text: void 0, wrap: void 0 }, messageType) {
  if (messageType === LINETYPE.ACTIVE_END) {
    const cnt2 = activationCount(idFrom.actor);
    if (cnt2 < 1) {
      let error = new Error("Trying to inactivate an inactive participant (" + idFrom.actor + ")");
      error.hash = {
        text: "->>-",
        token: "->>-",
        line: "1",
        loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
        expected: ["'ACTIVE_PARTICIPANT'"]
      };
      throw error;
    }
  }
  messages.push({
    from: idFrom,
    to: idTo,
    message: message2.text,
    wrap: message2.wrap === void 0 && autoWrap() || !!message2.wrap,
    type: messageType
  });
  return true;
};
const getMessages = function() {
  return messages;
};
const getActors$1 = function() {
  return actors$1;
};
const getActor = function(id2) {
  return actors$1[id2];
};
const getActorKeys = function() {
  return Object.keys(actors$1);
};
const enableSequenceNumbers = function() {
  sequenceNumbersEnabled = true;
};
const disableSequenceNumbers = function() {
  sequenceNumbersEnabled = false;
};
const showSequenceNumbers = () => sequenceNumbersEnabled;
const setWrap = function(wrapSetting) {
  wrapEnabled = wrapSetting;
};
const autoWrap = () => {
  if (typeof wrapEnabled !== "undefined") {
    return wrapEnabled;
  }
  return getConfig$1().sequence.wrap;
};
const clear$2 = function() {
  actors$1 = {};
  messages = [];
  sequenceNumbersEnabled = false;
  clear$g();
};
const parseMessage = function(str) {
  const _str = str.trim();
  const message2 = {
    text: _str.replace(/^[:]?(?:no)?wrap:/, "").trim(),
    wrap: _str.match(/^[:]?wrap:/) !== null ? true : _str.match(/^[:]?nowrap:/) !== null ? false : void 0
  };
  log$1.debug("parseMessage:", message2);
  return message2;
};
const LINETYPE = {
  SOLID: 0,
  DOTTED: 1,
  NOTE: 2,
  SOLID_CROSS: 3,
  DOTTED_CROSS: 4,
  SOLID_OPEN: 5,
  DOTTED_OPEN: 6,
  LOOP_START: 10,
  LOOP_END: 11,
  ALT_START: 12,
  ALT_ELSE: 13,
  ALT_END: 14,
  OPT_START: 15,
  OPT_END: 16,
  ACTIVE_START: 17,
  ACTIVE_END: 18,
  PAR_START: 19,
  PAR_AND: 20,
  PAR_END: 21,
  RECT_START: 22,
  RECT_END: 23,
  SOLID_POINT: 24,
  DOTTED_POINT: 25,
  AUTONUMBER: 26,
  CRITICAL_START: 27,
  CRITICAL_OPTION: 28,
  CRITICAL_END: 29,
  BREAK_START: 30,
  BREAK_END: 31
};
const ARROWTYPE = {
  FILLED: 0,
  OPEN: 1
};
const PLACEMENT = {
  LEFTOF: 0,
  RIGHTOF: 1,
  OVER: 2
};
const addNote = function(actor, placement, message2) {
  ({
    actor,
    placement,
    message: message2.text,
    wrap: message2.wrap === void 0 && autoWrap() || !!message2.wrap
  });
  const actors2 = [].concat(actor, actor);
  messages.push({
    from: actors2[0],
    to: actors2[1],
    message: message2.text,
    wrap: message2.wrap === void 0 && autoWrap() || !!message2.wrap,
    type: LINETYPE.NOTE,
    placement
  });
};
const addLinks = function(actorId, text2) {
  const actor = getActor(actorId);
  try {
    let sanitizedText = sanitizeText$5(text2.text, getConfig$1());
    sanitizedText = sanitizedText.replace(/&amp;/g, "&");
    sanitizedText = sanitizedText.replace(/&equals;/g, "=");
    const links2 = JSON.parse(sanitizedText);
    insertLinks(actor, links2);
  } catch (e) {
    log$1.error("error while parsing actor link text", e);
  }
};
const addALink = function(actorId, text2) {
  const actor = getActor(actorId);
  try {
    const links2 = {};
    let sanitizedText = sanitizeText$5(text2.text, getConfig$1());
    var sep2 = sanitizedText.indexOf("@");
    sanitizedText = sanitizedText.replace(/&amp;/g, "&");
    sanitizedText = sanitizedText.replace(/&equals;/g, "=");
    var label = sanitizedText.slice(0, sep2 - 1).trim();
    var link2 = sanitizedText.slice(sep2 + 1).trim();
    links2[label] = link2;
    insertLinks(actor, links2);
  } catch (e) {
    log$1.error("error while parsing actor link text", e);
  }
};
function insertLinks(actor, links2) {
  if (actor.links == null) {
    actor.links = links2;
  } else {
    for (let key in links2) {
      actor.links[key] = links2[key];
    }
  }
}
const addProperties = function(actorId, text2) {
  const actor = getActor(actorId);
  try {
    let sanitizedText = sanitizeText$5(text2.text, getConfig$1());
    const properties2 = JSON.parse(sanitizedText);
    insertProperties(actor, properties2);
  } catch (e) {
    log$1.error("error while parsing actor properties text", e);
  }
};
function insertProperties(actor, properties2) {
  if (actor.properties == null) {
    actor.properties = properties2;
  } else {
    for (let key in properties2) {
      actor.properties[key] = properties2[key];
    }
  }
}
const addDetails = function(actorId, text2) {
  const actor = getActor(actorId);
  const elem = document.getElementById(text2.text);
  try {
    const text22 = elem.innerHTML;
    const details = JSON.parse(text22);
    if (details["properties"]) {
      insertProperties(actor, details["properties"]);
    }
    if (details["links"]) {
      insertLinks(actor, details["links"]);
    }
  } catch (e) {
    log$1.error("error while parsing actor details text", e);
  }
};
const getActorProperty = function(actor, key) {
  if (typeof actor !== "undefined" && typeof actor.properties !== "undefined") {
    return actor.properties[key];
  }
  return void 0;
};
const apply = function(param) {
  if (param instanceof Array) {
    param.forEach(function(item) {
      apply(item);
    });
  } else {
    switch (param.type) {
      case "sequenceIndex":
        messages.push({
          from: void 0,
          to: void 0,
          message: {
            start: param.sequenceIndex,
            step: param.sequenceIndexStep,
            visible: param.sequenceVisible
          },
          wrap: false,
          type: param.signalType
        });
        break;
      case "addParticipant":
        addActor(param.actor, param.actor, param.description, "participant");
        break;
      case "addActor":
        addActor(param.actor, param.actor, param.description, "actor");
        break;
      case "activeStart":
        addSignal(param.actor, void 0, void 0, param.signalType);
        break;
      case "activeEnd":
        addSignal(param.actor, void 0, void 0, param.signalType);
        break;
      case "addNote":
        addNote(param.actor, param.placement, param.text);
        break;
      case "addLinks":
        addLinks(param.actor, param.text);
        break;
      case "addALink":
        addALink(param.actor, param.text);
        break;
      case "addProperties":
        addProperties(param.actor, param.text);
        break;
      case "addDetails":
        addDetails(param.actor, param.text);
        break;
      case "addMessage":
        addSignal(param.from, param.to, param.msg, param.signalType);
        break;
      case "loopStart":
        addSignal(void 0, void 0, param.loopText, param.signalType);
        break;
      case "loopEnd":
        addSignal(void 0, void 0, void 0, param.signalType);
        break;
      case "rectStart":
        addSignal(void 0, void 0, param.color, param.signalType);
        break;
      case "rectEnd":
        addSignal(void 0, void 0, void 0, param.signalType);
        break;
      case "optStart":
        addSignal(void 0, void 0, param.optText, param.signalType);
        break;
      case "optEnd":
        addSignal(void 0, void 0, void 0, param.signalType);
        break;
      case "altStart":
        addSignal(void 0, void 0, param.altText, param.signalType);
        break;
      case "else":
        addSignal(void 0, void 0, param.altText, param.signalType);
        break;
      case "altEnd":
        addSignal(void 0, void 0, void 0, param.signalType);
        break;
      case "setAccTitle":
        setAccTitle(param.text);
        break;
      case "parStart":
        addSignal(void 0, void 0, param.parText, param.signalType);
        break;
      case "and":
        addSignal(void 0, void 0, param.parText, param.signalType);
        break;
      case "parEnd":
        addSignal(void 0, void 0, void 0, param.signalType);
        break;
      case "criticalStart":
        addSignal(void 0, void 0, param.criticalText, param.signalType);
        break;
      case "option":
        addSignal(void 0, void 0, param.optionText, param.signalType);
        break;
      case "criticalEnd":
        addSignal(void 0, void 0, void 0, param.signalType);
        break;
      case "breakStart":
        addSignal(void 0, void 0, param.breakText, param.signalType);
        break;
      case "breakEnd":
        addSignal(void 0, void 0, void 0, param.signalType);
        break;
    }
  }
};
const sequenceDb = {
  addActor,
  addMessage,
  addSignal,
  addLinks,
  addDetails,
  addProperties,
  autoWrap,
  setWrap,
  enableSequenceNumbers,
  disableSequenceNumbers,
  showSequenceNumbers,
  getMessages,
  getActors: getActors$1,
  getActor,
  getActorKeys,
  getActorProperty,
  getAccTitle,
  getDiagramTitle,
  setDiagramTitle,
  parseDirective: parseDirective$3,
  getConfig: () => getConfig$1().sequence,
  clear: clear$2,
  parseMessage,
  LINETYPE,
  ARROWTYPE,
  PLACEMENT,
  addNote,
  setAccTitle,
  apply,
  setAccDescription,
  getAccDescription
};
let interactionFunctions = [];
const addFunction = (func) => {
  interactionFunctions.push(func);
};
const attachFunctions = () => {
  interactionFunctions.forEach((f2) => {
    f2();
  });
  interactionFunctions = [];
};
const drawRect$1 = function(elem, rectData) {
  const rectElem = elem.append("rect");
  rectElem.attr("x", rectData.x);
  rectElem.attr("y", rectData.y);
  rectElem.attr("fill", rectData.fill);
  rectElem.attr("stroke", rectData.stroke);
  rectElem.attr("width", rectData.width);
  rectElem.attr("height", rectData.height);
  rectElem.attr("rx", rectData.rx);
  rectElem.attr("ry", rectData.ry);
  if (typeof rectData.class !== "undefined") {
    rectElem.attr("class", rectData.class);
  }
  return rectElem;
};
const addPopupInteraction = (id2, actorCnt2) => {
  addFunction(() => {
    const arr = document.querySelectorAll(id2);
    if (arr.length === 0)
      return;
    arr[0].addEventListener("mouseover", function() {
      popupMenuUpFunc("actor" + actorCnt2 + "_popup");
    });
    arr[0].addEventListener("mouseout", function() {
      popupMenuDownFunc("actor" + actorCnt2 + "_popup");
    });
  });
};
const drawPopup = function(elem, actor, minMenuWidth, textAttrs, forceMenus) {
  if (actor.links === void 0 || actor.links === null || Object.keys(actor.links).length === 0) {
    return { height: 0, width: 0 };
  }
  const links2 = actor.links;
  const actorCnt2 = actor.actorCnt;
  const rectData = actor.rectData;
  var displayValue = "none";
  if (forceMenus) {
    displayValue = "block !important";
  }
  const g2 = elem.append("g");
  g2.attr("id", "actor" + actorCnt2 + "_popup");
  g2.attr("class", "actorPopupMenu");
  g2.attr("display", displayValue);
  addPopupInteraction("#actor" + actorCnt2 + "_popup", actorCnt2);
  var actorClass = "";
  if (typeof rectData.class !== "undefined") {
    actorClass = " " + rectData.class;
  }
  let menuWidth = rectData.width > minMenuWidth ? rectData.width : minMenuWidth;
  const rectElem = g2.append("rect");
  rectElem.attr("class", "actorPopupMenuPanel" + actorClass);
  rectElem.attr("x", rectData.x);
  rectElem.attr("y", rectData.height);
  rectElem.attr("fill", rectData.fill);
  rectElem.attr("stroke", rectData.stroke);
  rectElem.attr("width", menuWidth);
  rectElem.attr("height", rectData.height);
  rectElem.attr("rx", rectData.rx);
  rectElem.attr("ry", rectData.ry);
  if (links2 != null) {
    var linkY = 20;
    for (let key in links2) {
      var linkElem = g2.append("a");
      var sanitizedLink = sanitizeUrl_1(links2[key]);
      linkElem.attr("xlink:href", sanitizedLink);
      linkElem.attr("target", "_blank");
      _drawMenuItemTextCandidateFunc(textAttrs)(
        key,
        linkElem,
        rectData.x + 10,
        rectData.height + linkY,
        menuWidth,
        20,
        { class: "actor" },
        textAttrs
      );
      linkY += 30;
    }
  }
  rectElem.attr("height", linkY);
  return { height: rectData.height + linkY, width: menuWidth };
};
const drawImage = function(elem, x2, y2, link2) {
  const imageElem = elem.append("image");
  imageElem.attr("x", x2);
  imageElem.attr("y", y2);
  var sanitizedLink = sanitizeUrl_1(link2);
  imageElem.attr("xlink:href", sanitizedLink);
};
const drawEmbeddedImage = function(elem, x2, y2, link2) {
  const imageElem = elem.append("use");
  imageElem.attr("x", x2);
  imageElem.attr("y", y2);
  var sanitizedLink = sanitizeUrl_1(link2);
  imageElem.attr("xlink:href", "#" + sanitizedLink);
};
const popupMenu = function(popid) {
  return "var pu = document.getElementById('" + popid + "'); if (pu != null) { pu.style.display = 'block'; }";
};
const popdownMenu = function(popid) {
  return "var pu = document.getElementById('" + popid + "'); if (pu != null) { pu.style.display = 'none'; }";
};
const popupMenuUpFunc = function(popupId) {
  var pu = document.getElementById(popupId);
  if (pu != null) {
    pu.style.display = "block";
  }
};
const popupMenuDownFunc = function(popupId) {
  var pu = document.getElementById(popupId);
  if (pu != null) {
    pu.style.display = "none";
  }
};
const drawText$1 = function(elem, textData) {
  let prevTextHeight = 0, textHeight = 0;
  const lines = textData.text.split(common.lineBreakRegex);
  let textElems = [];
  let dy = 0;
  let yfunc = () => textData.y;
  if (typeof textData.valign !== "undefined" && typeof textData.textMargin !== "undefined" && textData.textMargin > 0) {
    switch (textData.valign) {
      case "top":
      case "start":
        yfunc = () => Math.round(textData.y + textData.textMargin);
        break;
      case "middle":
      case "center":
        yfunc = () => Math.round(textData.y + (prevTextHeight + textHeight + textData.textMargin) / 2);
        break;
      case "bottom":
      case "end":
        yfunc = () => Math.round(
          textData.y + (prevTextHeight + textHeight + 2 * textData.textMargin) - textData.textMargin
        );
        break;
    }
  }
  if (typeof textData.anchor !== "undefined" && typeof textData.textMargin !== "undefined" && typeof textData.width !== "undefined") {
    switch (textData.anchor) {
      case "left":
      case "start":
        textData.x = Math.round(textData.x + textData.textMargin);
        textData.anchor = "start";
        textData.dominantBaseline = "middle";
        textData.alignmentBaseline = "middle";
        break;
      case "middle":
      case "center":
        textData.x = Math.round(textData.x + textData.width / 2);
        textData.anchor = "middle";
        textData.dominantBaseline = "middle";
        textData.alignmentBaseline = "middle";
        break;
      case "right":
      case "end":
        textData.x = Math.round(textData.x + textData.width - textData.textMargin);
        textData.anchor = "end";
        textData.dominantBaseline = "middle";
        textData.alignmentBaseline = "middle";
        break;
    }
  }
  for (let i = 0; i < lines.length; i++) {
    let line2 = lines[i];
    if (typeof textData.textMargin !== "undefined" && textData.textMargin === 0 && typeof textData.fontSize !== "undefined") {
      dy = i * textData.fontSize;
    }
    const textElem = elem.append("text");
    textElem.attr("x", textData.x);
    textElem.attr("y", yfunc());
    if (typeof textData.anchor !== "undefined") {
      textElem.attr("text-anchor", textData.anchor).attr("dominant-baseline", textData.dominantBaseline).attr("alignment-baseline", textData.alignmentBaseline);
    }
    if (typeof textData.fontFamily !== "undefined") {
      textElem.style("font-family", textData.fontFamily);
    }
    if (typeof textData.fontSize !== "undefined") {
      textElem.style("font-size", textData.fontSize);
    }
    if (typeof textData.fontWeight !== "undefined") {
      textElem.style("font-weight", textData.fontWeight);
    }
    if (typeof textData.fill !== "undefined") {
      textElem.attr("fill", textData.fill);
    }
    if (typeof textData.class !== "undefined") {
      textElem.attr("class", textData.class);
    }
    if (typeof textData.dy !== "undefined") {
      textElem.attr("dy", textData.dy);
    } else if (dy !== 0) {
      textElem.attr("dy", dy);
    }
    if (textData.tspan) {
      const span = textElem.append("tspan");
      span.attr("x", textData.x);
      if (typeof textData.fill !== "undefined") {
        span.attr("fill", textData.fill);
      }
      span.text(line2);
    } else {
      textElem.text(line2);
    }
    if (typeof textData.valign !== "undefined" && typeof textData.textMargin !== "undefined" && textData.textMargin > 0) {
      textHeight += (textElem._groups || textElem)[0][0].getBBox().height;
      prevTextHeight = textHeight;
    }
    textElems.push(textElem);
  }
  return textElems;
};
const drawLabel$1 = function(elem, txtObject) {
  function genPoints(x2, y2, width2, height2, cut) {
    return x2 + "," + y2 + " " + (x2 + width2) + "," + y2 + " " + (x2 + width2) + "," + (y2 + height2 - cut) + " " + (x2 + width2 - cut * 1.2) + "," + (y2 + height2) + " " + x2 + "," + (y2 + height2);
  }
  const polygon = elem.append("polygon");
  polygon.attr("points", genPoints(txtObject.x, txtObject.y, txtObject.width, txtObject.height, 7));
  polygon.attr("class", "labelBox");
  txtObject.y = txtObject.y + txtObject.height / 2;
  drawText$1(elem, txtObject);
  return polygon;
};
let actorCnt = -1;
const fixLifeLineHeights = (diagram, bounds2) => {
  if (!diagram.selectAll)
    return;
  diagram.selectAll(".actor-line").attr("class", "200").attr("y2", bounds2 - 55);
};
const drawActorTypeParticipant = function(elem, actor, conf2) {
  const center2 = actor.x + actor.width / 2;
  const boxpluslineGroup = elem.append("g");
  var g2 = boxpluslineGroup;
  if (actor.y === 0) {
    actorCnt++;
    g2.append("line").attr("id", "actor" + actorCnt).attr("x1", center2).attr("y1", 5).attr("x2", center2).attr("y2", 2e3).attr("class", "actor-line").attr("stroke-width", "0.5px").attr("stroke", "#999");
    g2 = boxpluslineGroup.append("g");
    actor.actorCnt = actorCnt;
    if (actor.links != null) {
      g2.attr("id", "root-" + actorCnt);
      addPopupInteraction("#root-" + actorCnt, actorCnt);
    }
  }
  const rect2 = getNoteRect$1();
  var cssclass = "actor";
  if (actor.properties != null && actor.properties["class"]) {
    cssclass = actor.properties["class"];
  } else {
    rect2.fill = "#eaeaea";
  }
  rect2.x = actor.x;
  rect2.y = actor.y;
  rect2.width = actor.width;
  rect2.height = actor.height;
  rect2.class = cssclass;
  rect2.rx = 3;
  rect2.ry = 3;
  const rectElem = drawRect$1(g2, rect2);
  actor.rectData = rect2;
  if (actor.properties != null && actor.properties["icon"]) {
    const iconSrc = actor.properties["icon"].trim();
    if (iconSrc.charAt(0) === "@") {
      drawEmbeddedImage(g2, rect2.x + rect2.width - 20, rect2.y + 10, iconSrc.substr(1));
    } else {
      drawImage(g2, rect2.x + rect2.width - 20, rect2.y + 10, iconSrc);
    }
  }
  _drawTextCandidateFunc$1(conf2)(
    actor.description,
    g2,
    rect2.x,
    rect2.y,
    rect2.width,
    rect2.height,
    { class: "actor" },
    conf2
  );
  let height2 = actor.height;
  if (rectElem.node) {
    const bounds2 = rectElem.node().getBBox();
    actor.height = bounds2.height;
    height2 = bounds2.height;
  }
  return height2;
};
const drawActorTypeActor = function(elem, actor, conf2) {
  const center2 = actor.x + actor.width / 2;
  if (actor.y === 0) {
    actorCnt++;
    elem.append("line").attr("id", "actor" + actorCnt).attr("x1", center2).attr("y1", 80).attr("x2", center2).attr("y2", 2e3).attr("class", "actor-line").attr("stroke-width", "0.5px").attr("stroke", "#999");
  }
  const actElem = elem.append("g");
  actElem.attr("class", "actor-man");
  const rect2 = getNoteRect$1();
  rect2.x = actor.x;
  rect2.y = actor.y;
  rect2.fill = "#eaeaea";
  rect2.width = actor.width;
  rect2.height = actor.height;
  rect2.class = "actor";
  rect2.rx = 3;
  rect2.ry = 3;
  actElem.append("line").attr("id", "actor-man-torso" + actorCnt).attr("x1", center2).attr("y1", actor.y + 25).attr("x2", center2).attr("y2", actor.y + 45);
  actElem.append("line").attr("id", "actor-man-arms" + actorCnt).attr("x1", center2 - 18).attr("y1", actor.y + 33).attr("x2", center2 + 18).attr("y2", actor.y + 33);
  actElem.append("line").attr("x1", center2 - 18).attr("y1", actor.y + 60).attr("x2", center2).attr("y2", actor.y + 45);
  actElem.append("line").attr("x1", center2).attr("y1", actor.y + 45).attr("x2", center2 + 16).attr("y2", actor.y + 60);
  const circle2 = actElem.append("circle");
  circle2.attr("cx", actor.x + actor.width / 2);
  circle2.attr("cy", actor.y + 10);
  circle2.attr("r", 15);
  circle2.attr("width", actor.width);
  circle2.attr("height", actor.height);
  const bounds2 = actElem.node().getBBox();
  actor.height = bounds2.height;
  _drawTextCandidateFunc$1(conf2)(
    actor.description,
    actElem,
    rect2.x,
    rect2.y + 35,
    rect2.width,
    rect2.height,
    { class: "actor" },
    conf2
  );
  return actor.height;
};
const drawActor = function(elem, actor, conf2) {
  switch (actor.type) {
    case "actor":
      return drawActorTypeActor(elem, actor, conf2);
    case "participant":
      return drawActorTypeParticipant(elem, actor, conf2);
  }
};
const anchorElement = function(elem) {
  return elem.append("g");
};
const drawActivation = function(elem, bounds2, verticalPos, conf2, actorActivations2) {
  const rect2 = getNoteRect$1();
  const g2 = bounds2.anchored;
  rect2.x = bounds2.startx;
  rect2.y = bounds2.starty;
  rect2.class = "activation" + actorActivations2 % 3;
  rect2.width = bounds2.stopx - bounds2.startx;
  rect2.height = verticalPos - bounds2.starty;
  drawRect$1(g2, rect2);
};
const drawLoop = function(elem, loopModel, labelText, conf2) {
  const {
    boxMargin,
    boxTextMargin,
    labelBoxHeight,
    labelBoxWidth,
    messageFontFamily: fontFamily,
    messageFontSize: fontSize,
    messageFontWeight: fontWeight
  } = conf2;
  const g2 = elem.append("g");
  const drawLoopLine = function(startx, starty, stopx, stopy) {
    return g2.append("line").attr("x1", startx).attr("y1", starty).attr("x2", stopx).attr("y2", stopy).attr("class", "loopLine");
  };
  drawLoopLine(loopModel.startx, loopModel.starty, loopModel.stopx, loopModel.starty);
  drawLoopLine(loopModel.stopx, loopModel.starty, loopModel.stopx, loopModel.stopy);
  drawLoopLine(loopModel.startx, loopModel.stopy, loopModel.stopx, loopModel.stopy);
  drawLoopLine(loopModel.startx, loopModel.starty, loopModel.startx, loopModel.stopy);
  if (typeof loopModel.sections !== "undefined") {
    loopModel.sections.forEach(function(item) {
      drawLoopLine(loopModel.startx, item.y, loopModel.stopx, item.y).style(
        "stroke-dasharray",
        "3, 3"
      );
    });
  }
  let txt = getTextObj$1();
  txt.text = labelText;
  txt.x = loopModel.startx;
  txt.y = loopModel.starty;
  txt.fontFamily = fontFamily;
  txt.fontSize = fontSize;
  txt.fontWeight = fontWeight;
  txt.anchor = "middle";
  txt.valign = "middle";
  txt.tspan = false;
  txt.width = labelBoxWidth || 50;
  txt.height = labelBoxHeight || 20;
  txt.textMargin = boxTextMargin;
  txt.class = "labelText";
  drawLabel$1(g2, txt);
  txt = getTextObj$1();
  txt.text = loopModel.title;
  txt.x = loopModel.startx + labelBoxWidth / 2 + (loopModel.stopx - loopModel.startx) / 2;
  txt.y = loopModel.starty + boxMargin + boxTextMargin;
  txt.anchor = "middle";
  txt.valign = "middle";
  txt.textMargin = boxTextMargin;
  txt.class = "loopText";
  txt.fontFamily = fontFamily;
  txt.fontSize = fontSize;
  txt.fontWeight = fontWeight;
  txt.wrap = true;
  let textElem = drawText$1(g2, txt);
  if (typeof loopModel.sectionTitles !== "undefined") {
    loopModel.sectionTitles.forEach(function(item, idx) {
      if (item.message) {
        txt.text = item.message;
        txt.x = loopModel.startx + (loopModel.stopx - loopModel.startx) / 2;
        txt.y = loopModel.sections[idx].y + boxMargin + boxTextMargin;
        txt.class = "loopText";
        txt.anchor = "middle";
        txt.valign = "middle";
        txt.tspan = false;
        txt.fontFamily = fontFamily;
        txt.fontSize = fontSize;
        txt.fontWeight = fontWeight;
        txt.wrap = loopModel.wrap;
        textElem = drawText$1(g2, txt);
        let sectionHeight = Math.round(
          textElem.map((te) => (te._groups || te)[0][0].getBBox().height).reduce((acc, curr) => acc + curr)
        );
        loopModel.sections[idx].height += sectionHeight - (boxMargin + boxTextMargin);
      }
    });
  }
  loopModel.height = Math.round(loopModel.stopy - loopModel.starty);
  return g2;
};
const drawBackgroundRect$1 = function(elem, bounds2) {
  const rectElem = drawRect$1(elem, {
    x: bounds2.startx,
    y: bounds2.starty,
    width: bounds2.stopx - bounds2.startx,
    height: bounds2.stopy - bounds2.starty,
    fill: bounds2.fill,
    class: "rect"
  });
  rectElem.lower();
};
const insertDatabaseIcon = function(elem) {
  elem.append("defs").append("symbol").attr("id", "database").attr("fill-rule", "evenodd").attr("clip-rule", "evenodd").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M12.258.001l.256.004.255.005.253.008.251.01.249.012.247.015.246.016.242.019.241.02.239.023.236.024.233.027.231.028.229.031.225.032.223.034.22.036.217.038.214.04.211.041.208.043.205.045.201.046.198.048.194.05.191.051.187.053.183.054.18.056.175.057.172.059.168.06.163.061.16.063.155.064.15.066.074.033.073.033.071.034.07.034.069.035.068.035.067.035.066.035.064.036.064.036.062.036.06.036.06.037.058.037.058.037.055.038.055.038.053.038.052.038.051.039.05.039.048.039.047.039.045.04.044.04.043.04.041.04.04.041.039.041.037.041.036.041.034.041.033.042.032.042.03.042.029.042.027.042.026.043.024.043.023.043.021.043.02.043.018.044.017.043.015.044.013.044.012.044.011.045.009.044.007.045.006.045.004.045.002.045.001.045v17l-.001.045-.002.045-.004.045-.006.045-.007.045-.009.044-.011.045-.012.044-.013.044-.015.044-.017.043-.018.044-.02.043-.021.043-.023.043-.024.043-.026.043-.027.042-.029.042-.03.042-.032.042-.033.042-.034.041-.036.041-.037.041-.039.041-.04.041-.041.04-.043.04-.044.04-.045.04-.047.039-.048.039-.05.039-.051.039-.052.038-.053.038-.055.038-.055.038-.058.037-.058.037-.06.037-.06.036-.062.036-.064.036-.064.036-.066.035-.067.035-.068.035-.069.035-.07.034-.071.034-.073.033-.074.033-.15.066-.155.064-.16.063-.163.061-.168.06-.172.059-.175.057-.18.056-.183.054-.187.053-.191.051-.194.05-.198.048-.201.046-.205.045-.208.043-.211.041-.214.04-.217.038-.22.036-.223.034-.225.032-.229.031-.231.028-.233.027-.236.024-.239.023-.241.02-.242.019-.246.016-.247.015-.249.012-.251.01-.253.008-.255.005-.256.004-.258.001-.258-.001-.256-.004-.255-.005-.253-.008-.251-.01-.249-.012-.247-.015-.245-.016-.243-.019-.241-.02-.238-.023-.236-.024-.234-.027-.231-.028-.228-.031-.226-.032-.223-.034-.22-.036-.217-.038-.214-.04-.211-.041-.208-.043-.204-.045-.201-.046-.198-.048-.195-.05-.19-.051-.187-.053-.184-.054-.179-.056-.176-.057-.172-.059-.167-.06-.164-.061-.159-.063-.155-.064-.151-.066-.074-.033-.072-.033-.072-.034-.07-.034-.069-.035-.068-.035-.067-.035-.066-.035-.064-.036-.063-.036-.062-.036-.061-.036-.06-.037-.058-.037-.057-.037-.056-.038-.055-.038-.053-.038-.052-.038-.051-.039-.049-.039-.049-.039-.046-.039-.046-.04-.044-.04-.043-.04-.041-.04-.04-.041-.039-.041-.037-.041-.036-.041-.034-.041-.033-.042-.032-.042-.03-.042-.029-.042-.027-.042-.026-.043-.024-.043-.023-.043-.021-.043-.02-.043-.018-.044-.017-.043-.015-.044-.013-.044-.012-.044-.011-.045-.009-.044-.007-.045-.006-.045-.004-.045-.002-.045-.001-.045v-17l.001-.045.002-.045.004-.045.006-.045.007-.045.009-.044.011-.045.012-.044.013-.044.015-.044.017-.043.018-.044.02-.043.021-.043.023-.043.024-.043.026-.043.027-.042.029-.042.03-.042.032-.042.033-.042.034-.041.036-.041.037-.041.039-.041.04-.041.041-.04.043-.04.044-.04.046-.04.046-.039.049-.039.049-.039.051-.039.052-.038.053-.038.055-.038.056-.038.057-.037.058-.037.06-.037.061-.036.062-.036.063-.036.064-.036.066-.035.067-.035.068-.035.069-.035.07-.034.072-.034.072-.033.074-.033.151-.066.155-.064.159-.063.164-.061.167-.06.172-.059.176-.057.179-.056.184-.054.187-.053.19-.051.195-.05.198-.048.201-.046.204-.045.208-.043.211-.041.214-.04.217-.038.22-.036.223-.034.226-.032.228-.031.231-.028.234-.027.236-.024.238-.023.241-.02.243-.019.245-.016.247-.015.249-.012.251-.01.253-.008.255-.005.256-.004.258-.001.258.001zm-9.258 20.499v.01l.001.021.003.021.004.022.005.021.006.022.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.023.018.024.019.024.021.024.022.025.023.024.024.025.052.049.056.05.061.051.066.051.07.051.075.051.079.052.084.052.088.052.092.052.097.052.102.051.105.052.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.048.144.049.147.047.152.047.155.047.16.045.163.045.167.043.171.043.176.041.178.041.183.039.187.039.19.037.194.035.197.035.202.033.204.031.209.03.212.029.216.027.219.025.222.024.226.021.23.02.233.018.236.016.24.015.243.012.246.01.249.008.253.005.256.004.259.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.021.224-.024.22-.026.216-.027.212-.028.21-.031.205-.031.202-.034.198-.034.194-.036.191-.037.187-.039.183-.04.179-.04.175-.042.172-.043.168-.044.163-.045.16-.046.155-.046.152-.047.148-.048.143-.049.139-.049.136-.05.131-.05.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.053.083-.051.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.05.023-.024.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.023.01-.022.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.127l-.077.055-.08.053-.083.054-.085.053-.087.052-.09.052-.093.051-.095.05-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.045-.118.044-.12.043-.122.042-.124.042-.126.041-.128.04-.13.04-.132.038-.134.038-.135.037-.138.037-.139.035-.142.035-.143.034-.144.033-.147.032-.148.031-.15.03-.151.03-.153.029-.154.027-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.01-.179.008-.179.008-.181.006-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.006-.179-.008-.179-.008-.178-.01-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.027-.153-.029-.151-.03-.15-.03-.148-.031-.146-.032-.145-.033-.143-.034-.141-.035-.14-.035-.137-.037-.136-.037-.134-.038-.132-.038-.13-.04-.128-.04-.126-.041-.124-.042-.122-.042-.12-.044-.117-.043-.116-.045-.113-.045-.112-.046-.109-.047-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.05-.093-.052-.09-.051-.087-.052-.085-.053-.083-.054-.08-.054-.077-.054v4.127zm0-5.654v.011l.001.021.003.021.004.021.005.022.006.022.007.022.009.022.01.022.011.023.012.023.013.023.015.024.016.023.017.024.018.024.019.024.021.024.022.024.023.025.024.024.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.052.11.051.114.051.119.052.123.05.127.051.131.05.135.049.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.044.171.042.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.022.23.02.233.018.236.016.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.012.241-.015.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.048.139-.05.136-.049.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.051.051-.049.023-.025.023-.024.021-.025.02-.024.019-.024.018-.024.017-.024.015-.023.014-.023.013-.024.012-.022.01-.023.01-.023.008-.022.006-.022.006-.022.004-.021.004-.022.001-.021.001-.021v-4.139l-.077.054-.08.054-.083.054-.085.052-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.044-.118.044-.12.044-.122.042-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.035-.143.033-.144.033-.147.033-.148.031-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.009-.179.009-.179.007-.181.007-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.007-.179-.007-.179-.009-.178-.009-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.031-.146-.033-.145-.033-.143-.033-.141-.035-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.04-.126-.041-.124-.042-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.051-.093-.051-.09-.051-.087-.053-.085-.052-.083-.054-.08-.054-.077-.054v4.139zm0-5.666v.011l.001.02.003.022.004.021.005.022.006.021.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.024.018.023.019.024.021.025.022.024.023.024.024.025.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.051.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.043.171.043.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.021.23.02.233.018.236.017.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.013.241-.014.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.049.139-.049.136-.049.131-.051.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.049.023-.025.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.022.01-.023.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.153l-.077.054-.08.054-.083.053-.085.053-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.048-.105.048-.106.048-.109.046-.111.046-.114.046-.115.044-.118.044-.12.043-.122.043-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.034-.143.034-.144.033-.147.032-.148.032-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.024-.161.024-.162.023-.163.023-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.01-.178.01-.179.009-.179.007-.181.006-.182.006-.182.004-.184.003-.184.001-.185.001-.185-.001-.184-.001-.184-.003-.182-.004-.182-.006-.181-.006-.179-.007-.179-.009-.178-.01-.176-.01-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.023-.162-.023-.161-.024-.159-.024-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.032-.146-.032-.145-.033-.143-.034-.141-.034-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.041-.126-.041-.124-.041-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.048-.105-.048-.102-.048-.1-.05-.097-.049-.095-.051-.093-.051-.09-.052-.087-.052-.085-.053-.083-.053-.08-.054-.077-.054v4.153zm8.74-8.179l-.257.004-.254.005-.25.008-.247.011-.244.012-.241.014-.237.016-.233.018-.231.021-.226.022-.224.023-.22.026-.216.027-.212.028-.21.031-.205.032-.202.033-.198.034-.194.036-.191.038-.187.038-.183.04-.179.041-.175.042-.172.043-.168.043-.163.045-.16.046-.155.046-.152.048-.148.048-.143.048-.139.049-.136.05-.131.05-.126.051-.123.051-.118.051-.114.052-.11.052-.106.052-.101.052-.096.052-.092.052-.088.052-.083.052-.079.052-.074.051-.07.052-.065.051-.06.05-.056.05-.051.05-.023.025-.023.024-.021.024-.02.025-.019.024-.018.024-.017.023-.015.024-.014.023-.013.023-.012.023-.01.023-.01.022-.008.022-.006.023-.006.021-.004.022-.004.021-.001.021-.001.021.001.021.001.021.004.021.004.022.006.021.006.023.008.022.01.022.01.023.012.023.013.023.014.023.015.024.017.023.018.024.019.024.02.025.021.024.023.024.023.025.051.05.056.05.06.05.065.051.07.052.074.051.079.052.083.052.088.052.092.052.096.052.101.052.106.052.11.052.114.052.118.051.123.051.126.051.131.05.136.05.139.049.143.048.148.048.152.048.155.046.16.046.163.045.168.043.172.043.175.042.179.041.183.04.187.038.191.038.194.036.198.034.202.033.205.032.21.031.212.028.216.027.22.026.224.023.226.022.231.021.233.018.237.016.241.014.244.012.247.011.25.008.254.005.257.004.26.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.022.224-.023.22-.026.216-.027.212-.028.21-.031.205-.032.202-.033.198-.034.194-.036.191-.038.187-.038.183-.04.179-.041.175-.042.172-.043.168-.043.163-.045.16-.046.155-.046.152-.048.148-.048.143-.048.139-.049.136-.05.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.05.051-.05.023-.025.023-.024.021-.024.02-.025.019-.024.018-.024.017-.023.015-.024.014-.023.013-.023.012-.023.01-.023.01-.022.008-.022.006-.023.006-.021.004-.022.004-.021.001-.021.001-.021-.001-.021-.001-.021-.004-.021-.004-.022-.006-.021-.006-.023-.008-.022-.01-.022-.01-.023-.012-.023-.013-.023-.014-.023-.015-.024-.017-.023-.018-.024-.019-.024-.02-.025-.021-.024-.023-.024-.023-.025-.051-.05-.056-.05-.06-.05-.065-.051-.07-.052-.074-.051-.079-.052-.083-.052-.088-.052-.092-.052-.096-.052-.101-.052-.106-.052-.11-.052-.114-.052-.118-.051-.123-.051-.126-.051-.131-.05-.136-.05-.139-.049-.143-.048-.148-.048-.152-.048-.155-.046-.16-.046-.163-.045-.168-.043-.172-.043-.175-.042-.179-.041-.183-.04-.187-.038-.191-.038-.194-.036-.198-.034-.202-.033-.205-.032-.21-.031-.212-.028-.216-.027-.22-.026-.224-.023-.226-.022-.231-.021-.233-.018-.237-.016-.241-.014-.244-.012-.247-.011-.25-.008-.254-.005-.257-.004-.26-.001-.26.001z"
  );
};
const insertComputerIcon = function(elem) {
  elem.append("defs").append("symbol").attr("id", "computer").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M2 2v13h20v-13h-20zm18 11h-16v-9h16v9zm-10.228 6l.466-1h3.524l.467 1h-4.457zm14.228 3h-24l2-6h2.104l-1.33 4h18.45l-1.297-4h2.073l2 6zm-5-10h-14v-7h14v7z"
  );
};
const insertClockIcon = function(elem) {
  elem.append("defs").append("symbol").attr("id", "clock").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm5.848 12.459c.202.038.202.333.001.372-1.907.361-6.045 1.111-6.547 1.111-.719 0-1.301-.582-1.301-1.301 0-.512.77-5.447 1.125-7.445.034-.192.312-.181.343.014l.985 6.238 5.394 1.011z"
  );
};
const insertArrowHead = function(elem) {
  elem.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 9).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z");
};
const insertArrowFilledHead = function(elem) {
  elem.append("defs").append("marker").attr("id", "filled-head").attr("refX", 18).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
};
const insertSequenceNumber = function(elem) {
  elem.append("defs").append("marker").attr("id", "sequencenumber").attr("refX", 15).attr("refY", 15).attr("markerWidth", 60).attr("markerHeight", 40).attr("orient", "auto").append("circle").attr("cx", 15).attr("cy", 15).attr("r", 6);
};
const insertArrowCrossHead = function(elem) {
  const defs = elem.append("defs");
  const marker = defs.append("marker").attr("id", "crosshead").attr("markerWidth", 15).attr("markerHeight", 8).attr("orient", "auto").attr("refX", 16).attr("refY", 4);
  marker.append("path").attr("fill", "black").attr("stroke", "#000000").style("stroke-dasharray", "0, 0").attr("stroke-width", "1px").attr("d", "M 9,2 V 6 L16,4 Z");
  marker.append("path").attr("fill", "none").attr("stroke", "#000000").style("stroke-dasharray", "0, 0").attr("stroke-width", "1px").attr("d", "M 0,1 L 6,7 M 6,1 L 0,7");
};
const getTextObj$1 = function() {
  return {
    x: 0,
    y: 0,
    fill: void 0,
    anchor: void 0,
    style: "#666",
    width: void 0,
    height: void 0,
    textMargin: 0,
    rx: 0,
    ry: 0,
    tspan: true,
    valign: void 0
  };
};
const getNoteRect$1 = function() {
  return {
    x: 0,
    y: 0,
    fill: "#EDF2AE",
    stroke: "#666",
    width: 100,
    anchor: "start",
    height: 100,
    rx: 0,
    ry: 0
  };
};
const _drawTextCandidateFunc$1 = function() {
  function byText(content2, g2, x2, y2, width2, height2, textAttrs) {
    const text2 = g2.append("text").attr("x", x2 + width2 / 2).attr("y", y2 + height2 / 2 + 5).style("text-anchor", "middle").text(content2);
    _setTextAttrs(text2, textAttrs);
  }
  function byTspan(content2, g2, x2, y2, width2, height2, textAttrs, conf2) {
    const { actorFontSize, actorFontFamily, actorFontWeight } = conf2;
    let _actorFontSize = actorFontSize && actorFontSize.replace ? actorFontSize.replace("px", "") : actorFontSize;
    const lines = content2.split(common.lineBreakRegex);
    for (let i = 0; i < lines.length; i++) {
      const dy = i * _actorFontSize - _actorFontSize * (lines.length - 1) / 2;
      const text2 = g2.append("text").attr("x", x2 + width2 / 2).attr("y", y2).style("text-anchor", "middle").style("font-size", actorFontSize).style("font-weight", actorFontWeight).style("font-family", actorFontFamily);
      text2.append("tspan").attr("x", x2 + width2 / 2).attr("dy", dy).text(lines[i]);
      text2.attr("y", y2 + height2 / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central");
      _setTextAttrs(text2, textAttrs);
    }
  }
  function byFo(content2, g2, x2, y2, width2, height2, textAttrs, conf2) {
    const s2 = g2.append("switch");
    const f2 = s2.append("foreignObject").attr("x", x2).attr("y", y2).attr("width", width2).attr("height", height2);
    const text2 = f2.append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    text2.append("div").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(content2);
    byTspan(content2, s2, x2, y2, width2, height2, textAttrs, conf2);
    _setTextAttrs(text2, textAttrs);
  }
  function _setTextAttrs(toText, fromTextAttrsDict) {
    for (const key in fromTextAttrsDict) {
      if (fromTextAttrsDict.hasOwnProperty(key)) {
        toText.attr(key, fromTextAttrsDict[key]);
      }
    }
  }
  return function(conf2) {
    return conf2.textPlacement === "fo" ? byFo : conf2.textPlacement === "old" ? byText : byTspan;
  };
}();
const _drawMenuItemTextCandidateFunc = function() {
  function byText(content2, g2, x2, y2, width2, height2, textAttrs) {
    const text2 = g2.append("text").attr("x", x2).attr("y", y2).style("text-anchor", "start").text(content2);
    _setTextAttrs(text2, textAttrs);
  }
  function byTspan(content2, g2, x2, y2, width2, height2, textAttrs, conf2) {
    const { actorFontSize, actorFontFamily, actorFontWeight } = conf2;
    const lines = content2.split(common.lineBreakRegex);
    for (let i = 0; i < lines.length; i++) {
      const dy = i * actorFontSize - actorFontSize * (lines.length - 1) / 2;
      const text2 = g2.append("text").attr("x", x2).attr("y", y2).style("text-anchor", "start").style("font-size", actorFontSize).style("font-weight", actorFontWeight).style("font-family", actorFontFamily);
      text2.append("tspan").attr("x", x2).attr("dy", dy).text(lines[i]);
      text2.attr("y", y2 + height2 / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central");
      _setTextAttrs(text2, textAttrs);
    }
  }
  function byFo(content2, g2, x2, y2, width2, height2, textAttrs, conf2) {
    const s2 = g2.append("switch");
    const f2 = s2.append("foreignObject").attr("x", x2).attr("y", y2).attr("width", width2).attr("height", height2);
    const text2 = f2.append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    text2.append("div").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(content2);
    byTspan(content2, s2, x2, y2, width2, height2, textAttrs, conf2);
    _setTextAttrs(text2, textAttrs);
  }
  function _setTextAttrs(toText, fromTextAttrsDict) {
    for (const key in fromTextAttrsDict) {
      if (fromTextAttrsDict.hasOwnProperty(key)) {
        toText.attr(key, fromTextAttrsDict[key]);
      }
    }
  }
  return function(conf2) {
    return conf2.textPlacement === "fo" ? byFo : conf2.textPlacement === "old" ? byText : byTspan;
  };
}();
const svgDraw$1 = {
  drawRect: drawRect$1,
  drawText: drawText$1,
  drawLabel: drawLabel$1,
  drawActor,
  drawPopup,
  drawImage,
  drawEmbeddedImage,
  anchorElement,
  drawActivation,
  drawLoop,
  drawBackgroundRect: drawBackgroundRect$1,
  insertArrowHead,
  insertArrowFilledHead,
  insertSequenceNumber,
  insertArrowCrossHead,
  insertDatabaseIcon,
  insertComputerIcon,
  insertClockIcon,
  getTextObj: getTextObj$1,
  getNoteRect: getNoteRect$1,
  popupMenu,
  popdownMenu,
  fixLifeLineHeights,
  sanitizeUrl: sanitizeUrl_1
};
let conf$4 = {};
const bounds$1 = {
  data: {
    startx: void 0,
    stopx: void 0,
    starty: void 0,
    stopy: void 0
  },
  verticalPos: 0,
  sequenceItems: [],
  activations: [],
  models: {
    getHeight: function() {
      return Math.max.apply(
        null,
        this.actors.length === 0 ? [0] : this.actors.map((actor) => actor.height || 0)
      ) + (this.loops.length === 0 ? 0 : this.loops.map((it) => it.height || 0).reduce((acc, h2) => acc + h2)) + (this.messages.length === 0 ? 0 : this.messages.map((it) => it.height || 0).reduce((acc, h2) => acc + h2)) + (this.notes.length === 0 ? 0 : this.notes.map((it) => it.height || 0).reduce((acc, h2) => acc + h2));
    },
    clear: function() {
      this.actors = [];
      this.loops = [];
      this.messages = [];
      this.notes = [];
    },
    addActor: function(actorModel) {
      this.actors.push(actorModel);
    },
    addLoop: function(loopModel) {
      this.loops.push(loopModel);
    },
    addMessage: function(msgModel) {
      this.messages.push(msgModel);
    },
    addNote: function(noteModel) {
      this.notes.push(noteModel);
    },
    lastActor: function() {
      return this.actors[this.actors.length - 1];
    },
    lastLoop: function() {
      return this.loops[this.loops.length - 1];
    },
    lastMessage: function() {
      return this.messages[this.messages.length - 1];
    },
    lastNote: function() {
      return this.notes[this.notes.length - 1];
    },
    actors: [],
    loops: [],
    messages: [],
    notes: []
  },
  init: function() {
    this.sequenceItems = [];
    this.activations = [];
    this.models.clear();
    this.data = {
      startx: void 0,
      stopx: void 0,
      starty: void 0,
      stopy: void 0
    };
    this.verticalPos = 0;
    setConf$4(getConfig$1());
  },
  updateVal: function(obj, key, val, fun) {
    if (typeof obj[key] === "undefined") {
      obj[key] = val;
    } else {
      obj[key] = fun(val, obj[key]);
    }
  },
  updateBounds: function(startx, starty, stopx, stopy) {
    const _self = this;
    let cnt2 = 0;
    function updateFn(type2) {
      return function updateItemBounds(item) {
        cnt2++;
        const n = _self.sequenceItems.length - cnt2 + 1;
        _self.updateVal(item, "starty", starty - n * conf$4.boxMargin, Math.min);
        _self.updateVal(item, "stopy", stopy + n * conf$4.boxMargin, Math.max);
        _self.updateVal(bounds$1.data, "startx", startx - n * conf$4.boxMargin, Math.min);
        _self.updateVal(bounds$1.data, "stopx", stopx + n * conf$4.boxMargin, Math.max);
        if (!(type2 === "activation")) {
          _self.updateVal(item, "startx", startx - n * conf$4.boxMargin, Math.min);
          _self.updateVal(item, "stopx", stopx + n * conf$4.boxMargin, Math.max);
          _self.updateVal(bounds$1.data, "starty", starty - n * conf$4.boxMargin, Math.min);
          _self.updateVal(bounds$1.data, "stopy", stopy + n * conf$4.boxMargin, Math.max);
        }
      };
    }
    this.sequenceItems.forEach(updateFn());
    this.activations.forEach(updateFn("activation"));
  },
  insert: function(startx, starty, stopx, stopy) {
    const _startx = Math.min(startx, stopx);
    const _stopx = Math.max(startx, stopx);
    const _starty = Math.min(starty, stopy);
    const _stopy = Math.max(starty, stopy);
    this.updateVal(bounds$1.data, "startx", _startx, Math.min);
    this.updateVal(bounds$1.data, "starty", _starty, Math.min);
    this.updateVal(bounds$1.data, "stopx", _stopx, Math.max);
    this.updateVal(bounds$1.data, "stopy", _stopy, Math.max);
    this.updateBounds(_startx, _starty, _stopx, _stopy);
  },
  newActivation: function(message2, diagram, actors2) {
    const actorRect = actors2[message2.from.actor];
    const stackedSize = actorActivations(message2.from.actor).length || 0;
    const x2 = actorRect.x + actorRect.width / 2 + (stackedSize - 1) * conf$4.activationWidth / 2;
    this.activations.push({
      startx: x2,
      starty: this.verticalPos + 2,
      stopx: x2 + conf$4.activationWidth,
      stopy: void 0,
      actor: message2.from.actor,
      anchored: svgDraw$1.anchorElement(diagram)
    });
  },
  endActivation: function(message2) {
    const lastActorActivationIdx = this.activations.map(function(activation) {
      return activation.actor;
    }).lastIndexOf(message2.from.actor);
    return this.activations.splice(lastActorActivationIdx, 1)[0];
  },
  createLoop: function(title2 = { message: void 0, wrap: false, width: void 0 }, fill) {
    return {
      startx: void 0,
      starty: this.verticalPos,
      stopx: void 0,
      stopy: void 0,
      title: title2.message,
      wrap: title2.wrap,
      width: title2.width,
      height: 0,
      fill
    };
  },
  newLoop: function(title2 = { message: void 0, wrap: false, width: void 0 }, fill) {
    this.sequenceItems.push(this.createLoop(title2, fill));
  },
  endLoop: function() {
    return this.sequenceItems.pop();
  },
  addSectionToLoop: function(message2) {
    const loop = this.sequenceItems.pop();
    loop.sections = loop.sections || [];
    loop.sectionTitles = loop.sectionTitles || [];
    loop.sections.push({ y: bounds$1.getVerticalPos(), height: 0 });
    loop.sectionTitles.push(message2);
    this.sequenceItems.push(loop);
  },
  bumpVerticalPos: function(bump) {
    this.verticalPos = this.verticalPos + bump;
    this.data.stopy = this.verticalPos;
  },
  getVerticalPos: function() {
    return this.verticalPos;
  },
  getBounds: function() {
    return { bounds: this.data, models: this.models };
  }
};
const drawNote$1 = function(elem, noteModel) {
  bounds$1.bumpVerticalPos(conf$4.boxMargin);
  noteModel.height = conf$4.boxMargin;
  noteModel.starty = bounds$1.getVerticalPos();
  const rect2 = svgDraw$1.getNoteRect();
  rect2.x = noteModel.startx;
  rect2.y = noteModel.starty;
  rect2.width = noteModel.width || conf$4.width;
  rect2.class = "note";
  const g2 = elem.append("g");
  const rectElem = svgDraw$1.drawRect(g2, rect2);
  const textObj = svgDraw$1.getTextObj();
  textObj.x = noteModel.startx;
  textObj.y = noteModel.starty;
  textObj.width = rect2.width;
  textObj.dy = "1em";
  textObj.text = noteModel.message;
  textObj.class = "noteText";
  textObj.fontFamily = conf$4.noteFontFamily;
  textObj.fontSize = conf$4.noteFontSize;
  textObj.fontWeight = conf$4.noteFontWeight;
  textObj.anchor = conf$4.noteAlign;
  textObj.textMargin = conf$4.noteMargin;
  textObj.valign = "center";
  const textElem = drawText$1(g2, textObj);
  const textHeight = Math.round(
    textElem.map((te) => (te._groups || te)[0][0].getBBox().height).reduce((acc, curr) => acc + curr)
  );
  rectElem.attr("height", textHeight + 2 * conf$4.noteMargin);
  noteModel.height += textHeight + 2 * conf$4.noteMargin;
  bounds$1.bumpVerticalPos(textHeight + 2 * conf$4.noteMargin);
  noteModel.stopy = noteModel.starty + textHeight + 2 * conf$4.noteMargin;
  noteModel.stopx = noteModel.startx + rect2.width;
  bounds$1.insert(noteModel.startx, noteModel.starty, noteModel.stopx, noteModel.stopy);
  bounds$1.models.addNote(noteModel);
};
const messageFont = (cnf) => {
  return {
    fontFamily: cnf.messageFontFamily,
    fontSize: cnf.messageFontSize,
    fontWeight: cnf.messageFontWeight
  };
};
const noteFont = (cnf) => {
  return {
    fontFamily: cnf.noteFontFamily,
    fontSize: cnf.noteFontSize,
    fontWeight: cnf.noteFontWeight
  };
};
const actorFont = (cnf) => {
  return {
    fontFamily: cnf.actorFontFamily,
    fontSize: cnf.actorFontSize,
    fontWeight: cnf.actorFontWeight
  };
};
const boundMessage = function(diagram, msgModel) {
  bounds$1.bumpVerticalPos(10);
  const { startx, stopx, message: message2 } = msgModel;
  const lines = common.splitBreaks(message2).length;
  const textDims = utils.calculateTextDimensions(message2, messageFont(conf$4));
  const lineHeight = textDims.height / lines;
  msgModel.height += lineHeight;
  bounds$1.bumpVerticalPos(lineHeight);
  let lineStarty;
  let totalOffset = textDims.height - 10;
  const textWidth = textDims.width;
  if (startx === stopx) {
    lineStarty = bounds$1.getVerticalPos() + totalOffset;
    if (!conf$4.rightAngles) {
      totalOffset += conf$4.boxMargin;
      lineStarty = bounds$1.getVerticalPos() + totalOffset;
    }
    totalOffset += 30;
    const dx = Math.max(textWidth / 2, conf$4.width / 2);
    bounds$1.insert(
      startx - dx,
      bounds$1.getVerticalPos() - 10 + totalOffset,
      stopx + dx,
      bounds$1.getVerticalPos() + 30 + totalOffset
    );
  } else {
    totalOffset += conf$4.boxMargin;
    lineStarty = bounds$1.getVerticalPos() + totalOffset;
    bounds$1.insert(startx, lineStarty - 10, stopx, lineStarty);
  }
  bounds$1.bumpVerticalPos(totalOffset);
  msgModel.height += totalOffset;
  msgModel.stopy = msgModel.starty + msgModel.height;
  bounds$1.insert(msgModel.fromBounds, msgModel.starty, msgModel.toBounds, msgModel.stopy);
  return lineStarty;
};
const drawMessage = function(diagram, msgModel, lineStarty, diagObj) {
  const { startx, stopx, starty, message: message2, type: type2, sequenceIndex, sequenceVisible } = msgModel;
  const textDims = utils.calculateTextDimensions(message2, messageFont(conf$4));
  const textObj = svgDraw$1.getTextObj();
  textObj.x = startx;
  textObj.y = starty + 10;
  textObj.width = stopx - startx;
  textObj.class = "messageText";
  textObj.dy = "1em";
  textObj.text = message2;
  textObj.fontFamily = conf$4.messageFontFamily;
  textObj.fontSize = conf$4.messageFontSize;
  textObj.fontWeight = conf$4.messageFontWeight;
  textObj.anchor = conf$4.messageAlign;
  textObj.valign = "center";
  textObj.textMargin = conf$4.wrapPadding;
  textObj.tspan = false;
  drawText$1(diagram, textObj);
  const textWidth = textDims.width;
  let line2;
  if (startx === stopx) {
    if (conf$4.rightAngles) {
      line2 = diagram.append("path").attr(
        "d",
        `M  ${startx},${lineStarty} H ${startx + Math.max(conf$4.width / 2, textWidth / 2)} V ${lineStarty + 25} H ${startx}`
      );
    } else {
      line2 = diagram.append("path").attr(
        "d",
        "M " + startx + "," + lineStarty + " C " + (startx + 60) + "," + (lineStarty - 10) + " " + (startx + 60) + "," + (lineStarty + 30) + " " + startx + "," + (lineStarty + 20)
      );
    }
  } else {
    line2 = diagram.append("line");
    line2.attr("x1", startx);
    line2.attr("y1", lineStarty);
    line2.attr("x2", stopx);
    line2.attr("y2", lineStarty);
  }
  if (type2 === diagObj.db.LINETYPE.DOTTED || type2 === diagObj.db.LINETYPE.DOTTED_CROSS || type2 === diagObj.db.LINETYPE.DOTTED_POINT || type2 === diagObj.db.LINETYPE.DOTTED_OPEN) {
    line2.style("stroke-dasharray", "3, 3");
    line2.attr("class", "messageLine1");
  } else {
    line2.attr("class", "messageLine0");
  }
  let url = "";
  if (conf$4.arrowMarkerAbsolute) {
    url = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search;
    url = url.replace(/\(/g, "\\(");
    url = url.replace(/\)/g, "\\)");
  }
  line2.attr("stroke-width", 2);
  line2.attr("stroke", "none");
  line2.style("fill", "none");
  if (type2 === diagObj.db.LINETYPE.SOLID || type2 === diagObj.db.LINETYPE.DOTTED) {
    line2.attr("marker-end", "url(" + url + "#arrowhead)");
  }
  if (type2 === diagObj.db.LINETYPE.SOLID_POINT || type2 === diagObj.db.LINETYPE.DOTTED_POINT) {
    line2.attr("marker-end", "url(" + url + "#filled-head)");
  }
  if (type2 === diagObj.db.LINETYPE.SOLID_CROSS || type2 === diagObj.db.LINETYPE.DOTTED_CROSS) {
    line2.attr("marker-end", "url(" + url + "#crosshead)");
  }
  if (sequenceVisible || conf$4.showSequenceNumbers) {
    line2.attr("marker-start", "url(" + url + "#sequencenumber)");
    diagram.append("text").attr("x", startx).attr("y", lineStarty + 4).attr("font-family", "sans-serif").attr("font-size", "12px").attr("text-anchor", "middle").attr("class", "sequenceNumber").text(sequenceIndex);
  }
};
const drawActors = function(diagram, actors2, actorKeys, verticalPos, configuration, messages2) {
  if (configuration.hideUnusedParticipants === true) {
    const newActors = /* @__PURE__ */ new Set();
    messages2.forEach((message2) => {
      newActors.add(message2.from);
      newActors.add(message2.to);
    });
    actorKeys = actorKeys.filter((actorKey) => newActors.has(actorKey));
  }
  let prevWidth = 0;
  let prevMargin = 0;
  let maxHeight = 0;
  for (let i = 0; i < actorKeys.length; i++) {
    const actor = actors2[actorKeys[i]];
    actor.width = actor.width || conf$4.width;
    actor.height = Math.max(actor.height || conf$4.height, conf$4.height);
    actor.margin = actor.margin || conf$4.actorMargin;
    actor.x = prevWidth + prevMargin;
    actor.y = verticalPos;
    const height2 = svgDraw$1.drawActor(diagram, actor, conf$4);
    maxHeight = Math.max(maxHeight, height2);
    bounds$1.insert(actor.x, verticalPos, actor.x + actor.width, actor.height);
    prevWidth += actor.width;
    prevMargin += actor.margin;
    bounds$1.models.addActor(actor);
  }
  bounds$1.bumpVerticalPos(maxHeight);
};
const drawActorsPopup = function(diagram, actors2, actorKeys, doc2) {
  let maxHeight = 0;
  let maxWidth = 0;
  for (let i = 0; i < actorKeys.length; i++) {
    const actor = actors2[actorKeys[i]];
    const minMenuWidth = getRequiredPopupWidth(actor);
    const menuDimensions = svgDraw$1.drawPopup(
      diagram,
      actor,
      minMenuWidth,
      conf$4,
      conf$4.forceMenus,
      doc2
    );
    if (menuDimensions.height > maxHeight) {
      maxHeight = menuDimensions.height;
    }
    if (menuDimensions.width + actor.x > maxWidth) {
      maxWidth = menuDimensions.width + actor.x;
    }
  }
  return { maxHeight, maxWidth };
};
const setConf$4 = function(cnf) {
  assignWithDepth(conf$4, cnf);
  if (cnf.fontFamily) {
    conf$4.actorFontFamily = conf$4.noteFontFamily = conf$4.messageFontFamily = cnf.fontFamily;
  }
  if (cnf.fontSize) {
    conf$4.actorFontSize = conf$4.noteFontSize = conf$4.messageFontSize = cnf.fontSize;
  }
  if (cnf.fontWeight) {
    conf$4.actorFontWeight = conf$4.noteFontWeight = conf$4.messageFontWeight = cnf.fontWeight;
  }
};
const actorActivations = function(actor) {
  return bounds$1.activations.filter(function(activation) {
    return activation.actor === actor;
  });
};
const activationBounds = function(actor, actors2) {
  const actorObj = actors2[actor];
  const activations = actorActivations(actor);
  const left2 = activations.reduce(function(acc, activation) {
    return Math.min(acc, activation.startx);
  }, actorObj.x + actorObj.width / 2);
  const right2 = activations.reduce(function(acc, activation) {
    return Math.max(acc, activation.stopx);
  }, actorObj.x + actorObj.width / 2);
  return [left2, right2];
};
function adjustLoopHeightForWrap(loopWidths, msg, preMargin, postMargin, addLoopFn) {
  bounds$1.bumpVerticalPos(preMargin);
  let heightAdjust = postMargin;
  if (msg.id && msg.message && loopWidths[msg.id]) {
    const loopWidth = loopWidths[msg.id].width;
    const textConf = messageFont(conf$4);
    msg.message = utils.wrapLabel(`[${msg.message}]`, loopWidth - 2 * conf$4.wrapPadding, textConf);
    msg.width = loopWidth;
    msg.wrap = true;
    const textDims = utils.calculateTextDimensions(msg.message, textConf);
    const totalOffset = Math.max(textDims.height, conf$4.labelBoxHeight);
    heightAdjust = postMargin + totalOffset;
    log$1.debug(`${totalOffset} - ${msg.message}`);
  }
  addLoopFn(msg);
  bounds$1.bumpVerticalPos(heightAdjust);
}
const draw$4 = function(_text, id2, _version, diagObj) {
  const { securityLevel, sequence: sequence2 } = getConfig$1();
  conf$4 = sequence2;
  let sandboxElement;
  if (securityLevel === "sandbox") {
    sandboxElement = select$1("#i" + id2);
  }
  const root2 = securityLevel === "sandbox" ? select$1(sandboxElement.nodes()[0].contentDocument.body) : select$1("body");
  const doc2 = securityLevel === "sandbox" ? sandboxElement.nodes()[0].contentDocument : document;
  bounds$1.init();
  log$1.debug(diagObj.db);
  const diagram = securityLevel === "sandbox" ? root2.select(`[id="${id2}"]`) : select$1(`[id="${id2}"]`);
  const actors2 = diagObj.db.getActors();
  const actorKeys = diagObj.db.getActorKeys();
  const messages2 = diagObj.db.getMessages();
  const title2 = diagObj.db.getDiagramTitle();
  const maxMessageWidthPerActor = getMaxMessageWidthPerActor(actors2, messages2, diagObj);
  conf$4.height = calculateActorMargins(actors2, maxMessageWidthPerActor);
  svgDraw$1.insertComputerIcon(diagram);
  svgDraw$1.insertDatabaseIcon(diagram);
  svgDraw$1.insertClockIcon(diagram);
  drawActors(diagram, actors2, actorKeys, 0, conf$4, messages2);
  const loopWidths = calculateLoopBounds(messages2, actors2, maxMessageWidthPerActor, diagObj);
  svgDraw$1.insertArrowHead(diagram);
  svgDraw$1.insertArrowCrossHead(diagram);
  svgDraw$1.insertArrowFilledHead(diagram);
  svgDraw$1.insertSequenceNumber(diagram);
  function activeEnd(msg, verticalPos) {
    const activationData = bounds$1.endActivation(msg);
    if (activationData.starty + 18 > verticalPos) {
      activationData.starty = verticalPos - 6;
      verticalPos += 12;
    }
    svgDraw$1.drawActivation(
      diagram,
      activationData,
      verticalPos,
      conf$4,
      actorActivations(msg.from.actor).length
    );
    bounds$1.insert(activationData.startx, verticalPos - 10, activationData.stopx, verticalPos);
  }
  let sequenceIndex = 1;
  let sequenceIndexStep = 1;
  const messagesToDraw = [];
  messages2.forEach(function(msg) {
    let loopModel, noteModel, msgModel;
    switch (msg.type) {
      case diagObj.db.LINETYPE.NOTE:
        noteModel = msg.noteModel;
        drawNote$1(diagram, noteModel);
        break;
      case diagObj.db.LINETYPE.ACTIVE_START:
        bounds$1.newActivation(msg, diagram, actors2);
        break;
      case diagObj.db.LINETYPE.ACTIVE_END:
        activeEnd(msg, bounds$1.getVerticalPos());
        break;
      case diagObj.db.LINETYPE.LOOP_START:
        adjustLoopHeightForWrap(
          loopWidths,
          msg,
          conf$4.boxMargin,
          conf$4.boxMargin + conf$4.boxTextMargin,
          (message2) => bounds$1.newLoop(message2)
        );
        break;
      case diagObj.db.LINETYPE.LOOP_END:
        loopModel = bounds$1.endLoop();
        svgDraw$1.drawLoop(diagram, loopModel, "loop", conf$4);
        bounds$1.bumpVerticalPos(loopModel.stopy - bounds$1.getVerticalPos());
        bounds$1.models.addLoop(loopModel);
        break;
      case diagObj.db.LINETYPE.RECT_START:
        adjustLoopHeightForWrap(
          loopWidths,
          msg,
          conf$4.boxMargin,
          conf$4.boxMargin,
          (message2) => bounds$1.newLoop(void 0, message2.message)
        );
        break;
      case diagObj.db.LINETYPE.RECT_END:
        loopModel = bounds$1.endLoop();
        svgDraw$1.drawBackgroundRect(diagram, loopModel);
        bounds$1.models.addLoop(loopModel);
        bounds$1.bumpVerticalPos(loopModel.stopy - bounds$1.getVerticalPos());
        break;
      case diagObj.db.LINETYPE.OPT_START:
        adjustLoopHeightForWrap(
          loopWidths,
          msg,
          conf$4.boxMargin,
          conf$4.boxMargin + conf$4.boxTextMargin,
          (message2) => bounds$1.newLoop(message2)
        );
        break;
      case diagObj.db.LINETYPE.OPT_END:
        loopModel = bounds$1.endLoop();
        svgDraw$1.drawLoop(diagram, loopModel, "opt", conf$4);
        bounds$1.bumpVerticalPos(loopModel.stopy - bounds$1.getVerticalPos());
        bounds$1.models.addLoop(loopModel);
        break;
      case diagObj.db.LINETYPE.ALT_START:
        adjustLoopHeightForWrap(
          loopWidths,
          msg,
          conf$4.boxMargin,
          conf$4.boxMargin + conf$4.boxTextMargin,
          (message2) => bounds$1.newLoop(message2)
        );
        break;
      case diagObj.db.LINETYPE.ALT_ELSE:
        adjustLoopHeightForWrap(
          loopWidths,
          msg,
          conf$4.boxMargin + conf$4.boxTextMargin,
          conf$4.boxMargin,
          (message2) => bounds$1.addSectionToLoop(message2)
        );
        break;
      case diagObj.db.LINETYPE.ALT_END:
        loopModel = bounds$1.endLoop();
        svgDraw$1.drawLoop(diagram, loopModel, "alt", conf$4);
        bounds$1.bumpVerticalPos(loopModel.stopy - bounds$1.getVerticalPos());
        bounds$1.models.addLoop(loopModel);
        break;
      case diagObj.db.LINETYPE.PAR_START:
        adjustLoopHeightForWrap(
          loopWidths,
          msg,
          conf$4.boxMargin,
          conf$4.boxMargin + conf$4.boxTextMargin,
          (message2) => bounds$1.newLoop(message2)
        );
        break;
      case diagObj.db.LINETYPE.PAR_AND:
        adjustLoopHeightForWrap(
          loopWidths,
          msg,
          conf$4.boxMargin + conf$4.boxTextMargin,
          conf$4.boxMargin,
          (message2) => bounds$1.addSectionToLoop(message2)
        );
        break;
      case diagObj.db.LINETYPE.PAR_END:
        loopModel = bounds$1.endLoop();
        svgDraw$1.drawLoop(diagram, loopModel, "par", conf$4);
        bounds$1.bumpVerticalPos(loopModel.stopy - bounds$1.getVerticalPos());
        bounds$1.models.addLoop(loopModel);
        break;
      case diagObj.db.LINETYPE.AUTONUMBER:
        sequenceIndex = msg.message.start || sequenceIndex;
        sequenceIndexStep = msg.message.step || sequenceIndexStep;
        if (msg.message.visible)
          diagObj.db.enableSequenceNumbers();
        else
          diagObj.db.disableSequenceNumbers();
        break;
      case diagObj.db.LINETYPE.CRITICAL_START:
        adjustLoopHeightForWrap(
          loopWidths,
          msg,
          conf$4.boxMargin,
          conf$4.boxMargin + conf$4.boxTextMargin,
          (message2) => bounds$1.newLoop(message2)
        );
        break;
      case diagObj.db.LINETYPE.CRITICAL_OPTION:
        adjustLoopHeightForWrap(
          loopWidths,
          msg,
          conf$4.boxMargin + conf$4.boxTextMargin,
          conf$4.boxMargin,
          (message2) => bounds$1.addSectionToLoop(message2)
        );
        break;
      case diagObj.db.LINETYPE.CRITICAL_END:
        loopModel = bounds$1.endLoop();
        svgDraw$1.drawLoop(diagram, loopModel, "critical", conf$4);
        bounds$1.bumpVerticalPos(loopModel.stopy - bounds$1.getVerticalPos());
        bounds$1.models.addLoop(loopModel);
        break;
      case diagObj.db.LINETYPE.BREAK_START:
        adjustLoopHeightForWrap(
          loopWidths,
          msg,
          conf$4.boxMargin,
          conf$4.boxMargin + conf$4.boxTextMargin,
          (message2) => bounds$1.newLoop(message2)
        );
        break;
      case diagObj.db.LINETYPE.BREAK_END:
        loopModel = bounds$1.endLoop();
        svgDraw$1.drawLoop(diagram, loopModel, "break", conf$4);
        bounds$1.bumpVerticalPos(loopModel.stopy - bounds$1.getVerticalPos());
        bounds$1.models.addLoop(loopModel);
        break;
      default:
        try {
          msgModel = msg.msgModel;
          msgModel.starty = bounds$1.getVerticalPos();
          msgModel.sequenceIndex = sequenceIndex;
          msgModel.sequenceVisible = diagObj.db.showSequenceNumbers();
          const lineStarty = boundMessage(diagram, msgModel);
          messagesToDraw.push({ messageModel: msgModel, lineStarty });
          bounds$1.models.addMessage(msgModel);
        } catch (e) {
          log$1.error("error while drawing message", e);
        }
    }
    if ([
      diagObj.db.LINETYPE.SOLID_OPEN,
      diagObj.db.LINETYPE.DOTTED_OPEN,
      diagObj.db.LINETYPE.SOLID,
      diagObj.db.LINETYPE.DOTTED,
      diagObj.db.LINETYPE.SOLID_CROSS,
      diagObj.db.LINETYPE.DOTTED_CROSS,
      diagObj.db.LINETYPE.SOLID_POINT,
      diagObj.db.LINETYPE.DOTTED_POINT
    ].includes(msg.type)) {
      sequenceIndex = sequenceIndex + sequenceIndexStep;
    }
  });
  messagesToDraw.forEach((e) => drawMessage(diagram, e.messageModel, e.lineStarty, diagObj));
  if (conf$4.mirrorActors) {
    bounds$1.bumpVerticalPos(conf$4.boxMargin * 2);
    drawActors(diagram, actors2, actorKeys, bounds$1.getVerticalPos(), conf$4, messages2);
    bounds$1.bumpVerticalPos(conf$4.boxMargin);
    fixLifeLineHeights(diagram, bounds$1.getVerticalPos());
  }
  const requiredBoxSize = drawActorsPopup(diagram, actors2, actorKeys, doc2);
  const { bounds: box } = bounds$1.getBounds();
  log$1.debug("For line height fix Querying: #" + id2 + " .actor-line");
  const actorLines = selectAll$1("#" + id2 + " .actor-line");
  actorLines.attr("y2", box.stopy);
  let boxHeight = box.stopy - box.starty;
  if (boxHeight < requiredBoxSize.maxHeight) {
    boxHeight = requiredBoxSize.maxHeight;
  }
  let height2 = boxHeight + 2 * conf$4.diagramMarginY;
  if (conf$4.mirrorActors) {
    height2 = height2 - conf$4.boxMargin + conf$4.bottomMarginAdj;
  }
  let boxWidth = box.stopx - box.startx;
  if (boxWidth < requiredBoxSize.maxWidth) {
    boxWidth = requiredBoxSize.maxWidth;
  }
  const width2 = boxWidth + 2 * conf$4.diagramMarginX;
  if (title2) {
    diagram.append("text").text(title2).attr("x", (box.stopx - box.startx) / 2 - 2 * conf$4.diagramMarginX).attr("y", -25);
  }
  configureSvgSize(diagram, height2, width2, conf$4.useMaxWidth);
  const extraVertForTitle = title2 ? 40 : 0;
  diagram.attr(
    "viewBox",
    box.startx - conf$4.diagramMarginX + " -" + (conf$4.diagramMarginY + extraVertForTitle) + " " + width2 + " " + (height2 + extraVertForTitle)
  );
  addSVGAccessibilityFields(diagObj.db, diagram, id2);
  log$1.debug(`models:`, bounds$1.models);
};
const getMaxMessageWidthPerActor = function(actors2, messages2, diagObj) {
  const maxMessageWidthPerActor = {};
  messages2.forEach(function(msg) {
    if (actors2[msg.to] && actors2[msg.from]) {
      const actor = actors2[msg.to];
      if (msg.placement === diagObj.db.PLACEMENT.LEFTOF && !actor.prevActor) {
        return;
      }
      if (msg.placement === diagObj.db.PLACEMENT.RIGHTOF && !actor.nextActor) {
        return;
      }
      const isNote = msg.placement !== void 0;
      const isMessage = !isNote;
      const textFont = isNote ? noteFont(conf$4) : messageFont(conf$4);
      const wrappedMessage = msg.wrap ? utils.wrapLabel(msg.message, conf$4.width - 2 * conf$4.wrapPadding, textFont) : msg.message;
      const messageDimensions = utils.calculateTextDimensions(wrappedMessage, textFont);
      const messageWidth = messageDimensions.width + 2 * conf$4.wrapPadding;
      if (isMessage && msg.from === actor.nextActor) {
        maxMessageWidthPerActor[msg.to] = Math.max(
          maxMessageWidthPerActor[msg.to] || 0,
          messageWidth
        );
      } else if (isMessage && msg.from === actor.prevActor) {
        maxMessageWidthPerActor[msg.from] = Math.max(
          maxMessageWidthPerActor[msg.from] || 0,
          messageWidth
        );
      } else if (isMessage && msg.from === msg.to) {
        maxMessageWidthPerActor[msg.from] = Math.max(
          maxMessageWidthPerActor[msg.from] || 0,
          messageWidth / 2
        );
        maxMessageWidthPerActor[msg.to] = Math.max(
          maxMessageWidthPerActor[msg.to] || 0,
          messageWidth / 2
        );
      } else if (msg.placement === diagObj.db.PLACEMENT.RIGHTOF) {
        maxMessageWidthPerActor[msg.from] = Math.max(
          maxMessageWidthPerActor[msg.from] || 0,
          messageWidth
        );
      } else if (msg.placement === diagObj.db.PLACEMENT.LEFTOF) {
        maxMessageWidthPerActor[actor.prevActor] = Math.max(
          maxMessageWidthPerActor[actor.prevActor] || 0,
          messageWidth
        );
      } else if (msg.placement === diagObj.db.PLACEMENT.OVER) {
        if (actor.prevActor) {
          maxMessageWidthPerActor[actor.prevActor] = Math.max(
            maxMessageWidthPerActor[actor.prevActor] || 0,
            messageWidth / 2
          );
        }
        if (actor.nextActor) {
          maxMessageWidthPerActor[msg.from] = Math.max(
            maxMessageWidthPerActor[msg.from] || 0,
            messageWidth / 2
          );
        }
      }
    }
  });
  log$1.debug("maxMessageWidthPerActor:", maxMessageWidthPerActor);
  return maxMessageWidthPerActor;
};
const getRequiredPopupWidth = function(actor) {
  let requiredPopupWidth = 0;
  const textFont = actorFont(conf$4);
  for (const key in actor.links) {
    const labelDimensions = utils.calculateTextDimensions(key, textFont);
    const labelWidth = labelDimensions.width + 2 * conf$4.wrapPadding + 2 * conf$4.boxMargin;
    if (requiredPopupWidth < labelWidth) {
      requiredPopupWidth = labelWidth;
    }
  }
  return requiredPopupWidth;
};
const calculateActorMargins = function(actors2, actorToMessageWidth) {
  let maxHeight = 0;
  Object.keys(actors2).forEach((prop) => {
    const actor = actors2[prop];
    if (actor.wrap) {
      actor.description = utils.wrapLabel(
        actor.description,
        conf$4.width - 2 * conf$4.wrapPadding,
        actorFont(conf$4)
      );
    }
    const actDims = utils.calculateTextDimensions(actor.description, actorFont(conf$4));
    actor.width = actor.wrap ? conf$4.width : Math.max(conf$4.width, actDims.width + 2 * conf$4.wrapPadding);
    actor.height = actor.wrap ? Math.max(actDims.height, conf$4.height) : conf$4.height;
    maxHeight = Math.max(maxHeight, actor.height);
  });
  for (const actorKey in actorToMessageWidth) {
    const actor = actors2[actorKey];
    if (!actor) {
      continue;
    }
    const nextActor = actors2[actor.nextActor];
    if (!nextActor) {
      continue;
    }
    const messageWidth = actorToMessageWidth[actorKey];
    const actorWidth = messageWidth + conf$4.actorMargin - actor.width / 2 - nextActor.width / 2;
    actor.margin = Math.max(actorWidth, conf$4.actorMargin);
  }
  return Math.max(maxHeight, conf$4.height);
};
const buildNoteModel = function(msg, actors2, diagObj) {
  const startx = actors2[msg.from].x;
  const stopx = actors2[msg.to].x;
  const shouldWrap = msg.wrap && msg.message;
  let textDimensions = utils.calculateTextDimensions(
    shouldWrap ? utils.wrapLabel(msg.message, conf$4.width, noteFont(conf$4)) : msg.message,
    noteFont(conf$4)
  );
  const noteModel = {
    width: shouldWrap ? conf$4.width : Math.max(conf$4.width, textDimensions.width + 2 * conf$4.noteMargin),
    height: 0,
    startx: actors2[msg.from].x,
    stopx: 0,
    starty: 0,
    stopy: 0,
    message: msg.message
  };
  if (msg.placement === diagObj.db.PLACEMENT.RIGHTOF) {
    noteModel.width = shouldWrap ? Math.max(conf$4.width, textDimensions.width) : Math.max(
      actors2[msg.from].width / 2 + actors2[msg.to].width / 2,
      textDimensions.width + 2 * conf$4.noteMargin
    );
    noteModel.startx = startx + (actors2[msg.from].width + conf$4.actorMargin) / 2;
  } else if (msg.placement === diagObj.db.PLACEMENT.LEFTOF) {
    noteModel.width = shouldWrap ? Math.max(conf$4.width, textDimensions.width + 2 * conf$4.noteMargin) : Math.max(
      actors2[msg.from].width / 2 + actors2[msg.to].width / 2,
      textDimensions.width + 2 * conf$4.noteMargin
    );
    noteModel.startx = startx - noteModel.width + (actors2[msg.from].width - conf$4.actorMargin) / 2;
  } else if (msg.to === msg.from) {
    textDimensions = utils.calculateTextDimensions(
      shouldWrap ? utils.wrapLabel(msg.message, Math.max(conf$4.width, actors2[msg.from].width), noteFont(conf$4)) : msg.message,
      noteFont(conf$4)
    );
    noteModel.width = shouldWrap ? Math.max(conf$4.width, actors2[msg.from].width) : Math.max(actors2[msg.from].width, conf$4.width, textDimensions.width + 2 * conf$4.noteMargin);
    noteModel.startx = startx + (actors2[msg.from].width - noteModel.width) / 2;
  } else {
    noteModel.width = Math.abs(startx + actors2[msg.from].width / 2 - (stopx + actors2[msg.to].width / 2)) + conf$4.actorMargin;
    noteModel.startx = startx < stopx ? startx + actors2[msg.from].width / 2 - conf$4.actorMargin / 2 : stopx + actors2[msg.to].width / 2 - conf$4.actorMargin / 2;
  }
  if (shouldWrap) {
    noteModel.message = utils.wrapLabel(
      msg.message,
      noteModel.width - 2 * conf$4.wrapPadding,
      noteFont(conf$4)
    );
  }
  log$1.debug(
    `NM:[${noteModel.startx},${noteModel.stopx},${noteModel.starty},${noteModel.stopy}:${noteModel.width},${noteModel.height}=${msg.message}]`
  );
  return noteModel;
};
const buildMessageModel = function(msg, actors2, diagObj) {
  let process2 = false;
  if ([
    diagObj.db.LINETYPE.SOLID_OPEN,
    diagObj.db.LINETYPE.DOTTED_OPEN,
    diagObj.db.LINETYPE.SOLID,
    diagObj.db.LINETYPE.DOTTED,
    diagObj.db.LINETYPE.SOLID_CROSS,
    diagObj.db.LINETYPE.DOTTED_CROSS,
    diagObj.db.LINETYPE.SOLID_POINT,
    diagObj.db.LINETYPE.DOTTED_POINT
  ].includes(msg.type)) {
    process2 = true;
  }
  if (!process2) {
    return {};
  }
  const fromBounds = activationBounds(msg.from, actors2);
  const toBounds = activationBounds(msg.to, actors2);
  const fromIdx = fromBounds[0] <= toBounds[0] ? 1 : 0;
  const toIdx = fromBounds[0] < toBounds[0] ? 0 : 1;
  const allBounds = fromBounds.concat(toBounds);
  const boundedWidth = Math.abs(toBounds[toIdx] - fromBounds[fromIdx]);
  if (msg.wrap && msg.message) {
    msg.message = utils.wrapLabel(
      msg.message,
      Math.max(boundedWidth + 2 * conf$4.wrapPadding, conf$4.width),
      messageFont(conf$4)
    );
  }
  const msgDims = utils.calculateTextDimensions(msg.message, messageFont(conf$4));
  return {
    width: Math.max(
      msg.wrap ? 0 : msgDims.width + 2 * conf$4.wrapPadding,
      boundedWidth + 2 * conf$4.wrapPadding,
      conf$4.width
    ),
    height: 0,
    startx: fromBounds[fromIdx],
    stopx: toBounds[toIdx],
    starty: 0,
    stopy: 0,
    message: msg.message,
    type: msg.type,
    wrap: msg.wrap,
    fromBounds: Math.min.apply(null, allBounds),
    toBounds: Math.max.apply(null, allBounds)
  };
};
const calculateLoopBounds = function(messages2, actors2, _maxWidthPerActor, diagObj) {
  const loops = {};
  const stack2 = [];
  let current, noteModel, msgModel;
  messages2.forEach(function(msg) {
    msg.id = utils.random({ length: 10 });
    switch (msg.type) {
      case diagObj.db.LINETYPE.LOOP_START:
      case diagObj.db.LINETYPE.ALT_START:
      case diagObj.db.LINETYPE.OPT_START:
      case diagObj.db.LINETYPE.PAR_START:
      case diagObj.db.LINETYPE.CRITICAL_START:
      case diagObj.db.LINETYPE.BREAK_START:
        stack2.push({
          id: msg.id,
          msg: msg.message,
          from: Number.MAX_SAFE_INTEGER,
          to: Number.MIN_SAFE_INTEGER,
          width: 0
        });
        break;
      case diagObj.db.LINETYPE.ALT_ELSE:
      case diagObj.db.LINETYPE.PAR_AND:
      case diagObj.db.LINETYPE.CRITICAL_OPTION:
        if (msg.message) {
          current = stack2.pop();
          loops[current.id] = current;
          loops[msg.id] = current;
          stack2.push(current);
        }
        break;
      case diagObj.db.LINETYPE.LOOP_END:
      case diagObj.db.LINETYPE.ALT_END:
      case diagObj.db.LINETYPE.OPT_END:
      case diagObj.db.LINETYPE.PAR_END:
      case diagObj.db.LINETYPE.CRITICAL_END:
      case diagObj.db.LINETYPE.BREAK_END:
        current = stack2.pop();
        loops[current.id] = current;
        break;
      case diagObj.db.LINETYPE.ACTIVE_START:
        {
          const actorRect = actors2[msg.from ? msg.from.actor : msg.to.actor];
          const stackedSize = actorActivations(msg.from ? msg.from.actor : msg.to.actor).length;
          const x2 = actorRect.x + actorRect.width / 2 + (stackedSize - 1) * conf$4.activationWidth / 2;
          const toAdd = {
            startx: x2,
            stopx: x2 + conf$4.activationWidth,
            actor: msg.from.actor,
            enabled: true
          };
          bounds$1.activations.push(toAdd);
        }
        break;
      case diagObj.db.LINETYPE.ACTIVE_END:
        {
          const lastActorActivationIdx = bounds$1.activations.map((a2) => a2.actor).lastIndexOf(msg.from.actor);
          delete bounds$1.activations.splice(lastActorActivationIdx, 1)[0];
        }
        break;
    }
    const isNote = msg.placement !== void 0;
    if (isNote) {
      noteModel = buildNoteModel(msg, actors2, diagObj);
      msg.noteModel = noteModel;
      stack2.forEach((stk) => {
        current = stk;
        current.from = Math.min(current.from, noteModel.startx);
        current.to = Math.max(current.to, noteModel.startx + noteModel.width);
        current.width = Math.max(current.width, Math.abs(current.from - current.to)) - conf$4.labelBoxWidth;
      });
    } else {
      msgModel = buildMessageModel(msg, actors2, diagObj);
      msg.msgModel = msgModel;
      if (msgModel.startx && msgModel.stopx && stack2.length > 0) {
        stack2.forEach((stk) => {
          current = stk;
          if (msgModel.startx === msgModel.stopx) {
            const from2 = actors2[msg.from];
            const to2 = actors2[msg.to];
            current.from = Math.min(
              from2.x - msgModel.width / 2,
              from2.x - from2.width / 2,
              current.from
            );
            current.to = Math.max(to2.x + msgModel.width / 2, to2.x + from2.width / 2, current.to);
            current.width = Math.max(current.width, Math.abs(current.to - current.from)) - conf$4.labelBoxWidth;
          } else {
            current.from = Math.min(msgModel.startx, current.from);
            current.to = Math.max(msgModel.stopx, current.to);
            current.width = Math.max(current.width, msgModel.width) - conf$4.labelBoxWidth;
          }
        });
      }
    }
  });
  bounds$1.activations = [];
  log$1.debug("Loop type widths:", loops);
  return loops;
};
const sequenceRenderer = {
  bounds: bounds$1,
  drawActors,
  drawActorsPopup,
  setConf: setConf$4,
  draw: draw$4
};
var parser$1 = function() {
  var o = function(k2, v, o2, l2) {
    for (o2 = o2 || {}, l2 = k2.length; l2--; o2[k2[l2]] = v)
      ;
    return o2;
  }, $V0 = [1, 2], $V1 = [1, 3], $V2 = [1, 5], $V3 = [1, 7], $V4 = [2, 5], $V5 = [1, 15], $V6 = [1, 17], $V7 = [1, 19], $V8 = [1, 20], $V9 = [1, 21], $Va = [1, 22], $Vb = [1, 33], $Vc = [1, 23], $Vd = [1, 24], $Ve = [1, 25], $Vf = [1, 26], $Vg = [1, 27], $Vh = [1, 30], $Vi = [1, 31], $Vj = [1, 32], $Vk = [1, 35], $Vl = [1, 36], $Vm = [1, 37], $Vn = [1, 38], $Vo = [1, 34], $Vp = [1, 41], $Vq = [1, 4, 5, 14, 15, 17, 19, 20, 22, 23, 24, 25, 26, 27, 31, 33, 35, 41, 42, 43, 44, 47, 50], $Vr = [1, 4, 5, 12, 13, 14, 15, 17, 19, 20, 22, 23, 24, 25, 26, 27, 31, 33, 35, 41, 42, 43, 44, 47, 50], $Vs = [1, 4, 5, 7, 14, 15, 17, 19, 20, 22, 23, 24, 25, 26, 27, 31, 33, 35, 41, 42, 43, 44, 47, 50], $Vt = [4, 5, 14, 15, 17, 19, 20, 22, 23, 24, 25, 26, 27, 31, 33, 35, 41, 42, 43, 44, 47, 50];
  var parser2 = {
    trace: function trace() {
    },
    yy: {},
    symbols_: { "error": 2, "start": 3, "SPACE": 4, "NL": 5, "directive": 6, "SD": 7, "document": 8, "line": 9, "statement": 10, "idStatement": 11, "DESCR": 12, "-->": 13, "HIDE_EMPTY": 14, "scale": 15, "WIDTH": 16, "COMPOSIT_STATE": 17, "STRUCT_START": 18, "STRUCT_STOP": 19, "STATE_DESCR": 20, "AS": 21, "ID": 22, "FORK": 23, "JOIN": 24, "CHOICE": 25, "CONCURRENT": 26, "note": 27, "notePosition": 28, "NOTE_TEXT": 29, "direction": 30, "acc_title": 31, "acc_title_value": 32, "acc_descr": 33, "acc_descr_value": 34, "acc_descr_multiline_value": 35, "openDirective": 36, "typeDirective": 37, "closeDirective": 38, ":": 39, "argDirective": 40, "direction_tb": 41, "direction_bt": 42, "direction_rl": 43, "direction_lr": 44, "eol": 45, ";": 46, "EDGE_STATE": 47, "left_of": 48, "right_of": 49, "open_directive": 50, "type_directive": 51, "arg_directive": 52, "close_directive": 53, "$accept": 0, "$end": 1 },
    terminals_: { 2: "error", 4: "SPACE", 5: "NL", 7: "SD", 12: "DESCR", 13: "-->", 14: "HIDE_EMPTY", 15: "scale", 16: "WIDTH", 17: "COMPOSIT_STATE", 18: "STRUCT_START", 19: "STRUCT_STOP", 20: "STATE_DESCR", 21: "AS", 22: "ID", 23: "FORK", 24: "JOIN", 25: "CHOICE", 26: "CONCURRENT", 27: "note", 29: "NOTE_TEXT", 31: "acc_title", 32: "acc_title_value", 33: "acc_descr", 34: "acc_descr_value", 35: "acc_descr_multiline_value", 39: ":", 41: "direction_tb", 42: "direction_bt", 43: "direction_rl", 44: "direction_lr", 46: ";", 47: "EDGE_STATE", 48: "left_of", 49: "right_of", 50: "open_directive", 51: "type_directive", 52: "arg_directive", 53: "close_directive" },
    productions_: [0, [3, 2], [3, 2], [3, 2], [3, 2], [8, 0], [8, 2], [9, 2], [9, 1], [9, 1], [10, 1], [10, 2], [10, 3], [10, 4], [10, 1], [10, 2], [10, 1], [10, 4], [10, 3], [10, 6], [10, 1], [10, 1], [10, 1], [10, 1], [10, 4], [10, 4], [10, 1], [10, 1], [10, 2], [10, 2], [10, 1], [6, 3], [6, 5], [30, 1], [30, 1], [30, 1], [30, 1], [45, 1], [45, 1], [11, 1], [11, 1], [28, 1], [28, 1], [36, 1], [37, 1], [40, 1], [38, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 4:
          yy.setRootDoc($$[$0]);
          return $$[$0];
        case 5:
          this.$ = [];
          break;
        case 6:
          if ($$[$0] != "nl") {
            $$[$0 - 1].push($$[$0]);
            this.$ = $$[$0 - 1];
          }
          break;
        case 7:
        case 8:
          this.$ = $$[$0];
          break;
        case 9:
          this.$ = "nl";
          break;
        case 10:
          this.$ = { stmt: "state", id: $$[$0], type: "default", description: "" };
          break;
        case 11:
          this.$ = { stmt: "state", id: $$[$0 - 1], type: "default", description: yy.trimColon($$[$0]) };
          break;
        case 12:
          this.$ = { stmt: "relation", state1: { stmt: "state", id: $$[$0 - 2], type: "default", description: "" }, state2: { stmt: "state", id: $$[$0], type: "default", description: "" } };
          break;
        case 13:
          this.$ = { stmt: "relation", state1: { stmt: "state", id: $$[$0 - 3], type: "default", description: "" }, state2: { stmt: "state", id: $$[$0 - 1], type: "default", description: "" }, description: $$[$0].substr(1).trim() };
          break;
        case 17:
          this.$ = { stmt: "state", id: $$[$0 - 3], type: "default", description: "", doc: $$[$0 - 1] };
          break;
        case 18:
          var id2 = $$[$0];
          var description2 = $$[$0 - 2].trim();
          if ($$[$0].match(":")) {
            var parts = $$[$0].split(":");
            id2 = parts[0];
            description2 = [description2, parts[1]];
          }
          this.$ = { stmt: "state", id: id2, type: "default", description: description2 };
          break;
        case 19:
          this.$ = { stmt: "state", id: $$[$0 - 3], type: "default", description: $$[$0 - 5], doc: $$[$0 - 1] };
          break;
        case 20:
          this.$ = { stmt: "state", id: $$[$0], type: "fork" };
          break;
        case 21:
          this.$ = { stmt: "state", id: $$[$0], type: "join" };
          break;
        case 22:
          this.$ = { stmt: "state", id: $$[$0], type: "choice" };
          break;
        case 23:
          this.$ = { stmt: "state", id: yy.getDividerId(), type: "divider" };
          break;
        case 24:
          this.$ = { stmt: "state", id: $$[$0 - 1].trim(), note: { position: $$[$0 - 2].trim(), text: $$[$0].trim() } };
          break;
        case 28:
          this.$ = $$[$0].trim();
          yy.setAccTitle(this.$);
          break;
        case 29:
        case 30:
          this.$ = $$[$0].trim();
          yy.setAccDescription(this.$);
          break;
        case 33:
          yy.setDirection("TB");
          this.$ = { stmt: "dir", value: "TB" };
          break;
        case 34:
          yy.setDirection("BT");
          this.$ = { stmt: "dir", value: "BT" };
          break;
        case 35:
          yy.setDirection("RL");
          this.$ = { stmt: "dir", value: "RL" };
          break;
        case 36:
          yy.setDirection("LR");
          this.$ = { stmt: "dir", value: "LR" };
          break;
        case 39:
        case 40:
          this.$ = $$[$0];
          break;
        case 43:
          yy.parseDirective("%%{", "open_directive");
          break;
        case 44:
          yy.parseDirective($$[$0], "type_directive");
          break;
        case 45:
          $$[$0] = $$[$0].trim().replace(/'/g, '"');
          yy.parseDirective($$[$0], "arg_directive");
          break;
        case 46:
          yy.parseDirective("}%%", "close_directive", "state");
          break;
      }
    },
    table: [{ 3: 1, 4: $V0, 5: $V1, 6: 4, 7: $V2, 36: 6, 50: $V3 }, { 1: [3] }, { 3: 8, 4: $V0, 5: $V1, 6: 4, 7: $V2, 36: 6, 50: $V3 }, { 3: 9, 4: $V0, 5: $V1, 6: 4, 7: $V2, 36: 6, 50: $V3 }, { 3: 10, 4: $V0, 5: $V1, 6: 4, 7: $V2, 36: 6, 50: $V3 }, o([1, 4, 5, 14, 15, 17, 20, 22, 23, 24, 25, 26, 27, 31, 33, 35, 41, 42, 43, 44, 47, 50], $V4, { 8: 11 }), { 37: 12, 51: [1, 13] }, { 51: [2, 43] }, { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 3] }, { 1: [2, 4], 4: $V5, 5: $V6, 6: 28, 9: 14, 10: 16, 11: 18, 14: $V7, 15: $V8, 17: $V9, 20: $Va, 22: $Vb, 23: $Vc, 24: $Vd, 25: $Ve, 26: $Vf, 27: $Vg, 30: 29, 31: $Vh, 33: $Vi, 35: $Vj, 36: 6, 41: $Vk, 42: $Vl, 43: $Vm, 44: $Vn, 47: $Vo, 50: $V3 }, { 38: 39, 39: [1, 40], 53: $Vp }, o([39, 53], [2, 44]), o($Vq, [2, 6]), { 6: 28, 10: 42, 11: 18, 14: $V7, 15: $V8, 17: $V9, 20: $Va, 22: $Vb, 23: $Vc, 24: $Vd, 25: $Ve, 26: $Vf, 27: $Vg, 30: 29, 31: $Vh, 33: $Vi, 35: $Vj, 36: 6, 41: $Vk, 42: $Vl, 43: $Vm, 44: $Vn, 47: $Vo, 50: $V3 }, o($Vq, [2, 8]), o($Vq, [2, 9]), o($Vq, [2, 10], { 12: [1, 43], 13: [1, 44] }), o($Vq, [2, 14]), { 16: [1, 45] }, o($Vq, [2, 16], { 18: [1, 46] }), { 21: [1, 47] }, o($Vq, [2, 20]), o($Vq, [2, 21]), o($Vq, [2, 22]), o($Vq, [2, 23]), { 28: 48, 29: [1, 49], 48: [1, 50], 49: [1, 51] }, o($Vq, [2, 26]), o($Vq, [2, 27]), { 32: [1, 52] }, { 34: [1, 53] }, o($Vq, [2, 30]), o($Vr, [2, 39]), o($Vr, [2, 40]), o($Vq, [2, 33]), o($Vq, [2, 34]), o($Vq, [2, 35]), o($Vq, [2, 36]), o($Vs, [2, 31]), { 40: 54, 52: [1, 55] }, o($Vs, [2, 46]), o($Vq, [2, 7]), o($Vq, [2, 11]), { 11: 56, 22: $Vb, 47: $Vo }, o($Vq, [2, 15]), o($Vt, $V4, { 8: 57 }), { 22: [1, 58] }, { 22: [1, 59] }, { 21: [1, 60] }, { 22: [2, 41] }, { 22: [2, 42] }, o($Vq, [2, 28]), o($Vq, [2, 29]), { 38: 61, 53: $Vp }, { 53: [2, 45] }, o($Vq, [2, 12], { 12: [1, 62] }), { 4: $V5, 5: $V6, 6: 28, 9: 14, 10: 16, 11: 18, 14: $V7, 15: $V8, 17: $V9, 19: [1, 63], 20: $Va, 22: $Vb, 23: $Vc, 24: $Vd, 25: $Ve, 26: $Vf, 27: $Vg, 30: 29, 31: $Vh, 33: $Vi, 35: $Vj, 36: 6, 41: $Vk, 42: $Vl, 43: $Vm, 44: $Vn, 47: $Vo, 50: $V3 }, o($Vq, [2, 18], { 18: [1, 64] }), { 29: [1, 65] }, { 22: [1, 66] }, o($Vs, [2, 32]), o($Vq, [2, 13]), o($Vq, [2, 17]), o($Vt, $V4, { 8: 67 }), o($Vq, [2, 24]), o($Vq, [2, 25]), { 4: $V5, 5: $V6, 6: 28, 9: 14, 10: 16, 11: 18, 14: $V7, 15: $V8, 17: $V9, 19: [1, 68], 20: $Va, 22: $Vb, 23: $Vc, 24: $Vd, 25: $Ve, 26: $Vf, 27: $Vg, 30: 29, 31: $Vh, 33: $Vi, 35: $Vj, 36: 6, 41: $Vk, 42: $Vl, 43: $Vm, 44: $Vn, 47: $Vo, 50: $V3 }, o($Vq, [2, 19])],
    defaultActions: { 7: [2, 43], 8: [2, 1], 9: [2, 2], 10: [2, 3], 50: [2, 41], 51: [2, 42], 55: [2, 45] },
    parseError: function parseError(str, hash2) {
      if (hash2.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash2;
        throw error;
      }
    },
    parse: function parse2(input) {
      var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k2 in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
          sharedState.yy[k2] = this.yy[k2];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges2 = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function lex() {
        var token2;
        token2 = tstack.pop() || lexer2.lex() || EOF2;
        if (typeof token2 !== "number") {
          if (token2 instanceof Array) {
            tstack = token2;
            token2 = tstack.pop();
          }
          token2 = self2.symbols_[token2] || token2;
        }
        return token2;
      }
      var symbol2, state, action, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack2[stack2.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol2 === null || typeof symbol2 == "undefined") {
            symbol2 = lex();
          }
          action = table[state] && table[state][symbol2];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push("'" + this.terminals_[p] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol2] || symbol2) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol2 == EOF2 ? "end of input" : "'" + (this.terminals_[symbol2] || symbol2) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol2] || symbol2,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol2);
        }
        switch (action[0]) {
          case 1:
            stack2.push(symbol2);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack2.push(action[1]);
            symbol2 = null;
            {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges2) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
              ];
            }
            r = this.performAction.apply(yyval, [
              yytext,
              yyleng,
              yylineno,
              sharedState.yy,
              action[1],
              vstack,
              lstack
            ].concat(args));
            if (typeof r !== "undefined") {
              return r;
            }
            if (len) {
              stack2 = stack2.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack2.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
            stack2.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash2) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash2);
        } else {
          throw new Error(str);
        }
      },
      setInput: function(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      input: function() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      unput: function(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      more: function() {
        this._more = true;
        return this;
      },
      reject: function() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      less: function(n) {
        this.unput(this.match.slice(n));
      },
      pastInput: function() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var next2 = this.match;
        if (next2.length < 20) {
          next2 += this._input.substr(0, 20 - next2.length);
        }
        return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var pre = this.pastInput();
        var c2 = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c2 + "^";
      },
      test_match: function(match, indexed_rule) {
        var token2, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token2) {
          return token2;
        } else if (this._backtrack) {
          for (var k2 in backup) {
            this[k2] = backup[k2];
          }
          return false;
        }
        return false;
      },
      next: function() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token2, match, tempMatch, index2;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index2 = i;
            if (this.options.backtrack_lexer) {
              token2 = this.test_match(tempMatch, rules[i]);
              if (token2 !== false) {
                return token2;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token2 = this.test_match(match, rules[index2]);
          if (token2 !== false) {
            return token2;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": true },
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        switch ($avoiding_name_collisions) {
          case 0:
            return 41;
          case 1:
            return 42;
          case 2:
            return 43;
          case 3:
            return 44;
          case 4:
            this.begin("open_directive");
            return 50;
          case 5:
            this.begin("type_directive");
            return 51;
          case 6:
            this.popState();
            this.begin("arg_directive");
            return 39;
          case 7:
            this.popState();
            this.popState();
            return 53;
          case 8:
            return 52;
          case 9:
            break;
          case 10:
            break;
          case 11:
            return 5;
          case 12:
            break;
          case 13:
            break;
          case 14:
            break;
          case 15:
            break;
          case 16:
            this.pushState("SCALE");
            return 15;
          case 17:
            return 16;
          case 18:
            this.popState();
            break;
          case 19:
            this.begin("acc_title");
            return 31;
          case 20:
            this.popState();
            return "acc_title_value";
          case 21:
            this.begin("acc_descr");
            return 33;
          case 22:
            this.popState();
            return "acc_descr_value";
          case 23:
            this.begin("acc_descr_multiline");
            break;
          case 24:
            this.popState();
            break;
          case 25:
            return "acc_descr_multiline_value";
          case 26:
            this.pushState("STATE");
            break;
          case 27:
            this.popState();
            yy_.yytext = yy_.yytext.slice(0, -8).trim();
            return 23;
          case 28:
            this.popState();
            yy_.yytext = yy_.yytext.slice(0, -8).trim();
            return 24;
          case 29:
            this.popState();
            yy_.yytext = yy_.yytext.slice(0, -10).trim();
            return 25;
          case 30:
            this.popState();
            yy_.yytext = yy_.yytext.slice(0, -8).trim();
            return 23;
          case 31:
            this.popState();
            yy_.yytext = yy_.yytext.slice(0, -8).trim();
            return 24;
          case 32:
            this.popState();
            yy_.yytext = yy_.yytext.slice(0, -10).trim();
            return 25;
          case 33:
            return 41;
          case 34:
            return 42;
          case 35:
            return 43;
          case 36:
            return 44;
          case 37:
            this.begin("STATE_STRING");
            break;
          case 38:
            this.popState();
            this.pushState("STATE_ID");
            return "AS";
          case 39:
            this.popState();
            return "ID";
          case 40:
            this.popState();
            break;
          case 41:
            return "STATE_DESCR";
          case 42:
            return 17;
          case 43:
            this.popState();
            break;
          case 44:
            this.popState();
            this.pushState("struct");
            return 18;
          case 45:
            this.popState();
            return 19;
          case 46:
            break;
          case 47:
            this.begin("NOTE");
            return 27;
          case 48:
            this.popState();
            this.pushState("NOTE_ID");
            return 48;
          case 49:
            this.popState();
            this.pushState("NOTE_ID");
            return 49;
          case 50:
            this.popState();
            this.pushState("FLOATING_NOTE");
            break;
          case 51:
            this.popState();
            this.pushState("FLOATING_NOTE_ID");
            return "AS";
          case 52:
            break;
          case 53:
            return "NOTE_TEXT";
          case 54:
            this.popState();
            return "ID";
          case 55:
            this.popState();
            this.pushState("NOTE_TEXT");
            return 22;
          case 56:
            this.popState();
            yy_.yytext = yy_.yytext.substr(2).trim();
            return 29;
          case 57:
            this.popState();
            yy_.yytext = yy_.yytext.slice(0, -8).trim();
            return 29;
          case 58:
            return 7;
          case 59:
            return 7;
          case 60:
            return 14;
          case 61:
            return 47;
          case 62:
            return 22;
          case 63:
            yy_.yytext = yy_.yytext.trim();
            return 12;
          case 64:
            return 13;
          case 65:
            return 26;
          case 66:
            return 5;
          case 67:
            return "INVALID";
        }
      },
      rules: [/^(?:.*direction\s+TB[^\n]*)/i, /^(?:.*direction\s+BT[^\n]*)/i, /^(?:.*direction\s+RL[^\n]*)/i, /^(?:.*direction\s+LR[^\n]*)/i, /^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:%%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n]+)/i, /^(?:[\s]+)/i, /^(?:((?!\n)\s)+)/i, /^(?:#[^\n]*)/i, /^(?:%[^\n]*)/i, /^(?:scale\s+)/i, /^(?:\d+)/i, /^(?:\s+width\b)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:state\s+)/i, /^(?:.*<<fork>>)/i, /^(?:.*<<join>>)/i, /^(?:.*<<choice>>)/i, /^(?:.*\[\[fork\]\])/i, /^(?:.*\[\[join\]\])/i, /^(?:.*\[\[choice\]\])/i, /^(?:.*direction\s+TB[^\n]*)/i, /^(?:.*direction\s+BT[^\n]*)/i, /^(?:.*direction\s+RL[^\n]*)/i, /^(?:.*direction\s+LR[^\n]*)/i, /^(?:["])/i, /^(?:\s*as\s+)/i, /^(?:[^\n\{]*)/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:[^\n\s\{]+)/i, /^(?:\n)/i, /^(?:\{)/i, /^(?:\})/i, /^(?:[\n])/i, /^(?:note\s+)/i, /^(?:left of\b)/i, /^(?:right of\b)/i, /^(?:")/i, /^(?:\s*as\s*)/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:[^\n]*)/i, /^(?:\s*[^:\n\s\-]+)/i, /^(?:\s*:[^:\n;]+)/i, /^(?:[\s\S]*?end note\b)/i, /^(?:stateDiagram\s+)/i, /^(?:stateDiagram-v2\s+)/i, /^(?:hide empty description\b)/i, /^(?:\[\*\])/i, /^(?:[^:\n\s\-\{]+)/i, /^(?:\s*:[^:\n;]+)/i, /^(?:-->)/i, /^(?:--)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { "LINE": { "rules": [13, 14], "inclusive": false }, "close_directive": { "rules": [13, 14], "inclusive": false }, "arg_directive": { "rules": [7, 8, 13, 14], "inclusive": false }, "type_directive": { "rules": [6, 7, 13, 14], "inclusive": false }, "open_directive": { "rules": [5, 13, 14], "inclusive": false }, "struct": { "rules": [13, 14, 26, 33, 34, 35, 36, 45, 46, 47, 61, 62, 63, 64, 65], "inclusive": false }, "FLOATING_NOTE_ID": { "rules": [54], "inclusive": false }, "FLOATING_NOTE": { "rules": [51, 52, 53], "inclusive": false }, "NOTE_TEXT": { "rules": [56, 57], "inclusive": false }, "NOTE_ID": { "rules": [55], "inclusive": false }, "NOTE": { "rules": [48, 49, 50], "inclusive": false }, "acc_descr_multiline": { "rules": [24, 25], "inclusive": false }, "acc_descr": { "rules": [22], "inclusive": false }, "acc_title": { "rules": [20], "inclusive": false }, "SCALE": { "rules": [17, 18], "inclusive": false }, "ALIAS": { "rules": [], "inclusive": false }, "STATE_ID": { "rules": [39], "inclusive": false }, "STATE_STRING": { "rules": [40, 41], "inclusive": false }, "FORK_STATE": { "rules": [], "inclusive": false }, "STATE": { "rules": [13, 14, 27, 28, 29, 30, 31, 32, 37, 38, 42, 43, 44], "inclusive": false }, "ID": { "rules": [13, 14], "inclusive": false }, "INITIAL": { "rules": [0, 1, 2, 3, 4, 9, 10, 11, 12, 14, 15, 16, 19, 21, 23, 26, 44, 47, 58, 59, 60, 61, 62, 63, 64, 66, 67], "inclusive": true } }
    };
    return lexer2;
  }();
  parser2.lexer = lexer;
  function Parser2() {
    this.yy = {};
  }
  Parser2.prototype = parser2;
  parser2.Parser = Parser2;
  return new Parser2();
}();
parser$1.parser = parser$1;
const stateDetector = (txt, config2) => {
  var _a2;
  if (((_a2 = config2 == null ? void 0 : config2.state) == null ? void 0 : _a2.defaultRenderer) === "dagre-wrapper")
    return false;
  return txt.match(/^\s*stateDiagram/) !== null;
};
const stateDetectorV2 = (text2, config2) => {
  var _a2;
  if (text2.match(/^\s*stateDiagram-v2/) !== null)
    return true;
  if (text2.match(/^\s*stateDiagram/) && ((_a2 = config2 == null ? void 0 : config2.state) == null ? void 0 : _a2.defaultRenderer) === "dagre-wrapper")
    return true;
  return false;
};
const clone = (o) => JSON.parse(JSON.stringify(o));
let rootDoc = [];
const parseDirective$2 = function(statement, context, type2) {
  mermaidAPI.parseDirective(this, statement, context, type2);
};
const setRootDoc = (o) => {
  log$1.info("Setting root doc", o);
  rootDoc = o;
};
const getRootDoc = () => rootDoc;
const docTranslator = (parent, node2, first) => {
  if (node2.stmt === "relation") {
    docTranslator(parent, node2.state1, true);
    docTranslator(parent, node2.state2, false);
  } else {
    if (node2.stmt === "state") {
      if (node2.id === "[*]") {
        node2.id = first ? parent.id + "_start" : parent.id + "_end";
        node2.start = first;
      }
    }
    if (node2.doc) {
      const doc2 = [];
      let i = 0;
      let currentDoc = [];
      for (i = 0; i < node2.doc.length; i++) {
        if (node2.doc[i].type === "divider") {
          const newNode = clone(node2.doc[i]);
          newNode.doc = clone(currentDoc);
          doc2.push(newNode);
          currentDoc = [];
        } else {
          currentDoc.push(node2.doc[i]);
        }
      }
      if (doc2.length > 0 && currentDoc.length > 0) {
        const newNode = {
          stmt: "state",
          id: generateId$1(),
          type: "divider",
          doc: clone(currentDoc)
        };
        doc2.push(clone(newNode));
        node2.doc = doc2;
      }
      node2.doc.forEach((docNode) => docTranslator(node2, docNode, true));
    }
  }
};
const getRootDocV2 = () => {
  docTranslator({ id: "root" }, { id: "root", doc: rootDoc }, true);
  return { id: "root", doc: rootDoc };
};
const extract = (_doc) => {
  let doc2;
  if (_doc.doc) {
    doc2 = _doc.doc;
  } else {
    doc2 = _doc;
  }
  log$1.info(doc2);
  clear$1(true);
  log$1.info("Extract", doc2);
  doc2.forEach((item) => {
    if (item.stmt === "state") {
      addState(item.id, item.type, item.doc, item.description, item.note);
    }
    if (item.stmt === "relation") {
      addRelation(item.state1.id, item.state2.id, item.description);
    }
  });
};
const newDoc = () => {
  return {
    relations: [],
    states: {},
    documents: {}
  };
};
let documents = {
  root: newDoc()
};
let currentDocument = documents.root;
let startCnt = 0;
const addState = function(id2, type2, doc2, descr, note2) {
  if (typeof currentDocument.states[id2] === "undefined") {
    currentDocument.states[id2] = {
      id: id2,
      descriptions: [],
      type: type2,
      doc: doc2,
      note: note2
    };
  } else {
    if (!currentDocument.states[id2].doc) {
      currentDocument.states[id2].doc = doc2;
    }
    if (!currentDocument.states[id2].type) {
      currentDocument.states[id2].type = type2;
    }
  }
  if (descr) {
    log$1.info("Adding state ", id2, descr);
    if (typeof descr === "string")
      addDescription(id2, descr.trim());
    if (typeof descr === "object") {
      descr.forEach((des) => addDescription(id2, des.trim()));
    }
  }
  if (note2) {
    currentDocument.states[id2].note = note2;
    currentDocument.states[id2].note.text = common.sanitizeText(
      currentDocument.states[id2].note.text,
      getConfig$1()
    );
  }
};
const clear$1 = function(saveCommon) {
  documents = {
    root: newDoc()
  };
  currentDocument = documents.root;
  currentDocument = documents.root;
  startCnt = 0;
  classes = [];
  if (!saveCommon) {
    clear$g();
  }
};
const getState = function(id2) {
  return currentDocument.states[id2];
};
const getStates = function() {
  return currentDocument.states;
};
const logDocuments = function() {
  log$1.info("Documents = ", documents);
};
const getRelations = function() {
  return currentDocument.relations;
};
const addRelation = function(_id1, _id2, title2) {
  let id1 = _id1;
  let id2 = _id2;
  let type1 = "default";
  let type2 = "default";
  if (_id1 === "[*]") {
    startCnt++;
    id1 = "start" + startCnt;
    type1 = "start";
  }
  if (_id2 === "[*]") {
    id2 = "end" + startCnt;
    type2 = "end";
  }
  addState(id1, type1);
  addState(id2, type2);
  currentDocument.relations.push({
    id1,
    id2,
    title: common.sanitizeText(title2, getConfig$1())
  });
};
const addDescription = function(id2, _descr) {
  const theState = currentDocument.states[id2];
  let descr = _descr;
  if (descr[0] === ":") {
    descr = descr.substr(1).trim();
  }
  theState.descriptions.push(common.sanitizeText(descr, getConfig$1()));
};
const cleanupLabel = function(label) {
  if (label.substring(0, 1) === ":") {
    return label.substr(2).trim();
  } else {
    return label.trim();
  }
};
const lineType = {
  LINE: 0,
  DOTTED_LINE: 1
};
let dividerCnt = 0;
const getDividerId = () => {
  dividerCnt++;
  return "divider-id-" + dividerCnt;
};
let classes = [];
const getClasses$1 = () => classes;
let direction = "TB";
const getDirection = () => direction;
const setDirection = (dir) => {
  direction = dir;
};
const relationType = {
  AGGREGATION: 0,
  EXTENSION: 1,
  COMPOSITION: 2,
  DEPENDENCY: 3
};
const trimColon = (str) => str && str[0] === ":" ? str.substr(1).trim() : str.trim();
const stateDb = {
  parseDirective: parseDirective$2,
  getConfig: () => getConfig$1().state,
  addState,
  clear: clear$1,
  getState,
  getStates,
  getRelations,
  getClasses: getClasses$1,
  getDirection,
  addRelation,
  getDividerId,
  setDirection,
  cleanupLabel,
  lineType,
  relationType,
  logDocuments,
  getRootDoc,
  setRootDoc,
  getRootDocV2,
  extract,
  trimColon,
  getAccTitle,
  setAccTitle,
  getAccDescription,
  setAccDescription
};
const drawStartState = (g2) => g2.append("circle").attr("class", "start-state").attr("r", getConfig$1().state.sizeUnit).attr("cx", getConfig$1().state.padding + getConfig$1().state.sizeUnit).attr("cy", getConfig$1().state.padding + getConfig$1().state.sizeUnit);
const drawDivider = (g2) => g2.append("line").style("stroke", "grey").style("stroke-dasharray", "3").attr("x1", getConfig$1().state.textHeight).attr("class", "divider").attr("x2", getConfig$1().state.textHeight * 2).attr("y1", 0).attr("y2", 0);
const drawSimpleState = (g2, stateDef) => {
  const state = g2.append("text").attr("x", 2 * getConfig$1().state.padding).attr("y", getConfig$1().state.textHeight + 2 * getConfig$1().state.padding).attr("font-size", getConfig$1().state.fontSize).attr("class", "state-title").text(stateDef.id);
  const classBox = state.node().getBBox();
  g2.insert("rect", ":first-child").attr("x", getConfig$1().state.padding).attr("y", getConfig$1().state.padding).attr("width", classBox.width + 2 * getConfig$1().state.padding).attr("height", classBox.height + 2 * getConfig$1().state.padding).attr("rx", getConfig$1().state.radius);
  return state;
};
const drawDescrState = (g2, stateDef) => {
  const addTspan2 = function(textEl, txt, isFirst2) {
    const tSpan = textEl.append("tspan").attr("x", 2 * getConfig$1().state.padding).text(txt);
    if (!isFirst2) {
      tSpan.attr("dy", getConfig$1().state.textHeight);
    }
  };
  const title2 = g2.append("text").attr("x", 2 * getConfig$1().state.padding).attr("y", getConfig$1().state.textHeight + 1.3 * getConfig$1().state.padding).attr("font-size", getConfig$1().state.fontSize).attr("class", "state-title").text(stateDef.descriptions[0]);
  const titleBox = title2.node().getBBox();
  const titleHeight = titleBox.height;
  const description2 = g2.append("text").attr("x", getConfig$1().state.padding).attr(
    "y",
    titleHeight + getConfig$1().state.padding * 0.4 + getConfig$1().state.dividerMargin + getConfig$1().state.textHeight
  ).attr("class", "state-description");
  let isFirst = true;
  let isSecond = true;
  stateDef.descriptions.forEach(function(descr) {
    if (!isFirst) {
      addTspan2(description2, descr, isSecond);
      isSecond = false;
    }
    isFirst = false;
  });
  const descrLine = g2.append("line").attr("x1", getConfig$1().state.padding).attr("y1", getConfig$1().state.padding + titleHeight + getConfig$1().state.dividerMargin / 2).attr("y2", getConfig$1().state.padding + titleHeight + getConfig$1().state.dividerMargin / 2).attr("class", "descr-divider");
  const descrBox = description2.node().getBBox();
  const width2 = Math.max(descrBox.width, titleBox.width);
  descrLine.attr("x2", width2 + 3 * getConfig$1().state.padding);
  g2.insert("rect", ":first-child").attr("x", getConfig$1().state.padding).attr("y", getConfig$1().state.padding).attr("width", width2 + 2 * getConfig$1().state.padding).attr("height", descrBox.height + titleHeight + 2 * getConfig$1().state.padding).attr("rx", getConfig$1().state.radius);
  return g2;
};
const addTitleAndBox = (g2, stateDef, altBkg) => {
  const pad2 = getConfig$1().state.padding;
  const dblPad = 2 * getConfig$1().state.padding;
  const orgBox = g2.node().getBBox();
  const orgWidth = orgBox.width;
  const orgX = orgBox.x;
  const title2 = g2.append("text").attr("x", 0).attr("y", getConfig$1().state.titleShift).attr("font-size", getConfig$1().state.fontSize).attr("class", "state-title").text(stateDef.id);
  const titleBox = title2.node().getBBox();
  const titleWidth = titleBox.width + dblPad;
  let width2 = Math.max(titleWidth, orgWidth);
  if (width2 === orgWidth) {
    width2 = width2 + dblPad;
  }
  let startX;
  const graphBox = g2.node().getBBox();
  if (stateDef.doc)
    ;
  startX = orgX - pad2;
  if (titleWidth > orgWidth) {
    startX = (orgWidth - width2) / 2 + pad2;
  }
  if (Math.abs(orgX - graphBox.x) < pad2) {
    if (titleWidth > orgWidth) {
      startX = orgX - (titleWidth - orgWidth) / 2;
    }
  }
  const lineY = 1 - getConfig$1().state.textHeight;
  g2.insert("rect", ":first-child").attr("x", startX).attr("y", lineY).attr("class", altBkg ? "alt-composit" : "composit").attr("width", width2).attr(
    "height",
    graphBox.height + getConfig$1().state.textHeight + getConfig$1().state.titleShift + 1
  ).attr("rx", "0");
  title2.attr("x", startX + pad2);
  if (titleWidth <= orgWidth)
    title2.attr("x", orgX + (width2 - dblPad) / 2 - titleWidth / 2 + pad2);
  g2.insert("rect", ":first-child").attr("x", startX).attr(
    "y",
    getConfig$1().state.titleShift - getConfig$1().state.textHeight - getConfig$1().state.padding
  ).attr("width", width2).attr("height", getConfig$1().state.textHeight * 3).attr("rx", getConfig$1().state.radius);
  g2.insert("rect", ":first-child").attr("x", startX).attr(
    "y",
    getConfig$1().state.titleShift - getConfig$1().state.textHeight - getConfig$1().state.padding
  ).attr("width", width2).attr("height", graphBox.height + 3 + 2 * getConfig$1().state.textHeight).attr("rx", getConfig$1().state.radius);
  return g2;
};
const drawEndState = (g2) => {
  g2.append("circle").attr("class", "end-state-outer").attr("r", getConfig$1().state.sizeUnit + getConfig$1().state.miniPadding).attr(
    "cx",
    getConfig$1().state.padding + getConfig$1().state.sizeUnit + getConfig$1().state.miniPadding
  ).attr(
    "cy",
    getConfig$1().state.padding + getConfig$1().state.sizeUnit + getConfig$1().state.miniPadding
  );
  return g2.append("circle").attr("class", "end-state-inner").attr("r", getConfig$1().state.sizeUnit).attr("cx", getConfig$1().state.padding + getConfig$1().state.sizeUnit + 2).attr("cy", getConfig$1().state.padding + getConfig$1().state.sizeUnit + 2);
};
const drawForkJoinState = (g2, stateDef) => {
  let width2 = getConfig$1().state.forkWidth;
  let height2 = getConfig$1().state.forkHeight;
  if (stateDef.parentId) {
    let tmp = width2;
    width2 = height2;
    height2 = tmp;
  }
  return g2.append("rect").style("stroke", "black").style("fill", "black").attr("width", width2).attr("height", height2).attr("x", getConfig$1().state.padding).attr("y", getConfig$1().state.padding);
};
const _drawLongText = (_text, x2, y2, g2) => {
  let textHeight = 0;
  const textElem = g2.append("text");
  textElem.style("text-anchor", "start");
  textElem.attr("class", "noteText");
  let text2 = _text.replace(/\r\n/g, "<br/>");
  text2 = text2.replace(/\n/g, "<br/>");
  const lines = text2.split(common.lineBreakRegex);
  let tHeight = 1.25 * getConfig$1().state.noteMargin;
  for (const line2 of lines) {
    const txt = line2.trim();
    if (txt.length > 0) {
      const span = textElem.append("tspan");
      span.text(txt);
      if (tHeight === 0) {
        const textBounds = span.node().getBBox();
        tHeight += textBounds.height;
      }
      textHeight += tHeight;
      span.attr("x", x2 + getConfig$1().state.noteMargin);
      span.attr("y", y2 + textHeight + 1.25 * getConfig$1().state.noteMargin);
    }
  }
  return { textWidth: textElem.node().getBBox().width, textHeight };
};
const drawNote = (text2, g2) => {
  g2.attr("class", "state-note");
  const note2 = g2.append("rect").attr("x", 0).attr("y", getConfig$1().state.padding);
  const rectElem = g2.append("g");
  const { textWidth, textHeight } = _drawLongText(text2, 0, 0, rectElem);
  note2.attr("height", textHeight + 2 * getConfig$1().state.noteMargin);
  note2.attr("width", textWidth + getConfig$1().state.noteMargin * 2);
  return note2;
};
const drawState = function(elem, stateDef) {
  const id2 = stateDef.id;
  const stateInfo = {
    id: id2,
    label: stateDef.id,
    width: 0,
    height: 0
  };
  const g2 = elem.append("g").attr("id", id2).attr("class", "stateGroup");
  if (stateDef.type === "start")
    drawStartState(g2);
  if (stateDef.type === "end")
    drawEndState(g2);
  if (stateDef.type === "fork" || stateDef.type === "join")
    drawForkJoinState(g2, stateDef);
  if (stateDef.type === "note")
    drawNote(stateDef.note.text, g2);
  if (stateDef.type === "divider")
    drawDivider(g2);
  if (stateDef.type === "default" && stateDef.descriptions.length === 0)
    drawSimpleState(g2, stateDef);
  if (stateDef.type === "default" && stateDef.descriptions.length > 0)
    drawDescrState(g2, stateDef);
  const stateBox = g2.node().getBBox();
  stateInfo.width = stateBox.width + 2 * getConfig$1().state.padding;
  stateInfo.height = stateBox.height + 2 * getConfig$1().state.padding;
  return stateInfo;
};
let edgeCount = 0;
const drawEdge = function(elem, path2, relation) {
  const getRelationType = function(type2) {
    switch (type2) {
      case stateDb.relationType.AGGREGATION:
        return "aggregation";
      case stateDb.relationType.EXTENSION:
        return "extension";
      case stateDb.relationType.COMPOSITION:
        return "composition";
      case stateDb.relationType.DEPENDENCY:
        return "dependency";
    }
  };
  path2.points = path2.points.filter((p) => !Number.isNaN(p.y));
  const lineData = path2.points;
  const lineFunction = line$2().x(function(d) {
    return d.x;
  }).y(function(d) {
    return d.y;
  }).curve(curveBasis);
  const svgPath = elem.append("path").attr("d", lineFunction(lineData)).attr("id", "edge" + edgeCount).attr("class", "transition");
  let url = "";
  if (getConfig$1().state.arrowMarkerAbsolute) {
    url = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search;
    url = url.replace(/\(/g, "\\(");
    url = url.replace(/\)/g, "\\)");
  }
  svgPath.attr(
    "marker-end",
    "url(" + url + "#" + getRelationType(stateDb.relationType.DEPENDENCY) + "End)"
  );
  if (typeof relation.title !== "undefined") {
    const label = elem.append("g").attr("class", "stateLabel");
    const { x: x2, y: y2 } = utils.calcLabelPosition(path2.points);
    const rows = common.getRows(relation.title);
    let titleHeight = 0;
    const titleRows = [];
    let maxWidth = 0;
    let minX = 0;
    for (let i = 0; i <= rows.length; i++) {
      const title2 = label.append("text").attr("text-anchor", "middle").text(rows[i]).attr("x", x2).attr("y", y2 + titleHeight);
      const boundstmp = title2.node().getBBox();
      maxWidth = Math.max(maxWidth, boundstmp.width);
      minX = Math.min(minX, boundstmp.x);
      log$1.info(boundstmp.x, x2, y2 + titleHeight);
      if (titleHeight === 0) {
        const titleBox = title2.node().getBBox();
        titleHeight = titleBox.height;
        log$1.info("Title height", titleHeight, y2);
      }
      titleRows.push(title2);
    }
    let boxHeight = titleHeight * rows.length;
    if (rows.length > 1) {
      const heightAdj = (rows.length - 1) * titleHeight * 0.5;
      titleRows.forEach((title2, i) => title2.attr("y", y2 + i * titleHeight - heightAdj));
      boxHeight = titleHeight * rows.length;
    }
    const bounds2 = label.node().getBBox();
    label.insert("rect", ":first-child").attr("class", "box").attr("x", x2 - maxWidth / 2 - getConfig$1().state.padding / 2).attr("y", y2 - boxHeight / 2 - getConfig$1().state.padding / 2 - 3.5).attr("width", maxWidth + getConfig$1().state.padding).attr("height", boxHeight + getConfig$1().state.padding);
    log$1.info(bounds2);
  }
  edgeCount++;
};
let conf$3;
const transformationLog = {};
const setConf$3 = function() {
};
const insertMarkers = function(elem) {
  elem.append("defs").append("marker").attr("id", "dependencyEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
};
const draw$3 = function(text2, id2, _version, diagObj) {
  conf$3 = getConfig$1().state;
  const securityLevel = getConfig$1().securityLevel;
  let sandboxElement;
  if (securityLevel === "sandbox") {
    sandboxElement = select$1("#i" + id2);
  }
  const root2 = securityLevel === "sandbox" ? select$1(sandboxElement.nodes()[0].contentDocument.body) : select$1("body");
  const doc2 = securityLevel === "sandbox" ? sandboxElement.nodes()[0].contentDocument : document;
  log$1.debug("Rendering diagram " + text2);
  const diagram = root2.select(`[id='${id2}']`);
  insertMarkers(diagram);
  const graph2 = new graphlib$2.Graph({
    multigraph: true,
    compound: true,
    rankdir: "RL"
  });
  graph2.setDefaultEdgeLabel(function() {
    return {};
  });
  const rootDoc2 = diagObj.db.getRootDoc();
  renderDoc(rootDoc2, diagram, void 0, false, root2, doc2, diagObj);
  const padding2 = conf$3.padding;
  const bounds2 = diagram.node().getBBox();
  const width2 = bounds2.width + padding2 * 2;
  const height2 = bounds2.height + padding2 * 2;
  const svgWidth = width2 * 1.75;
  configureSvgSize(diagram, height2, svgWidth, conf$3.useMaxWidth);
  diagram.attr(
    "viewBox",
    `${bounds2.x - conf$3.padding}  ${bounds2.y - conf$3.padding} ` + width2 + " " + height2
  );
  addSVGAccessibilityFields(diagObj.db, diagram, id2);
};
const getLabelWidth = (text2) => {
  return text2 ? text2.length * conf$3.fontSizeFactor : 1;
};
const renderDoc = (doc2, diagram, parentId, altBkg, root2, domDocument, diagObj) => {
  const graph2 = new graphlib$2.Graph({
    compound: true,
    multigraph: true
  });
  let i;
  let edgeFreeDoc = true;
  for (i = 0; i < doc2.length; i++) {
    if (doc2[i].stmt === "relation") {
      edgeFreeDoc = false;
      break;
    }
  }
  if (parentId)
    graph2.setGraph({
      rankdir: "LR",
      multigraph: true,
      compound: true,
      ranker: "tight-tree",
      ranksep: edgeFreeDoc ? 1 : conf$3.edgeLengthFactor,
      nodeSep: edgeFreeDoc ? 1 : 50,
      isMultiGraph: true
    });
  else {
    graph2.setGraph({
      rankdir: "TB",
      multigraph: true,
      compound: true,
      ranksep: edgeFreeDoc ? 1 : conf$3.edgeLengthFactor,
      nodeSep: edgeFreeDoc ? 1 : 50,
      ranker: "tight-tree",
      isMultiGraph: true
    });
  }
  graph2.setDefaultEdgeLabel(function() {
    return {};
  });
  diagObj.db.extract(doc2);
  const states = diagObj.db.getStates();
  const relations2 = diagObj.db.getRelations();
  const keys2 = Object.keys(states);
  for (let i2 = 0; i2 < keys2.length; i2++) {
    const stateDef = states[keys2[i2]];
    if (parentId) {
      stateDef.parentId = parentId;
    }
    let node2;
    if (stateDef.doc) {
      let sub = diagram.append("g").attr("id", stateDef.id).attr("class", "stateGroup");
      node2 = renderDoc(stateDef.doc, sub, stateDef.id, !altBkg, root2, domDocument, diagObj);
      {
        sub = addTitleAndBox(sub, stateDef, altBkg);
        let boxBounds = sub.node().getBBox();
        node2.width = boxBounds.width;
        node2.height = boxBounds.height + conf$3.padding / 2;
        transformationLog[stateDef.id] = { y: conf$3.compositTitleSize };
      }
    } else {
      node2 = drawState(diagram, stateDef);
    }
    if (stateDef.note) {
      const noteDef = {
        descriptions: [],
        id: stateDef.id + "-note",
        note: stateDef.note,
        type: "note"
      };
      const note2 = drawState(diagram, noteDef);
      if (stateDef.note.position === "left of") {
        graph2.setNode(node2.id + "-note", note2);
        graph2.setNode(node2.id, node2);
      } else {
        graph2.setNode(node2.id, node2);
        graph2.setNode(node2.id + "-note", note2);
      }
      graph2.setParent(node2.id, node2.id + "-group");
      graph2.setParent(node2.id + "-note", node2.id + "-group");
    } else {
      graph2.setNode(node2.id, node2);
    }
  }
  log$1.debug("Count=", graph2.nodeCount(), graph2);
  let cnt2 = 0;
  relations2.forEach(function(relation) {
    cnt2++;
    log$1.debug("Setting edge", relation);
    graph2.setEdge(
      relation.id1,
      relation.id2,
      {
        relation,
        width: getLabelWidth(relation.title),
        height: conf$3.labelHeight * common.getRows(relation.title).length,
        labelpos: "c"
      },
      "id" + cnt2
    );
  });
  dagre$1.layout(graph2);
  log$1.debug("Graph after layout", graph2.nodes());
  const svgElem = diagram.node();
  graph2.nodes().forEach(function(v) {
    if (typeof v !== "undefined" && typeof graph2.node(v) !== "undefined") {
      log$1.warn("Node " + v + ": " + JSON.stringify(graph2.node(v)));
      root2.select("#" + svgElem.id + " #" + v).attr(
        "transform",
        "translate(" + (graph2.node(v).x - graph2.node(v).width / 2) + "," + (graph2.node(v).y + (transformationLog[v] ? transformationLog[v].y : 0) - graph2.node(v).height / 2) + " )"
      );
      root2.select("#" + svgElem.id + " #" + v).attr("data-x-shift", graph2.node(v).x - graph2.node(v).width / 2);
      const dividers = domDocument.querySelectorAll("#" + svgElem.id + " #" + v + " .divider");
      dividers.forEach((divider2) => {
        const parent = divider2.parentElement;
        let pWidth = 0;
        let pShift = 0;
        if (parent) {
          if (parent.parentElement)
            pWidth = parent.parentElement.getBBox().width;
          pShift = parseInt(parent.getAttribute("data-x-shift"), 10);
          if (Number.isNaN(pShift)) {
            pShift = 0;
          }
        }
        divider2.setAttribute("x1", 0 - pShift + 8);
        divider2.setAttribute("x2", pWidth - pShift - 8);
      });
    } else {
      log$1.debug("No Node " + v + ": " + JSON.stringify(graph2.node(v)));
    }
  });
  let stateBox = svgElem.getBBox();
  graph2.edges().forEach(function(e) {
    if (typeof e !== "undefined" && typeof graph2.edge(e) !== "undefined") {
      log$1.debug("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(graph2.edge(e)));
      drawEdge(diagram, graph2.edge(e), graph2.edge(e).relation);
    }
  });
  stateBox = svgElem.getBBox();
  const stateInfo = {
    id: parentId ? parentId : "root",
    label: parentId ? parentId : "root",
    width: 0,
    height: 0
  };
  stateInfo.width = stateBox.width + 2 * conf$3.padding;
  stateInfo.height = stateBox.height + 2 * conf$3.padding;
  log$1.debug("Doc rendered", stateInfo, graph2);
  return stateInfo;
};
const stateRenderer = {
  setConf: setConf$3,
  draw: draw$3
};
const conf$2 = {};
const setConf$2 = function(cnf) {
  const keys2 = Object.keys(cnf);
  for (let i = 0; i < keys2.length; i++) {
    conf$2[keys2[i]] = cnf[keys2[i]];
  }
};
let nodeDb = {};
const getClasses = function(text2, diag) {
  log$1.trace("Extracting classes");
  diag.sb.clear();
  diag.parser.parse(text2);
  return diag.sb.getClasses();
};
const setupNode = (g2, parent, node2, altFlag) => {
  if (node2.id !== "root") {
    let shape = "rect";
    if (node2.start === true) {
      shape = "start";
    }
    if (node2.start === false) {
      shape = "end";
    }
    if (node2.type !== "default") {
      shape = node2.type;
    }
    if (!nodeDb[node2.id]) {
      nodeDb[node2.id] = {
        id: node2.id,
        shape,
        description: common.sanitizeText(node2.id, getConfig$1()),
        classes: "statediagram-state"
      };
    }
    if (node2.description) {
      if (Array.isArray(nodeDb[node2.id].description)) {
        nodeDb[node2.id].shape = "rectWithTitle";
        nodeDb[node2.id].description.push(node2.description);
      } else {
        if (nodeDb[node2.id].description.length > 0) {
          nodeDb[node2.id].shape = "rectWithTitle";
          if (nodeDb[node2.id].description === node2.id) {
            nodeDb[node2.id].description = [node2.description];
          } else {
            nodeDb[node2.id].description = [nodeDb[node2.id].description, node2.description];
          }
        } else {
          nodeDb[node2.id].shape = "rect";
          nodeDb[node2.id].description = node2.description;
        }
      }
      nodeDb[node2.id].description = common.sanitizeTextOrArray(
        nodeDb[node2.id].description,
        getConfig$1()
      );
    }
    if (nodeDb[node2.id].description.length === 1 && nodeDb[node2.id].shape === "rectWithTitle") {
      nodeDb[node2.id].shape = "rect";
    }
    if (!nodeDb[node2.id].type && node2.doc) {
      log$1.info("Setting cluster for ", node2.id, getDir(node2));
      nodeDb[node2.id].type = "group";
      nodeDb[node2.id].dir = getDir(node2);
      nodeDb[node2.id].shape = node2.type === "divider" ? "divider" : "roundedWithTitle";
      nodeDb[node2.id].classes = nodeDb[node2.id].classes + " " + (altFlag ? "statediagram-cluster statediagram-cluster-alt" : "statediagram-cluster");
    }
    const nodeData = {
      labelStyle: "",
      shape: nodeDb[node2.id].shape,
      labelText: nodeDb[node2.id].description,
      classes: nodeDb[node2.id].classes,
      style: "",
      id: node2.id,
      dir: nodeDb[node2.id].dir,
      domId: "state-" + node2.id + "-" + cnt,
      type: nodeDb[node2.id].type,
      padding: 15
    };
    if (node2.note) {
      const noteData = {
        labelStyle: "",
        shape: "note",
        labelText: node2.note.text,
        classes: "statediagram-note",
        style: "",
        id: node2.id + "----note-" + cnt,
        domId: "state-" + node2.id + "----note-" + cnt,
        type: nodeDb[node2.id].type,
        padding: 15
      };
      const groupData = {
        labelStyle: "",
        shape: "noteGroup",
        labelText: node2.note.text,
        classes: nodeDb[node2.id].classes,
        style: "",
        id: node2.id + "----parent",
        domId: "state-" + node2.id + "----parent-" + cnt,
        type: "group",
        padding: 0
      };
      cnt++;
      g2.setNode(node2.id + "----parent", groupData);
      g2.setNode(noteData.id, noteData);
      g2.setNode(node2.id, nodeData);
      g2.setParent(node2.id, node2.id + "----parent");
      g2.setParent(noteData.id, node2.id + "----parent");
      let from2 = node2.id;
      let to2 = noteData.id;
      if (node2.note.position === "left of") {
        from2 = noteData.id;
        to2 = node2.id;
      }
      g2.setEdge(from2, to2, {
        arrowhead: "none",
        arrowType: "",
        style: "fill:none",
        labelStyle: "",
        classes: "transition note-edge",
        arrowheadStyle: "fill: #333",
        labelpos: "c",
        labelType: "text",
        thickness: "normal"
      });
    } else {
      g2.setNode(node2.id, nodeData);
    }
  }
  if (parent) {
    if (parent.id !== "root") {
      log$1.trace("Setting node ", node2.id, " to be child of its parent ", parent.id);
      g2.setParent(node2.id, parent.id);
    }
  }
  if (node2.doc) {
    log$1.trace("Adding nodes children ");
    setupDoc(g2, node2, node2.doc, !altFlag);
  }
};
let cnt = 0;
const setupDoc = (g2, parent, doc2, altFlag) => {
  log$1.trace("items", doc2);
  doc2.forEach((item) => {
    if (item.stmt === "state" || item.stmt === "default") {
      setupNode(g2, parent, item, altFlag);
    } else if (item.stmt === "relation") {
      setupNode(g2, parent, item.state1, altFlag);
      setupNode(g2, parent, item.state2, altFlag);
      const edgeData = {
        id: "edge" + cnt,
        arrowhead: "normal",
        arrowTypeEnd: "arrow_barb",
        style: "fill:none",
        labelStyle: "",
        label: common.sanitizeText(item.description, getConfig$1()),
        arrowheadStyle: "fill: #333",
        labelpos: "c",
        labelType: "text",
        thickness: "normal",
        classes: "transition"
      };
      let startId = item.state1.id;
      let endId = item.state2.id;
      g2.setEdge(startId, endId, edgeData, cnt);
      cnt++;
    }
  });
};
const getDir = (nodes, defaultDir) => {
  let dir = defaultDir || "TB";
  if (nodes.doc) {
    for (let i = 0; i < nodes.doc.length; i++) {
      const node2 = nodes.doc[i];
      if (node2.stmt === "dir") {
        dir = node2.value;
      }
    }
  }
  return dir;
};
const draw$2 = function(text2, id2, _version, diag) {
  log$1.info("Drawing state diagram (v2)", id2);
  nodeDb = {};
  diag.db.getDirection();
  const { securityLevel, state: conf2 } = getConfig$1();
  const nodeSpacing = conf2.nodeSpacing || 50;
  const rankSpacing = conf2.rankSpacing || 50;
  log$1.info(diag.db.getRootDocV2());
  diag.db.extract(diag.db.getRootDocV2());
  log$1.info(diag.db.getRootDocV2());
  const g2 = new graphlib$2.Graph({
    multigraph: true,
    compound: true
  }).setGraph({
    rankdir: getDir(diag.db.getRootDocV2()),
    nodesep: nodeSpacing,
    ranksep: rankSpacing,
    marginx: 8,
    marginy: 8
  }).setDefaultEdgeLabel(function() {
    return {};
  });
  setupNode(g2, void 0, diag.db.getRootDocV2(), true);
  let sandboxElement;
  if (securityLevel === "sandbox") {
    sandboxElement = select$1("#i" + id2);
  }
  const root2 = securityLevel === "sandbox" ? select$1(sandboxElement.nodes()[0].contentDocument.body) : select$1("body");
  const svg2 = root2.select(`[id="${id2}"]`);
  const element = root2.select("#" + id2 + " g");
  render$1(element, g2, ["barb"], "statediagram", id2);
  const padding2 = 8;
  const bounds2 = svg2.node().getBBox();
  const width2 = bounds2.width + padding2 * 2;
  const height2 = bounds2.height + padding2 * 2;
  svg2.attr("class", "statediagram");
  const svgBounds = svg2.node().getBBox();
  configureSvgSize(svg2, height2, width2, conf2.useMaxWidth);
  const vBox = `${svgBounds.x - padding2} ${svgBounds.y - padding2} ${width2} ${height2}`;
  log$1.debug(`viewBox ${vBox}`);
  svg2.attr("viewBox", vBox);
  const labels = document.querySelectorAll('[id="' + id2 + '"] .edgeLabel .label');
  for (let k2 = 0; k2 < labels.length; k2++) {
    const label = labels[k2];
    const dim = label.getBBox();
    const rect2 = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rect2.setAttribute("rx", 0);
    rect2.setAttribute("ry", 0);
    rect2.setAttribute("width", dim.width);
    rect2.setAttribute("height", dim.height);
    label.insertBefore(rect2, label.firstChild);
  }
  addSVGAccessibilityFields(diag.db, svg2, id2);
};
const stateRendererV2 = {
  setConf: setConf$2,
  getClasses,
  draw: draw$2
};
var parser = function() {
  var o = function(k2, v, o2, l2) {
    for (o2 = o2 || {}, l2 = k2.length; l2--; o2[k2[l2]] = v)
      ;
    return o2;
  }, $V0 = [1, 2], $V1 = [1, 5], $V2 = [6, 9, 11, 17, 18, 20, 22, 23, 24, 26], $V3 = [1, 15], $V4 = [1, 16], $V5 = [1, 17], $V6 = [1, 18], $V7 = [1, 19], $V8 = [1, 20], $V9 = [1, 24], $Va = [4, 6, 9, 11, 17, 18, 20, 22, 23, 24, 26];
  var parser2 = {
    trace: function trace() {
    },
    yy: {},
    symbols_: { "error": 2, "start": 3, "journey": 4, "document": 5, "EOF": 6, "directive": 7, "line": 8, "SPACE": 9, "statement": 10, "NEWLINE": 11, "openDirective": 12, "typeDirective": 13, "closeDirective": 14, ":": 15, "argDirective": 16, "title": 17, "acc_title": 18, "acc_title_value": 19, "acc_descr": 20, "acc_descr_value": 21, "acc_descr_multiline_value": 22, "section": 23, "taskName": 24, "taskData": 25, "open_directive": 26, "type_directive": 27, "arg_directive": 28, "close_directive": 29, "$accept": 0, "$end": 1 },
    terminals_: { 2: "error", 4: "journey", 6: "EOF", 9: "SPACE", 11: "NEWLINE", 15: ":", 17: "title", 18: "acc_title", 19: "acc_title_value", 20: "acc_descr", 21: "acc_descr_value", 22: "acc_descr_multiline_value", 23: "section", 24: "taskName", 25: "taskData", 26: "open_directive", 27: "type_directive", 28: "arg_directive", 29: "close_directive" },
    productions_: [0, [3, 3], [3, 2], [5, 0], [5, 2], [8, 2], [8, 1], [8, 1], [8, 1], [7, 4], [7, 6], [10, 1], [10, 2], [10, 2], [10, 1], [10, 1], [10, 2], [10, 1], [12, 1], [13, 1], [16, 1], [14, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 1:
          return $$[$0 - 1];
        case 3:
          this.$ = [];
          break;
        case 4:
          $$[$0 - 1].push($$[$0]);
          this.$ = $$[$0 - 1];
          break;
        case 5:
        case 6:
          this.$ = $$[$0];
          break;
        case 7:
        case 8:
          this.$ = [];
          break;
        case 11:
          yy.setDiagramTitle($$[$0].substr(6));
          this.$ = $$[$0].substr(6);
          break;
        case 12:
          this.$ = $$[$0].trim();
          yy.setAccTitle(this.$);
          break;
        case 13:
        case 14:
          this.$ = $$[$0].trim();
          yy.setAccDescription(this.$);
          break;
        case 15:
          yy.addSection($$[$0].substr(8));
          this.$ = $$[$0].substr(8);
          break;
        case 16:
          yy.addTask($$[$0 - 1], $$[$0]);
          this.$ = "task";
          break;
        case 18:
          yy.parseDirective("%%{", "open_directive");
          break;
        case 19:
          yy.parseDirective($$[$0], "type_directive");
          break;
        case 20:
          $$[$0] = $$[$0].trim().replace(/'/g, '"');
          yy.parseDirective($$[$0], "arg_directive");
          break;
        case 21:
          yy.parseDirective("}%%", "close_directive", "journey");
          break;
      }
    },
    table: [{ 3: 1, 4: $V0, 7: 3, 12: 4, 26: $V1 }, { 1: [3] }, o($V2, [2, 3], { 5: 6 }), { 3: 7, 4: $V0, 7: 3, 12: 4, 26: $V1 }, { 13: 8, 27: [1, 9] }, { 27: [2, 18] }, { 6: [1, 10], 7: 21, 8: 11, 9: [1, 12], 10: 13, 11: [1, 14], 12: 4, 17: $V3, 18: $V4, 20: $V5, 22: $V6, 23: $V7, 24: $V8, 26: $V1 }, { 1: [2, 2] }, { 14: 22, 15: [1, 23], 29: $V9 }, o([15, 29], [2, 19]), o($V2, [2, 8], { 1: [2, 1] }), o($V2, [2, 4]), { 7: 21, 10: 25, 12: 4, 17: $V3, 18: $V4, 20: $V5, 22: $V6, 23: $V7, 24: $V8, 26: $V1 }, o($V2, [2, 6]), o($V2, [2, 7]), o($V2, [2, 11]), { 19: [1, 26] }, { 21: [1, 27] }, o($V2, [2, 14]), o($V2, [2, 15]), { 25: [1, 28] }, o($V2, [2, 17]), { 11: [1, 29] }, { 16: 30, 28: [1, 31] }, { 11: [2, 21] }, o($V2, [2, 5]), o($V2, [2, 12]), o($V2, [2, 13]), o($V2, [2, 16]), o($Va, [2, 9]), { 14: 32, 29: $V9 }, { 29: [2, 20] }, { 11: [1, 33] }, o($Va, [2, 10])],
    defaultActions: { 5: [2, 18], 7: [2, 2], 24: [2, 21], 31: [2, 20] },
    parseError: function parseError(str, hash2) {
      if (hash2.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash2;
        throw error;
      }
    },
    parse: function parse2(input) {
      var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k2 in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
          sharedState.yy[k2] = this.yy[k2];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges2 = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function lex() {
        var token2;
        token2 = tstack.pop() || lexer2.lex() || EOF2;
        if (typeof token2 !== "number") {
          if (token2 instanceof Array) {
            tstack = token2;
            token2 = tstack.pop();
          }
          token2 = self2.symbols_[token2] || token2;
        }
        return token2;
      }
      var symbol2, state, action, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack2[stack2.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol2 === null || typeof symbol2 == "undefined") {
            symbol2 = lex();
          }
          action = table[state] && table[state][symbol2];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push("'" + this.terminals_[p] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol2] || symbol2) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol2 == EOF2 ? "end of input" : "'" + (this.terminals_[symbol2] || symbol2) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol2] || symbol2,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol2);
        }
        switch (action[0]) {
          case 1:
            stack2.push(symbol2);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack2.push(action[1]);
            symbol2 = null;
            {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges2) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
              ];
            }
            r = this.performAction.apply(yyval, [
              yytext,
              yyleng,
              yylineno,
              sharedState.yy,
              action[1],
              vstack,
              lstack
            ].concat(args));
            if (typeof r !== "undefined") {
              return r;
            }
            if (len) {
              stack2 = stack2.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack2.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
            stack2.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash2) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash2);
        } else {
          throw new Error(str);
        }
      },
      setInput: function(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      input: function() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      unput: function(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      more: function() {
        this._more = true;
        return this;
      },
      reject: function() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      less: function(n) {
        this.unput(this.match.slice(n));
      },
      pastInput: function() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var next2 = this.match;
        if (next2.length < 20) {
          next2 += this._input.substr(0, 20 - next2.length);
        }
        return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var pre = this.pastInput();
        var c2 = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c2 + "^";
      },
      test_match: function(match, indexed_rule) {
        var token2, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token2) {
          return token2;
        } else if (this._backtrack) {
          for (var k2 in backup) {
            this[k2] = backup[k2];
          }
          return false;
        }
        return false;
      },
      next: function() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token2, match, tempMatch, index2;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index2 = i;
            if (this.options.backtrack_lexer) {
              token2 = this.test_match(tempMatch, rules[i]);
              if (token2 !== false) {
                return token2;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token2 = this.test_match(match, rules[index2]);
          if (token2 !== false) {
            return token2;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": true },
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        switch ($avoiding_name_collisions) {
          case 0:
            this.begin("open_directive");
            return 26;
          case 1:
            this.begin("type_directive");
            return 27;
          case 2:
            this.popState();
            this.begin("arg_directive");
            return 15;
          case 3:
            this.popState();
            this.popState();
            return 29;
          case 4:
            return 28;
          case 5:
            break;
          case 6:
            break;
          case 7:
            return 11;
          case 8:
            break;
          case 9:
            break;
          case 10:
            return 4;
          case 11:
            return 17;
          case 12:
            this.begin("acc_title");
            return 18;
          case 13:
            this.popState();
            return "acc_title_value";
          case 14:
            this.begin("acc_descr");
            return 20;
          case 15:
            this.popState();
            return "acc_descr_value";
          case 16:
            this.begin("acc_descr_multiline");
            break;
          case 17:
            this.popState();
            break;
          case 18:
            return "acc_descr_multiline_value";
          case 19:
            return 23;
          case 20:
            return 24;
          case 21:
            return 25;
          case 22:
            return 15;
          case 23:
            return 6;
          case 24:
            return "INVALID";
        }
      },
      rules: [/^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:#[^\n]*)/i, /^(?:journey\b)/i, /^(?:title\s[^#\n;]+)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:section\s[^#:\n;]+)/i, /^(?:[^#:\n;]+)/i, /^(?::[^#\n;]+)/i, /^(?::)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { "open_directive": { "rules": [1], "inclusive": false }, "type_directive": { "rules": [2, 3], "inclusive": false }, "arg_directive": { "rules": [3, 4], "inclusive": false }, "acc_descr_multiline": { "rules": [17, 18], "inclusive": false }, "acc_descr": { "rules": [15], "inclusive": false }, "acc_title": { "rules": [13], "inclusive": false }, "INITIAL": { "rules": [0, 5, 6, 7, 8, 9, 10, 11, 12, 14, 16, 19, 20, 21, 22, 23, 24], "inclusive": true } }
    };
    return lexer2;
  }();
  parser2.lexer = lexer;
  function Parser2() {
    this.yy = {};
  }
  Parser2.prototype = parser2;
  parser2.Parser = Parser2;
  return new Parser2();
}();
parser.parser = parser;
const journeyDetector = (txt) => {
  return txt.match(/^\s*journey/) !== null;
};
let currentSection = "";
const sections = [];
const tasks = [];
const rawTasks = [];
const parseDirective$1 = function(statement, context, type2) {
  mermaidAPI.parseDirective(this, statement, context, type2);
};
const clear = function() {
  sections.length = 0;
  tasks.length = 0;
  currentSection = "";
  rawTasks.length = 0;
  clear$g();
};
const addSection = function(txt) {
  currentSection = txt;
  sections.push(txt);
};
const getSections = function() {
  return sections;
};
const getTasks = function() {
  let allItemsProcessed = compileTasks();
  const maxDepth2 = 100;
  let iterationCount = 0;
  while (!allItemsProcessed && iterationCount < maxDepth2) {
    allItemsProcessed = compileTasks();
    iterationCount++;
  }
  tasks.push(...rawTasks);
  return tasks;
};
const updateActors = function() {
  const tempActors = [];
  tasks.forEach((task) => {
    if (task.people) {
      tempActors.push(...task.people);
    }
  });
  const unique = new Set(tempActors);
  return [...unique].sort();
};
const addTask = function(descr, taskData) {
  const pieces = taskData.substr(1).split(":");
  let score2 = 0;
  let peeps = [];
  if (pieces.length === 1) {
    score2 = Number(pieces[0]);
    peeps = [];
  } else {
    score2 = Number(pieces[0]);
    peeps = pieces[1].split(",");
  }
  const peopleList = peeps.map((s2) => s2.trim());
  const rawTask = {
    section: currentSection,
    type: currentSection,
    people: peopleList,
    task: descr,
    score: score2
  };
  rawTasks.push(rawTask);
};
const addTaskOrg = function(descr) {
  const newTask = {
    section: currentSection,
    type: currentSection,
    description: descr,
    task: descr,
    classes: []
  };
  tasks.push(newTask);
};
const compileTasks = function() {
  const compileTask = function(pos) {
    return rawTasks[pos].processed;
  };
  let allProcessed = true;
  for (let i = 0; i < rawTasks.length; i++) {
    compileTask(i);
    allProcessed = allProcessed && rawTasks[i].processed;
  }
  return allProcessed;
};
const getActors = function() {
  return updateActors();
};
const journeyDb = {
  parseDirective: parseDirective$1,
  getConfig: () => getConfig$1().journey,
  clear,
  setDiagramTitle,
  getDiagramTitle,
  setAccTitle,
  getAccTitle,
  setAccDescription,
  getAccDescription,
  addSection,
  getSections,
  getTasks,
  addTask,
  addTaskOrg,
  getActors
};
const drawRect = function(elem, rectData) {
  const rectElem = elem.append("rect");
  rectElem.attr("x", rectData.x);
  rectElem.attr("y", rectData.y);
  rectElem.attr("fill", rectData.fill);
  rectElem.attr("stroke", rectData.stroke);
  rectElem.attr("width", rectData.width);
  rectElem.attr("height", rectData.height);
  rectElem.attr("rx", rectData.rx);
  rectElem.attr("ry", rectData.ry);
  if (typeof rectData.class !== "undefined") {
    rectElem.attr("class", rectData.class);
  }
  return rectElem;
};
const drawFace = function(element, faceData) {
  const radius = 15;
  const circleElement = element.append("circle").attr("cx", faceData.cx).attr("cy", faceData.cy).attr("class", "face").attr("r", radius).attr("stroke-width", 2).attr("overflow", "visible");
  const face = element.append("g");
  face.append("circle").attr("cx", faceData.cx - radius / 3).attr("cy", faceData.cy - radius / 3).attr("r", 1.5).attr("stroke-width", 2).attr("fill", "#666").attr("stroke", "#666");
  face.append("circle").attr("cx", faceData.cx + radius / 3).attr("cy", faceData.cy - radius / 3).attr("r", 1.5).attr("stroke-width", 2).attr("fill", "#666").attr("stroke", "#666");
  function smile(face2) {
    const arc$1$1 = arc$1().startAngle(Math.PI / 2).endAngle(3 * (Math.PI / 2)).innerRadius(radius / 2).outerRadius(radius / 2.2);
    face2.append("path").attr("class", "mouth").attr("d", arc$1$1).attr("transform", "translate(" + faceData.cx + "," + (faceData.cy + 2) + ")");
  }
  function sad(face2) {
    const arc$1$1 = arc$1().startAngle(3 * Math.PI / 2).endAngle(5 * (Math.PI / 2)).innerRadius(radius / 2).outerRadius(radius / 2.2);
    face2.append("path").attr("class", "mouth").attr("d", arc$1$1).attr("transform", "translate(" + faceData.cx + "," + (faceData.cy + 7) + ")");
  }
  function ambivalent(face2) {
    face2.append("line").attr("class", "mouth").attr("stroke", 2).attr("x1", faceData.cx - 5).attr("y1", faceData.cy + 7).attr("x2", faceData.cx + 5).attr("y2", faceData.cy + 7).attr("class", "mouth").attr("stroke-width", "1px").attr("stroke", "#666");
  }
  if (faceData.score > 3) {
    smile(face);
  } else if (faceData.score < 3) {
    sad(face);
  } else {
    ambivalent(face);
  }
  return circleElement;
};
const drawCircle = function(element, circleData) {
  const circleElement = element.append("circle");
  circleElement.attr("cx", circleData.cx);
  circleElement.attr("cy", circleData.cy);
  circleElement.attr("class", "actor-" + circleData.pos);
  circleElement.attr("fill", circleData.fill);
  circleElement.attr("stroke", circleData.stroke);
  circleElement.attr("r", circleData.r);
  if (typeof circleElement.class !== "undefined") {
    circleElement.attr("class", circleElement.class);
  }
  if (typeof circleData.title !== "undefined") {
    circleElement.append("title").text(circleData.title);
  }
  return circleElement;
};
const drawText = function(elem, textData) {
  const nText = textData.text.replace(/<br\s*\/?>/gi, " ");
  const textElem = elem.append("text");
  textElem.attr("x", textData.x);
  textElem.attr("y", textData.y);
  textElem.attr("class", "legend");
  textElem.style("text-anchor", textData.anchor);
  if (typeof textData.class !== "undefined") {
    textElem.attr("class", textData.class);
  }
  const span = textElem.append("tspan");
  span.attr("x", textData.x + textData.textMargin * 2);
  span.text(nText);
  return textElem;
};
const drawLabel = function(elem, txtObject) {
  function genPoints(x2, y2, width2, height2, cut) {
    return x2 + "," + y2 + " " + (x2 + width2) + "," + y2 + " " + (x2 + width2) + "," + (y2 + height2 - cut) + " " + (x2 + width2 - cut * 1.2) + "," + (y2 + height2) + " " + x2 + "," + (y2 + height2);
  }
  const polygon = elem.append("polygon");
  polygon.attr("points", genPoints(txtObject.x, txtObject.y, 50, 20, 7));
  polygon.attr("class", "labelBox");
  txtObject.y = txtObject.y + txtObject.labelMargin;
  txtObject.x = txtObject.x + 0.5 * txtObject.labelMargin;
  drawText(elem, txtObject);
};
const drawSection = function(elem, section, conf2) {
  const g2 = elem.append("g");
  const rect2 = getNoteRect();
  rect2.x = section.x;
  rect2.y = section.y;
  rect2.fill = section.fill;
  rect2.width = conf2.width;
  rect2.height = conf2.height;
  rect2.class = "journey-section section-type-" + section.num;
  rect2.rx = 3;
  rect2.ry = 3;
  drawRect(g2, rect2);
  _drawTextCandidateFunc(conf2)(
    section.text,
    g2,
    rect2.x,
    rect2.y,
    rect2.width,
    rect2.height,
    { class: "journey-section section-type-" + section.num },
    conf2,
    section.colour
  );
};
let taskCount = -1;
const drawTask = function(elem, task, conf2) {
  const center2 = task.x + conf2.width / 2;
  const g2 = elem.append("g");
  taskCount++;
  const maxHeight = 300 + 5 * 30;
  g2.append("line").attr("id", "task" + taskCount).attr("x1", center2).attr("y1", task.y).attr("x2", center2).attr("y2", maxHeight).attr("class", "task-line").attr("stroke-width", "1px").attr("stroke-dasharray", "4 2").attr("stroke", "#666");
  drawFace(g2, {
    cx: center2,
    cy: 300 + (5 - task.score) * 30,
    score: task.score
  });
  const rect2 = getNoteRect();
  rect2.x = task.x;
  rect2.y = task.y;
  rect2.fill = task.fill;
  rect2.width = conf2.width;
  rect2.height = conf2.height;
  rect2.class = "task task-type-" + task.num;
  rect2.rx = 3;
  rect2.ry = 3;
  drawRect(g2, rect2);
  let xPos = task.x + 14;
  task.people.forEach((person) => {
    const colour = task.actors[person].color;
    const circle2 = {
      cx: xPos,
      cy: task.y,
      r: 7,
      fill: colour,
      stroke: "#000",
      title: person,
      pos: task.actors[person].position
    };
    drawCircle(g2, circle2);
    xPos += 10;
  });
  _drawTextCandidateFunc(conf2)(
    task.task,
    g2,
    rect2.x,
    rect2.y,
    rect2.width,
    rect2.height,
    { class: "task" },
    conf2,
    task.colour
  );
};
const drawBackgroundRect = function(elem, bounds2) {
  const rectElem = drawRect(elem, {
    x: bounds2.startx,
    y: bounds2.starty,
    width: bounds2.stopx - bounds2.startx,
    height: bounds2.stopy - bounds2.starty,
    fill: bounds2.fill,
    class: "rect"
  });
  rectElem.lower();
};
const getTextObj = function() {
  return {
    x: 0,
    y: 0,
    fill: void 0,
    "text-anchor": "start",
    width: 100,
    height: 100,
    textMargin: 0,
    rx: 0,
    ry: 0
  };
};
const getNoteRect = function() {
  return {
    x: 0,
    y: 0,
    width: 100,
    anchor: "start",
    height: 100,
    rx: 0,
    ry: 0
  };
};
const _drawTextCandidateFunc = function() {
  function byText(content2, g2, x2, y2, width2, height2, textAttrs, colour) {
    const text2 = g2.append("text").attr("x", x2 + width2 / 2).attr("y", y2 + height2 / 2 + 5).style("font-color", colour).style("text-anchor", "middle").text(content2);
    _setTextAttrs(text2, textAttrs);
  }
  function byTspan(content2, g2, x2, y2, width2, height2, textAttrs, conf2, colour) {
    const { taskFontSize, taskFontFamily } = conf2;
    const lines = content2.split(/<br\s*\/?>/gi);
    for (let i = 0; i < lines.length; i++) {
      const dy = i * taskFontSize - taskFontSize * (lines.length - 1) / 2;
      const text2 = g2.append("text").attr("x", x2 + width2 / 2).attr("y", y2).attr("fill", colour).style("text-anchor", "middle").style("font-size", taskFontSize).style("font-family", taskFontFamily);
      text2.append("tspan").attr("x", x2 + width2 / 2).attr("dy", dy).text(lines[i]);
      text2.attr("y", y2 + height2 / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central");
      _setTextAttrs(text2, textAttrs);
    }
  }
  function byFo(content2, g2, x2, y2, width2, height2, textAttrs, conf2) {
    const body = g2.append("switch");
    const f2 = body.append("foreignObject").attr("x", x2).attr("y", y2).attr("width", width2).attr("height", height2).attr("position", "fixed");
    const text2 = f2.append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    text2.append("div").attr("class", "label").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(content2);
    byTspan(content2, body, x2, y2, width2, height2, textAttrs, conf2);
    _setTextAttrs(text2, textAttrs);
  }
  function _setTextAttrs(toText, fromTextAttrsDict) {
    for (const key in fromTextAttrsDict) {
      if (key in fromTextAttrsDict) {
        toText.attr(key, fromTextAttrsDict[key]);
      }
    }
  }
  return function(conf2) {
    return conf2.textPlacement === "fo" ? byFo : conf2.textPlacement === "old" ? byText : byTspan;
  };
}();
const initGraphics = function(graphics) {
  graphics.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 5).attr("refY", 2).attr("markerWidth", 6).attr("markerHeight", 4).attr("orient", "auto").append("path").attr("d", "M 0,0 V 4 L6,2 Z");
};
const svgDraw = {
  drawRect,
  drawCircle,
  drawSection,
  drawText,
  drawLabel,
  drawTask,
  drawBackgroundRect,
  getTextObj,
  getNoteRect,
  initGraphics
};
const setConf$1 = function(cnf) {
  const keys2 = Object.keys(cnf);
  keys2.forEach(function(key) {
    conf$1[key] = cnf[key];
  });
};
const actors = {};
function drawActorLegend(diagram) {
  const conf2 = getConfig$1().journey;
  let yPos = 60;
  Object.keys(actors).forEach((person) => {
    const colour = actors[person].color;
    const circleData = {
      cx: 20,
      cy: yPos,
      r: 7,
      fill: colour,
      stroke: "#000",
      pos: actors[person].position
    };
    svgDraw.drawCircle(diagram, circleData);
    const labelData = {
      x: 40,
      y: yPos + 7,
      fill: "#666",
      text: person,
      textMargin: conf2.boxTextMargin | 5
    };
    svgDraw.drawText(diagram, labelData);
    yPos += 20;
  });
}
const conf$1 = getConfig$1().journey;
const LEFT_MARGIN = conf$1.leftMargin;
const draw$1 = function(text2, id2, version2, diagObj) {
  const conf2 = getConfig$1().journey;
  diagObj.db.clear();
  diagObj.parser.parse(text2 + "\n");
  const securityLevel = getConfig$1().securityLevel;
  let sandboxElement;
  if (securityLevel === "sandbox") {
    sandboxElement = select$1("#i" + id2);
  }
  const root2 = securityLevel === "sandbox" ? select$1(sandboxElement.nodes()[0].contentDocument.body) : select$1("body");
  bounds.init();
  const diagram = root2.select("#" + id2);
  svgDraw.initGraphics(diagram);
  const tasks2 = diagObj.db.getTasks();
  const title2 = diagObj.db.getDiagramTitle();
  const actorNames = diagObj.db.getActors();
  for (const member in actors)
    delete actors[member];
  let actorPos = 0;
  actorNames.forEach((actorName) => {
    actors[actorName] = {
      color: conf2.actorColours[actorPos % conf2.actorColours.length],
      position: actorPos
    };
    actorPos++;
  });
  drawActorLegend(diagram);
  bounds.insert(0, 0, LEFT_MARGIN, Object.keys(actors).length * 50);
  drawTasks(diagram, tasks2, 0);
  const box = bounds.getBounds();
  if (title2) {
    diagram.append("text").text(title2).attr("x", LEFT_MARGIN).attr("font-size", "4ex").attr("font-weight", "bold").attr("y", 25);
  }
  const height2 = box.stopy - box.starty + 2 * conf2.diagramMarginY;
  const width2 = LEFT_MARGIN + box.stopx + 2 * conf2.diagramMarginX;
  configureSvgSize(diagram, height2, width2, conf2.useMaxWidth);
  diagram.append("line").attr("x1", LEFT_MARGIN).attr("y1", conf2.height * 4).attr("x2", width2 - LEFT_MARGIN - 4).attr("y2", conf2.height * 4).attr("stroke-width", 4).attr("stroke", "black").attr("marker-end", "url(#arrowhead)");
  const extraVertForTitle = title2 ? 70 : 0;
  diagram.attr("viewBox", `${box.startx} -25 ${width2} ${height2 + extraVertForTitle}`);
  diagram.attr("preserveAspectRatio", "xMinYMin meet");
  diagram.attr("height", height2 + extraVertForTitle + 25);
  addSVGAccessibilityFields(diagObj.db, diagram, id2);
};
const bounds = {
  data: {
    startx: void 0,
    stopx: void 0,
    starty: void 0,
    stopy: void 0
  },
  verticalPos: 0,
  sequenceItems: [],
  init: function() {
    this.sequenceItems = [];
    this.data = {
      startx: void 0,
      stopx: void 0,
      starty: void 0,
      stopy: void 0
    };
    this.verticalPos = 0;
  },
  updateVal: function(obj, key, val, fun) {
    if (typeof obj[key] === "undefined") {
      obj[key] = val;
    } else {
      obj[key] = fun(val, obj[key]);
    }
  },
  updateBounds: function(startx, starty, stopx, stopy) {
    const conf2 = getConfig$1().journey;
    const _self = this;
    let cnt2 = 0;
    function updateFn(type2) {
      return function updateItemBounds(item) {
        cnt2++;
        const n = _self.sequenceItems.length - cnt2 + 1;
        _self.updateVal(item, "starty", starty - n * conf2.boxMargin, Math.min);
        _self.updateVal(item, "stopy", stopy + n * conf2.boxMargin, Math.max);
        _self.updateVal(bounds.data, "startx", startx - n * conf2.boxMargin, Math.min);
        _self.updateVal(bounds.data, "stopx", stopx + n * conf2.boxMargin, Math.max);
        if (!(type2 === "activation")) {
          _self.updateVal(item, "startx", startx - n * conf2.boxMargin, Math.min);
          _self.updateVal(item, "stopx", stopx + n * conf2.boxMargin, Math.max);
          _self.updateVal(bounds.data, "starty", starty - n * conf2.boxMargin, Math.min);
          _self.updateVal(bounds.data, "stopy", stopy + n * conf2.boxMargin, Math.max);
        }
      };
    }
    this.sequenceItems.forEach(updateFn());
  },
  insert: function(startx, starty, stopx, stopy) {
    const _startx = Math.min(startx, stopx);
    const _stopx = Math.max(startx, stopx);
    const _starty = Math.min(starty, stopy);
    const _stopy = Math.max(starty, stopy);
    this.updateVal(bounds.data, "startx", _startx, Math.min);
    this.updateVal(bounds.data, "starty", _starty, Math.min);
    this.updateVal(bounds.data, "stopx", _stopx, Math.max);
    this.updateVal(bounds.data, "stopy", _stopy, Math.max);
    this.updateBounds(_startx, _starty, _stopx, _stopy);
  },
  bumpVerticalPos: function(bump) {
    this.verticalPos = this.verticalPos + bump;
    this.data.stopy = this.verticalPos;
  },
  getVerticalPos: function() {
    return this.verticalPos;
  },
  getBounds: function() {
    return this.data;
  }
};
const fills = conf$1.sectionFills;
const textColours = conf$1.sectionColours;
const drawTasks = function(diagram, tasks2, verticalPos) {
  const conf2 = getConfig$1().journey;
  let lastSection = "";
  const sectionVHeight = conf2.height * 2 + conf2.diagramMarginY;
  const taskPos = verticalPos + sectionVHeight;
  let sectionNumber = 0;
  let fill = "#CCC";
  let colour = "black";
  let num = 0;
  for (let i = 0; i < tasks2.length; i++) {
    const task = tasks2[i];
    if (lastSection !== task.section) {
      fill = fills[sectionNumber % fills.length];
      num = sectionNumber % fills.length;
      colour = textColours[sectionNumber % textColours.length];
      const section = {
        x: i * conf2.taskMargin + i * conf2.width + LEFT_MARGIN,
        y: 50,
        text: task.section,
        fill,
        num,
        colour
      };
      svgDraw.drawSection(diagram, section, conf2);
      lastSection = task.section;
      sectionNumber++;
    }
    const taskActors = task.people.reduce((acc, actorName) => {
      if (actors[actorName]) {
        acc[actorName] = actors[actorName];
      }
      return acc;
    }, {});
    task.x = i * conf2.taskMargin + i * conf2.width + LEFT_MARGIN;
    task.y = taskPos;
    task.width = conf2.diagramMarginX;
    task.height = conf2.diagramMarginY;
    task.colour = colour;
    task.fill = fill;
    task.num = num;
    task.actors = taskActors;
    svgDraw.drawTask(diagram, task, conf2);
    bounds.insert(task.x, task.y, task.x + task.width + conf2.taskMargin, 300 + 5 * 30);
  }
};
const journeyRenderer = {
  setConf: setConf$1,
  draw: draw$1
};
let conf = {};
const setConf = function(cnf) {
  conf = { ...conf, ...cnf };
};
const draw = (text2, id2, mermaidVersion) => {
  try {
    log$1.debug("Renering svg for syntax error\n");
    const svg2 = select$1("#" + id2);
    const g2 = svg2.append("g");
    g2.append("path").attr("class", "error-icon").attr(
      "d",
      "m411.313,123.313c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32-9.375,9.375-20.688-20.688c-12.484-12.5-32.766-12.5-45.25,0l-16,16c-1.261,1.261-2.304,2.648-3.31,4.051-21.739-8.561-45.324-13.426-70.065-13.426-105.867,0-192,86.133-192,192s86.133,192 192,192 192-86.133 192-192c0-24.741-4.864-48.327-13.426-70.065 1.402-1.007 2.79-2.049 4.051-3.31l16-16c12.5-12.492 12.5-32.758 0-45.25l-20.688-20.688 9.375-9.375 32.001-31.999zm-219.313,100.687c-52.938,0-96,43.063-96,96 0,8.836-7.164,16-16,16s-16-7.164-16-16c0-70.578 57.422-128 128-128 8.836,0 16,7.164 16,16s-7.164,16-16,16z"
    );
    g2.append("path").attr("class", "error-icon").attr(
      "d",
      "m459.02,148.98c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l16,16c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16.001-16z"
    );
    g2.append("path").attr("class", "error-icon").attr(
      "d",
      "m340.395,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16-16c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l15.999,16z"
    );
    g2.append("path").attr("class", "error-icon").attr(
      "d",
      "m400,64c8.844,0 16-7.164 16-16v-32c0-8.836-7.156-16-16-16-8.844,0-16,7.164-16,16v32c0,8.836 7.156,16 16,16z"
    );
    g2.append("path").attr("class", "error-icon").attr(
      "d",
      "m496,96.586h-32c-8.844,0-16,7.164-16,16 0,8.836 7.156,16 16,16h32c8.844,0 16-7.164 16-16 0-8.836-7.156-16-16-16z"
    );
    g2.append("path").attr("class", "error-icon").attr(
      "d",
      "m436.98,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688l32-32c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32c-6.251,6.25-6.251,16.375-0.001,22.625z"
    );
    g2.append("text").attr("class", "error-text").attr("x", 1440).attr("y", 250).attr("font-size", "150px").style("text-anchor", "middle").text("Syntax error in graph");
    g2.append("text").attr("class", "error-text").attr("x", 1250).attr("y", 400).attr("font-size", "100px").style("text-anchor", "middle").text("mermaid version " + mermaidVersion);
    svg2.attr("height", 100);
    svg2.attr("width", 500);
    svg2.attr("viewBox", "768 0 912 512");
  } catch (e) {
    log$1.error("Error while rendering info diagram");
    log$1.error(getErrorMessage(e));
  }
};
const errorRenderer = {
  setConf,
  draw
};
let hasLoadedDiagrams = false;
const addDiagrams = () => {
  if (hasLoadedDiagrams) {
    return;
  }
  hasLoadedDiagrams = true;
  registerDiagram(
    "error",
    {
      db: {
        clear: () => {
        }
      },
      styles: getStyles$b,
      renderer: errorRenderer,
      parser: {
        parser: { yy: {} },
        parse: () => {
        }
      },
      init: () => {
      }
    },
    (text2) => text2.toLowerCase().trim() === "error"
  );
  registerDiagram(
    "c4",
    {
      parser: parser$a,
      db: c4Db,
      renderer: c4Renderer,
      styles: getStyles$2,
      init: (cnf) => {
        c4Renderer.setConf(cnf.c4);
      }
    },
    c4Detector
  );
  registerDiagram(
    "class",
    {
      parser: parser$9,
      db: classDb,
      renderer: classRenderer,
      styles: getStyles$d,
      init: (cnf) => {
        if (!cnf.class) {
          cnf.class = {};
        }
        cnf.class.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
        classDb.clear();
      }
    },
    classDetector
  );
  registerDiagram(
    "classDiagram",
    {
      parser: parser$9,
      db: classDb,
      renderer: classRendererV2,
      styles: getStyles$d,
      init: (cnf) => {
        if (!cnf.class) {
          cnf.class = {};
        }
        cnf.class.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
        classDb.clear();
      }
    },
    classDetectorV2
  );
  registerDiagram(
    "er",
    {
      parser: parser$8,
      db: erDb,
      renderer: erRenderer,
      styles: getStyles$c
    },
    erDetector
  );
  registerDiagram(
    "gantt",
    {
      parser: parser$6,
      db: ganttDb,
      renderer: ganttRenderer,
      styles: getStyles$9
    },
    ganttDetector
  );
  registerDiagram(
    "info",
    {
      parser: parser$5,
      db: infoDb,
      renderer: infoRenderer,
      styles: getStyles$8
    },
    infoDetector
  );
  registerDiagram(
    "pie",
    {
      parser: parser$4,
      db: pieDb,
      renderer: pieRenderer,
      styles: getStyles$7
    },
    pieDetector
  );
  registerDiagram(
    "requirement",
    {
      parser: parser$3,
      db: requirementDb,
      renderer: requirementRenderer,
      styles: getStyles$6
    },
    requirementDetector
  );
  registerDiagram(
    "sequence",
    {
      parser: parser$2,
      db: sequenceDb,
      renderer: sequenceRenderer,
      styles: getStyles$5,
      init: (cnf) => {
        if (!cnf.sequence) {
          cnf.sequence = {};
        }
        cnf.sequence.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
        if ("sequenceDiagram" in cnf) {
          throw new Error(
            "`mermaid config.sequenceDiagram` has been renamed to `config.sequence`. Please update your mermaid config."
          );
        }
        sequenceDb.setWrap(cnf.wrap);
        sequenceRenderer.setConf(cnf.sequence);
      }
    },
    sequenceDetector
  );
  registerDiagram(
    "state",
    {
      parser: parser$1,
      db: stateDb,
      renderer: stateRenderer,
      styles: getStyles$4,
      init: (cnf) => {
        if (!cnf.state) {
          cnf.state = {};
        }
        cnf.state.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
        stateDb.clear();
      }
    },
    stateDetector
  );
  registerDiagram(
    "stateDiagram",
    {
      parser: parser$1,
      db: stateDb,
      renderer: stateRendererV2,
      styles: getStyles$4,
      init: (cnf) => {
        if (!cnf.state) {
          cnf.state = {};
        }
        cnf.state.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
        stateDb.clear();
      }
    },
    stateDetectorV2
  );
  registerDiagram(
    "journey",
    {
      parser,
      db: journeyDb,
      renderer: journeyRenderer,
      styles: getStyles$3,
      init: (cnf) => {
        journeyRenderer.setConf(cnf.journey);
        journeyDb.clear();
      }
    },
    journeyDetector
  );
  registerDiagram(
    "flowchart",
    {
      parser: parser$7,
      db: flowDb,
      renderer: flowRendererV2,
      styles: getStyles$a,
      init: (cnf) => {
        if (!cnf.flowchart) {
          cnf.flowchart = {};
        }
        cnf.flowchart.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
        flowRenderer.setConf(cnf.flowchart);
        flowDb.clear();
        flowDb.setGen("gen-1");
      }
    },
    flowDetector
  );
  registerDiagram(
    "flowchart-v2",
    {
      parser: parser$7,
      db: flowDb,
      renderer: flowRendererV2,
      styles: getStyles$a,
      init: (cnf) => {
        if (!cnf.flowchart) {
          cnf.flowchart = {};
        }
        cnf.flowchart.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
        setConfig({ flowchart: { arrowMarkerAbsolute: cnf.arrowMarkerAbsolute } });
        flowRendererV2.setConf(cnf.flowchart);
        flowDb.clear();
        flowDb.setGen("gen-2");
      }
    },
    flowDetectorV2
  );
  registerDiagram(
    "gitGraph",
    { parser: parser$b, db: gitGraphDb, renderer: gitGraphRenderer, styles: getStyles },
    gitGraphDetector
  );
};
class Diagram {
  constructor(txt, parseError) {
    __publicField(this, "type", "graph");
    __publicField(this, "parser");
    __publicField(this, "renderer");
    __publicField(this, "db");
    __publicField(this, "detectTypeFailed", false);
    var _a2, _b;
    this.txt = txt;
    const cnf = getConfig$1();
    this.txt = txt;
    try {
      this.type = detectType(txt, cnf);
    } catch (e) {
      this.handleError(e, parseError);
      this.type = "error";
      this.detectTypeFailed = true;
    }
    const diagram = getDiagram(this.type);
    log$1.debug("Type " + this.type);
    this.db = diagram.db;
    (_b = (_a2 = this.db).clear) == null ? void 0 : _b.call(_a2);
    this.renderer = diagram.renderer;
    this.parser = diagram.parser;
    this.parser.parser.yy = this.db;
    if (diagram.init) {
      diagram.init(cnf);
      log$1.debug("Initialized diagram " + this.type, cnf);
    }
    this.txt += "\n";
    this.parse(this.txt, parseError);
  }
  parse(text2, parseError) {
    if (this.detectTypeFailed) {
      return false;
    }
    try {
      text2 = text2 + "\n";
      this.db.clear();
      this.parser.parse(text2);
      return true;
    } catch (error) {
      this.handleError(error, parseError);
    }
    return false;
  }
  handleError(error, parseError) {
    if (parseError) {
      if (isDetailedError(error)) {
        parseError(error.str, error.hash);
      } else {
        parseError(error);
      }
    } else {
      throw error;
    }
  }
  getParser() {
    return this.parser;
  }
  getType() {
    return this.type;
  }
}
const getDiagramFromText = (txt, parseError) => {
  const type2 = detectType(txt, getConfig$1());
  try {
    getDiagram(type2);
    return new Diagram(txt, parseError);
  } catch (error) {
    if (!(error instanceof DiagramNotFoundError)) {
      log$1.error(error);
      throw error;
    }
    const loader = getDiagramLoader(type2);
    if (!loader) {
      throw new Error(`Loader for ${type2} not found.`);
    }
    return loader().then(({ diagram }) => {
      registerDiagram(type2, diagram, void 0, diagram.injectUtils);
      return new Diagram(txt, parseError);
    });
  }
};
function parse$1(text2, parseError) {
  addDiagrams();
  const diagram = new Diagram(text2, parseError);
  return diagram.parse(text2, parseError);
}
async function parseAsync$1(text2, parseError) {
  addDiagrams();
  const diagram = await getDiagramFromText(text2, parseError);
  return diagram.parse(text2, parseError);
}
const encodeEntities = function(text2) {
  let txt = text2;
  txt = txt.replace(/style.*:\S*#.*;/g, function(s2) {
    const innerTxt = s2.substring(0, s2.length - 1);
    return innerTxt;
  });
  txt = txt.replace(/classDef.*:\S*#.*;/g, function(s2) {
    const innerTxt = s2.substring(0, s2.length - 1);
    return innerTxt;
  });
  txt = txt.replace(/#\w+;/g, function(s2) {
    const innerTxt = s2.substring(1, s2.length - 1);
    const isInt = /^\+?\d+$/.test(innerTxt);
    if (isInt) {
      return "\uFB02\xB0\xB0" + innerTxt + "\xB6\xDF";
    } else {
      return "\uFB02\xB0" + innerTxt + "\xB6\xDF";
    }
  });
  return txt;
};
const decodeEntities = function(text2) {
  let txt = text2;
  txt = txt.replace(/ﬂ°°/g, function() {
    return "&#";
  });
  txt = txt.replace(/ﬂ°/g, function() {
    return "&";
  });
  txt = txt.replace(/¶ß/g, function() {
    return ";";
  });
  return txt;
};
const render = function(id2, text2, cb, container) {
  var _a2;
  addDiagrams();
  reset();
  text2 = text2.replace(/\r\n?/g, "\n");
  const graphInit = utils.detectInit(text2);
  if (graphInit) {
    directiveSanitizer(graphInit);
    addDirective(graphInit);
  }
  const cnf = getConfig$1();
  log$1.debug(cnf);
  if (text2.length > cnf.maxTextSize) {
    text2 = "graph TB;a[Maximum text size in diagram exceeded];style a fill:#faa";
  }
  let root2 = select$1("body");
  if (typeof container !== "undefined") {
    if (container) {
      container.innerHTML = "";
    }
    if (cnf.securityLevel === "sandbox") {
      const iframe = select$1(container).append("iframe").attr("id", "i" + id2).attr("style", "width: 100%; height: 100%;").attr("sandbox", "");
      root2 = select$1(iframe.nodes()[0].contentDocument.body);
      root2.node().style.margin = 0;
    } else {
      root2 = select$1(container);
    }
    root2.append("div").attr("id", "d" + id2).attr("style", "font-family: " + cnf.fontFamily).append("svg").attr("id", id2).attr("width", "100%").attr("xmlns", "http://www.w3.org/2000/svg").attr("xmlns:xlink", "http://www.w3.org/1999/xlink").append("g");
  } else {
    const existingSvg = document.getElementById(id2);
    if (existingSvg) {
      existingSvg.remove();
    }
    let element2;
    if (cnf.securityLevel === "sandbox") {
      element2 = document.querySelector("#i" + id2);
    } else {
      element2 = document.querySelector("#d" + id2);
    }
    if (element2) {
      element2.remove();
    }
    if (cnf.securityLevel === "sandbox") {
      const iframe = select$1("body").append("iframe").attr("id", "i" + id2).attr("style", "width: 100%; height: 100%;").attr("sandbox", "");
      root2 = select$1(iframe.nodes()[0].contentDocument.body);
      root2.node().style.margin = 0;
    } else {
      root2 = select$1("body");
    }
    root2.append("div").attr("id", "d" + id2).append("svg").attr("id", id2).attr("width", "100%").attr("xmlns", "http://www.w3.org/2000/svg").append("g");
  }
  text2 = encodeEntities(text2);
  let diag;
  let parseEncounteredException;
  try {
    diag = getDiagramFromText(text2);
    if ("then" in diag) {
      throw new Error("Diagram is a promise");
    }
  } catch (error) {
    diag = new Diagram("error");
    parseEncounteredException = error;
  }
  const element = root2.select("#d" + id2).node();
  const graphType = diag.type;
  const svg2 = element.firstChild;
  const firstChild = svg2.firstChild;
  let userStyles = "";
  if (cnf.themeCSS !== void 0) {
    userStyles += `
${cnf.themeCSS}`;
  }
  if (cnf.fontFamily !== void 0) {
    userStyles += `
:root { --mermaid-font-family: ${cnf.fontFamily}}`;
  }
  if (cnf.altFontFamily !== void 0) {
    userStyles += `
:root { --mermaid-alt-font-family: ${cnf.altFontFamily}}`;
  }
  if (graphType === "flowchart" || graphType === "flowchart-v2" || graphType === "graph") {
    const classes2 = flowRenderer.getClasses(text2, diag);
    const htmlLabels = cnf.htmlLabels || ((_a2 = cnf.flowchart) == null ? void 0 : _a2.htmlLabels);
    for (const className2 in classes2) {
      if (htmlLabels) {
        userStyles += `
.${className2} > * { ${classes2[className2].styles.join(
          " !important; "
        )} !important; }`;
        userStyles += `
.${className2} span { ${classes2[className2].styles.join(
          " !important; "
        )} !important; }`;
      } else {
        userStyles += `
.${className2} path { ${classes2[className2].styles.join(
          " !important; "
        )} !important; }`;
        userStyles += `
.${className2} rect { ${classes2[className2].styles.join(
          " !important; "
        )} !important; }`;
        userStyles += `
.${className2} polygon { ${classes2[className2].styles.join(
          " !important; "
        )} !important; }`;
        userStyles += `
.${className2} ellipse { ${classes2[className2].styles.join(
          " !important; "
        )} !important; }`;
        userStyles += `
.${className2} circle { ${classes2[className2].styles.join(
          " !important; "
        )} !important; }`;
        if (classes2[className2].textStyles) {
          userStyles += `
.${className2} tspan { ${classes2[className2].textStyles.join(
            " !important; "
          )} !important; }`;
        }
      }
    }
  }
  const stylis = (selector2, styles) => serialize(compile(`${selector2}{${styles}}`), stringify);
  const rules = stylis(`#${id2}`, getStyles$1(graphType, userStyles, cnf.themeVariables));
  const style1 = document.createElement("style");
  style1.innerHTML = `#${id2} ` + rules;
  svg2.insertBefore(style1, firstChild);
  try {
    diag.renderer.draw(text2, id2, pkg.version, diag);
  } catch (e) {
    errorRenderer.draw(text2, id2, pkg.version);
    throw e;
  }
  root2.select(`[id="${id2}"]`).selectAll("foreignobject > *").attr("xmlns", "http://www.w3.org/1999/xhtml");
  let svgCode = root2.select("#d" + id2).node().innerHTML;
  log$1.debug("cnf.arrowMarkerAbsolute", cnf.arrowMarkerAbsolute);
  if (!evaluate(cnf.arrowMarkerAbsolute) && cnf.securityLevel !== "sandbox") {
    svgCode = svgCode.replace(/marker-end="url\(.*?#/g, 'marker-end="url(#', "g");
  }
  svgCode = decodeEntities(svgCode);
  svgCode = svgCode.replace(/<br>/g, "<br/>");
  if (cnf.securityLevel === "sandbox") {
    const svgEl = root2.select("#d" + id2 + " svg").node();
    const width2 = "100%";
    let height2 = "100%";
    if (svgEl) {
      height2 = svgEl.viewBox.baseVal.height + "px";
    }
    svgCode = `<iframe style="width:${width2};height:${height2};border:0;margin:0;" src="data:text/html;base64,${btoa(
      '<body style="margin:0">' + svgCode + "</body>"
    )}" sandbox="allow-top-navigation-by-user-activation allow-popups">
  The \u201Ciframe\u201D tag is not supported by your browser.
</iframe>`;
  } else {
    if (cnf.securityLevel !== "loose") {
      svgCode = purify.sanitize(svgCode, {
        ADD_TAGS: ["foreignobject"],
        ADD_ATTR: ["dominant-baseline"]
      });
    }
  }
  if (typeof cb !== "undefined") {
    switch (graphType) {
      case "flowchart":
      case "flowchart-v2":
        cb(svgCode, flowDb.bindFunctions);
        break;
      case "gantt":
        cb(svgCode, ganttDb.bindFunctions);
        break;
      case "class":
      case "classDiagram":
        cb(svgCode, classDb.bindFunctions);
        break;
      default:
        cb(svgCode);
    }
  } else {
    log$1.debug("CB = undefined!");
  }
  attachFunctions();
  const tmpElementSelector = cnf.securityLevel === "sandbox" ? "#i" + id2 : "#d" + id2;
  const node2 = select$1(tmpElementSelector).node();
  if (node2 && "remove" in node2) {
    node2.remove();
  }
  if (parseEncounteredException) {
    throw parseEncounteredException;
  }
  return svgCode;
};
const renderAsync$1 = async function(id2, text2, cb, container) {
  var _a2;
  addDiagrams();
  reset();
  text2 = text2.replace(/\r\n?/g, "\n");
  const graphInit = utils.detectInit(text2);
  if (graphInit) {
    directiveSanitizer(graphInit);
    addDirective(graphInit);
  }
  const cnf = getConfig$1();
  log$1.debug(cnf);
  if (text2.length > cnf.maxTextSize) {
    text2 = "graph TB;a[Maximum text size in diagram exceeded];style a fill:#faa";
  }
  let root2 = select$1("body");
  if (typeof container !== "undefined") {
    if (container) {
      container.innerHTML = "";
    }
    if (cnf.securityLevel === "sandbox") {
      const iframe = select$1(container).append("iframe").attr("id", "i" + id2).attr("style", "width: 100%; height: 100%;").attr("sandbox", "");
      root2 = select$1(iframe.nodes()[0].contentDocument.body);
      root2.node().style.margin = 0;
    } else {
      root2 = select$1(container);
    }
    root2.append("div").attr("id", "d" + id2).attr("style", "font-family: " + cnf.fontFamily).append("svg").attr("id", id2).attr("width", "100%").attr("xmlns", "http://www.w3.org/2000/svg").attr("xmlns:xlink", "http://www.w3.org/1999/xlink").append("g");
  } else {
    const existingSvg = document.getElementById(id2);
    if (existingSvg) {
      existingSvg.remove();
    }
    let element2;
    if (cnf.securityLevel === "sandbox") {
      element2 = document.querySelector("#i" + id2);
    } else {
      element2 = document.querySelector("#d" + id2);
    }
    if (element2) {
      element2.remove();
    }
    if (cnf.securityLevel === "sandbox") {
      const iframe = select$1("body").append("iframe").attr("id", "i" + id2).attr("style", "width: 100%; height: 100%;").attr("sandbox", "");
      root2 = select$1(iframe.nodes()[0].contentDocument.body);
      root2.node().style.margin = 0;
    } else {
      root2 = select$1("body");
    }
    root2.append("div").attr("id", "d" + id2).append("svg").attr("id", id2).attr("width", "100%").attr("xmlns", "http://www.w3.org/2000/svg").append("g");
  }
  text2 = encodeEntities(text2);
  let diag;
  let parseEncounteredException;
  try {
    diag = await getDiagramFromText(text2);
  } catch (error) {
    diag = new Diagram("error");
    parseEncounteredException = error;
  }
  const element = root2.select("#d" + id2).node();
  const graphType = diag.type;
  const svg2 = element.firstChild;
  const firstChild = svg2.firstChild;
  let userStyles = "";
  if (cnf.themeCSS !== void 0) {
    userStyles += `
${cnf.themeCSS}`;
  }
  if (cnf.fontFamily !== void 0) {
    userStyles += `
:root { --mermaid-font-family: ${cnf.fontFamily}}`;
  }
  if (cnf.altFontFamily !== void 0) {
    userStyles += `
:root { --mermaid-alt-font-family: ${cnf.altFontFamily}}`;
  }
  if (graphType === "flowchart" || graphType === "flowchart-v2" || graphType === "graph") {
    const classes2 = flowRenderer.getClasses(text2, diag);
    const htmlLabels = cnf.htmlLabels || ((_a2 = cnf.flowchart) == null ? void 0 : _a2.htmlLabels);
    for (const className2 in classes2) {
      if (htmlLabels) {
        userStyles += `
.${className2} > * { ${classes2[className2].styles.join(
          " !important; "
        )} !important; }`;
        userStyles += `
.${className2} span { ${classes2[className2].styles.join(
          " !important; "
        )} !important; }`;
      } else {
        userStyles += `
.${className2} path { ${classes2[className2].styles.join(
          " !important; "
        )} !important; }`;
        userStyles += `
.${className2} rect { ${classes2[className2].styles.join(
          " !important; "
        )} !important; }`;
        userStyles += `
.${className2} polygon { ${classes2[className2].styles.join(
          " !important; "
        )} !important; }`;
        userStyles += `
.${className2} ellipse { ${classes2[className2].styles.join(
          " !important; "
        )} !important; }`;
        userStyles += `
.${className2} circle { ${classes2[className2].styles.join(
          " !important; "
        )} !important; }`;
        if (classes2[className2].textStyles) {
          userStyles += `
.${className2} tspan { ${classes2[className2].textStyles.join(
            " !important; "
          )} !important; }`;
        }
      }
    }
  }
  const stylis = (selector2, styles) => serialize(compile(`${selector2}{${styles}}`), stringify);
  const rules = stylis(`#${id2}`, getStyles$1(graphType, userStyles, cnf.themeVariables));
  const style1 = document.createElement("style");
  style1.innerHTML = `#${id2} ` + rules;
  svg2.insertBefore(style1, firstChild);
  try {
    await diag.renderer.draw(text2, id2, pkg.version, diag);
  } catch (e) {
    errorRenderer.draw(text2, id2, pkg.version);
    throw e;
  }
  root2.select(`[id="${id2}"]`).selectAll("foreignobject > *").attr("xmlns", "http://www.w3.org/1999/xhtml");
  let svgCode = root2.select("#d" + id2).node().innerHTML;
  log$1.debug("cnf.arrowMarkerAbsolute", cnf.arrowMarkerAbsolute);
  if (!evaluate(cnf.arrowMarkerAbsolute) && cnf.securityLevel !== "sandbox") {
    svgCode = svgCode.replace(/marker-end="url\(.*?#/g, 'marker-end="url(#', "g");
  }
  svgCode = decodeEntities(svgCode);
  svgCode = svgCode.replace(/<br>/g, "<br/>");
  if (cnf.securityLevel === "sandbox") {
    const svgEl = root2.select("#d" + id2 + " svg").node();
    const width2 = "100%";
    let height2 = "100%";
    if (svgEl) {
      height2 = svgEl.viewBox.baseVal.height + "px";
    }
    svgCode = `<iframe style="width:${width2};height:${height2};border:0;margin:0;" src="data:text/html;base64,${btoa(
      '<body style="margin:0">' + svgCode + "</body>"
    )}" sandbox="allow-top-navigation-by-user-activation allow-popups">
  The \u201Ciframe\u201D tag is not supported by your browser.
</iframe>`;
  } else {
    if (cnf.securityLevel !== "loose") {
      svgCode = purify.sanitize(svgCode, {
        ADD_TAGS: ["foreignobject"],
        ADD_ATTR: ["dominant-baseline"]
      });
    }
  }
  if (typeof cb !== "undefined") {
    switch (graphType) {
      case "flowchart":
      case "flowchart-v2":
        cb(svgCode, flowDb.bindFunctions);
        break;
      case "gantt":
        cb(svgCode, ganttDb.bindFunctions);
        break;
      case "class":
      case "classDiagram":
        cb(svgCode, classDb.bindFunctions);
        break;
      default:
        cb(svgCode);
    }
  } else {
    log$1.debug("CB = undefined!");
  }
  attachFunctions();
  const tmpElementSelector = cnf.securityLevel === "sandbox" ? "#i" + id2 : "#d" + id2;
  const node2 = select$1(tmpElementSelector).node();
  if (node2 && "remove" in node2) {
    node2.remove();
  }
  if (parseEncounteredException) {
    throw parseEncounteredException;
  }
  return svgCode;
};
let currentDirective = {};
const parseDirective = function(p, statement, context, type2) {
  try {
    if (statement !== void 0) {
      statement = statement.trim();
      switch (context) {
        case "open_directive":
          currentDirective = {};
          break;
        case "type_directive":
          if (!currentDirective)
            throw new Error("currentDirective is undefined");
          currentDirective.type = statement.toLowerCase();
          break;
        case "arg_directive":
          if (!currentDirective)
            throw new Error("currentDirective is undefined");
          currentDirective.args = JSON.parse(statement);
          break;
        case "close_directive":
          handleDirective(p, currentDirective, type2);
          currentDirective = void 0;
          break;
      }
    }
  } catch (error) {
    log$1.error(
      `Error while rendering sequenceDiagram directive: ${statement} jison context: ${context}`
    );
    log$1.error(error.message);
  }
};
const handleDirective = function(p, directive2, type2) {
  log$1.debug(`Directive type=${directive2.type} with args:`, directive2.args);
  switch (directive2.type) {
    case "init":
    case "initialize": {
      ["config"].forEach((prop) => {
        if (typeof directive2.args[prop] !== "undefined") {
          if (type2 === "flowchart-v2") {
            type2 = "flowchart";
          }
          directive2.args[type2] = directive2.args[prop];
          delete directive2.args[prop];
        }
      });
      log$1.debug("sanitize in handleDirective", directive2.args);
      directiveSanitizer(directive2.args);
      log$1.debug("sanitize in handleDirective (done)", directive2.args);
      addDirective(directive2.args);
      break;
    }
    case "wrap":
    case "nowrap":
      if (p && p["setWrap"]) {
        p.setWrap(directive2.type === "wrap");
      }
      break;
    case "themeCss":
      log$1.warn("themeCss encountered");
      break;
    default:
      log$1.warn(
        `Unhandled directive: source: '%%{${directive2.type}: ${JSON.stringify(
          directive2.args ? directive2.args : {}
        )}}%%`,
        directive2
      );
      break;
  }
};
function initialize$1(options2 = {}) {
  if (options2.fontFamily) {
    if (!options2.themeVariables) {
      options2.themeVariables = {};
    }
    options2.themeVariables.fontFamily = options2.fontFamily;
  }
  saveConfigFromInitialize(options2);
  if ((options2 == null ? void 0 : options2.theme) && options2.theme in theme$3) {
    options2.themeVariables = theme$3[options2.theme].getThemeVariables(
      options2.themeVariables
    );
  } else if (options2) {
    options2.themeVariables = theme$3.default.getThemeVariables(options2.themeVariables);
  }
  const config2 = typeof options2 === "object" ? setSiteConfig(options2) : getSiteConfig();
  setLogLevel$1(config2.logLevel);
  addDiagrams();
}
const mermaidAPI = Object.freeze({
  render,
  renderAsync: renderAsync$1,
  parse: parse$1,
  parseAsync: parseAsync$1,
  parseDirective,
  initialize: initialize$1,
  getConfig: getConfig$1,
  setConfig,
  getSiteConfig,
  updateSiteConfig,
  reset: () => {
    reset();
  },
  globalReset: () => {
    reset(defaultConfig);
  },
  defaultConfig
});
setLogLevel$1(getConfig$1().logLevel);
reset(getConfig$1());
const init = async function(config2, nodes, callback) {
  try {
    const conf2 = mermaidAPI.getConfig();
    if ((conf2 == null ? void 0 : conf2.lazyLoadedDiagrams) && conf2.lazyLoadedDiagrams.length > 0) {
      await initThrowsErrorsAsync(config2, nodes, callback);
    } else {
      initThrowsErrors(config2, nodes, callback);
    }
  } catch (e) {
    log$1.warn("Syntax Error rendering");
    if (isDetailedError(e)) {
      log$1.warn(e.str);
    }
    if (mermaid$1.parseError) {
      mermaid$1.parseError(e);
    }
  }
};
const handleError = (error, errors, parseError) => {
  log$1.warn(error);
  if (isDetailedError(error)) {
    if (parseError) {
      parseError(error.str, error.hash);
    }
    errors.push({ ...error, message: error.str, error });
  } else {
    if (parseError) {
      parseError(error);
    }
    if (error instanceof Error) {
      errors.push({
        str: error.message,
        message: error.message,
        hash: error.name,
        error
      });
    }
  }
};
const initThrowsErrors = function(config2, nodes, callback) {
  const conf2 = mermaidAPI.getConfig();
  if (config2) {
    mermaid$1.sequenceConfig = config2;
  }
  log$1.debug(`${!callback ? "No " : ""}Callback function found`);
  let nodesToProcess;
  if (typeof nodes === "undefined") {
    nodesToProcess = document.querySelectorAll(".mermaid");
  } else if (typeof nodes === "string") {
    nodesToProcess = document.querySelectorAll(nodes);
  } else if (nodes instanceof HTMLElement) {
    nodesToProcess = [nodes];
  } else if (nodes instanceof NodeList) {
    nodesToProcess = nodes;
  } else {
    throw new Error("Invalid argument nodes for mermaid.init");
  }
  log$1.debug(`Found ${nodesToProcess.length} diagrams`);
  if (typeof (config2 == null ? void 0 : config2.startOnLoad) !== "undefined") {
    log$1.debug("Start On Load: " + (config2 == null ? void 0 : config2.startOnLoad));
    mermaidAPI.updateSiteConfig({ startOnLoad: config2 == null ? void 0 : config2.startOnLoad });
  }
  const idGenerator = new utils.initIdGenerator(conf2.deterministicIds, conf2.deterministicIDSeed);
  let txt;
  const errors = [];
  for (const element of Array.from(nodesToProcess)) {
    log$1.info("Rendering diagram: " + element.id);
    /*! Check if previously processed */
    if (element.getAttribute("data-processed")) {
      continue;
    }
    element.setAttribute("data-processed", "true");
    const id2 = `mermaid-${idGenerator.next()}`;
    txt = element.innerHTML;
    txt = utils.entityDecode(txt).trim().replace(/<br\s*\/?>/gi, "<br/>");
    const init2 = utils.detectInit(txt);
    if (init2) {
      log$1.debug("Detected early reinit: ", init2);
    }
    try {
      mermaidAPI.render(
        id2,
        txt,
        (svgCode, bindFunctions2) => {
          element.innerHTML = svgCode;
          if (typeof callback !== "undefined") {
            callback(id2);
          }
          if (bindFunctions2)
            bindFunctions2(element);
        },
        element
      );
    } catch (error) {
      handleError(error, errors, mermaid$1.parseError);
    }
  }
  if (errors.length > 0) {
    throw errors[0];
  }
};
let lazyLoadingPromise = void 0;
const registerLazyLoadedDiagrams = async (conf2) => {
  var _a2;
  if (lazyLoadingPromise === void 0) {
    lazyLoadingPromise = Promise.allSettled(
      ((_a2 = conf2 == null ? void 0 : conf2.lazyLoadedDiagrams) != null ? _a2 : []).map(async (diagram) => {
        const { id: id2, detector, loadDiagram } = await __vitePreload(() => import(diagram), true ? [] : void 0);
        addDetector(id2, detector, loadDiagram);
      })
    );
  }
  return await lazyLoadingPromise;
};
let loadingPromise = void 0;
const loadExternalDiagrams = async (conf2) => {
  var _a2, _b;
  if (loadingPromise === void 0) {
    log$1.debug(`Loading ${(_a2 = conf2 == null ? void 0 : conf2.lazyLoadedDiagrams) == null ? void 0 : _a2.length} external diagrams`);
    loadingPromise = Promise.allSettled(
      ((_b = conf2 == null ? void 0 : conf2.lazyLoadedDiagrams) != null ? _b : []).map(async (url) => {
        const { id: id2, detector, loadDiagram } = await __vitePreload(() => import(url), true ? [] : void 0);
        const { diagram } = await loadDiagram();
        registerDiagram(id2, diagram, detector, diagram.injectUtils);
      })
    );
  }
  await loadingPromise;
};
const initThrowsErrorsAsync = async function(config2, nodes, callback) {
  const conf2 = mermaidAPI.getConfig();
  const registerLazyLoadedDiagramsErrors = [];
  for (const registerResult of await registerLazyLoadedDiagrams(conf2)) {
    if (registerResult.status == "rejected") {
      registerLazyLoadedDiagramsErrors.push(registerResult.reason);
    }
  }
  if (config2) {
    mermaid$1.sequenceConfig = config2;
  }
  log$1.debug(`${!callback ? "No " : ""}Callback function found`);
  let nodesToProcess;
  if (typeof nodes === "undefined") {
    nodesToProcess = document.querySelectorAll(".mermaid");
  } else if (typeof nodes === "string") {
    nodesToProcess = document.querySelectorAll(nodes);
  } else if (nodes instanceof HTMLElement) {
    nodesToProcess = [nodes];
  } else if (nodes instanceof NodeList) {
    nodesToProcess = nodes;
  } else {
    throw new Error("Invalid argument nodes for mermaid.init");
  }
  log$1.debug(`Found ${nodesToProcess.length} diagrams`);
  if (typeof (config2 == null ? void 0 : config2.startOnLoad) !== "undefined") {
    log$1.debug("Start On Load: " + (config2 == null ? void 0 : config2.startOnLoad));
    mermaidAPI.updateSiteConfig({ startOnLoad: config2 == null ? void 0 : config2.startOnLoad });
  }
  const idGenerator = new utils.initIdGenerator(conf2.deterministicIds, conf2.deterministicIDSeed);
  let txt;
  const errors = [];
  for (const element of Array.from(nodesToProcess)) {
    log$1.info("Rendering diagram: " + element.id);
    /*! Check if previously processed */
    if (element.getAttribute("data-processed")) {
      continue;
    }
    element.setAttribute("data-processed", "true");
    const id2 = `mermaid-${idGenerator.next()}`;
    txt = element.innerHTML;
    txt = utils.entityDecode(txt).trim().replace(/<br\s*\/?>/gi, "<br/>");
    const init2 = utils.detectInit(txt);
    if (init2) {
      log$1.debug("Detected early reinit: ", init2);
    }
    try {
      await mermaidAPI.renderAsync(
        id2,
        txt,
        (svgCode, bindFunctions2) => {
          element.innerHTML = svgCode;
          if (typeof callback !== "undefined") {
            callback(id2);
          }
          if (bindFunctions2)
            bindFunctions2(element);
        },
        element
      );
    } catch (error) {
      handleError(error, errors, mermaid$1.parseError);
    }
  }
  const allErrors = [...registerLazyLoadedDiagramsErrors, ...errors];
  if (allErrors.length > 0) {
    throw allErrors[0];
  }
};
const initialize = function(config2) {
  mermaidAPI.initialize(config2);
};
const initializeAsync = async function(config2) {
  if (config2.loadExternalDiagramsAtStartup) {
    await loadExternalDiagrams(config2);
  } else {
    await registerLazyLoadedDiagrams(config2);
  }
  mermaidAPI.initialize(config2);
};
const contentLoaded = function() {
  if (mermaid$1.startOnLoad) {
    const { startOnLoad } = mermaidAPI.getConfig();
    if (startOnLoad) {
      mermaid$1.init();
    }
  }
};
if (typeof document !== "undefined") {
  /*!
   * Wait for document loaded before starting the execution
   */
  window.addEventListener("load", contentLoaded, false);
}
const setParseErrorHandler = function(newParseErrorHandler) {
  mermaid$1.parseError = newParseErrorHandler;
};
const parse = (txt) => {
  return mermaidAPI.parse(txt, mermaid$1.parseError);
};
const executionQueue = [];
let executionQueueRunning = false;
const executeQueue = async () => {
  if (executionQueueRunning) {
    return;
  }
  executionQueueRunning = true;
  while (executionQueue.length > 0) {
    const f2 = executionQueue.shift();
    if (f2) {
      try {
        await f2();
      } catch (e) {
        log$1.error("Error executing queue", e);
      }
    }
  }
  executionQueueRunning = false;
};
const parseAsync = (txt) => {
  return new Promise((resolve, reject) => {
    const performCall = () => new Promise((res, rej) => {
      mermaidAPI.parseAsync(txt, mermaid$1.parseError).then(
        (r) => {
          res(r);
          resolve(r);
        },
        (e) => {
          log$1.error("Error parsing", e);
          rej(e);
          reject(e);
        }
      );
    });
    executionQueue.push(performCall);
    executeQueue();
  });
};
const renderAsync = (id2, text2, cb, container) => {
  return new Promise((resolve, reject) => {
    const performCall = () => new Promise((res, rej) => {
      mermaidAPI.renderAsync(id2, text2, cb, container).then(
        (r) => {
          res(r);
          resolve(r);
        },
        (e) => {
          log$1.error("Error parsing", e);
          rej(e);
          reject(e);
        }
      );
    });
    executionQueue.push(performCall);
    executeQueue();
  });
};
const mermaid$1 = {
  startOnLoad: true,
  diagrams: {},
  mermaidAPI,
  parse,
  parseAsync,
  render: mermaidAPI.render,
  renderAsync,
  init,
  initThrowsErrors,
  initThrowsErrorsAsync,
  initialize,
  initializeAsync,
  parseError: void 0,
  contentLoaded,
  setParseErrorHandler
};
const toEl = (html2) => {
  const template2 = document.createElement("template");
  template2.insertAdjacentHTML("afterbegin", html2);
  return template2.firstChild;
};
const background = "#121212";
const font = '"Inter", helvetica, sans-serif';
const primary = adjust$2("rgb(59, 130, 246)", { h: 10 });
const makeColors = (color2) => {
  const lighter = lighten$1(color2, 50);
  const darker2 = darken$1(color2, 50);
  return {
    background: color2,
    border: darken$1(color2, 5),
    text: contrast$1(lighter, color2) > contrast$1(darker2, color2) ? lighter : darker2
  };
};
const colors = {
  primary: makeColors(primary),
  secondary: makeColors(adjust$2(primary, { h: 30 })),
  tertiary: makeColors(adjust$2(primary, { h: 60 })),
  fourth: makeColors(adjust$2(primary, { h: 90 })),
  fifth: makeColors(adjust$2(primary, { h: 120 })),
  sixth: makeColors(adjust$2(primary, { h: 150 })),
  seventh: makeColors(adjust$2(primary, { h: 180 })),
  eighth: makeColors(adjust$2(primary, { h: 210 })),
  ninth: makeColors(adjust$2(primary, { h: 240 })),
  tenth: makeColors(adjust$2(primary, { h: 270 })),
  eleventh: makeColors(adjust$2(primary, { h: 300 })),
  twelfth: makeColors(adjust$2(primary, { h: 330 })),
  neutral: makeColors("#eaeaea"),
  active: makeColors(primary),
  inactive: makeColors("#777777"),
  danger: makeColors("#ff0000")
};
const textSize = "16px";
const textSizeLarge = "24px";
const makePattern = (id2, pattern) => {
  return `
    <defs xmlns="http://www.w3.org/2000/svg">
      <pattern id="${id2}" height="10" width="10" patternUnits="userSpaceOnUse">
        ${pattern}
      </pattern>
    </defs>
  `;
};
const makeStripes = (colorKey) => {
  return makePattern(`stripes-${colorKey}`, `
    <rect class="ignore" height="100%" width="100%" fill="${background}" />
    <line class="ignore" x1="0" y1="0" x2="10" y2="10" stroke="${colors[colorKey].background}" stroke-width="1px" stroke-linecap="square" />
  `);
};
const makeScale = (index2, color2) => {
  const backgroundKey = `cScale${index2}`;
  const foregroundKey = `cScaleInv${index2}`;
  const borderKey = `cScalePeer${index2}`;
  return {
    [backgroundKey]: color2,
    [foregroundKey]: invert$1(color2),
    [borderKey]: darken$1(color2, 10)
  };
};
const updateSvg = (html2) => {
  const svg2 = toEl(html2);
  const colorKeys = Object.keys(colors);
  colorKeys.forEach((colorKey) => {
    svg2.insertAdjacentHTML("afterbegin", makeStripes(colorKey));
  });
  return svg2;
};
const theme$2 = {
  background,
  primaryColor: colors.primary.background,
  secondaryColor: colors.secondary.background,
  tertiaryColor: colors.tertiary.background,
  primaryTextColor: colors.primary.text,
  secondaryTextColor: colors.secondary.text,
  tertiaryTextColor: colors.tertiary.text,
  mainBkg: colors.primary.background,
  secondBkg: colors.secondary.background,
  tertiaryBkg: colors.tertiary.background,
  primaryBorderColor: colors.primary.border,
  secondaryBorderColor: colors.secondary.border,
  tertiaryBorderColor: colors.tertiary.border,
  lineColor: colors.neutral.background,
  fontFamily: font,
  fontSize: textSize,
  labelBackground: colors.neutral.background,
  labelTextColor: colors.primary.text,
  textColor: invert$1(colors.primary.text),
  titleColor: invert$1(colors.secondary.text),
  THEME_COLOR_LIMIT: 12,
  personBkg: colors.primary.background,
  personBorder: colors.primary.border,
  clusterBkg: "url(#stripes-secondary)",
  clusterBorder: colors.secondary.border,
  edgeLabelBackground: adjust$2(colors.tertiary.background, { a: -0.2 }),
  nodeTextColor: colors.tertiary.text,
  sectionBkgColor: "url(#stripes-primary)",
  altSectionBkgColor: "url(#stripes-secondary)",
  sectionBkgColor2: "url(#stripes-tertiary)",
  taskBkgColor: colors.neutral.background,
  taskBorderColor: colors.neutral.border,
  taskTextColor: colors.primary.text,
  activeTaskBkgColor: colors.active.background,
  activeTaskBorderColor: colors.active.border,
  taskTextDarkColor: colors.active.text,
  gridColor: colors.tertiary.border,
  doneTaskBkgColor: colors.inactive.background,
  doneTaskBorderColor: colors.inactive.border,
  critBkgColor: colors.danger.background,
  critBorderColor: colors.danger.border,
  todayLineColor: colors.secondary.background,
  commitLabelColor: invert$1(colors.primary.text),
  commitLabelBackground: darken$1(colors.inactive.background, 30),
  git0: colors.primary.background,
  git1: colors.secondary.background,
  git2: colors.tertiary.background,
  git3: colors.fourth.background,
  git4: colors.fifth.background,
  git5: colors.sixth.background,
  git6: colors.seventh.background,
  git7: colors.eighth.background,
  gitInv0: colors.neutral.background,
  gitInv1: colors.neutral.background,
  gitInv2: colors.neutral.background,
  gitInv3: colors.neutral.background,
  gitInv4: colors.neutral.background,
  gitInv5: colors.neutral.background,
  gitInv6: colors.neutral.background,
  gitInv7: colors.neutral.background,
  pie1: colors.primary.background,
  pie2: colors.secondary.background,
  pie3: colors.tertiary.background,
  pie4: colors.fourth.background,
  pie5: colors.fifth.background,
  pie6: colors.sixth.background,
  pie7: colors.seventh.background,
  pie8: colors.eighth.background,
  pie9: colors.ninth.background,
  pie10: colors.tenth.background,
  pie11: colors.eleventh.background,
  pie12: colors.twelfth.background,
  pieTitleTextSize: textSizeLarge,
  pieTitleTextColor: invert$1(colors.primary.text),
  pieSectionTextSize: textSize,
  pieSectionTextColor: colors.primary.text,
  pieLegendTextSize: textSize,
  pieLegendTextColor: invert$1(colors.primary.text),
  pieStrokeColor: background,
  pieStrokeWidth: "2px",
  pieOpacity: "1",
  actorTextColor: colors.primary.text,
  actorLineColor: colors.neutral.background,
  signalColor: colors.neutral.background,
  activationBkgColor: colors.secondary.background,
  activationBorderColor: colors.secondary.border,
  loopTextColor: invert$1(colors.neutral.text),
  labelColor: "black",
  errorBkgColor: "#552222",
  errorTextColor: "#552222",
  ...makeScale(0, colors.primary.background),
  ...makeScale(1, colors.secondary.background),
  ...makeScale(2, colors.tertiary.background),
  ...makeScale(3, colors.fourth.background),
  ...makeScale(4, colors.fifth.background),
  ...makeScale(5, colors.sixth.background),
  ...makeScale(6, colors.seventh.background),
  ...makeScale(7, colors.eighth.background),
  ...makeScale(8, colors.ninth.background),
  ...makeScale(9, colors.tenth.background),
  ...makeScale(10, colors.eleventh.background),
  ...makeScale(11, colors.twelfth.background)
};
const themeStyles = `
  .edgeLabel:not(:empty) {
    border-radius: 2px;
    padding: 2px 4px;
  }

  svg {
    stroke-linejoin: round;
    line-height: 1.5;
    margin: auto;
  }

  svg marker#arrowhead path {
    d: path('M 1,1 L5,5 L1,9 L10,5 Z');
  }

  svg marker#crosshead path:first-child {
    d: path('M 10,1.75 L12,4 L10,6.25 L15,4 Z');
    stroke-linecap: round;
    stroke-linejoin: round;
    stroke-width: 0.5px;
  }

  svg marker#crosshead path:last-child {
    d: path('M2.5,1.5 L7.5,6.5 M7.5,1.5 L2.5,6.5');
    stroke-linecap: round;
    stroke-width: 0.75px;
    stroke-linejoin: round;
  }

  svg marker#flowchart-pointEnd path {
    d: path('M 1,1 L5,5 L1,9 L10,5 Z');
  }

  svg circle:not(.ignore),
  svg line:not(.ignore),
  svg polygon:not(.ignore),
  svg rect:not(.ignore) {
    stroke-linecap: round;
    stroke-linejoin: round;
    stroke-width: 2px !important;
  }

  svg .commit-label-bkg {
    stroke: ${darken$1(colors.inactive.background, 30)};
    stroke-linejoin: round;
    stroke-width: 2px !important;
  }

  svg .edge-pattern-dotted {
    stroke-linecap: round;
    stroke-dasharray: 2, 4 !important;
  }

  svg .loopLine {
    opacity: 0.8;
    stroke-dasharray: 2, 4 !important;
  }

  svg .section,
  svg .task {
    opacity: 0.75;
  }
`;
const alpha = customAlphabet("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
const preview = (text2) => {
  return {
    compare: (other) => {
      return other.text === text2;
    },
    destroy: () => {
    },
    eq: (other) => {
      return other.text === text2;
    },
    estimatedHeight: -1,
    ignoreEvent: () => true,
    text: text2,
    toDOM: () => {
      const container = document.createElement("div");
      const content2 = document.createElement("div");
      const targetId = alpha();
      container.style.paddingBottom = "0.5rem";
      container.style.paddingTop = "0.5rem";
      container.setAttribute("aria-hidden", "true");
      content2.id = targetId;
      content2.style.backgroundColor = "#121212";
      content2.style.borderRadius = "0.25rem";
      container.appendChild(content2);
      try {
        if (mermaid$1.parse(text2)) {
          mermaid$1.render(targetId, text2, (svg2) => {
            content2.replaceChildren(updateSvg(svg2));
          });
        }
      } catch (error) {
        console.log("[mermaid]", error);
      }
      return container;
    },
    updateDOM: () => false
  };
};
const widget = (_config) => {
  mermaid$1.initialize({ theme: "base", themeCSS: themeStyles, themeVariables: theme$2 });
  const previewDecoration = (text2) => Decoration.widget({
    block: true,
    side: -1,
    widget: preview(text2)
  });
  const decorate = (state) => {
    const widgets = [];
    syntaxTree(state).iterate({
      enter: ({ type: type2, from: from2, to: to2 }) => {
        if (type2.name === "FencedCode") {
          if (from2 + 2 === to2 - 2) {
            return;
          }
          const block = state.sliceDoc(from2, to2);
          const isMermaid = /^`+mermaid(?:\s|$)/.test(block);
          if (isMermaid) {
            const position2 = state.doc.lineAt(from2).from;
            const lines = block.split("\n");
            lines.shift();
            lines.pop();
            const text2 = lines.join("\n");
            if (text2) {
              widgets.push(previewDecoration(text2).range(position2));
            }
          }
        }
      }
    });
    return widgets.length > 0 ? RangeSet.of(widgets) : Decoration.none;
  };
  const stateField = StateField.define({
    create(state) {
      return decorate(state);
    },
    update(references2, transaction) {
      if (transaction.docChanged || transaction.reconfigured || transaction.effects.length > 0) {
        return decorate(transaction.state);
      }
      return references2;
    },
    provide(field) {
      return EditorView.decorations.from(field);
    }
  });
  return [
    stateField
  ];
};
const mermaid = (config2) => {
  return [
    { type: "default", value: widget() }
  ];
};
const completions = (config2) => {
  return (context) => {
    const match = context.matchBefore(/\[\[.*?/);
    if (!match) {
      return null;
    }
    return {
      from: match.from + 2,
      options: config2.docs.map((doc2) => {
        return {
          apply: doc2.id,
          label: doc2.title || doc2.id,
          type: "text"
        };
      })
    };
  };
};
const referenceWidget = (text2) => {
  return {
    compare: (other) => {
      return other.text === text2;
    },
    destroy: () => {
    },
    eq: (other) => {
      return other.text === text2;
    },
    estimatedHeight: -1,
    ignoreEvent: () => true,
    text: text2,
    toDOM: () => {
      const span = document.createElement("span");
      span.innerText = text2;
      span.setAttribute("aria-hidden", "true");
      return span;
    },
    updateDOM: () => false
  };
};
const hasOverlap = (x12, x2, y12, y2) => {
  return Math.max(x12, y12) <= Math.min(x2, y2);
};
const isCursorInRange = (state, from2, to2) => {
  return state.selection.ranges.some((range2) => {
    return hasOverlap(from2, to2, range2.from, range2.to);
  });
};
const replacements = (config2) => {
  const referenceDecoration = (text2) => Decoration.replace({
    widget: referenceWidget(text2)
  });
  const decorate = (state) => {
    const widgets = [];
    syntaxTree(state).iterate({
      enter: ({ type: type2, from: from2, to: to2 }) => {
        if (type2.name === "Reference") {
          if (from2 + 2 === to2 - 2) {
            return;
          }
          const id2 = state.sliceDoc(from2 + 2, to2 - 2);
          const doc2 = config2.docs.find((doc22) => doc22.id === id2);
          if (doc2 && !isCursorInRange(state, from2 + 2, to2 - 2)) {
            widgets.push(referenceDecoration(doc2.title).range(from2 + 2, to2 - 2));
          }
        }
      }
    });
    return widgets.length > 0 ? RangeSet.of(widgets) : Decoration.none;
  };
  const stateField = StateField.define({
    create(state) {
      return decorate(state);
    },
    update(_references, { state }) {
      return decorate(state);
    },
    provide(field) {
      return EditorView.decorations.from(field);
    }
  });
  return [
    stateField
  ];
};
const LEFT_BRACKET_CODE = 91;
const RIGHT_BRACKET_CODE = 93;
const tags$1 = {
  reference: Tag.define(),
  referenceMark: Tag.define()
};
const ReferenceStartDelimiter = {};
const grammar$1 = {
  defineNodes: [
    {
      name: "Reference",
      style: tags$1.reference
    },
    {
      name: "ReferenceMark",
      style: [tags$1.referenceMark, tags$5.processingInstruction]
    }
  ],
  parseInline: [
    {
      name: "ReferenceStart",
      parse(cx, next2, pos) {
        return next2 === LEFT_BRACKET_CODE && cx.char(pos + 1) === LEFT_BRACKET_CODE ? cx.addDelimiter(ReferenceStartDelimiter, pos, pos + 2, true, false) : -1;
      },
      after: "Emphasis"
    },
    {
      name: "Reference",
      parse(cx, next2, pos) {
        if (!(next2 === RIGHT_BRACKET_CODE && cx.char(pos + 1) === RIGHT_BRACKET_CODE)) {
          return -1;
        }
        const parts = cx.parts;
        const openIndex = cx.findOpeningDelimiter(ReferenceStartDelimiter);
        if (Number.isInteger(openIndex)) {
          const start2 = parts[openIndex].from;
          const end2 = pos + 2;
          const content2 = cx.takeContent(openIndex);
          content2.unshift(cx.elt("ReferenceMark", start2, start2 + 2));
          content2.push(cx.elt("ReferenceMark", end2 - 2, end2));
          let ref2 = parts[openIndex] = cx.elt("Reference", start2, end2, content2);
          return ref2.to;
        }
        return -1;
      },
      after: "ReferenceStart"
    }
  ]
};
const theme$1 = syntaxHighlighting(
  HighlightStyle.define([
    {
      tag: tags$1.reference
    },
    {
      tag: tags$1.referenceMark
    }
  ])
);
const references = (config2) => {
  return [
    { type: "completion", value: completions(config2) },
    { type: "default", value: theme$1 },
    { type: "default", value: replacements(config2) },
    { type: "grammar", value: grammar$1 }
  ];
};
const URL_REGEX_HEAD = /\b[a-z](?:[-a-z0-9\+\.])*:\/\//;
const URL_REGEX_TAIL = /(?:(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\uA0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\u10000-\u1FFFD\u20000-\u2FFFD\u30000-\u3FFFD\u40000-\u4FFFD\u50000-\u5FFFD\u60000-\u6FFFD\u70000-\u7FFFD\u80000-\u8FFFD\u90000-\u9FFFD\uA0000-\uAFFFD\uB0000-\uBFFFD\uC0000-\uCFFFD\uD0000-\uDFFFD\uE1000-\uEFFFD!\$&\'\(\)\*\+,;=:])*@)?(?:\[(?:(?:(?:[0-9a-f]{1,4}:){6}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|::(?:[0-9a-f]{1,4}:){5}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:[0-9a-f]{1,4}:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|v[0-9a-f]+[-a-z0-9\._~!\$&\'\(\)\*\+,;=:]+)\]|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3}|(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\uA0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\u10000-\u1FFFD\u20000-\u2FFFD\u30000-\u3FFFD\u40000-\u4FFFD\u50000-\u5FFFD\u60000-\u6FFFD\u70000-\u7FFFD\u80000-\u8FFFD\u90000-\u9FFFD\uA0000-\uAFFFD\uB0000-\uBFFFD\uC0000-\uCFFFD\uD0000-\uDFFFD\uE1000-\uEFFFD!\$&\'\(\)\*\+,;=@])*)(?::[0-9]*)?(?:\/(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\uA0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\u10000-\u1FFFD\u20000-\u2FFFD\u30000-\u3FFFD\u40000-\u4FFFD\u50000-\u5FFFD\u60000-\u6FFFD\u70000-\u7FFFD\u80000-\u8FFFD\u90000-\u9FFFD\uA0000-\uAFFFD\uB0000-\uBFFFD\uC0000-\uCFFFD\uD0000-\uDFFFD\uE1000-\uEFFFD!\$&\'\(\)\*\+,;=:@]))*)*|\/(?:(?:(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\uA0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\u10000-\u1FFFD\u20000-\u2FFFD\u30000-\u3FFFD\u40000-\u4FFFD\u50000-\u5FFFD\u60000-\u6FFFD\u70000-\u7FFFD\u80000-\u8FFFD\u90000-\u9FFFD\uA0000-\uAFFFD\uB0000-\uBFFFD\uC0000-\uCFFFD\uD0000-\uDFFFD\uE1000-\uEFFFD!\$&\'\(\)\*\+,;=:@]))+)(?:\/(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\uA0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\u10000-\u1FFFD\u20000-\u2FFFD\u30000-\u3FFFD\u40000-\u4FFFD\u50000-\u5FFFD\u60000-\u6FFFD\u70000-\u7FFFD\u80000-\u8FFFD\u90000-\u9FFFD\uA0000-\uAFFFD\uB0000-\uBFFFD\uC0000-\uCFFFD\uD0000-\uDFFFD\uE1000-\uEFFFD!\$&\'\(\)\*\+,;=:@]))*)*)?|(?:(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\uA0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\u10000-\u1FFFD\u20000-\u2FFFD\u30000-\u3FFFD\u40000-\u4FFFD\u50000-\u5FFFD\u60000-\u6FFFD\u70000-\u7FFFD\u80000-\u8FFFD\u90000-\u9FFFD\uA0000-\uAFFFD\uB0000-\uBFFFD\uC0000-\uCFFFD\uD0000-\uDFFFD\uE1000-\uEFFFD!\$&\'\(\)\*\+,;=:@]))+)(?:\/(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\uA0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\u10000-\u1FFFD\u20000-\u2FFFD\u30000-\u3FFFD\u40000-\u4FFFD\u50000-\u5FFFD\u60000-\u6FFFD\u70000-\u7FFFD\u80000-\u8FFFD\u90000-\u9FFFD\uA0000-\uAFFFD\uB0000-\uBFFFD\uC0000-\uCFFFD\uD0000-\uDFFFD\uE1000-\uEFFFD!\$&\'\(\)\*\+,;=:@]))*)*|(?!(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\uA0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\u10000-\u1FFFD\u20000-\u2FFFD\u30000-\u3FFFD\u40000-\u4FFFD\u50000-\u5FFFD\u60000-\u6FFFD\u70000-\u7FFFD\u80000-\u8FFFD\u90000-\u9FFFD\uA0000-\uAFFFD\uB0000-\uBFFFD\uC0000-\uCFFFD\uD0000-\uDFFFD\uE1000-\uEFFFD!\$&\'\(\)\*\+,;=:@])))(?:\?(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\uA0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\u10000-\u1FFFD\u20000-\u2FFFD\u30000-\u3FFFD\u40000-\u4FFFD\u50000-\u5FFFD\u60000-\u6FFFD\u70000-\u7FFFD\u80000-\u8FFFD\u90000-\u9FFFD\uA0000-\uAFFFD\uB0000-\uBFFFD\uC0000-\uCFFFD\uD0000-\uDFFFD\uE1000-\uEFFFD!\$&\'\(\)\*\+,;=:@])|[\uE000-\uF8FF\uF0000-\uFFFFD|\u100000-\u10FFFD\/\?])*)?(?:\#(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\uA0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\u10000-\u1FFFD\u20000-\u2FFFD\u30000-\u3FFFD\u40000-\u4FFFD\u50000-\u5FFFD\u60000-\u6FFFD\u70000-\u7FFFD\u80000-\u8FFFD\u90000-\u9FFFD\uA0000-\uAFFFD\uB0000-\uBFFFD\uC0000-\uCFFFD\uD0000-\uDFFFD\uE1000-\uEFFFD!\$&\'\(\)\*\+,;=:@])|[\/\?])*)?\b/i;
const URL_REGEX_FULL = new RegExp(URL_REGEX_HEAD.source + URL_REGEX_TAIL.source, "i");
const MATCH_URL = new RegExp(`(${URL_REGEX_HEAD.source}${URL_REGEX_TAIL.source})`, "i");
const MATCH_URL_PREFIX = new RegExp(`.*(${URL_REGEX_HEAD.source})$`, "i");
const matchUrlPrefix = (text2) => {
  return text2.match(MATCH_URL_PREFIX);
};
const matchUrl = (text2) => {
  return text2.match(MATCH_URL);
};
const matchUrls = (text2) => {
  const regex = new RegExp(URL_REGEX_FULL.source, "gi");
  return [...text2.matchAll(regex)];
};
const findUrl = (text2, position2) => {
  const matches = matchUrls(text2);
  const found = matches.find((match) => {
    const start2 = Number(match.index);
    const end2 = Number(match.index) + match[0].length;
    if (start2 < position2 && end2 > position2) {
      return true;
    }
  });
  if (found) {
    const [url] = found;
    return url;
  }
};
const clickHandler = EditorView.domEventHandlers({
  click: (event2, view) => {
    if (event2.metaKey) {
      const selection2 = view.state.selection;
      const line2 = view.state.doc.lineAt(selection2.main.from);
      const text2 = line2.text;
      const offset = selection2.main.from - line2.from;
      const url = findUrl(text2, offset);
      if (url) {
        window.open(url, "_blank");
      }
    }
  }
});
const clickable = (_config) => {
  return clickHandler;
};
const tags = {
  url: Tag.define()
};
const theme = (_config) => {
  return syntaxHighlighting(
    HighlightStyle.define([
      {
        tag: tags.url,
        textDecoration: "underline"
      },
      {
        tag: tags$5.url,
        textDecoration: "underline"
      }
    ])
  );
};
const grammar = (_config) => {
  return {
    defineNodes: [
      {
        name: "ClickableUrl",
        style: tags.url
      }
    ],
    parseInline: [
      {
        name: "ClickableUrl",
        parse: (inline, nextChar2, index2) => {
          if (nextChar2 !== 58 || inline.char(index2 + 1) !== 47 || inline.char(index2 + 2) !== 47 || inline.char(index2 + 3) === 47)
            return -1;
          const text2 = inline.slice(
            inline.offset,
            index2 + 3
          );
          const prefixMatch2 = matchUrlPrefix(text2);
          if (prefixMatch2) {
            const start2 = index2 - prefixMatch2[1].length + 3;
            const fullMatch = matchUrl(inline.slice(start2, inline.end));
            if (fullMatch) {
              return inline.addElement(
                inline.elt(
                  "ClickableUrl",
                  start2,
                  start2 + fullMatch[1].length
                )
              );
            }
          }
          return -1;
        }
      }
    ]
  };
};
const urls = (config2) => {
  return [
    { type: "default", value: clickable() },
    { type: "default", value: theme() },
    { type: "grammar", value: grammar() }
  ];
};
const plugins = (config2) => {
  return [
    ...hashtags(config2),
    ...references(config2),
    ...urls()
  ];
};
const Editor_vue_vue_type_style_index_0_scoped_d012d7b3_lang = "";
const _sfc_main = defineComponent({
  emits: ["input"],
  components: {
    Ink: _$E
  },
  inject: ["mq"],
  props: {
    appearance: {
      type: String,
      default: () => "auto",
      validator: (value) => ["auto", "dark", "light"].includes(value)
    },
    doc: {
      type: Object
    },
    initialFocus: {
      type: String,
      default: () => "any",
      validator: (position2) => ["any", "start", "end"].includes(position2)
    },
    initialSelections: {
      type: Array
    },
    initialVimMode: {
      type: String
    },
    readonly: {
      type: Boolean
    },
    settings: {
      type: Object
    }
  },
  watch: {
    text(value) {
      if (value !== this.editor.getDoc()) {
        this.editor.load(value);
      }
    }
  },
  computed: {
    docs() {
      return this.$store.getters.kept.reduce((docs, doc2) => {
        if (doc2.id && doc2.id !== this.doc.id && doc2.headers.length > 0) {
          docs.push({
            id: doc2.id,
            title: doc2.headers[0]
          });
        }
        return docs;
      }, []);
    },
    editor() {
      var _a2;
      return (_a2 = this.$refs.editable) == null ? void 0 : _a2.instance;
    },
    maxWidthInChars() {
      return this.settings.readability.maxWidthInChars;
    },
    mediumPlus() {
      return ["md", "lg", "xl"].includes(this.mq.current);
    },
    numberOfWords() {
      return wordCount(this.text);
    },
    options() {
      return {
        files: {
          clipboard: this.pro,
          dragAndDrop: this.pro,
          handler: (files2) => {
            return this.uploadFiles(files2);
          },
          injectMarkup: false
        },
        interface: {
          appearance: this.appearance,
          attribution: false,
          autocomplete: true,
          images: this.settings.images.enabled,
          lists: this.settings.lists.enabled,
          readonly: this.readonly,
          spellcheck: this.settings.spellcheck,
          toolbar: this.settings.toolbar
        },
        plugins: [
          ...this.plugins,
          ...this.$store.state.settings.experimental ? mermaid() : []
        ],
        selections: this.initialSelections || [],
        toolbar: {
          upload: this.pro
        },
        vim: this.settings.keyMap === "vim"
      };
    },
    plugins() {
      return plugins(this);
    },
    pro() {
      return subscription.value.pro;
    },
    readTime() {
      return readTime(this.text, this.wordsPerMinute);
    },
    readTimeDescription() {
      if (this.readTimeMinutes === 0)
        return `${this.readTimeSeconds}s to read`;
      return `${this.readTimeMinutes}m ${this.readTimeSeconds}s to read`;
    },
    readTimeMinutes() {
      return Math.floor(this.readTime);
    },
    readTimeSeconds() {
      return Math.floor(this.readTime % 1 * 60);
    },
    showReadabilityBar() {
      return this.settings.readability.enabled;
    },
    showRightSidebar() {
      return this.$store.state.showRightSidebar;
    },
    spellcheck() {
      return this.settings.spellcheck;
    },
    styles() {
      return {
        maxWidth: `${this.maxWidthInChars}ch`
      };
    },
    tags() {
      return this.$store.getters.allTags.filter((tag) => {
        return !this.doc.tags.includes(tag);
      });
    },
    text: {
      get() {
        return this.doc.text;
      },
      set(value) {
        this.input(value);
      }
    },
    wordsPerMinute() {
      return this.settings.readability.wordsPerMinute;
    }
  },
  methods: {
    focusEditor() {
      this.editor.focus();
    },
    focusInitial() {
      this.focusEditor();
      if (this.initialFocus === "start") {
        this.focusEditorStart();
      } else if (this.initialFocus === "end") {
        this.focusEditorEnd();
      }
    },
    focusEditorEnd() {
      this.focusEditor();
      this.editor.select({ at: "end" });
    },
    focusEditorStart() {
      this.focusEditor();
      this.editor.select({ at: "start" });
    },
    async input(text2) {
      this.$emit("input", text2);
    },
    async toggleMeta() {
      this.$store.dispatch(SET_RIGHT_SIDEBAR_VISIBILITY, !this.showRightSidebar);
    },
    uploadFiles(files2) {
      return Promise.all(
        Array.from(files2).map(async (file) => {
          return addFile(file).then((uploadedFile) => {
            if (/^image\/.*/.test(uploadedFile.mimeType)) {
              this.editor.insert(`![](${uploadedFile.url})`);
            }
          });
        })
      );
    }
  },
  mounted() {
    this.focusInitial();
  }
});
const _withScopeId = (n) => (pushScopeId("data-v-d012d7b3"), n = n(), popScopeId(), n);
const _hoisted_1 = { class: "min-w-0 flex flex-grow p-4 md:px-16 md:py-0" };
const _hoisted_2 = {
  key: 0,
  class: "text-gray-400 dark:text-gray-600 text-right"
};
const _hoisted_3 = {
  key: 0,
  class: "fixed top-4 right-4 z-index-10 hidden md:block"
};
const _hoisted_4 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("svg", {
  height: "1.25em",
  width: "1.25em",
  xmlns: "http://www.w3.org/2000/svg",
  fill: "none",
  viewBox: "0 0 24 24",
  stroke: "currentColor"
}, [
  /* @__PURE__ */ createBaseVNode("path", {
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "2",
    d: "M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
  })
], -1));
const _hoisted_5 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", { class: "ml-3" }, "Info", -1));
const _hoisted_6 = [
  _hoisted_4,
  _hoisted_5
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Ink = resolveComponent("Ink");
  return openBlock(), createElementBlock("div", {
    onClick: _cache[4] || (_cache[4] = (...args) => _ctx.focusEditor && _ctx.focusEditor(...args)),
    class: "flex flex-col flex-grow"
  }, [
    createBaseVNode("div", _hoisted_1, [
      createBaseVNode("div", {
        class: "editor flex flex-col flex-grow w-full mx-auto",
        style: normalizeStyle(_ctx.styles)
      }, [
        createBaseVNode("div", {
          class: "gutter h-8",
          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.focusEditorStart && _ctx.focusEditorStart(...args))
        }),
        createVNode(_component_Ink, {
          ref: "editable",
          class: "ink-editor",
          options: _ctx.options,
          modelValue: _ctx.text,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.text = $event)
        }, null, 8, ["options", "modelValue"]),
        _ctx.showReadabilityBar ? (openBlock(), createElementBlock("p", _hoisted_2, toDisplayString(_ctx.numberOfWords) + " words | " + toDisplayString(_ctx.readTimeDescription), 1)) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: "gutter h-8 flex-grow",
          onClick: _cache[2] || (_cache[2] = (...args) => _ctx.focusEditorEnd && _ctx.focusEditorEnd(...args))
        })
      ], 4)
    ]),
    !_ctx.readonly && !_ctx.showRightSidebar && _ctx.text ? (openBlock(), createElementBlock("div", _hoisted_3, [
      createBaseVNode("button", {
        onClick: _cache[3] || (_cache[3] = (...args) => _ctx.toggleMeta && _ctx.toggleMeta(...args)),
        class: "button button-size-medium button-color-gray"
      }, _hoisted_6)
    ])) : createCommentVNode("", true)
  ]);
}
const Editor = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__scopeId", "data-v-d012d7b3"]]);
export {
  delimitedIndent as $,
  cursorLineBoundaryBackward as A,
  cursorLineBoundaryForward as B,
  CharCategory as C,
  Decoration as D,
  Editor as E,
  cursorCharBackward as F,
  indentUnit as G,
  ensureSyntaxTree as H,
  Direction as I,
  indentNodeProp as J,
  continuedIndent as K,
  foldNodeProp as L,
  MapMode as M,
  styleTags as N,
  tags$5 as O,
  Prec as P,
  LRLanguage as Q,
  RangeSet as R,
  StateField as S,
  LanguageSupport as T,
  ExternalTokenizer as U,
  ViewPlugin as V,
  WidgetType as W,
  LRParser as X,
  ifNotIn as Y,
  completeFromList as Z,
  flatIndent as _,
  autocompletion as a,
  foldInside as a0,
  html$3 as a1,
  parseMixed as a2,
  ContextTracker as a3,
  EditorView as b,
  closeBrackets as c,
  EditorState as d,
  StateEffect as e,
  findClusterBreak as f,
  codePointAt as g,
  fromCodePoint as h,
  codePointSize as i,
  showPanel as j,
  StringStream as k,
  cursorCharLeft as l,
  insertNewlineAndIndent as m,
  indentSelection as n,
  deleteCharBackward as o,
  deleteCharForward as p,
  matchBrackets as q,
  re$2 as r,
  syntaxTree as s,
  RangeSetBuilder as t,
  undo$3 as u,
  redo as v,
  EditorSelection as w,
  foldCode as x,
  indentMore as y,
  indentLess as z
};
//# sourceMappingURL=Editor.47c56eaf.js.map
