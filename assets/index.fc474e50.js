(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(script) {
    const fetchOpts = {};
    if (script.integrity)
      fetchOpts.integrity = script.integrity;
    if (script.referrerpolicy)
      fetchOpts.referrerPolicy = script.referrerpolicy;
    if (script.crossorigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (script.crossorigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
function makeMap(str, expectsLowerCase) {
  const map = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i2 = 0; i2 < list.length; i2++) {
    map[list[i2]] = true;
  }
  return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function normalizeStyle(value) {
  if (isArray$3(value)) {
    const res = {};
    for (let i2 = 0; i2 < value.length; i2++) {
      const item = value[i2];
      const normalized = isString$3(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$3(value)) {
    return value;
  } else if (isObject$4(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:(.+)/;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString$3(value)) {
    res = value;
  } else if (isArray$3(value)) {
    for (let i2 = 0; i2 < value.length; i2++) {
      const normalized = normalizeClass(value[i2]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$4(value)) {
    for (const name2 in value) {
      if (value[name2]) {
        res += name2 + " ";
      }
    }
  }
  return res.trim();
}
function looseCompareArrays(a2, b2) {
  if (a2.length !== b2.length)
    return false;
  let equal2 = true;
  for (let i2 = 0; equal2 && i2 < a2.length; i2++) {
    equal2 = looseEqual(a2[i2], b2[i2]);
  }
  return equal2;
}
function looseEqual(a2, b2) {
  if (a2 === b2)
    return true;
  let aValidType = isDate$1(a2);
  let bValidType = isDate$1(b2);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a2.getTime() === b2.getTime() : false;
  }
  aValidType = isSymbol(a2);
  bValidType = isSymbol(b2);
  if (aValidType || bValidType) {
    return a2 === b2;
  }
  aValidType = isArray$3(a2);
  bValidType = isArray$3(b2);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a2, b2) : false;
  }
  aValidType = isObject$4(a2);
  bValidType = isObject$4(b2);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a2).length;
    const bKeysCount = Object.keys(b2).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a2) {
      const aHasKey = a2.hasOwnProperty(key);
      const bHasKey = b2.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a2[key], b2[key])) {
        return false;
      }
    }
  }
  return String(a2) === String(b2);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const toDisplayString = (val) => {
  return isString$3(val) ? val : val == null ? "" : isArray$3(val) || isObject$4(val) && (val.toString === objectToString || !isFunction$2(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
        entries[`${key} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject$4(val) && !isArray$3(val) && !isPlainObject$2(val)) {
    return String(val);
  }
  return val;
};
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i2 = arr.indexOf(el);
  if (i2 > -1) {
    arr.splice(i2, 1);
  }
};
const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
const isArray$3 = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isDate$1 = (val) => toTypeString(val) === "[object Date]";
const isFunction$2 = (val) => typeof val === "function";
const isString$3 = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject$4 = (val) => val !== null && typeof val === "object";
const isPromise$1 = (val) => {
  return isObject$4(val) && isFunction$2(val.then) && isFunction$2(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject$2 = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString$3(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn2) => {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache2[str];
    return hit || (cache2[str] = fn2(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i2 = 0; i2 < fns.length; i2++) {
    fns[i2](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const toNumber = (val) => {
  const n2 = parseFloat(val);
  return isNaN(n2) ? val : n2;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.active = true;
    this.effects = [];
    this.cleanups = [];
    if (!detached && activeEffectScope) {
      this.parent = activeEffectScope;
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
  }
  run(fn2) {
    if (this.active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn2();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  on() {
    activeEffectScope = this;
  }
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this.active) {
      let i2, l2;
      for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
        this.effects[i2].stop();
      }
      for (i2 = 0, l2 = this.cleanups.length; i2 < l2; i2++) {
        this.cleanups[i2]();
      }
      if (this.scopes) {
        for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
          this.scopes[i2].stop(true);
        }
      }
      if (this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function recordEffectScope(effect, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn2) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn2);
  }
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i2 = 0; i2 < deps.length; i2++) {
      deps[i2].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect) => {
  const { deps } = effect;
  if (deps.length) {
    let ptr = 0;
    for (let i2 = 0; i2 < deps.length; i2++) {
      const dep = deps[i2];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
class ReactiveEffect {
  constructor(fn2, scheduler = null, scope) {
    this.fn = fn2;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent2 = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent2) {
      if (parent2 === this) {
        return;
      }
      parent2 = parent2.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect) {
  const { deps } = effect;
  if (deps.length) {
    for (let i2 = 0; i2 < deps.length; i2++) {
      deps[i2].delete(effect);
    }
    deps.length = 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type2, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    trackEffects(dep);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
function trigger(target, type2, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type2 === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray$3(target)) {
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newValue) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type2) {
      case "add":
        if (!isArray$3(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$3(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray$3(dep) ? dep : [...dep];
  for (const effect of effects) {
    if (effect.computed) {
      triggerEffect(effect);
    }
  }
  for (const effect of effects) {
    if (!effect.computed) {
      triggerEffect(effect);
    }
  }
}
function triggerEffect(effect, debuggerEventExtraInfo) {
  if (effect !== activeEffect || effect.allowRecurse) {
    if (effect.scheduler) {
      effect.scheduler();
    } else {
      effect.run();
    }
  }
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
const get = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i2 = 0, l2 = this.length; i2 < l2; i2++) {
        track(arr, "get", i2 + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get3(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray$3(target);
    if (!isReadonly2 && targetIsArray && hasOwn(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver);
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$4(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set2(target, key, value, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow) {
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray$3(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray$3(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn(target, key);
  target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function has(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys(target) {
  track(target, "iterate", isArray$3(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
const mutableHandlers = {
  get,
  set,
  deleteProperty,
  has,
  ownKeys
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    return true;
  },
  deleteProperty(target, key) {
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
});
const toShallow = (value) => value;
const getProto = (v2) => Reflect.getPrototypeOf(v2);
function get$1(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap2(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap2(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has$1(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set$1(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get3 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  const oldValue = get3.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get3 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  get3 ? get3.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap2(value), wrap2(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap2(value[0]), wrap2(value[1])] : wrap2(value),
          done
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type2) {
  return function(...args) {
    return type2 === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$1(this, key);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$1(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$1(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target) {
  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$4(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive = (value) => isObject$4(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$4(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  if (ref2.dep) {
    {
      triggerEffects(ref2.dep);
    }
  }
}
function isRef(r2) {
  return !!(r2 && r2.__v_isRef === true);
}
function ref$2(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive(newVal);
      triggerRefValue(this);
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
function toRefs(object) {
  const ret = isArray$3(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = toRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
}
function toRef(object, key, defaultValue) {
  const val = object[key];
  return isRef(val) ? val : new ObjectRefImpl(object, key, defaultValue);
}
var _a$2;
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this[_a$2] = false;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
_a$2 = "__v_isReadonly";
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction$2(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  return cRef;
}
function callWithErrorHandling(fn2, instance, type2, args) {
  let res;
  try {
    res = args ? fn2(...args) : fn2();
  } catch (err) {
    handleError(err, instance, type2);
  }
  return res;
}
function callWithAsyncErrorHandling(fn2, instance, type2, args) {
  if (isFunction$2(fn2)) {
    const res = callWithErrorHandling(fn2, instance, type2, args);
    if (res && isPromise$1(res)) {
      res.catch((err) => {
        handleError(err, instance, type2);
      });
    }
    return res;
  }
  const values = [];
  for (let i2 = 0; i2 < fn2.length; i2++) {
    values.push(callWithAsyncErrorHandling(fn2[i2], instance, type2, args));
  }
  return values;
}
function handleError(err, instance, type2, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = type2;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
          if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
      return;
    }
  }
  logError(err, type2, contextVNode, throwInDev);
}
function logError(err, type2, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn2) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn2 ? p2.then(this ? fn2.bind(this) : fn2) : p2;
}
function findInsertionIndex(id2) {
  let start2 = flushIndex + 1;
  let end = queue.length;
  while (start2 < end) {
    const middle = start2 + end >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id2 ? start2 = middle + 1 : end = middle;
  }
  return start2;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i2 = queue.indexOf(job);
  if (i2 > flushIndex) {
    queue.splice(i2, 1);
  }
}
function queuePostFlushCb(cb2) {
  if (!isArray$3(cb2)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(cb2, cb2.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) {
      pendingPostFlushCbs.push(cb2);
    }
  } else {
    pendingPostFlushCbs.push(...cb2);
  }
  queueFlush();
}
function flushPreFlushCbs(seen2, i2 = isFlushing ? flushIndex + 1 : 0) {
  for (; i2 < queue.length; i2++) {
    const cb2 = queue[i2];
    if (cb2 && cb2.pre) {
      queue.splice(i2, 1);
      i2--;
      cb2();
    }
  }
}
function flushPostFlushCbs(seen2) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    activePostFlushCbs.sort((a2, b2) => getId(a2) - getId(b2));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a2, b2) => {
  const diff = getId(a2) - getId(b2);
  if (diff === 0) {
    if (a2.pre && !b2.pre)
      return -1;
    if (b2.pre && !a2.pre)
      return 1;
  }
  return diff;
};
function flushJobs(seen2) {
  isFlushPending = false;
  isFlushing = true;
  queue.sort(comparator);
  const check = NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false)
          ;
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
function emit$1(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
    if (trim) {
      args = rawArgs.map((a2) => a2.trim());
    }
    if (number) {
      args = rawArgs.map(toNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(handler, instance, 6, args);
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(onceHandler, instance, 6, args);
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.emitsCache;
  const cached = cache2.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$2(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$4(comp)) {
      cache2.set(comp, null);
    }
    return null;
  }
  if (isArray$3(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  if (isObject$4(comp)) {
    cache2.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id2) {
  currentScopeId = id2;
}
function popScopeId() {
  currentScopeId = null;
}
function withCtx(fn2, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn2;
  if (fn2._n) {
    return fn2;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    const res = fn2(...args);
    setCurrentRenderingInstance(prevInstance);
    if (renderFnWithContext._d) {
      setBlockTracking(1);
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const { type: Component2, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render, renderCache, data, setupState, ctx, inheritAttrs } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component2;
      if (false)
        ;
      result = normalizeVNode(render2.length > 1 ? render2(props, false ? {
        get attrs() {
          markAttrsAccessed();
          return attrs;
        },
        slots,
        emit
      } : { attrs, slots, emit }) : render2(props, null));
      fallthroughAttrs = Component2.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys2 = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys2.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys2.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
        }
        root = cloneVNode(root, fallthroughAttrs);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    root.transition = vnode.transition;
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i2 = 0; i2 < dynamicProps.length; i2++) {
        const key = dynamicProps[i2];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i2 = 0; i2 < nextKeys.length; i2++) {
    const key = nextKeys[i2];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent: parent2 }, el) {
  while (parent2 && parent2.subTree === vnode) {
    (vnode = parent2.vnode).el = el;
    parent2 = parent2.parent;
  }
}
const isSuspense = (type2) => type2.__isSuspense;
function queueEffectWithSuspense(fn2, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$3(fn2)) {
      suspense.effects.push(...fn2);
    } else {
      suspense.effects.push(fn2);
    }
  } else {
    queuePostFlushCb(fn2);
  }
}
function provide(key, value) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance) {
    const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$2(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
    } else
      ;
  }
}
function watchEffect(effect, options) {
  return doWatch(effect, null, options);
}
function watchPostEffect(effect, options) {
  return doWatch(effect, null, { flush: "post" });
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb2, options) {
  return doWatch(source, cb2, options);
}
function doWatch(source, cb2, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  const instance = currentInstance;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray$3(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s2) => isReactive(s2) || isShallow(s2));
    getter = () => source.map((s2) => {
      if (isRef(s2)) {
        return s2.value;
      } else if (isReactive(s2)) {
        return traverse(s2);
      } else if (isFunction$2(s2)) {
        return callWithErrorHandling(s2, instance, 2);
      } else
        ;
    });
  } else if (isFunction$2(source)) {
    if (cb2) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(source, instance, 3, [onCleanup]);
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb2 && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn2) => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling(fn2, instance, 4);
    };
  };
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb2) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb2, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    return NOOP;
  }
  let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect.active) {
      return;
    }
    if (cb2) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i2) => hasChanged(v2, oldValue[i2])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb2, instance, 3, [
          newValue,
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect.run();
    }
  };
  job.allowRecurse = !!cb2;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance)
      job.id = instance.uid;
    scheduler = () => queueJob(job);
  }
  const effect = new ReactiveEffect(getter, scheduler);
  if (cb2) {
    if (immediate) {
      job();
    } else {
      oldValue = effect.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
  } else {
    effect.run();
  }
  return () => {
    effect.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect);
    }
  };
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString$3(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb2;
  if (isFunction$2(value)) {
    cb2 = value;
  } else {
    cb2 = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb2.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i2 = 0; i2 < segments.length && cur; i2++) {
      cur = cur[segments[i2]];
    }
    return cur;
  };
}
function traverse(value, seen2) {
  if (!isObject$4(value) || value["__v_skip"]) {
    return value;
  }
  seen2 = seen2 || /* @__PURE__ */ new Set();
  if (seen2.has(value)) {
    return value;
  }
  seen2.add(value);
  if (isRef(value)) {
    traverse(value.value, seen2);
  } else if (isArray$3(value)) {
    for (let i2 = 0; i2 < value.length; i2++) {
      traverse(value[i2], seen2);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v2) => {
      traverse(v2, seen2);
    });
  } else if (isPlainObject$2(value)) {
    for (const key in value) {
      traverse(value[key], seen2);
    }
  }
  return value;
}
function defineComponent(options) {
  return isFunction$2(options) ? { setup: options, name: options.name } : options;
}
const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
function defineAsyncComponent(source) {
  if (isFunction$2(source)) {
    source = { loader: source };
  }
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    timeout,
    suspensible = true,
    onError: userOnError
  } = source;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = () => {
    retries++;
    pendingRequest = null;
    return load();
  };
  const load = () => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise((resolve2, reject) => {
          const userRetry = () => resolve2(retry());
          const userFail = () => reject(err);
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then((comp) => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      resolvedComp = comp;
      return comp;
    }));
  };
  return defineComponent({
    name: "AsyncComponentWrapper",
    __asyncLoader: load,
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = (err) => {
        pendingRequest = null;
        handleError(err, instance, 13, !errorComponent);
      };
      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load().then((comp) => {
          return () => createInnerComp(comp, instance);
        }).catch((err) => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }
      const loaded = ref$2(false);
      const error = ref$2();
      const delayed = ref$2(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout != null) {
        setTimeout(() => {
          if (!loaded.value && !error.value) {
            const err = new Error(`Async component timed out after ${timeout}ms.`);
            onError(err);
            error.value = err;
          }
        }, timeout);
      }
      load().then(() => {
        loaded.value = true;
        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          queueJob(instance.parent.update);
        }
      }).catch((err) => {
        onError(err);
        error.value = err;
      });
      return () => {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}
function createInnerComp(comp, { vnode: { ref: ref2, props, children, shapeFlag }, parent: parent2 }) {
  const vnode = createVNode(comp, props, children);
  vnode.ref = ref2;
  return vnode;
}
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type2, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type2, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type2, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type2, target, keepAliveRoot) {
  const injected = injectHook(type2, hook, keepAliveRoot, true);
  onUnmounted(() => {
    remove(keepAliveRoot[type2], injected);
  }, target);
}
function injectHook(type2, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type2] || (target[type2] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type2, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
function withDirectives(vnode, directives) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
    return vnode;
  }
  const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i2 = 0; i2 < directives.length; i2++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i2];
    if (isFunction$2(dir)) {
      dir = {
        mounted: dir,
        updated: dir
      };
    }
    if (dir.deep) {
      traverse(value);
    }
    bindings.push({
      dir,
      instance,
      value,
      oldValue: void 0,
      arg,
      modifiers
    });
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name2) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i2 = 0; i2 < bindings.length; i2++) {
    const binding = bindings[i2];
    if (oldBindings) {
      binding.oldValue = oldBindings[i2].value;
    }
    let hook = binding.dir[name2];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const COMPONENTS = "components";
function resolveComponent(name2, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name2, true, maybeSelfReference) || name2;
}
const NULL_DYNAMIC_COMPONENT = Symbol();
function resolveDynamicComponent(component) {
  if (isString$3(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveAsset(type2, name2, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component2 = instance.type;
    if (type2 === COMPONENTS) {
      const selfName = getComponentName(Component2, false);
      if (selfName && (selfName === name2 || selfName === camelize(name2) || selfName === capitalize(camelize(name2)))) {
        return Component2;
      }
    }
    const res = resolve(instance[type2] || Component2[type2], name2) || resolve(instance.appContext[type2], name2);
    if (!res && maybeSelfReference) {
      return Component2;
    }
    return res;
  }
}
function resolve(registry, name2) {
  return registry && (registry[name2] || registry[camelize(name2)] || registry[capitalize(camelize(name2))]);
}
function renderList(source, renderItem, cache2, index) {
  let ret;
  const cached = cache2 && cache2[index];
  if (isArray$3(source) || isString$3(source)) {
    ret = new Array(source.length);
    for (let i2 = 0, l2 = source.length; i2 < l2; i2++) {
      ret[i2] = renderItem(source[i2], i2, void 0, cached && cached[i2]);
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i2 = 0; i2 < source; i2++) {
      ret[i2] = renderItem(i2 + 1, i2, void 0, cached && cached[i2]);
    }
  } else if (isObject$4(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(source, (item, i2) => renderItem(item, i2, void 0, cached && cached[i2]));
    } else {
      const keys2 = Object.keys(source);
      ret = new Array(keys2.length);
      for (let i2 = 0, l2 = keys2.length; i2 < l2; i2++) {
        const key = keys2[i2];
        ret[i2] = renderItem(source[key], key, i2, cached && cached[i2]);
      }
    }
  } else {
    ret = [];
  }
  if (cache2) {
    cache2[index] = ret;
  }
  return ret;
}
function renderSlot(slots, name2, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
    return createVNode("slot", name2 === "default" ? null : { name: name2 }, fallback && fallback());
  }
  let slot = slots[name2];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(Fragment, {
    key: props.key || validSlotContent && validSlotContent.key || `_${name2}`
  }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child2) => {
    if (!isVNode(child2))
      return true;
    if (child2.type === Comment)
      return false;
    if (child2.type === Fragment && !ensureValidVNode(child2.children))
      return false;
    return true;
  }) ? vnodes : null;
}
const getPublicInstance = (i2) => {
  if (!i2)
    return null;
  if (isStatefulComponent(i2))
    return getExposeProxy(i2) || i2.proxy;
  return getPublicInstance(i2.parent);
};
const publicPropertiesMap = /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
  $: (i2) => i2,
  $el: (i2) => i2.vnode.el,
  $data: (i2) => i2.data,
  $props: (i2) => i2.props,
  $attrs: (i2) => i2.attrs,
  $slots: (i2) => i2.slots,
  $refs: (i2) => i2.refs,
  $parent: (i2) => getPublicInstance(i2.parent),
  $root: (i2) => getPublicInstance(i2.root),
  $emit: (i2) => i2.emit,
  $options: (i2) => resolveMergedOptions(i2),
  $forceUpdate: (i2) => i2.f || (i2.f = () => queueJob(i2.update)),
  $nextTick: (i2) => i2.n || (i2.n = nextTick.bind(i2.proxy)),
  $watch: (i2) => instanceWatch.bind(i2)
});
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data, props, accessCache, type: type2, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n2 = accessCache[key];
      if (n2 !== void 0) {
        switch (n2) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if ((normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if ((cssModule = type2.__cssModules) && (cssModule = cssModule[key])) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)) {
      {
        return globalProperties[key];
      }
    } else
      ;
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || setupState !== EMPTY_OBJ && hasOwn(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook(options.beforeCreate, instance, "bc");
  }
  const {
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    expose,
    inheritAttrs,
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$2(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject$4(data))
      ;
    else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get3 = isFunction$2(opt) ? opt.bind(publicThis, publicThis) : isFunction$2(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set2 = !isFunction$2(opt) && isFunction$2(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c2 = computed({
        get: get3,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c2.value,
        set: (v2) => c2.value = v2
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$2(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook(created, instance, "c");
  }
  function registerLifecycleHook(register2, hook) {
    if (isArray$3(hook)) {
      hook.forEach((_hook) => register2(_hook.bind(publicThis)));
    } else if (hook) {
      register2(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$3(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {
  if (isArray$3(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$4(opt)) {
      if ("default" in opt) {
        injected = inject(opt.from || key, opt.default, true);
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      if (unwrapRef) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v2) => injected.value = v2
        });
      } else {
        ctx[key] = injected;
      }
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook(hook, instance, type2) {
  callWithAsyncErrorHandling(isArray$3(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type2);
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$3(raw)) {
    const handler = ctx[raw];
    if (isFunction$2(handler)) {
      watch(getter, handler);
    }
  } else if (isFunction$2(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$4(raw)) {
    if (isArray$3(raw)) {
      raw.forEach((r2) => createWatcher(r2, ctx, publicThis, key));
    } else {
      const handler = isFunction$2(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$2(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const { mixins: globalMixins, optionsCache: cache2, config: { optionMergeStrategies } } = instance.appContext;
  const cached = cache2.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach((m2) => mergeOptions$1(resolved, m2, optionMergeStrategies, true));
    }
    mergeOptions$1(resolved, base, optionMergeStrategies);
  }
  if (isObject$4(base)) {
    cache2.set(base, resolved);
  }
  return resolved;
}
function mergeOptions$1(to2, from2, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from2;
  if (extendsOptions) {
    mergeOptions$1(to2, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach((m2) => mergeOptions$1(to2, m2, strats, true));
  }
  for (const key in from2) {
    if (asMixin && key === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to2[key] = strat ? strat(to2[key], from2[key]) : from2[key];
    }
  }
  return to2;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeObjectOptions,
  emits: mergeObjectOptions,
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  watch: mergeWatchOptions,
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to2, from2) {
  if (!from2) {
    return to2;
  }
  if (!to2) {
    return from2;
  }
  return function mergedDataFn() {
    return extend(isFunction$2(to2) ? to2.call(this, this) : to2, isFunction$2(from2) ? from2.call(this, this) : from2);
  };
}
function mergeInject(to2, from2) {
  return mergeObjectOptions(normalizeInject(to2), normalizeInject(from2));
}
function normalizeInject(raw) {
  if (isArray$3(raw)) {
    const res = {};
    for (let i2 = 0; i2 < raw.length; i2++) {
      res[raw[i2]] = raw[i2];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to2, from2) {
  return to2 ? [...new Set([].concat(to2, from2))] : from2;
}
function mergeObjectOptions(to2, from2) {
  return to2 ? extend(extend(/* @__PURE__ */ Object.create(null), to2), from2) : from2;
}
function mergeWatchOptions(to2, from2) {
  if (!to2)
    return from2;
  if (!from2)
    return to2;
  const merged = extend(/* @__PURE__ */ Object.create(null), to2);
  for (const key in from2) {
    merged[key] = mergeAsArray(to2[key], from2[key]);
  }
  return merged;
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const { props, attrs, vnode: { patchFlag } } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if ((optimized || patchFlag > 0) && !(patchFlag & 16)) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
        let key = propsToUpdate[i2];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false);
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || !hasOwn(rawProps, key) && ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && (rawPrevProps[key] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance, true);
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i2 = 0; i2 < needCastKeys.length; i2++) {
      const key = needCastKeys[i2];
      props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !hasOwn(castValues, key));
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && isFunction$2(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(null, props);
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[0]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache2 = appContext.propsCache;
  const cached = cache2.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$2(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys2)
        needCastKeys.push(...keys2);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$4(comp)) {
      cache2.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$3(raw)) {
    for (let i2 = 0; i2 < raw.length; i2++) {
      const normalizedKey = camelize(raw[i2]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$3(opt) || isFunction$2(opt) ? { type: opt } : opt;
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[0] = booleanIndex > -1;
          prop[1] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$4(comp)) {
    cache2.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  }
  return false;
}
function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ctor === null ? "null" : "";
}
function isSameType(a2, b2) {
  return getType(a2) === getType(b2);
}
function getTypeIndex(type2, expectedTypes) {
  if (isArray$3(expectedTypes)) {
    return expectedTypes.findIndex((t2) => isSameType(t2, type2));
  } else if (isFunction$2(expectedTypes)) {
    return isSameType(expectedTypes, type2) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray$3(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot$1 = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction$2(value)) {
      slots[key] = normalizeSlot$1(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type2 = children._;
    if (type2) {
      instance.slots = toRaw(children);
      def(children, "_", type2);
    } else {
      normalizeObjectSlots(children, instance.slots = {});
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type2 = children._;
    if (type2) {
      if (optimized && type2 === 1) {
        needDeletionCheck = false;
      } else {
        extend(slots, children);
        if (!optimized && type2 === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid = 0;
function createAppAPI(render, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$2(rootComponent)) {
      rootComponent = Object.assign({}, rootComponent);
    }
    if (rootProps != null && !isObject$4(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    let isMounted = false;
    const app2 = context.app = {
      _uid: uid++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version: version$4,
      get config() {
        return context.config;
      },
      set config(v2) {
      },
      use(plugin2, ...options) {
        if (installedPlugins.has(plugin2))
          ;
        else if (plugin2 && isFunction$2(plugin2.install)) {
          installedPlugins.add(plugin2);
          plugin2.install(app2, ...options);
        } else if (isFunction$2(plugin2)) {
          installedPlugins.add(plugin2);
          plugin2(app2, ...options);
        } else
          ;
        return app2;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app2;
      },
      component(name2, component) {
        if (!component) {
          return context.components[name2];
        }
        context.components[name2] = component;
        return app2;
      },
      directive(name2, directive) {
        if (!directive) {
          return context.directives[name2];
        }
        context.directives[name2] = directive;
        return app2;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app2._container = rootContainer;
          rootContainer.__vue_app__ = app2;
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        }
      },
      unmount() {
        if (isMounted) {
          render(null, app2._container);
          delete app2._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app2;
      }
    };
    return app2;
  };
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$3(rawRef)) {
    rawRef.forEach((r2, i2) => setRef(r2, oldRawRef && (isArray$3(oldRawRef) ? oldRawRef[i2] : oldRawRef), parentSuspense, vnode, isUnmount));
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref2) {
    if (isString$3(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$2(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value, refs]);
  } else {
    const _isString = isString$3(ref2);
    const _isRef = isRef(ref2);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? refs[ref2] : ref2.value;
          if (isUnmount) {
            isArray$3(existing) && remove(existing, refValue);
          } else {
            if (!isArray$3(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
                if (hasOwn(setupState, ref2)) {
                  setupState[ref2] = refs[ref2];
                }
              } else {
                ref2.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref2.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref2] = value;
          if (hasOwn(setupState, ref2)) {
            setupState[ref2] = value;
          }
        } else if (_isRef) {
          ref2.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else
          ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, insertStaticContent: hostInsertStaticContent } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type: type2, ref: ref2, shapeFlag } = n2;
    switch (type2) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        }
        break;
      case Fragment:
        processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        break;
      default:
        if (shapeFlag & 1) {
          processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 6) {
          processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 64) {
          type2.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (shapeFlag & 128) {
          type2.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else
          ;
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { type: type2, props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type2 !== "foreignObject", slotScopeIds, optimized);
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
        hostSetScopeId(el, slotScopeIds[i2]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start2 = 0) => {
    for (let i2 = start2; i2 < children.length; i2++) {
      const child2 = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
      patch(null, child2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
    } else if (!optimized) {
      patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
            const key = propsToUpdate[i2];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i2 = 0; i2 < newChildren.length; i2++) {
      const oldVNode = oldChildren[i2];
      const newVNode = newChildren[i2];
      const container = oldVNode.el && (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : fallbackContainer;
      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n1.dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
        if (n2.key != null || parentComponent && n2 === parentComponent.subTree) {
          traverseStaticChildren(n1, n2, true);
        }
      } else {
        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
      } else {
        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m: m2, parent: parent2 } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent2, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(el, instance.subTree, instance, parentSuspense, null);
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
          initialVNode.el = subTree.el;
        }
        if (m2) {
          queuePostRenderEffect(m2, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent2, scopedInitialVNode), parentSuspense);
        }
        if (initialVNode.shapeFlag & 256 || parent2 && isAsyncWrapper(parent2.vnode) && parent2.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu: bu2, u: u2, parent: parent2, vnode } = instance;
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu2) {
          invokeArrayFns(bu2);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent2, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          hostParentNode(prevTree.el),
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          isSVG
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u2) {
          queuePostRenderEffect(u2, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent2, next, vnode), parentSuspense);
        }
      }
    };
    const effect = instance.effect = new ReactiveEffect(
      componentUpdateFn,
      () => queueJob(update3),
      instance.scope
    );
    const update3 = instance.update = () => effect.run();
    update3.id = instance.uid;
    toggleRecurse(instance, true);
    update3();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs();
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i2;
    for (i2 = 0; i2 < commonLength; i2++) {
      const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      patch(c1[i2], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
    if (oldLength > newLength) {
      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
    } else {
      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i2 = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[i2];
      const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      i2++;
    }
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i2 > e1) {
      if (i2 <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i2 <= e2) {
          patch(null, c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          i2++;
        }
      }
    } else if (i2 > e2) {
      while (i2 <= e1) {
        unmount(c1[i2], parentComponent, parentSuspense, true);
        i2++;
      }
    } else {
      const s1 = i2;
      const s2 = i2;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i2 = s2; i2 <= e2; i2++) {
        const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i2);
        }
      }
      let j2;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i2 = 0; i2 < toBePatched; i2++)
        newIndexToOldIndexMap[i2] = 0;
      for (i2 = s1; i2 <= e1; i2++) {
        const prevChild = c1[i2];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j2 = s2; j2 <= e2; j2++) {
            if (newIndexToOldIndexMap[j2 - s2] === 0 && isSameVNodeType(prevChild, c2[j2])) {
              newIndex = j2;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j2 = increasingNewIndexSequence.length - 1;
      for (i2 = toBePatched - 1; i2 >= 0; i2--) {
        const nextIndex = s2 + i2;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i2] === 0) {
          patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (moved) {
          if (j2 < 0 || i2 !== increasingNewIndexSequence[j2]) {
            move(nextChild, container, anchor, 2);
          } else {
            j2--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type: type2, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type2.move(vnode, container, anchor, internals);
      return;
    }
    if (type2 === Fragment) {
      hostInsert(el, container, anchor);
      for (let i2 = 0; i2 < children.length; i2++) {
        move(children[i2], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type2 === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove3 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove3();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove3, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const { type: type2, props, ref: ref2, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
      } else if (dynamicChildren && (type2 !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
      } else if (type2 === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type: type2, el, anchor, transition } = vnode;
    if (type2 === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type2 === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, update: update3, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update3) {
      update3.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start2 = 0) => {
    for (let i2 = start2; i2 < children.length; i2++) {
      unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPreFlushCbs();
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(internals);
  }
  return {
    render,
    hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}
function toggleRecurse({ effect, update: update3 }, allowed) {
  effect.allowRecurse = update3.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$3(ch1) && isArray$3(ch2)) {
    for (let i2 = 0; i2 < ch1.length; i2++) {
      const c1 = ch1[i2];
      let c2 = ch2[i2];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i2, j2, u2, v2, c2;
  const len = arr.length;
  for (i2 = 0; i2 < len; i2++) {
    const arrI = arr[i2];
    if (arrI !== 0) {
      j2 = result[result.length - 1];
      if (arr[j2] < arrI) {
        p2[i2] = j2;
        result.push(i2);
        continue;
      }
      u2 = 0;
      v2 = result.length - 1;
      while (u2 < v2) {
        c2 = u2 + v2 >> 1;
        if (arr[result[c2]] < arrI) {
          u2 = c2 + 1;
        } else {
          v2 = c2;
        }
      }
      if (arrI < arr[result[u2]]) {
        if (u2 > 0) {
          p2[i2] = result[u2 - 1];
        }
        result[u2] = i2;
      }
    }
  }
  u2 = result.length;
  v2 = result[u2 - 1];
  while (u2-- > 0) {
    result[u2] = v2;
    v2 = p2[v2];
  }
  return result;
}
const isTeleport = (type2) => type2.__isTeleport;
const Fragment = Symbol(void 0);
const Text = Symbol(void 0);
const Comment = Symbol(void 0);
const Static = Symbol(void 0);
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type2, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(createBaseVNode(type2, props, children, patchFlag, dynamicProps, shapeFlag, true));
}
function createBlock(type2, props, children, patchFlag, dynamicProps) {
  return setupBlock(createVNode(type2, props, children, patchFlag, dynamicProps, true));
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({ ref: ref2, ref_key, ref_for }) => {
  return ref2 != null ? isString$3(ref2) || isRef(ref2) || isFunction$2(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
};
function createBaseVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type2 === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type: type2,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type2.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$3(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type2, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type2 || type2 === NULL_DYNAMIC_COMPONENT) {
    type2 = Comment;
  }
  if (isVNode(type2)) {
    const cloned = cloneVNode(type2, props, true);
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type2)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type2)) {
    type2 = type2.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style: style2 } = props;
    if (klass && !isString$3(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$4(style2)) {
      if (isProxy(style2) && !isArray$3(style2)) {
        style2 = extend({}, style2);
      }
      props.style = normalizeStyle(style2);
    }
  }
  const shapeFlag = isString$3(type2) ? 1 : isSuspense(type2) ? 128 : isTeleport(type2) ? 64 : isObject$4(type2) ? 4 : isFunction$2(type2) ? 2 : 0;
  return createBaseVNode(type2, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref: ref2, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? mergeRef && ref2 ? isArray$3(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref2,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor
  };
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child2) {
  if (child2 == null || typeof child2 === "boolean") {
    return createVNode(Comment);
  } else if (isArray$3(child2)) {
    return createVNode(
      Fragment,
      null,
      child2.slice()
    );
  } else if (typeof child2 === "object") {
    return cloneIfMounted(child2);
  } else {
    return createVNode(Text, null, String(child2));
  }
}
function cloneIfMounted(child2) {
  return child2.el === null && child2.patchFlag !== -1 || child2.memo ? child2 : cloneVNode(child2);
}
function normalizeChildren(vnode, children) {
  let type2 = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$3(children)) {
    type2 = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type2 = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$2(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type2 = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type2 = 16;
      children = [createTextVNode(children)];
    } else {
      type2 = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type2;
}
function mergeProps(...args) {
  const ret = {};
  for (let i2 = 0; i2 < args.length; i2++) {
    const toMerge = args[i2];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$3(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid$1 = 0;
function createComponentInstance(vnode, parent2, suspense) {
  const type2 = vnode.type;
  const appContext = (parent2 ? parent2.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid$1++,
    vnode,
    type: type2,
    parent: parent2,
    appContext,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new EffectScope(true),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent2 ? parent2.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    components: null,
    directives: null,
    propsOptions: normalizePropsOptions(type2, appContext),
    emitsOptions: normalizeEmitsOptions(type2, appContext),
    emit: null,
    emitted: null,
    propsDefaults: EMPTY_OBJ,
    inheritAttrs: type2.inheritAttrs,
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent2 ? parent2.root : instance;
  instance.emit = emit$1.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
const setCurrentInstance = (instance) => {
  currentInstance = instance;
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  currentInstance = null;
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component2 = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  const { setup } = Component2;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(setup, instance, 0, [instance.props, setupContext]);
    resetTracking();
    unsetCurrentInstance();
    if (isPromise$1(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e2) => {
          handleError(e2, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$2(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$4(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance, isSSR);
}
let compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component2 = instance.type;
  if (!instance.render) {
    if (!isSSR && compile && !Component2.render) {
      const template = Component2.template || resolveMergedOptions(instance).template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component2;
        const finalCompilerOptions = extend(extend({
          isCustomElement,
          delimiters
        }, compilerOptions), componentCompilerOptions);
        Component2.render = compile(template, finalCompilerOptions);
      }
    }
    instance.render = Component2.render || NOOP;
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
}
function createAttrsProxy(instance) {
  return new Proxy(instance.attrs, {
    get(target, key) {
      track(instance, "get", "$attrs");
      return target[key];
    }
  });
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  let attrs;
  {
    return {
      get attrs() {
        return attrs || (attrs = createAttrsProxy(instance));
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      }
    }));
  }
}
function getComponentName(Component2, includeInferred = true) {
  return isFunction$2(Component2) ? Component2.displayName || Component2.name : Component2.name || includeInferred && Component2.__name;
}
function isClassComponent(value) {
  return isFunction$2(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
function useSlots() {
  return getContext().slots;
}
function getContext() {
  const i2 = getCurrentInstance();
  return i2.setupContext || (i2.setupContext = createSetupContext(i2));
}
function h$1(type2, propsOrChildren, children) {
  const l2 = arguments.length;
  if (l2 === 2) {
    if (isObject$4(propsOrChildren) && !isArray$3(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type2, null, [propsOrChildren]);
      }
      return createVNode(type2, propsOrChildren);
    } else {
      return createVNode(type2, null, propsOrChildren);
    }
  } else {
    if (l2 > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l2 === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type2, propsOrChildren, children);
  }
}
const version$4 = "3.2.40";
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child2, parent2, anchor) => {
    parent2.insertBefore(child2, anchor || null);
  },
  remove: (child2) => {
    const parent2 = child2.parentNode;
    if (parent2) {
      parent2.removeChild(child2);
    }
  },
  createElement: (tag, isSVG, is2, props) => {
    const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is2 ? { is: is2 } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id2) {
    el.setAttribute(id2, "");
  },
  insertStaticContent(content, parent2, anchor, isSVG, start2, end) {
    const before2 = anchor ? anchor.previousSibling : parent2.lastChild;
    if (start2 && (start2 === end || start2.nextSibling)) {
      while (true) {
        parent2.insertBefore(start2.cloneNode(true), anchor);
        if (start2 === end || !(start2 = start2.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent2.insertBefore(template, anchor);
    }
    return [
      before2 ? before2.nextSibling : parent2.firstChild,
      anchor ? anchor.previousSibling : parent2.lastChild
    ];
  }
};
function patchClass(el, value, isSVG) {
  const transitionClasses = el._vtc;
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
function patchStyle(el, prev, next) {
  const style2 = el.style;
  const isCssString = isString$3(next);
  if (next && !isCssString) {
    for (const key in next) {
      setStyle(style2, key, next[key]);
    }
    if (prev && !isString$3(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style2, key, "");
        }
      }
    }
  } else {
    const currentDisplay = style2.display;
    if (isCssString) {
      if (prev !== next) {
        style2.cssText = next;
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
    if ("_vod" in el) {
      style2.display = currentDisplay;
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style2, name2, val) {
  if (isArray$3(val)) {
    val.forEach((v2) => setStyle(style2, name2, v2));
  } else {
    if (val == null)
      val = "";
    if (name2.startsWith("--")) {
      style2.setProperty(name2, val);
    } else {
      const prefixed = autoPrefix(style2, name2);
      if (importantRE.test(val)) {
        style2.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
      } else {
        style2[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style2, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name2 = camelize(rawName);
  if (name2 !== "filter" && name2 in style2) {
    return prefixCache[rawName] = name2;
  }
  name2 = capitalize(name2);
  for (let i2 = 0; i2 < prefixes.length; i2++) {
    const prefixed = prefixes[i2] + name2;
    if (prefixed in style2) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean2 = isSpecialBooleanAttr(key);
    if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean2 ? "" : value);
    }
  }
}
function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value == null ? "" : value;
    return;
  }
  if (key === "value" && el.tagName !== "PROGRESS" && !el.tagName.includes("-")) {
    el._value = value;
    const newValue = value == null ? "" : value;
    if (el.value !== newValue || el.tagName === "OPTION") {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type2 = typeof el[key];
    if (type2 === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type2 === "string") {
      value = "";
      needRemove = true;
    } else if (type2 === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e2) {
  }
  needRemove && el.removeAttribute(key);
}
const [_getNow, skipTimestampCheck] = /* @__PURE__ */ (() => {
  let _getNow2 = Date.now;
  let skipTimestampCheck2 = false;
  if (typeof window !== "undefined") {
    if (Date.now() > document.createEvent("Event").timeStamp) {
      _getNow2 = performance.now.bind(performance);
    }
    const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
    skipTimestampCheck2 = !!(ffMatch && Number(ffMatch[1]) <= 53);
  }
  return [_getNow2, skipTimestampCheck2];
})();
let cachedNow = 0;
const p$2 = /* @__PURE__ */ Promise.resolve();
const reset = () => {
  cachedNow = 0;
};
const getNow = () => cachedNow || (p$2.then(reset), cachedNow = _getNow());
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el._vei || (el._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name2, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el, name2, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name2, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name2) {
  let options;
  if (optionsModifierRE.test(name2)) {
    options = {};
    let m2;
    while (m2 = name2.match(optionsModifierRE)) {
      name2 = name2.slice(0, name2.length - m2[0].length);
      options[m2[0].toLowerCase()] = true;
    }
  }
  const event = name2[2] === ":" ? name2.slice(3) : hyphenate(name2.slice(2));
  return [event, options];
}
function createInvoker(initialValue, instance) {
  const invoker = (e2) => {
    const timeStamp = e2.timeStamp || _getNow();
    if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
      callWithAsyncErrorHandling(patchStopImmediatePropagation(e2, invoker.value), instance, 5, [e2]);
    }
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e2, value) {
  if (isArray$3(value)) {
    const originalStop = e2.stopImmediatePropagation;
    e2.stopImmediatePropagation = () => {
      originalStop.call(e2);
      e2._stopped = true;
    };
    return value.map((fn2) => (e3) => !e3._stopped && fn2 && fn2(e3));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && nativeOnRE.test(key) && isFunction$2(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString$3(value)) {
    return false;
  }
  return key in el;
}
function useCssVars(getter) {
  const instance = getCurrentInstance();
  if (!instance) {
    return;
  }
  const setVars = () => setVarsOnVNode(instance.subTree, getter(instance.proxy));
  watchPostEffect(setVars);
  onMounted(() => {
    const ob2 = new MutationObserver(setVars);
    ob2.observe(instance.subTree.el.parentNode, { childList: true });
    onUnmounted(() => ob2.disconnect());
  });
}
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === Fragment) {
    vnode.children.forEach((c2) => setVarsOnVNode(c2, vars));
  } else if (vnode.type === Static) {
    let { el, anchor } = vnode;
    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor)
        break;
      el = el.nextSibling;
    }
  }
}
function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    const style2 = el.style;
    for (const key in vars) {
      style2.setProperty(`--${key}`, vars[key]);
    }
  }
}
const getModelAssigner = (vnode) => {
  const fn2 = vnode.props["onUpdate:modelValue"] || false;
  return isArray$3(fn2) ? (value) => invokeArrayFns(fn2, value) : fn2;
};
function onCompositionStart(e2) {
  e2.target.composing = true;
}
function onCompositionEnd(e2) {
  const target = e2.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
const vModelText = {
  created(el, { modifiers: { lazy, trim, number } }, vnode) {
    el._assign = getModelAssigner(vnode);
    const castToNumber = number || vnode.props && vnode.props.type === "number";
    addEventListener(el, lazy ? "change" : "input", (e2) => {
      if (e2.target.composing)
        return;
      let domValue = el.value;
      if (trim) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = toNumber(domValue);
      }
      el._assign(domValue);
    });
    if (trim) {
      addEventListener(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el, "compositionstart", onCompositionStart);
      addEventListener(el, "compositionend", onCompositionEnd);
      addEventListener(el, "change", onCompositionEnd);
    }
  },
  mounted(el, { value }) {
    el.value = value == null ? "" : value;
  },
  beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {
    el._assign = getModelAssigner(vnode);
    if (el.composing)
      return;
    if (document.activeElement === el && el.type !== "range") {
      if (lazy) {
        return;
      }
      if (trim && el.value.trim() === value) {
        return;
      }
      if ((number || el.type === "number") && toNumber(el.value) === value) {
        return;
      }
    }
    const newValue = value == null ? "" : value;
    if (el.value !== newValue) {
      el.value = newValue;
    }
  }
};
const vModelCheckbox = {
  deep: true,
  created(el, _2, vnode) {
    el._assign = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      const modelValue = el._modelValue;
      const elementValue = getValue(el);
      const checked = el.checked;
      const assign2 = el._assign;
      if (isArray$3(modelValue)) {
        const index = looseIndexOf(modelValue, elementValue);
        const found = index !== -1;
        if (checked && !found) {
          assign2(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index, 1);
          assign2(filtered);
        }
      } else if (isSet(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign2(cloned);
      } else {
        assign2(getCheckboxValue(el, checked));
      }
    });
  },
  mounted: setChecked,
  beforeUpdate(el, binding, vnode) {
    el._assign = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};
function setChecked(el, { value, oldValue }, vnode) {
  el._modelValue = value;
  if (isArray$3(value)) {
    el.checked = looseIndexOf(value, vnode.props.value) > -1;
  } else if (isSet(value)) {
    el.checked = value.has(vnode.props.value);
  } else if (value !== oldValue) {
    el.checked = looseEqual(value, getCheckboxValue(el, true));
  }
}
const vModelRadio = {
  created(el, { value }, vnode) {
    el.checked = looseEqual(value, vnode.props.value);
    el._assign = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      el._assign(getValue(el));
    });
  },
  beforeUpdate(el, { value, oldValue }, vnode) {
    el._assign = getModelAssigner(vnode);
    if (value !== oldValue) {
      el.checked = looseEqual(value, vnode.props.value);
    }
  }
};
const vModelSelect = {
  deep: true,
  created(el, { value, modifiers: { number } }, vnode) {
    const isSetModel = isSet(value);
    addEventListener(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o2) => o2.selected).map((o2) => number ? toNumber(getValue(o2)) : getValue(o2));
      el._assign(el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
    });
    el._assign = getModelAssigner(vnode);
  },
  mounted(el, { value }) {
    setSelected(el, value);
  },
  beforeUpdate(el, _binding, vnode) {
    el._assign = getModelAssigner(vnode);
  },
  updated(el, { value }) {
    setSelected(el, value);
  }
};
function setSelected(el, value) {
  const isMultiple = el.multiple;
  if (isMultiple && !isArray$3(value) && !isSet(value)) {
    return;
  }
  for (let i2 = 0, l2 = el.options.length; i2 < l2; i2++) {
    const option = el.options[i2];
    const optionValue = getValue(option);
    if (isMultiple) {
      if (isArray$3(value)) {
        option.selected = looseIndexOf(value, optionValue) > -1;
      } else {
        option.selected = value.has(optionValue);
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i2)
          el.selectedIndex = i2;
        return;
      }
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue(el) {
  return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
  const key = checked ? "_trueValue" : "_falseValue";
  return key in el ? el[key] : checked;
}
const vModelDynamic = {
  created(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "created");
  },
  mounted(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "mounted");
  },
  beforeUpdate(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
  },
  updated(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "updated");
  }
};
function resolveDynamicModel(tagName, type2) {
  switch (tagName) {
    case "SELECT":
      return vModelSelect;
    case "TEXTAREA":
      return vModelText;
    default:
      switch (type2) {
        case "checkbox":
          return vModelCheckbox;
        case "radio":
          return vModelRadio;
        default:
          return vModelText;
      }
  }
}
function callModelHook(el, binding, vnode, prevVNode, hook) {
  const modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);
  const fn2 = modelToUse[hook];
  fn2 && fn2(el, binding, vnode, prevVNode);
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e2) => e2.stopPropagation(),
  prevent: (e2) => e2.preventDefault(),
  self: (e2) => e2.target !== e2.currentTarget,
  ctrl: (e2) => !e2.ctrlKey,
  shift: (e2) => !e2.shiftKey,
  alt: (e2) => !e2.altKey,
  meta: (e2) => !e2.metaKey,
  left: (e2) => "button" in e2 && e2.button !== 0,
  middle: (e2) => "button" in e2 && e2.button !== 1,
  right: (e2) => "button" in e2 && e2.button !== 2,
  exact: (e2, modifiers) => systemModifiers.some((m2) => e2[`${m2}Key`] && !modifiers.includes(m2))
};
const withModifiers = (fn2, modifiers) => {
  return (event, ...args) => {
    for (let i2 = 0; i2 < modifiers.length; i2++) {
      const guard = modifierGuards[modifiers[i2]];
      if (guard && guard(event, modifiers))
        return;
    }
    return fn2(event, ...args);
  };
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn2, modifiers) => {
  return (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some((k2) => k2 === eventKey || keyNames[k2] === eventKey)) {
      return fn2(event);
    }
  };
};
const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app2 = ensureRenderer().createApp(...args);
  const { mount } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app2._component;
    if (!isFunction$2(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app2;
};
function normalizeContainer(container) {
  if (isString$3(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
var isVue2 = false;
var _a$1;
const isClient$1 = typeof window !== "undefined";
const isFunction$1 = (val) => typeof val === "function";
const isString$2 = (val) => typeof val === "string";
const noop$4 = () => {
};
isClient$1 && ((_a$1 = window == null ? void 0 : window.navigator) == null ? void 0 : _a$1.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function resolveUnref(r2) {
  return typeof r2 === "function" ? r2() : unref(r2);
}
function createFilterWrapper(filter, fn2) {
  function wrapper(...args) {
    filter(() => fn2.apply(this, args), { fn: fn2, thisArg: this, args });
  }
  return wrapper;
}
const bypassFilter = (invoke) => {
  return invoke();
};
function pausableFilter(extendFilter = bypassFilter) {
  const isActive = ref$2(true);
  function pause() {
    isActive.value = false;
  }
  function resume() {
    isActive.value = true;
  }
  const eventFilter = (...args) => {
    if (isActive.value)
      extendFilter(...args);
  };
  return { isActive, pause, resume, eventFilter };
}
function identity(arg) {
  return arg;
}
function tryOnScopeDispose(fn2) {
  if (getCurrentScope()) {
    onScopeDispose(fn2);
    return true;
  }
  return false;
}
function resolveRef(r2) {
  return typeof r2 === "function" ? computed(r2) : ref$2(r2);
}
function tryOnMounted(fn2, sync = true) {
  if (getCurrentInstance())
    onMounted(fn2);
  else if (sync)
    fn2();
  else
    nextTick(fn2);
}
var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
var __objRest$5 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$6.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$6)
    for (var prop of __getOwnPropSymbols$6(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$6.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function watchWithFilter(source, cb2, options = {}) {
  const _a2 = options, {
    eventFilter = bypassFilter
  } = _a2, watchOptions = __objRest$5(_a2, [
    "eventFilter"
  ]);
  return watch(source, createFilterWrapper(eventFilter, cb2), watchOptions);
}
var __defProp$2 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$2.call(b2, prop))
      __defNormalProp$2(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b2)) {
      if (__propIsEnum$2.call(b2, prop))
        __defNormalProp$2(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$2 = (a2, b2) => __defProps$2(a2, __getOwnPropDescs$2(b2));
var __objRest$1 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function watchPausable(source, cb2, options = {}) {
  const _a2 = options, {
    eventFilter: filter
  } = _a2, watchOptions = __objRest$1(_a2, [
    "eventFilter"
  ]);
  const { eventFilter, pause, resume, isActive } = pausableFilter(filter);
  const stop2 = watchWithFilter(source, cb2, __spreadProps$2(__spreadValues$2({}, watchOptions), {
    eventFilter
  }));
  return { stop: stop2, pause, resume, isActive };
}
function unrefElement(elRef) {
  var _a2;
  const plain = resolveUnref(elRef);
  return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
}
const defaultWindow = isClient$1 ? window : void 0;
isClient$1 ? window.document : void 0;
isClient$1 ? window.navigator : void 0;
isClient$1 ? window.location : void 0;
function useEventListener(...args) {
  let target;
  let event;
  let listener;
  let options;
  if (isString$2(args[0])) {
    [event, listener, options] = args;
    target = defaultWindow;
  } else {
    [target, event, listener, options] = args;
  }
  if (!target)
    return noop$4;
  let cleanup = noop$4;
  const stopWatch = watch(() => unrefElement(target), (el) => {
    cleanup();
    if (!el)
      return;
    el.addEventListener(event, listener, options);
    cleanup = () => {
      el.removeEventListener(event, listener, options);
      cleanup = noop$4;
    };
  }, { immediate: true, flush: "post" });
  const stop2 = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop2);
  return stop2;
}
function useSupported(callback, sync = false) {
  const isSupported = ref$2();
  const update3 = () => isSupported.value = Boolean(callback());
  update3();
  tryOnMounted(update3, sync);
  return isSupported;
}
function useMediaQuery(query, options = {}) {
  const { window: window2 = defaultWindow } = options;
  const isSupported = useSupported(() => window2 && "matchMedia" in window2 && typeof window2.matchMedia === "function");
  let mediaQuery;
  const matches = ref$2(false);
  const cleanup = () => {
    if (!mediaQuery)
      return;
    if ("removeEventListener" in mediaQuery)
      mediaQuery.removeEventListener("change", update3);
    else
      mediaQuery.removeListener(update3);
  };
  const update3 = () => {
    if (!isSupported.value)
      return;
    cleanup();
    mediaQuery = window2.matchMedia(resolveRef(query).value);
    matches.value = mediaQuery.matches;
    if ("addEventListener" in mediaQuery)
      mediaQuery.addEventListener("change", update3);
    else
      mediaQuery.addListener(update3);
  };
  watchEffect(update3);
  tryOnScopeDispose(() => cleanup());
  return matches;
}
const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
const globalKey = "__vueuse_ssr_handlers__";
_global[globalKey] = _global[globalKey] || {};
const handlers = _global[globalKey];
function getSSRHandler(key, fallback) {
  return handlers[key] || fallback;
}
function guessSerializerType(rawInit) {
  return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : Array.isArray(rawInit) ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
}
var __defProp$j = Object.defineProperty;
var __getOwnPropSymbols$l = Object.getOwnPropertySymbols;
var __hasOwnProp$l = Object.prototype.hasOwnProperty;
var __propIsEnum$l = Object.prototype.propertyIsEnumerable;
var __defNormalProp$j = (obj, key, value) => key in obj ? __defProp$j(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$j = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$l.call(b2, prop))
      __defNormalProp$j(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$l)
    for (var prop of __getOwnPropSymbols$l(b2)) {
      if (__propIsEnum$l.call(b2, prop))
        __defNormalProp$j(a2, prop, b2[prop]);
    }
  return a2;
};
const StorageSerializers = {
  boolean: {
    read: (v2) => v2 === "true",
    write: (v2) => String(v2)
  },
  object: {
    read: (v2) => JSON.parse(v2),
    write: (v2) => JSON.stringify(v2)
  },
  number: {
    read: (v2) => Number.parseFloat(v2),
    write: (v2) => String(v2)
  },
  any: {
    read: (v2) => v2,
    write: (v2) => String(v2)
  },
  string: {
    read: (v2) => v2,
    write: (v2) => String(v2)
  },
  map: {
    read: (v2) => new Map(JSON.parse(v2)),
    write: (v2) => JSON.stringify(Array.from(v2.entries()))
  },
  set: {
    read: (v2) => new Set(JSON.parse(v2)),
    write: (v2) => JSON.stringify(Array.from(v2))
  },
  date: {
    read: (v2) => new Date(v2),
    write: (v2) => v2.toISOString()
  }
};
function useStorage(key, defaults, storage, options = {}) {
  var _a2;
  const {
    flush = "pre",
    deep = true,
    listenToStorageChanges = true,
    writeDefaults = true,
    mergeDefaults = false,
    shallow,
    window: window2 = defaultWindow,
    eventFilter,
    onError = (e2) => {
      console.error(e2);
    }
  } = options;
  const data = (shallow ? shallowRef : ref$2)(defaults);
  if (!storage) {
    try {
      storage = getSSRHandler("getDefaultStorage", () => {
        var _a22;
        return (_a22 = defaultWindow) == null ? void 0 : _a22.localStorage;
      })();
    } catch (e2) {
      onError(e2);
    }
  }
  if (!storage)
    return data;
  const rawInit = resolveUnref(defaults);
  const type2 = guessSerializerType(rawInit);
  const serializer = (_a2 = options.serializer) != null ? _a2 : StorageSerializers[type2];
  const { pause: pauseWatch, resume: resumeWatch } = watchPausable(data, () => write(data.value), { flush, deep, eventFilter });
  if (window2 && listenToStorageChanges)
    useEventListener(window2, "storage", update3);
  update3();
  return data;
  function write(v2) {
    try {
      if (v2 == null)
        storage.removeItem(key);
      else
        storage.setItem(key, serializer.write(v2));
    } catch (e2) {
      onError(e2);
    }
  }
  function read(event) {
    pauseWatch();
    try {
      const rawValue = event ? event.newValue : storage.getItem(key);
      if (rawValue == null) {
        if (writeDefaults && rawInit !== null)
          storage.setItem(key, serializer.write(rawInit));
        return rawInit;
      } else if (!event && mergeDefaults) {
        const value = serializer.read(rawValue);
        if (isFunction$1(mergeDefaults))
          return mergeDefaults(value, rawInit);
        else if (type2 === "object" && !Array.isArray(value))
          return __spreadValues$j(__spreadValues$j({}, rawInit), value);
        return value;
      } else if (typeof rawValue !== "string") {
        return rawValue;
      } else {
        return serializer.read(rawValue);
      }
    } catch (e2) {
      onError(e2);
    } finally {
      resumeWatch();
    }
  }
  function update3(event) {
    if (event && event.storageArea !== storage)
      return;
    if (event && event.key === null) {
      data.value = rawInit;
      return;
    }
    if (event && event.key !== key)
      return;
    data.value = read(event);
  }
}
function usePreferredDark(options) {
  return useMediaQuery("(prefers-color-scheme: dark)", options);
}
var __defProp$i = Object.defineProperty;
var __getOwnPropSymbols$k = Object.getOwnPropertySymbols;
var __hasOwnProp$k = Object.prototype.hasOwnProperty;
var __propIsEnum$k = Object.prototype.propertyIsEnumerable;
var __defNormalProp$i = (obj, key, value) => key in obj ? __defProp$i(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$i = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$k.call(b2, prop))
      __defNormalProp$i(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$k)
    for (var prop of __getOwnPropSymbols$k(b2)) {
      if (__propIsEnum$k.call(b2, prop))
        __defNormalProp$i(a2, prop, b2[prop]);
    }
  return a2;
};
function useColorMode(options = {}) {
  const {
    selector = "html",
    attribute = "class",
    initialValue = "auto",
    window: window2 = defaultWindow,
    storage,
    storageKey = "vueuse-color-scheme",
    listenToStorageChanges = true,
    storageRef,
    emitAuto
  } = options;
  const modes = __spreadValues$i({
    auto: "",
    light: "light",
    dark: "dark"
  }, options.modes || {});
  const preferredDark = usePreferredDark({ window: window2 });
  const preferredMode = computed(() => preferredDark.value ? "dark" : "light");
  const store2 = storageRef || (storageKey == null ? ref$2(initialValue) : useStorage(storageKey, initialValue, storage, { window: window2, listenToStorageChanges }));
  const state = computed({
    get() {
      return store2.value === "auto" && !emitAuto ? preferredMode.value : store2.value;
    },
    set(v2) {
      store2.value = v2;
    }
  });
  const updateHTMLAttrs = getSSRHandler("updateHTMLAttrs", (selector2, attribute2, value) => {
    const el = window2 == null ? void 0 : window2.document.querySelector(selector2);
    if (!el)
      return;
    if (attribute2 === "class") {
      const current = value.split(/\s/g);
      Object.values(modes).flatMap((i2) => (i2 || "").split(/\s/g)).filter(Boolean).forEach((v2) => {
        if (current.includes(v2))
          el.classList.add(v2);
        else
          el.classList.remove(v2);
      });
    } else {
      el.setAttribute(attribute2, value);
    }
  });
  function defaultOnChanged(mode) {
    var _a2;
    const resolvedMode = mode === "auto" ? preferredMode.value : mode;
    updateHTMLAttrs(selector, attribute, (_a2 = modes[resolvedMode]) != null ? _a2 : resolvedMode);
  }
  function onChanged(mode) {
    if (options.onChanged)
      options.onChanged(mode, defaultOnChanged);
    else
      defaultOnChanged(mode);
  }
  watch(state, onChanged, { flush: "post", immediate: true });
  if (emitAuto)
    watch(preferredMode, () => onChanged(state.value), { flush: "post" });
  tryOnMounted(() => onChanged(state.value));
  return state;
}
function useNetwork(options = {}) {
  const { window: window2 = defaultWindow } = options;
  const navigator2 = window2 == null ? void 0 : window2.navigator;
  const isSupported = useSupported(() => navigator2 && "connection" in navigator2);
  const isOnline = ref$2(true);
  const saveData = ref$2(false);
  const offlineAt = ref$2(void 0);
  const onlineAt = ref$2(void 0);
  const downlink = ref$2(void 0);
  const downlinkMax = ref$2(void 0);
  const rtt = ref$2(void 0);
  const effectiveType = ref$2(void 0);
  const type2 = ref$2("unknown");
  const connection = isSupported.value && navigator2.connection;
  function updateNetworkInformation() {
    if (!navigator2)
      return;
    isOnline.value = navigator2.onLine;
    offlineAt.value = isOnline.value ? void 0 : Date.now();
    onlineAt.value = isOnline.value ? Date.now() : void 0;
    if (connection) {
      downlink.value = connection.downlink;
      downlinkMax.value = connection.downlinkMax;
      effectiveType.value = connection.effectiveType;
      rtt.value = connection.rtt;
      saveData.value = connection.saveData;
      type2.value = connection.type;
    }
  }
  if (window2) {
    useEventListener(window2, "offline", () => {
      isOnline.value = false;
      offlineAt.value = Date.now();
    });
    useEventListener(window2, "online", () => {
      isOnline.value = true;
      onlineAt.value = Date.now();
    });
  }
  if (connection)
    useEventListener(connection, "change", updateNetworkInformation, false);
  updateNetworkInformation();
  return {
    isSupported,
    isOnline,
    saveData,
    offlineAt,
    onlineAt,
    downlink,
    downlinkMax,
    effectiveType,
    rtt,
    type: type2
  };
}
function useOnline(options = {}) {
  const { isOnline } = useNetwork(options);
  return isOnline;
}
var SwipeDirection;
(function(SwipeDirection2) {
  SwipeDirection2["UP"] = "UP";
  SwipeDirection2["RIGHT"] = "RIGHT";
  SwipeDirection2["DOWN"] = "DOWN";
  SwipeDirection2["LEFT"] = "LEFT";
  SwipeDirection2["NONE"] = "NONE";
})(SwipeDirection || (SwipeDirection = {}));
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
const _TransitionPresets = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
__spreadValues({
  linear: identity
}, _TransitionPresets);
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const stringToByteArray$1 = function(str) {
  const out = [];
  let p2 = 0;
  for (let i2 = 0; i2 < str.length; i2++) {
    let c2 = str.charCodeAt(i2);
    if (c2 < 128) {
      out[p2++] = c2;
    } else if (c2 < 2048) {
      out[p2++] = c2 >> 6 | 192;
      out[p2++] = c2 & 63 | 128;
    } else if ((c2 & 64512) === 55296 && i2 + 1 < str.length && (str.charCodeAt(i2 + 1) & 64512) === 56320) {
      c2 = 65536 + ((c2 & 1023) << 10) + (str.charCodeAt(++i2) & 1023);
      out[p2++] = c2 >> 18 | 240;
      out[p2++] = c2 >> 12 & 63 | 128;
      out[p2++] = c2 >> 6 & 63 | 128;
      out[p2++] = c2 & 63 | 128;
    } else {
      out[p2++] = c2 >> 12 | 224;
      out[p2++] = c2 >> 6 & 63 | 128;
      out[p2++] = c2 & 63 | 128;
    }
  }
  return out;
};
const byteArrayToString = function(bytes) {
  const out = [];
  let pos = 0, c2 = 0;
  while (pos < bytes.length) {
    const c1 = bytes[pos++];
    if (c1 < 128) {
      out[c2++] = String.fromCharCode(c1);
    } else if (c1 > 191 && c1 < 224) {
      const c22 = bytes[pos++];
      out[c2++] = String.fromCharCode((c1 & 31) << 6 | c22 & 63);
    } else if (c1 > 239 && c1 < 365) {
      const c22 = bytes[pos++];
      const c3 = bytes[pos++];
      const c4 = bytes[pos++];
      const u2 = ((c1 & 7) << 18 | (c22 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 65536;
      out[c2++] = String.fromCharCode(55296 + (u2 >> 10));
      out[c2++] = String.fromCharCode(56320 + (u2 & 1023));
    } else {
      const c22 = bytes[pos++];
      const c3 = bytes[pos++];
      out[c2++] = String.fromCharCode((c1 & 15) << 12 | (c22 & 63) << 6 | c3 & 63);
    }
  }
  return out.join("");
};
const base64 = {
  byteToCharMap_: null,
  charToByteMap_: null,
  byteToCharMapWebSafe_: null,
  charToByteMapWebSafe_: null,
  ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
  get ENCODED_VALS() {
    return this.ENCODED_VALS_BASE + "+/=";
  },
  get ENCODED_VALS_WEBSAFE() {
    return this.ENCODED_VALS_BASE + "-_.";
  },
  HAS_NATIVE_SUPPORT: typeof atob === "function",
  encodeByteArray(input, webSafe) {
    if (!Array.isArray(input)) {
      throw Error("encodeByteArray takes an array as a parameter");
    }
    this.init_();
    const byteToCharMap = webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;
    const output = [];
    for (let i2 = 0; i2 < input.length; i2 += 3) {
      const byte1 = input[i2];
      const haveByte2 = i2 + 1 < input.length;
      const byte2 = haveByte2 ? input[i2 + 1] : 0;
      const haveByte3 = i2 + 2 < input.length;
      const byte3 = haveByte3 ? input[i2 + 2] : 0;
      const outByte1 = byte1 >> 2;
      const outByte2 = (byte1 & 3) << 4 | byte2 >> 4;
      let outByte3 = (byte2 & 15) << 2 | byte3 >> 6;
      let outByte4 = byte3 & 63;
      if (!haveByte3) {
        outByte4 = 64;
        if (!haveByte2) {
          outByte3 = 64;
        }
      }
      output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
    }
    return output.join("");
  },
  encodeString(input, webSafe) {
    if (this.HAS_NATIVE_SUPPORT && !webSafe) {
      return btoa(input);
    }
    return this.encodeByteArray(stringToByteArray$1(input), webSafe);
  },
  decodeString(input, webSafe) {
    if (this.HAS_NATIVE_SUPPORT && !webSafe) {
      return atob(input);
    }
    return byteArrayToString(this.decodeStringToByteArray(input, webSafe));
  },
  decodeStringToByteArray(input, webSafe) {
    this.init_();
    const charToByteMap = webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;
    const output = [];
    for (let i2 = 0; i2 < input.length; ) {
      const byte1 = charToByteMap[input.charAt(i2++)];
      const haveByte2 = i2 < input.length;
      const byte2 = haveByte2 ? charToByteMap[input.charAt(i2)] : 0;
      ++i2;
      const haveByte3 = i2 < input.length;
      const byte3 = haveByte3 ? charToByteMap[input.charAt(i2)] : 64;
      ++i2;
      const haveByte4 = i2 < input.length;
      const byte4 = haveByte4 ? charToByteMap[input.charAt(i2)] : 64;
      ++i2;
      if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {
        throw Error();
      }
      const outByte1 = byte1 << 2 | byte2 >> 4;
      output.push(outByte1);
      if (byte3 !== 64) {
        const outByte2 = byte2 << 4 & 240 | byte3 >> 2;
        output.push(outByte2);
        if (byte4 !== 64) {
          const outByte3 = byte3 << 6 & 192 | byte4;
          output.push(outByte3);
        }
      }
    }
    return output;
  },
  init_() {
    if (!this.byteToCharMap_) {
      this.byteToCharMap_ = {};
      this.charToByteMap_ = {};
      this.byteToCharMapWebSafe_ = {};
      this.charToByteMapWebSafe_ = {};
      for (let i2 = 0; i2 < this.ENCODED_VALS.length; i2++) {
        this.byteToCharMap_[i2] = this.ENCODED_VALS.charAt(i2);
        this.charToByteMap_[this.byteToCharMap_[i2]] = i2;
        this.byteToCharMapWebSafe_[i2] = this.ENCODED_VALS_WEBSAFE.charAt(i2);
        this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i2]] = i2;
        if (i2 >= this.ENCODED_VALS_BASE.length) {
          this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i2)] = i2;
          this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i2)] = i2;
        }
      }
    }
  }
};
const base64Encode = function(str) {
  const utf8Bytes = stringToByteArray$1(str);
  return base64.encodeByteArray(utf8Bytes, true);
};
const base64urlEncodeWithoutPadding = function(str) {
  return base64Encode(str).replace(/\./g, "");
};
const base64Decode = function(str) {
  try {
    return base64.decodeString(str, true);
  } catch (e2) {
    console.error("base64Decode failed: ", e2);
  }
  return null;
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Deferred {
  constructor() {
    this.reject = () => {
    };
    this.resolve = () => {
    };
    this.promise = new Promise((resolve2, reject) => {
      this.resolve = resolve2;
      this.reject = reject;
    });
  }
  wrapCallback(callback) {
    return (error, value) => {
      if (error) {
        this.reject(error);
      } else {
        this.resolve(value);
      }
      if (typeof callback === "function") {
        this.promise.catch(() => {
        });
        if (callback.length === 1) {
          callback(error);
        } else {
          callback(error, value);
        }
      }
    };
  }
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function createMockUserToken(token, projectId) {
  if (token.uid) {
    throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
  }
  const header = {
    alg: "none",
    type: "JWT"
  };
  const project = projectId || "demo-project";
  const iat = token.iat || 0;
  const sub = token.sub || token.user_id;
  if (!sub) {
    throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
  }
  const payload = Object.assign({
    iss: `https://securetoken.google.com/${project}`,
    aud: project,
    iat,
    exp: iat + 3600,
    auth_time: iat,
    sub,
    user_id: sub,
    firebase: {
      sign_in_provider: "custom",
      identities: {}
    }
  }, token);
  const signature = "";
  return [
    base64urlEncodeWithoutPadding(JSON.stringify(header)),
    base64urlEncodeWithoutPadding(JSON.stringify(payload)),
    signature
  ].join(".");
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getUA() {
  if (typeof navigator !== "undefined" && typeof navigator["userAgent"] === "string") {
    return navigator["userAgent"];
  } else {
    return "";
  }
}
function isMobileCordova() {
  return typeof window !== "undefined" && !!(window["cordova"] || window["phonegap"] || window["PhoneGap"]) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA());
}
function isBrowserExtension() {
  const runtime = typeof chrome === "object" ? chrome.runtime : typeof browser === "object" ? browser.runtime : void 0;
  return typeof runtime === "object" && runtime.id !== void 0;
}
function isReactNative() {
  return typeof navigator === "object" && navigator["product"] === "ReactNative";
}
function isElectron() {
  return getUA().indexOf("Electron/") >= 0;
}
function isIE() {
  const ua2 = getUA();
  return ua2.indexOf("MSIE ") >= 0 || ua2.indexOf("Trident/") >= 0;
}
function isUWP() {
  return getUA().indexOf("MSAppHost/") >= 0;
}
function isIndexedDBAvailable() {
  return typeof indexedDB === "object";
}
function validateIndexedDBOpenable() {
  return new Promise((resolve2, reject) => {
    try {
      let preExist = true;
      const DB_CHECK_NAME = "validate-browser-context-for-indexeddb-analytics-module";
      const request = self.indexedDB.open(DB_CHECK_NAME);
      request.onsuccess = () => {
        request.result.close();
        if (!preExist) {
          self.indexedDB.deleteDatabase(DB_CHECK_NAME);
        }
        resolve2(true);
      };
      request.onupgradeneeded = () => {
        preExist = false;
      };
      request.onerror = () => {
        var _a2;
        reject(((_a2 = request.error) === null || _a2 === void 0 ? void 0 : _a2.message) || "");
      };
    } catch (error) {
      reject(error);
    }
  });
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ERROR_NAME = "FirebaseError";
class FirebaseError extends Error {
  constructor(code, message, customData) {
    super(message);
    this.code = code;
    this.customData = customData;
    this.name = ERROR_NAME;
    Object.setPrototypeOf(this, FirebaseError.prototype);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ErrorFactory.prototype.create);
    }
  }
}
class ErrorFactory {
  constructor(service, serviceName, errors) {
    this.service = service;
    this.serviceName = serviceName;
    this.errors = errors;
  }
  create(code, ...data) {
    const customData = data[0] || {};
    const fullCode = `${this.service}/${code}`;
    const template = this.errors[code];
    const message = template ? replaceTemplate(template, customData) : "Error";
    const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;
    const error = new FirebaseError(fullCode, fullMessage, customData);
    return error;
  }
}
function replaceTemplate(template, data) {
  return template.replace(PATTERN, (_2, key) => {
    const value = data[key];
    return value != null ? String(value) : `<${key}?>`;
  });
}
const PATTERN = /\{\$([^}]+)}/g;
function isEmpty(obj) {
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      return false;
    }
  }
  return true;
}
function deepEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  const aKeys = Object.keys(a2);
  const bKeys = Object.keys(b2);
  for (const k2 of aKeys) {
    if (!bKeys.includes(k2)) {
      return false;
    }
    const aProp = a2[k2];
    const bProp = b2[k2];
    if (isObject$3(aProp) && isObject$3(bProp)) {
      if (!deepEqual(aProp, bProp)) {
        return false;
      }
    } else if (aProp !== bProp) {
      return false;
    }
  }
  for (const k2 of bKeys) {
    if (!aKeys.includes(k2)) {
      return false;
    }
  }
  return true;
}
function isObject$3(thing) {
  return thing !== null && typeof thing === "object";
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function querystring(querystringParams) {
  const params = [];
  for (const [key, value] of Object.entries(querystringParams)) {
    if (Array.isArray(value)) {
      value.forEach((arrayVal) => {
        params.push(encodeURIComponent(key) + "=" + encodeURIComponent(arrayVal));
      });
    } else {
      params.push(encodeURIComponent(key) + "=" + encodeURIComponent(value));
    }
  }
  return params.length ? "&" + params.join("&") : "";
}
function querystringDecode(querystring2) {
  const obj = {};
  const tokens = querystring2.replace(/^\?/, "").split("&");
  tokens.forEach((token) => {
    if (token) {
      const [key, value] = token.split("=");
      obj[decodeURIComponent(key)] = decodeURIComponent(value);
    }
  });
  return obj;
}
function extractQuerystring(url) {
  const queryStart = url.indexOf("?");
  if (!queryStart) {
    return "";
  }
  const fragmentStart = url.indexOf("#", queryStart);
  return url.substring(queryStart, fragmentStart > 0 ? fragmentStart : void 0);
}
function createSubscribe(executor, onNoObservers) {
  const proxy = new ObserverProxy(executor, onNoObservers);
  return proxy.subscribe.bind(proxy);
}
class ObserverProxy {
  constructor(executor, onNoObservers) {
    this.observers = [];
    this.unsubscribes = [];
    this.observerCount = 0;
    this.task = Promise.resolve();
    this.finalized = false;
    this.onNoObservers = onNoObservers;
    this.task.then(() => {
      executor(this);
    }).catch((e2) => {
      this.error(e2);
    });
  }
  next(value) {
    this.forEachObserver((observer) => {
      observer.next(value);
    });
  }
  error(error) {
    this.forEachObserver((observer) => {
      observer.error(error);
    });
    this.close(error);
  }
  complete() {
    this.forEachObserver((observer) => {
      observer.complete();
    });
    this.close();
  }
  subscribe(nextOrObserver, error, complete) {
    let observer;
    if (nextOrObserver === void 0 && error === void 0 && complete === void 0) {
      throw new Error("Missing Observer.");
    }
    if (implementsAnyMethods(nextOrObserver, [
      "next",
      "error",
      "complete"
    ])) {
      observer = nextOrObserver;
    } else {
      observer = {
        next: nextOrObserver,
        error,
        complete
      };
    }
    if (observer.next === void 0) {
      observer.next = noop$3;
    }
    if (observer.error === void 0) {
      observer.error = noop$3;
    }
    if (observer.complete === void 0) {
      observer.complete = noop$3;
    }
    const unsub = this.unsubscribeOne.bind(this, this.observers.length);
    if (this.finalized) {
      this.task.then(() => {
        try {
          if (this.finalError) {
            observer.error(this.finalError);
          } else {
            observer.complete();
          }
        } catch (e2) {
        }
        return;
      });
    }
    this.observers.push(observer);
    return unsub;
  }
  unsubscribeOne(i2) {
    if (this.observers === void 0 || this.observers[i2] === void 0) {
      return;
    }
    delete this.observers[i2];
    this.observerCount -= 1;
    if (this.observerCount === 0 && this.onNoObservers !== void 0) {
      this.onNoObservers(this);
    }
  }
  forEachObserver(fn2) {
    if (this.finalized) {
      return;
    }
    for (let i2 = 0; i2 < this.observers.length; i2++) {
      this.sendOne(i2, fn2);
    }
  }
  sendOne(i2, fn2) {
    this.task.then(() => {
      if (this.observers !== void 0 && this.observers[i2] !== void 0) {
        try {
          fn2(this.observers[i2]);
        } catch (e2) {
          if (typeof console !== "undefined" && console.error) {
            console.error(e2);
          }
        }
      }
    });
  }
  close(err) {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    if (err !== void 0) {
      this.finalError = err;
    }
    this.task.then(() => {
      this.observers = void 0;
      this.onNoObservers = void 0;
    });
  }
}
function implementsAnyMethods(obj, methods) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  for (const method of methods) {
    if (method in obj && typeof obj[method] === "function") {
      return true;
    }
  }
  return false;
}
function noop$3() {
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getModularInstance(service) {
  if (service && service._delegate) {
    return service._delegate;
  } else {
    return service;
  }
}
class Component {
  constructor(name2, instanceFactory, type2) {
    this.name = name2;
    this.instanceFactory = instanceFactory;
    this.type = type2;
    this.multipleInstances = false;
    this.serviceProps = {};
    this.instantiationMode = "LAZY";
    this.onInstanceCreated = null;
  }
  setInstantiationMode(mode) {
    this.instantiationMode = mode;
    return this;
  }
  setMultipleInstances(multipleInstances) {
    this.multipleInstances = multipleInstances;
    return this;
  }
  setServiceProps(props) {
    this.serviceProps = props;
    return this;
  }
  setInstanceCreatedCallback(callback) {
    this.onInstanceCreated = callback;
    return this;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_ENTRY_NAME$1 = "[DEFAULT]";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Provider {
  constructor(name2, container) {
    this.name = name2;
    this.container = container;
    this.component = null;
    this.instances = /* @__PURE__ */ new Map();
    this.instancesDeferred = /* @__PURE__ */ new Map();
    this.instancesOptions = /* @__PURE__ */ new Map();
    this.onInitCallbacks = /* @__PURE__ */ new Map();
  }
  get(identifier) {
    const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
    if (!this.instancesDeferred.has(normalizedIdentifier)) {
      const deferred = new Deferred();
      this.instancesDeferred.set(normalizedIdentifier, deferred);
      if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
        try {
          const instance = this.getOrInitializeService({
            instanceIdentifier: normalizedIdentifier
          });
          if (instance) {
            deferred.resolve(instance);
          }
        } catch (e2) {
        }
      }
    }
    return this.instancesDeferred.get(normalizedIdentifier).promise;
  }
  getImmediate(options) {
    var _a2;
    const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);
    const optional = (_a2 = options === null || options === void 0 ? void 0 : options.optional) !== null && _a2 !== void 0 ? _a2 : false;
    if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
      try {
        return this.getOrInitializeService({
          instanceIdentifier: normalizedIdentifier
        });
      } catch (e2) {
        if (optional) {
          return null;
        } else {
          throw e2;
        }
      }
    } else {
      if (optional) {
        return null;
      } else {
        throw Error(`Service ${this.name} is not available`);
      }
    }
  }
  getComponent() {
    return this.component;
  }
  setComponent(component) {
    if (component.name !== this.name) {
      throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);
    }
    if (this.component) {
      throw Error(`Component for ${this.name} has already been provided`);
    }
    this.component = component;
    if (!this.shouldAutoInitialize()) {
      return;
    }
    if (isComponentEager(component)) {
      try {
        this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME$1 });
      } catch (e2) {
      }
    }
    for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {
      const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
      try {
        const instance = this.getOrInitializeService({
          instanceIdentifier: normalizedIdentifier
        });
        instanceDeferred.resolve(instance);
      } catch (e2) {
      }
    }
  }
  clearInstance(identifier = DEFAULT_ENTRY_NAME$1) {
    this.instancesDeferred.delete(identifier);
    this.instancesOptions.delete(identifier);
    this.instances.delete(identifier);
  }
  async delete() {
    const services = Array.from(this.instances.values());
    await Promise.all([
      ...services.filter((service) => "INTERNAL" in service).map((service) => service.INTERNAL.delete()),
      ...services.filter((service) => "_delete" in service).map((service) => service._delete())
    ]);
  }
  isComponentSet() {
    return this.component != null;
  }
  isInitialized(identifier = DEFAULT_ENTRY_NAME$1) {
    return this.instances.has(identifier);
  }
  getOptions(identifier = DEFAULT_ENTRY_NAME$1) {
    return this.instancesOptions.get(identifier) || {};
  }
  initialize(opts = {}) {
    const { options = {} } = opts;
    const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);
    if (this.isInitialized(normalizedIdentifier)) {
      throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);
    }
    if (!this.isComponentSet()) {
      throw Error(`Component ${this.name} has not been registered yet`);
    }
    const instance = this.getOrInitializeService({
      instanceIdentifier: normalizedIdentifier,
      options
    });
    for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {
      const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
      if (normalizedIdentifier === normalizedDeferredIdentifier) {
        instanceDeferred.resolve(instance);
      }
    }
    return instance;
  }
  onInit(callback, identifier) {
    var _a2;
    const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
    const existingCallbacks = (_a2 = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a2 !== void 0 ? _a2 : /* @__PURE__ */ new Set();
    existingCallbacks.add(callback);
    this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);
    const existingInstance = this.instances.get(normalizedIdentifier);
    if (existingInstance) {
      callback(existingInstance, normalizedIdentifier);
    }
    return () => {
      existingCallbacks.delete(callback);
    };
  }
  invokeOnInitCallbacks(instance, identifier) {
    const callbacks = this.onInitCallbacks.get(identifier);
    if (!callbacks) {
      return;
    }
    for (const callback of callbacks) {
      try {
        callback(instance, identifier);
      } catch (_a2) {
      }
    }
  }
  getOrInitializeService({ instanceIdentifier, options = {} }) {
    let instance = this.instances.get(instanceIdentifier);
    if (!instance && this.component) {
      instance = this.component.instanceFactory(this.container, {
        instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),
        options
      });
      this.instances.set(instanceIdentifier, instance);
      this.instancesOptions.set(instanceIdentifier, options);
      this.invokeOnInitCallbacks(instance, instanceIdentifier);
      if (this.component.onInstanceCreated) {
        try {
          this.component.onInstanceCreated(this.container, instanceIdentifier, instance);
        } catch (_a2) {
        }
      }
    }
    return instance || null;
  }
  normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME$1) {
    if (this.component) {
      return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME$1;
    } else {
      return identifier;
    }
  }
  shouldAutoInitialize() {
    return !!this.component && this.component.instantiationMode !== "EXPLICIT";
  }
}
function normalizeIdentifierForFactory(identifier) {
  return identifier === DEFAULT_ENTRY_NAME$1 ? void 0 : identifier;
}
function isComponentEager(component) {
  return component.instantiationMode === "EAGER";
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ComponentContainer {
  constructor(name2) {
    this.name = name2;
    this.providers = /* @__PURE__ */ new Map();
  }
  addComponent(component) {
    const provider = this.getProvider(component.name);
    if (provider.isComponentSet()) {
      throw new Error(`Component ${component.name} has already been registered with ${this.name}`);
    }
    provider.setComponent(component);
  }
  addOrOverwriteComponent(component) {
    const provider = this.getProvider(component.name);
    if (provider.isComponentSet()) {
      this.providers.delete(component.name);
    }
    this.addComponent(component);
  }
  getProvider(name2) {
    if (this.providers.has(name2)) {
      return this.providers.get(name2);
    }
    const provider = new Provider(name2, this);
    this.providers.set(name2, provider);
    return provider;
  }
  getProviders() {
    return Array.from(this.providers.values());
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
  LogLevel2[LogLevel2["VERBOSE"] = 1] = "VERBOSE";
  LogLevel2[LogLevel2["INFO"] = 2] = "INFO";
  LogLevel2[LogLevel2["WARN"] = 3] = "WARN";
  LogLevel2[LogLevel2["ERROR"] = 4] = "ERROR";
  LogLevel2[LogLevel2["SILENT"] = 5] = "SILENT";
})(LogLevel || (LogLevel = {}));
const levelStringToEnum = {
  "debug": LogLevel.DEBUG,
  "verbose": LogLevel.VERBOSE,
  "info": LogLevel.INFO,
  "warn": LogLevel.WARN,
  "error": LogLevel.ERROR,
  "silent": LogLevel.SILENT
};
const defaultLogLevel = LogLevel.INFO;
const ConsoleMethod = {
  [LogLevel.DEBUG]: "log",
  [LogLevel.VERBOSE]: "log",
  [LogLevel.INFO]: "info",
  [LogLevel.WARN]: "warn",
  [LogLevel.ERROR]: "error"
};
const defaultLogHandler = (instance, logType, ...args) => {
  if (logType < instance.logLevel) {
    return;
  }
  const now2 = new Date().toISOString();
  const method = ConsoleMethod[logType];
  if (method) {
    console[method](`[${now2}]  ${instance.name}:`, ...args);
  } else {
    throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);
  }
};
class Logger {
  constructor(name2) {
    this.name = name2;
    this._logLevel = defaultLogLevel;
    this._logHandler = defaultLogHandler;
    this._userLogHandler = null;
  }
  get logLevel() {
    return this._logLevel;
  }
  set logLevel(val) {
    if (!(val in LogLevel)) {
      throw new TypeError(`Invalid value "${val}" assigned to \`logLevel\``);
    }
    this._logLevel = val;
  }
  setLogLevel(val) {
    this._logLevel = typeof val === "string" ? levelStringToEnum[val] : val;
  }
  get logHandler() {
    return this._logHandler;
  }
  set logHandler(val) {
    if (typeof val !== "function") {
      throw new TypeError("Value assigned to `logHandler` must be a function");
    }
    this._logHandler = val;
  }
  get userLogHandler() {
    return this._userLogHandler;
  }
  set userLogHandler(val) {
    this._userLogHandler = val;
  }
  debug(...args) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);
    this._logHandler(this, LogLevel.DEBUG, ...args);
  }
  log(...args) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.VERBOSE, ...args);
    this._logHandler(this, LogLevel.VERBOSE, ...args);
  }
  info(...args) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);
    this._logHandler(this, LogLevel.INFO, ...args);
  }
  warn(...args) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);
    this._logHandler(this, LogLevel.WARN, ...args);
  }
  error(...args) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);
    this._logHandler(this, LogLevel.ERROR, ...args);
  }
}
const instanceOfAny = (object, constructors) => constructors.some((c2) => object instanceof c2);
let idbProxyableTypes;
let cursorAdvanceMethods;
function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const cursorRequestMap = /* @__PURE__ */ new WeakMap();
const transactionDoneMap = /* @__PURE__ */ new WeakMap();
const transactionStoreNamesMap = /* @__PURE__ */ new WeakMap();
const transformCache = /* @__PURE__ */ new WeakMap();
const reverseTransformCache = /* @__PURE__ */ new WeakMap();
function promisifyRequest(request) {
  const promise = new Promise((resolve2, reject) => {
    const unlisten = () => {
      request.removeEventListener("success", success);
      request.removeEventListener("error", error);
    };
    const success = () => {
      resolve2(wrap(request.result));
      unlisten();
    };
    const error = () => {
      reject(request.error);
      unlisten();
    };
    request.addEventListener("success", success);
    request.addEventListener("error", error);
  });
  promise.then((value) => {
    if (value instanceof IDBCursor) {
      cursorRequestMap.set(value, request);
    }
  }).catch(() => {
  });
  reverseTransformCache.set(promise, request);
  return promise;
}
function cacheDonePromiseForTransaction(tx) {
  if (transactionDoneMap.has(tx))
    return;
  const done = new Promise((resolve2, reject) => {
    const unlisten = () => {
      tx.removeEventListener("complete", complete);
      tx.removeEventListener("error", error);
      tx.removeEventListener("abort", error);
    };
    const complete = () => {
      resolve2();
      unlisten();
    };
    const error = () => {
      reject(tx.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    };
    tx.addEventListener("complete", complete);
    tx.addEventListener("error", error);
    tx.addEventListener("abort", error);
  });
  transactionDoneMap.set(tx, done);
}
let idbProxyTraps = {
  get(target, prop, receiver) {
    if (target instanceof IDBTransaction) {
      if (prop === "done")
        return transactionDoneMap.get(target);
      if (prop === "objectStoreNames") {
        return target.objectStoreNames || transactionStoreNamesMap.get(target);
      }
      if (prop === "store") {
        return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
      }
    }
    return wrap(target[prop]);
  },
  set(target, prop, value) {
    target[prop] = value;
    return true;
  },
  has(target, prop) {
    if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
      return true;
    }
    return prop in target;
  }
};
function replaceTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
  if (func === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) {
    return function(storeNames, ...args) {
      const tx = func.call(unwrap$2(this), storeNames, ...args);
      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
      return wrap(tx);
    };
  }
  if (getCursorAdvanceMethods().includes(func)) {
    return function(...args) {
      func.apply(unwrap$2(this), args);
      return wrap(cursorRequestMap.get(this));
    };
  }
  return function(...args) {
    return wrap(func.apply(unwrap$2(this), args));
  };
}
function transformCachableValue(value) {
  if (typeof value === "function")
    return wrapFunction(value);
  if (value instanceof IDBTransaction)
    cacheDonePromiseForTransaction(value);
  if (instanceOfAny(value, getIdbProxyableTypes()))
    return new Proxy(value, idbProxyTraps);
  return value;
}
function wrap(value) {
  if (value instanceof IDBRequest)
    return promisifyRequest(value);
  if (transformCache.has(value))
    return transformCache.get(value);
  const newValue = transformCachableValue(value);
  if (newValue !== value) {
    transformCache.set(value, newValue);
    reverseTransformCache.set(newValue, value);
  }
  return newValue;
}
const unwrap$2 = (value) => reverseTransformCache.get(value);
function openDB(name2, version2, { blocked, upgrade, blocking, terminated } = {}) {
  const request = indexedDB.open(name2, version2);
  const openPromise = wrap(request);
  if (upgrade) {
    request.addEventListener("upgradeneeded", (event) => {
      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));
    });
  }
  if (blocked)
    request.addEventListener("blocked", () => blocked());
  openPromise.then((db2) => {
    if (terminated)
      db2.addEventListener("close", () => terminated());
    if (blocking)
      db2.addEventListener("versionchange", () => blocking());
  }).catch(() => {
  });
  return openPromise;
}
const readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
const writeMethods = ["put", "add", "delete", "clear"];
const cachedMethods = /* @__PURE__ */ new Map();
function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
    return;
  }
  if (cachedMethods.get(prop))
    return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, "");
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if (!(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {
    return;
  }
  const method = async function(storeName, ...args) {
    const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
    let target2 = tx.store;
    if (useIndex)
      target2 = target2.index(args.shift());
    return (await Promise.all([
      target2[targetFuncName](...args),
      isWrite && tx.done
    ]))[0];
  };
  cachedMethods.set(prop, method);
  return method;
}
replaceTraps((oldTraps) => ({
  ...oldTraps,
  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
}));
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PlatformLoggerServiceImpl {
  constructor(container) {
    this.container = container;
  }
  getPlatformInfoString() {
    const providers = this.container.getProviders();
    return providers.map((provider) => {
      if (isVersionServiceProvider(provider)) {
        const service = provider.getImmediate();
        return `${service.library}/${service.version}`;
      } else {
        return null;
      }
    }).filter((logString) => logString).join(" ");
  }
}
function isVersionServiceProvider(provider) {
  const component = provider.getComponent();
  return (component === null || component === void 0 ? void 0 : component.type) === "VERSION";
}
const name$o = "@firebase/app";
const version$1$1 = "0.7.28";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const logger = new Logger("@firebase/app");
const name$n = "@firebase/app-compat";
const name$m = "@firebase/analytics-compat";
const name$l = "@firebase/analytics";
const name$k = "@firebase/app-check-compat";
const name$j = "@firebase/app-check";
const name$i = "@firebase/auth";
const name$h = "@firebase/auth-compat";
const name$g = "@firebase/database";
const name$f = "@firebase/database-compat";
const name$e = "@firebase/functions";
const name$d = "@firebase/functions-compat";
const name$c = "@firebase/installations";
const name$b = "@firebase/installations-compat";
const name$a = "@firebase/messaging";
const name$9 = "@firebase/messaging-compat";
const name$8 = "@firebase/performance";
const name$7 = "@firebase/performance-compat";
const name$6 = "@firebase/remote-config";
const name$5 = "@firebase/remote-config-compat";
const name$4 = "@firebase/storage";
const name$3 = "@firebase/storage-compat";
const name$2$1 = "@firebase/firestore";
const name$1$1 = "@firebase/firestore-compat";
const name$p = "firebase";
const version$3 = "9.9.0";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_ENTRY_NAME = "[DEFAULT]";
const PLATFORM_LOG_STRING = {
  [name$o]: "fire-core",
  [name$n]: "fire-core-compat",
  [name$l]: "fire-analytics",
  [name$m]: "fire-analytics-compat",
  [name$j]: "fire-app-check",
  [name$k]: "fire-app-check-compat",
  [name$i]: "fire-auth",
  [name$h]: "fire-auth-compat",
  [name$g]: "fire-rtdb",
  [name$f]: "fire-rtdb-compat",
  [name$e]: "fire-fn",
  [name$d]: "fire-fn-compat",
  [name$c]: "fire-iid",
  [name$b]: "fire-iid-compat",
  [name$a]: "fire-fcm",
  [name$9]: "fire-fcm-compat",
  [name$8]: "fire-perf",
  [name$7]: "fire-perf-compat",
  [name$6]: "fire-rc",
  [name$5]: "fire-rc-compat",
  [name$4]: "fire-gcs",
  [name$3]: "fire-gcs-compat",
  [name$2$1]: "fire-fst",
  [name$1$1]: "fire-fst-compat",
  "fire-js": "fire-js",
  [name$p]: "fire-js-all"
};
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _apps = /* @__PURE__ */ new Map();
const _components = /* @__PURE__ */ new Map();
function _addComponent(app2, component) {
  try {
    app2.container.addComponent(component);
  } catch (e2) {
    logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app2.name}`, e2);
  }
}
function _registerComponent(component) {
  const componentName = component.name;
  if (_components.has(componentName)) {
    logger.debug(`There were multiple attempts to register component ${componentName}.`);
    return false;
  }
  _components.set(componentName, component);
  for (const app2 of _apps.values()) {
    _addComponent(app2, component);
  }
  return true;
}
function _getProvider(app2, name2) {
  const heartbeatController = app2.container.getProvider("heartbeat").getImmediate({ optional: true });
  if (heartbeatController) {
    void heartbeatController.triggerHeartbeat();
  }
  return app2.container.getProvider(name2);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ERRORS = {
  ["no-app"]: "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()",
  ["bad-app-name"]: "Illegal App name: '{$appName}",
  ["duplicate-app"]: "Firebase App named '{$appName}' already exists with different options or config",
  ["app-deleted"]: "Firebase App named '{$appName}' already deleted",
  ["invalid-app-argument"]: "firebase.{$appName}() takes either no argument or a Firebase App instance.",
  ["invalid-log-argument"]: "First argument to `onLog` must be null or a function.",
  ["storage-open"]: "Error thrown when opening storage. Original error: {$originalErrorMessage}.",
  ["storage-get"]: "Error thrown when reading from storage. Original error: {$originalErrorMessage}.",
  ["storage-set"]: "Error thrown when writing to storage. Original error: {$originalErrorMessage}.",
  ["storage-delete"]: "Error thrown when deleting from storage. Original error: {$originalErrorMessage}."
};
const ERROR_FACTORY = new ErrorFactory("app", "Firebase", ERRORS);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FirebaseAppImpl {
  constructor(options, config2, container) {
    this._isDeleted = false;
    this._options = Object.assign({}, options);
    this._config = Object.assign({}, config2);
    this._name = config2.name;
    this._automaticDataCollectionEnabled = config2.automaticDataCollectionEnabled;
    this._container = container;
    this.container.addComponent(new Component("app", () => this, "PUBLIC"));
  }
  get automaticDataCollectionEnabled() {
    this.checkDestroyed();
    return this._automaticDataCollectionEnabled;
  }
  set automaticDataCollectionEnabled(val) {
    this.checkDestroyed();
    this._automaticDataCollectionEnabled = val;
  }
  get name() {
    this.checkDestroyed();
    return this._name;
  }
  get options() {
    this.checkDestroyed();
    return this._options;
  }
  get config() {
    this.checkDestroyed();
    return this._config;
  }
  get container() {
    return this._container;
  }
  get isDeleted() {
    return this._isDeleted;
  }
  set isDeleted(val) {
    this._isDeleted = val;
  }
  checkDestroyed() {
    if (this.isDeleted) {
      throw ERROR_FACTORY.create("app-deleted", { appName: this._name });
    }
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const SDK_VERSION = version$3;
function initializeApp(options, rawConfig = {}) {
  if (typeof rawConfig !== "object") {
    const name3 = rawConfig;
    rawConfig = { name: name3 };
  }
  const config2 = Object.assign({ name: DEFAULT_ENTRY_NAME, automaticDataCollectionEnabled: false }, rawConfig);
  const name2 = config2.name;
  if (typeof name2 !== "string" || !name2) {
    throw ERROR_FACTORY.create("bad-app-name", {
      appName: String(name2)
    });
  }
  const existingApp = _apps.get(name2);
  if (existingApp) {
    if (deepEqual(options, existingApp.options) && deepEqual(config2, existingApp.config)) {
      return existingApp;
    } else {
      throw ERROR_FACTORY.create("duplicate-app", { appName: name2 });
    }
  }
  const container = new ComponentContainer(name2);
  for (const component of _components.values()) {
    container.addComponent(component);
  }
  const newApp = new FirebaseAppImpl(options, config2, container);
  _apps.set(name2, newApp);
  return newApp;
}
function getApp(name2 = DEFAULT_ENTRY_NAME) {
  const app2 = _apps.get(name2);
  if (!app2) {
    throw ERROR_FACTORY.create("no-app", { appName: name2 });
  }
  return app2;
}
function registerVersion(libraryKeyOrName, version2, variant) {
  var _a2;
  let library = (_a2 = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a2 !== void 0 ? _a2 : libraryKeyOrName;
  if (variant) {
    library += `-${variant}`;
  }
  const libraryMismatch = library.match(/\s|\//);
  const versionMismatch = version2.match(/\s|\//);
  if (libraryMismatch || versionMismatch) {
    const warning = [
      `Unable to register library "${library}" with version "${version2}":`
    ];
    if (libraryMismatch) {
      warning.push(`library name "${library}" contains illegal characters (whitespace or "/")`);
    }
    if (libraryMismatch && versionMismatch) {
      warning.push("and");
    }
    if (versionMismatch) {
      warning.push(`version name "${version2}" contains illegal characters (whitespace or "/")`);
    }
    logger.warn(warning.join(" "));
    return;
  }
  _registerComponent(new Component(`${library}-version`, () => ({ library, version: version2 }), "VERSION"));
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DB_NAME$1 = "firebase-heartbeat-database";
const DB_VERSION$1 = 1;
const STORE_NAME = "firebase-heartbeat-store";
let dbPromise = null;
function getDbPromise() {
  if (!dbPromise) {
    dbPromise = openDB(DB_NAME$1, DB_VERSION$1, {
      upgrade: (db2, oldVersion) => {
        switch (oldVersion) {
          case 0:
            db2.createObjectStore(STORE_NAME);
        }
      }
    }).catch((e2) => {
      throw ERROR_FACTORY.create("storage-open", {
        originalErrorMessage: e2.message
      });
    });
  }
  return dbPromise;
}
async function readHeartbeatsFromIndexedDB(app2) {
  var _a2;
  try {
    const db2 = await getDbPromise();
    return db2.transaction(STORE_NAME).objectStore(STORE_NAME).get(computeKey(app2));
  } catch (e2) {
    throw ERROR_FACTORY.create("storage-get", {
      originalErrorMessage: (_a2 = e2) === null || _a2 === void 0 ? void 0 : _a2.message
    });
  }
}
async function writeHeartbeatsToIndexedDB(app2, heartbeatObject) {
  var _a2;
  try {
    const db2 = await getDbPromise();
    const tx = db2.transaction(STORE_NAME, "readwrite");
    const objectStore = tx.objectStore(STORE_NAME);
    await objectStore.put(heartbeatObject, computeKey(app2));
    return tx.done;
  } catch (e2) {
    throw ERROR_FACTORY.create("storage-set", {
      originalErrorMessage: (_a2 = e2) === null || _a2 === void 0 ? void 0 : _a2.message
    });
  }
}
function computeKey(app2) {
  return `${app2.name}!${app2.options.appId}`;
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const MAX_HEADER_BYTES = 1024;
const STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1e3;
class HeartbeatServiceImpl {
  constructor(container) {
    this.container = container;
    this._heartbeatsCache = null;
    const app2 = this.container.getProvider("app").getImmediate();
    this._storage = new HeartbeatStorageImpl(app2);
    this._heartbeatsCachePromise = this._storage.read().then((result) => {
      this._heartbeatsCache = result;
      return result;
    });
  }
  async triggerHeartbeat() {
    const platformLogger = this.container.getProvider("platform-logger").getImmediate();
    const agent = platformLogger.getPlatformInfoString();
    const date = getUTCDateString();
    if (this._heartbeatsCache === null) {
      this._heartbeatsCache = await this._heartbeatsCachePromise;
    }
    if (this._heartbeatsCache.lastSentHeartbeatDate === date || this._heartbeatsCache.heartbeats.some((singleDateHeartbeat) => singleDateHeartbeat.date === date)) {
      return;
    } else {
      this._heartbeatsCache.heartbeats.push({ date, agent });
    }
    this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((singleDateHeartbeat) => {
      const hbTimestamp = new Date(singleDateHeartbeat.date).valueOf();
      const now2 = Date.now();
      return now2 - hbTimestamp <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS;
    });
    return this._storage.overwrite(this._heartbeatsCache);
  }
  async getHeartbeatsHeader() {
    if (this._heartbeatsCache === null) {
      await this._heartbeatsCachePromise;
    }
    if (this._heartbeatsCache === null || this._heartbeatsCache.heartbeats.length === 0) {
      return "";
    }
    const date = getUTCDateString();
    const { heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);
    const headerString = base64urlEncodeWithoutPadding(JSON.stringify({ version: 2, heartbeats: heartbeatsToSend }));
    this._heartbeatsCache.lastSentHeartbeatDate = date;
    if (unsentEntries.length > 0) {
      this._heartbeatsCache.heartbeats = unsentEntries;
      await this._storage.overwrite(this._heartbeatsCache);
    } else {
      this._heartbeatsCache.heartbeats = [];
      void this._storage.overwrite(this._heartbeatsCache);
    }
    return headerString;
  }
}
function getUTCDateString() {
  const today = new Date();
  return today.toISOString().substring(0, 10);
}
function extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {
  const heartbeatsToSend = [];
  let unsentEntries = heartbeatsCache.slice();
  for (const singleDateHeartbeat of heartbeatsCache) {
    const heartbeatEntry = heartbeatsToSend.find((hb2) => hb2.agent === singleDateHeartbeat.agent);
    if (!heartbeatEntry) {
      heartbeatsToSend.push({
        agent: singleDateHeartbeat.agent,
        dates: [singleDateHeartbeat.date]
      });
      if (countBytes(heartbeatsToSend) > maxSize) {
        heartbeatsToSend.pop();
        break;
      }
    } else {
      heartbeatEntry.dates.push(singleDateHeartbeat.date);
      if (countBytes(heartbeatsToSend) > maxSize) {
        heartbeatEntry.dates.pop();
        break;
      }
    }
    unsentEntries = unsentEntries.slice(1);
  }
  return {
    heartbeatsToSend,
    unsentEntries
  };
}
class HeartbeatStorageImpl {
  constructor(app2) {
    this.app = app2;
    this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();
  }
  async runIndexedDBEnvironmentCheck() {
    if (!isIndexedDBAvailable()) {
      return false;
    } else {
      return validateIndexedDBOpenable().then(() => true).catch(() => false);
    }
  }
  async read() {
    const canUseIndexedDB = await this._canUseIndexedDBPromise;
    if (!canUseIndexedDB) {
      return { heartbeats: [] };
    } else {
      const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);
      return idbHeartbeatObject || { heartbeats: [] };
    }
  }
  async overwrite(heartbeatsObject) {
    var _a2;
    const canUseIndexedDB = await this._canUseIndexedDBPromise;
    if (!canUseIndexedDB) {
      return;
    } else {
      const existingHeartbeatsObject = await this.read();
      return writeHeartbeatsToIndexedDB(this.app, {
        lastSentHeartbeatDate: (_a2 = heartbeatsObject.lastSentHeartbeatDate) !== null && _a2 !== void 0 ? _a2 : existingHeartbeatsObject.lastSentHeartbeatDate,
        heartbeats: heartbeatsObject.heartbeats
      });
    }
  }
  async add(heartbeatsObject) {
    var _a2;
    const canUseIndexedDB = await this._canUseIndexedDBPromise;
    if (!canUseIndexedDB) {
      return;
    } else {
      const existingHeartbeatsObject = await this.read();
      return writeHeartbeatsToIndexedDB(this.app, {
        lastSentHeartbeatDate: (_a2 = heartbeatsObject.lastSentHeartbeatDate) !== null && _a2 !== void 0 ? _a2 : existingHeartbeatsObject.lastSentHeartbeatDate,
        heartbeats: [
          ...existingHeartbeatsObject.heartbeats,
          ...heartbeatsObject.heartbeats
        ]
      });
    }
  }
}
function countBytes(heartbeatsCache) {
  return base64urlEncodeWithoutPadding(
    JSON.stringify({ version: 2, heartbeats: heartbeatsCache })
  ).length;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function registerCoreComponents(variant) {
  _registerComponent(new Component("platform-logger", (container) => new PlatformLoggerServiceImpl(container), "PRIVATE"));
  _registerComponent(new Component("heartbeat", (container) => new HeartbeatServiceImpl(container), "PRIVATE"));
  registerVersion(name$o, version$1$1, variant);
  registerVersion(name$o, version$1$1, "esm2017");
  registerVersion("fire-js", "");
}
registerCoreComponents("");
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
}
function _prodErrorMap() {
  return {
    ["dependent-sdk-initialized-before-auth"]: "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK."
  };
}
const prodErrorMap = _prodErrorMap;
const _DEFAULT_AUTH_ERROR_FACTORY = new ErrorFactory("auth", "Firebase", _prodErrorMap());
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const logClient = new Logger("@firebase/auth");
function _logError(msg, ...args) {
  if (logClient.logLevel <= LogLevel.ERROR) {
    logClient.error(`Auth (${SDK_VERSION}): ${msg}`, ...args);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _fail(authOrCode, ...rest) {
  throw createErrorInternal(authOrCode, ...rest);
}
function _createError(authOrCode, ...rest) {
  return createErrorInternal(authOrCode, ...rest);
}
function _errorWithCustomMessage(auth, code, message) {
  const errorMap = Object.assign(Object.assign({}, prodErrorMap()), { [code]: message });
  const factory2 = new ErrorFactory("auth", "Firebase", errorMap);
  return factory2.create(code, {
    appName: auth.name
  });
}
function _assertInstanceOf(auth, object, instance) {
  const constructorInstance = instance;
  if (!(object instanceof constructorInstance)) {
    if (constructorInstance.name !== object.constructor.name) {
      _fail(auth, "argument-error");
    }
    throw _errorWithCustomMessage(auth, "argument-error", `Type of ${object.constructor.name} does not match expected instance.Did you pass a reference from a different Auth SDK?`);
  }
}
function createErrorInternal(authOrCode, ...rest) {
  if (typeof authOrCode !== "string") {
    const code = rest[0];
    const fullParams = [...rest.slice(1)];
    if (fullParams[0]) {
      fullParams[0].appName = authOrCode.name;
    }
    return authOrCode._errorFactory.create(code, ...fullParams);
  }
  return _DEFAULT_AUTH_ERROR_FACTORY.create(authOrCode, ...rest);
}
function _assert(assertion, authOrCode, ...rest) {
  if (!assertion) {
    throw createErrorInternal(authOrCode, ...rest);
  }
}
function debugFail(failure) {
  const message = `INTERNAL ASSERTION FAILED: ` + failure;
  _logError(message);
  throw new Error(message);
}
function debugAssert(assertion, message) {
  if (!assertion) {
    debugFail(message);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const instanceCache = /* @__PURE__ */ new Map();
function _getInstance(cls) {
  debugAssert(cls instanceof Function, "Expected a class definition");
  let instance = instanceCache.get(cls);
  if (instance) {
    debugAssert(instance instanceof cls, "Instance stored in cache mismatched with class");
    return instance;
  }
  instance = new cls();
  instanceCache.set(cls, instance);
  return instance;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function initializeAuth(app2, deps) {
  const provider = _getProvider(app2, "auth");
  if (provider.isInitialized()) {
    const auth2 = provider.getImmediate();
    const initialOptions = provider.getOptions();
    if (deepEqual(initialOptions, deps !== null && deps !== void 0 ? deps : {})) {
      return auth2;
    } else {
      _fail(auth2, "already-initialized");
    }
  }
  const auth = provider.initialize({ options: deps });
  return auth;
}
function _initializeAuthInstance(auth, deps) {
  const persistence = (deps === null || deps === void 0 ? void 0 : deps.persistence) || [];
  const hierarchy = (Array.isArray(persistence) ? persistence : [persistence]).map(_getInstance);
  if (deps === null || deps === void 0 ? void 0 : deps.errorMap) {
    auth._updateErrorMap(deps.errorMap);
  }
  auth._initializeWithPersistence(hierarchy, deps === null || deps === void 0 ? void 0 : deps.popupRedirectResolver);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _getCurrentUrl() {
  var _a2;
  return typeof self !== "undefined" && ((_a2 = self.location) === null || _a2 === void 0 ? void 0 : _a2.href) || "";
}
function _isHttpOrHttps() {
  return _getCurrentScheme() === "http:" || _getCurrentScheme() === "https:";
}
function _getCurrentScheme() {
  var _a2;
  return typeof self !== "undefined" && ((_a2 = self.location) === null || _a2 === void 0 ? void 0 : _a2.protocol) || null;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _isOnline() {
  if (typeof navigator !== "undefined" && navigator && "onLine" in navigator && typeof navigator.onLine === "boolean" && (_isHttpOrHttps() || isBrowserExtension() || "connection" in navigator)) {
    return navigator.onLine;
  }
  return true;
}
function _getUserLanguage() {
  if (typeof navigator === "undefined") {
    return null;
  }
  const navigatorLanguage = navigator;
  return navigatorLanguage.languages && navigatorLanguage.languages[0] || navigatorLanguage.language || null;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Delay {
  constructor(shortDelay, longDelay) {
    this.shortDelay = shortDelay;
    this.longDelay = longDelay;
    debugAssert(longDelay > shortDelay, "Short delay should be less than long delay!");
    this.isMobile = isMobileCordova() || isReactNative();
  }
  get() {
    if (!_isOnline()) {
      return Math.min(5e3, this.shortDelay);
    }
    return this.isMobile ? this.longDelay : this.shortDelay;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _emulatorUrl(config2, path) {
  debugAssert(config2.emulator, "Emulator should always be set here");
  const { url } = config2.emulator;
  if (!path) {
    return url;
  }
  return `${url}${path.startsWith("/") ? path.slice(1) : path}`;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FetchProvider {
  static initialize(fetchImpl, headersImpl, responseImpl) {
    this.fetchImpl = fetchImpl;
    if (headersImpl) {
      this.headersImpl = headersImpl;
    }
    if (responseImpl) {
      this.responseImpl = responseImpl;
    }
  }
  static fetch() {
    if (this.fetchImpl) {
      return this.fetchImpl;
    }
    if (typeof self !== "undefined" && "fetch" in self) {
      return self.fetch;
    }
    debugFail("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
  }
  static headers() {
    if (this.headersImpl) {
      return this.headersImpl;
    }
    if (typeof self !== "undefined" && "Headers" in self) {
      return self.Headers;
    }
    debugFail("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
  }
  static response() {
    if (this.responseImpl) {
      return this.responseImpl;
    }
    if (typeof self !== "undefined" && "Response" in self) {
      return self.Response;
    }
    debugFail("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const SERVER_ERROR_MAP = {
  ["CREDENTIAL_MISMATCH"]: "custom-token-mismatch",
  ["MISSING_CUSTOM_TOKEN"]: "internal-error",
  ["INVALID_IDENTIFIER"]: "invalid-email",
  ["MISSING_CONTINUE_URI"]: "internal-error",
  ["INVALID_PASSWORD"]: "wrong-password",
  ["MISSING_PASSWORD"]: "internal-error",
  ["EMAIL_EXISTS"]: "email-already-in-use",
  ["PASSWORD_LOGIN_DISABLED"]: "operation-not-allowed",
  ["INVALID_IDP_RESPONSE"]: "invalid-credential",
  ["INVALID_PENDING_TOKEN"]: "invalid-credential",
  ["FEDERATED_USER_ID_ALREADY_LINKED"]: "credential-already-in-use",
  ["MISSING_REQ_TYPE"]: "internal-error",
  ["EMAIL_NOT_FOUND"]: "user-not-found",
  ["RESET_PASSWORD_EXCEED_LIMIT"]: "too-many-requests",
  ["EXPIRED_OOB_CODE"]: "expired-action-code",
  ["INVALID_OOB_CODE"]: "invalid-action-code",
  ["MISSING_OOB_CODE"]: "internal-error",
  ["CREDENTIAL_TOO_OLD_LOGIN_AGAIN"]: "requires-recent-login",
  ["INVALID_ID_TOKEN"]: "invalid-user-token",
  ["TOKEN_EXPIRED"]: "user-token-expired",
  ["USER_NOT_FOUND"]: "user-token-expired",
  ["TOO_MANY_ATTEMPTS_TRY_LATER"]: "too-many-requests",
  ["INVALID_CODE"]: "invalid-verification-code",
  ["INVALID_SESSION_INFO"]: "invalid-verification-id",
  ["INVALID_TEMPORARY_PROOF"]: "invalid-credential",
  ["MISSING_SESSION_INFO"]: "missing-verification-id",
  ["SESSION_EXPIRED"]: "code-expired",
  ["MISSING_ANDROID_PACKAGE_NAME"]: "missing-android-pkg-name",
  ["UNAUTHORIZED_DOMAIN"]: "unauthorized-continue-uri",
  ["INVALID_OAUTH_CLIENT_ID"]: "invalid-oauth-client-id",
  ["ADMIN_ONLY_OPERATION"]: "admin-restricted-operation",
  ["INVALID_MFA_PENDING_CREDENTIAL"]: "invalid-multi-factor-session",
  ["MFA_ENROLLMENT_NOT_FOUND"]: "multi-factor-info-not-found",
  ["MISSING_MFA_ENROLLMENT_ID"]: "missing-multi-factor-info",
  ["MISSING_MFA_PENDING_CREDENTIAL"]: "missing-multi-factor-session",
  ["SECOND_FACTOR_EXISTS"]: "second-factor-already-in-use",
  ["SECOND_FACTOR_LIMIT_EXCEEDED"]: "maximum-second-factor-count-exceeded",
  ["BLOCKING_FUNCTION_ERROR_RESPONSE"]: "internal-error"
};
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_API_TIMEOUT_MS = new Delay(3e4, 6e4);
function _addTidIfNecessary(auth, request) {
  if (auth.tenantId && !request.tenantId) {
    return Object.assign(Object.assign({}, request), { tenantId: auth.tenantId });
  }
  return request;
}
async function _performApiRequest(auth, method, path, request, customErrorMap = {}) {
  return _performFetchWithErrorHandling(auth, customErrorMap, async () => {
    let body = {};
    let params = {};
    if (request) {
      if (method === "GET") {
        params = request;
      } else {
        body = {
          body: JSON.stringify(request)
        };
      }
    }
    const query = querystring(Object.assign({ key: auth.config.apiKey }, params)).slice(1);
    const headers = await auth._getAdditionalHeaders();
    headers["Content-Type"] = "application/json";
    if (auth.languageCode) {
      headers["X-Firebase-Locale"] = auth.languageCode;
    }
    return FetchProvider.fetch()(_getFinalTarget(auth, auth.config.apiHost, path, query), Object.assign({
      method,
      headers,
      referrerPolicy: "no-referrer"
    }, body));
  });
}
async function _performFetchWithErrorHandling(auth, customErrorMap, fetchFn) {
  auth._canInitEmulator = false;
  const errorMap = Object.assign(Object.assign({}, SERVER_ERROR_MAP), customErrorMap);
  try {
    const networkTimeout = new NetworkTimeout(auth);
    const response = await Promise.race([
      fetchFn(),
      networkTimeout.promise
    ]);
    networkTimeout.clearNetworkTimeout();
    const json = await response.json();
    if ("needConfirmation" in json) {
      throw _makeTaggedError(auth, "account-exists-with-different-credential", json);
    }
    if (response.ok && !("errorMessage" in json)) {
      return json;
    } else {
      const errorMessage = response.ok ? json.errorMessage : json.error.message;
      const [serverErrorCode, serverErrorMessage] = errorMessage.split(" : ");
      if (serverErrorCode === "FEDERATED_USER_ID_ALREADY_LINKED") {
        throw _makeTaggedError(auth, "credential-already-in-use", json);
      } else if (serverErrorCode === "EMAIL_EXISTS") {
        throw _makeTaggedError(auth, "email-already-in-use", json);
      } else if (serverErrorCode === "USER_DISABLED") {
        throw _makeTaggedError(auth, "user-disabled", json);
      }
      const authError = errorMap[serverErrorCode] || serverErrorCode.toLowerCase().replace(/[_\s]+/g, "-");
      if (serverErrorMessage) {
        throw _errorWithCustomMessage(auth, authError, serverErrorMessage);
      } else {
        _fail(auth, authError);
      }
    }
  } catch (e2) {
    if (e2 instanceof FirebaseError) {
      throw e2;
    }
    _fail(auth, "network-request-failed");
  }
}
async function _performSignInRequest(auth, method, path, request, customErrorMap = {}) {
  const serverResponse = await _performApiRequest(auth, method, path, request, customErrorMap);
  if ("mfaPendingCredential" in serverResponse) {
    _fail(auth, "multi-factor-auth-required", {
      _serverResponse: serverResponse
    });
  }
  return serverResponse;
}
function _getFinalTarget(auth, host, path, query) {
  const base = `${host}${path}?${query}`;
  if (!auth.config.emulator) {
    return `${auth.config.apiScheme}://${base}`;
  }
  return _emulatorUrl(auth.config, base);
}
class NetworkTimeout {
  constructor(auth) {
    this.auth = auth;
    this.timer = null;
    this.promise = new Promise((_2, reject) => {
      this.timer = setTimeout(() => {
        return reject(_createError(this.auth, "network-request-failed"));
      }, DEFAULT_API_TIMEOUT_MS.get());
    });
  }
  clearNetworkTimeout() {
    clearTimeout(this.timer);
  }
}
function _makeTaggedError(auth, code, response) {
  const errorParams = {
    appName: auth.name
  };
  if (response.email) {
    errorParams.email = response.email;
  }
  if (response.phoneNumber) {
    errorParams.phoneNumber = response.phoneNumber;
  }
  const error = _createError(auth, code, errorParams);
  error.customData._tokenResponse = response;
  return error;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function deleteAccount(auth, request) {
  return _performApiRequest(auth, "POST", "/v1/accounts:delete", request);
}
async function getAccountInfo(auth, request) {
  return _performApiRequest(auth, "POST", "/v1/accounts:lookup", request);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function utcTimestampToDateString(utcTimestamp) {
  if (!utcTimestamp) {
    return void 0;
  }
  try {
    const date = new Date(Number(utcTimestamp));
    if (!isNaN(date.getTime())) {
      return date.toUTCString();
    }
  } catch (e2) {
  }
  return void 0;
}
async function getIdTokenResult(user, forceRefresh = false) {
  const userInternal = getModularInstance(user);
  const token = await userInternal.getIdToken(forceRefresh);
  const claims = _parseToken(token);
  _assert(claims && claims.exp && claims.auth_time && claims.iat, userInternal.auth, "internal-error");
  const firebase = typeof claims.firebase === "object" ? claims.firebase : void 0;
  const signInProvider = firebase === null || firebase === void 0 ? void 0 : firebase["sign_in_provider"];
  return {
    claims,
    token,
    authTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.auth_time)),
    issuedAtTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.iat)),
    expirationTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.exp)),
    signInProvider: signInProvider || null,
    signInSecondFactor: (firebase === null || firebase === void 0 ? void 0 : firebase["sign_in_second_factor"]) || null
  };
}
function secondsStringToMilliseconds(seconds) {
  return Number(seconds) * 1e3;
}
function _parseToken(token) {
  var _a2;
  const [algorithm2, payload, signature] = token.split(".");
  if (algorithm2 === void 0 || payload === void 0 || signature === void 0) {
    _logError("JWT malformed, contained fewer than 3 sections");
    return null;
  }
  try {
    const decoded = base64Decode(payload);
    if (!decoded) {
      _logError("Failed to decode base64 JWT payload");
      return null;
    }
    return JSON.parse(decoded);
  } catch (e2) {
    _logError("Caught error parsing JWT payload as JSON", (_a2 = e2) === null || _a2 === void 0 ? void 0 : _a2.toString());
    return null;
  }
}
function _tokenExpiresIn(token) {
  const parsedToken = _parseToken(token);
  _assert(parsedToken, "internal-error");
  _assert(typeof parsedToken.exp !== "undefined", "internal-error");
  _assert(typeof parsedToken.iat !== "undefined", "internal-error");
  return Number(parsedToken.exp) - Number(parsedToken.iat);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function _logoutIfInvalidated(user, promise, bypassAuthState = false) {
  if (bypassAuthState) {
    return promise;
  }
  try {
    return await promise;
  } catch (e2) {
    if (e2 instanceof FirebaseError && isUserInvalidated(e2)) {
      if (user.auth.currentUser === user) {
        await user.auth.signOut();
      }
    }
    throw e2;
  }
}
function isUserInvalidated({ code }) {
  return code === `auth/${"user-disabled"}` || code === `auth/${"user-token-expired"}`;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProactiveRefresh {
  constructor(user) {
    this.user = user;
    this.isRunning = false;
    this.timerId = null;
    this.errorBackoff = 3e4;
  }
  _start() {
    if (this.isRunning) {
      return;
    }
    this.isRunning = true;
    this.schedule();
  }
  _stop() {
    if (!this.isRunning) {
      return;
    }
    this.isRunning = false;
    if (this.timerId !== null) {
      clearTimeout(this.timerId);
    }
  }
  getInterval(wasError) {
    var _a2;
    if (wasError) {
      const interval = this.errorBackoff;
      this.errorBackoff = Math.min(this.errorBackoff * 2, 96e4);
      return interval;
    } else {
      this.errorBackoff = 3e4;
      const expTime = (_a2 = this.user.stsTokenManager.expirationTime) !== null && _a2 !== void 0 ? _a2 : 0;
      const interval = expTime - Date.now() - 3e5;
      return Math.max(0, interval);
    }
  }
  schedule(wasError = false) {
    if (!this.isRunning) {
      return;
    }
    const interval = this.getInterval(wasError);
    this.timerId = setTimeout(async () => {
      await this.iteration();
    }, interval);
  }
  async iteration() {
    var _a2;
    try {
      await this.user.getIdToken(true);
    } catch (e2) {
      if (((_a2 = e2) === null || _a2 === void 0 ? void 0 : _a2.code) === `auth/${"network-request-failed"}`) {
        this.schedule(true);
      }
      return;
    }
    this.schedule();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UserMetadata {
  constructor(createdAt, lastLoginAt) {
    this.createdAt = createdAt;
    this.lastLoginAt = lastLoginAt;
    this._initializeTime();
  }
  _initializeTime() {
    this.lastSignInTime = utcTimestampToDateString(this.lastLoginAt);
    this.creationTime = utcTimestampToDateString(this.createdAt);
  }
  _copy(metadata) {
    this.createdAt = metadata.createdAt;
    this.lastLoginAt = metadata.lastLoginAt;
    this._initializeTime();
  }
  toJSON() {
    return {
      createdAt: this.createdAt,
      lastLoginAt: this.lastLoginAt
    };
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function _reloadWithoutSaving(user) {
  var _a2;
  const auth = user.auth;
  const idToken = await user.getIdToken();
  const response = await _logoutIfInvalidated(user, getAccountInfo(auth, { idToken }));
  _assert(response === null || response === void 0 ? void 0 : response.users.length, auth, "internal-error");
  const coreAccount = response.users[0];
  user._notifyReloadListener(coreAccount);
  const newProviderData = ((_a2 = coreAccount.providerUserInfo) === null || _a2 === void 0 ? void 0 : _a2.length) ? extractProviderData(coreAccount.providerUserInfo) : [];
  const providerData = mergeProviderData(user.providerData, newProviderData);
  const oldIsAnonymous = user.isAnonymous;
  const newIsAnonymous = !(user.email && coreAccount.passwordHash) && !(providerData === null || providerData === void 0 ? void 0 : providerData.length);
  const isAnonymous = !oldIsAnonymous ? false : newIsAnonymous;
  const updates = {
    uid: coreAccount.localId,
    displayName: coreAccount.displayName || null,
    photoURL: coreAccount.photoUrl || null,
    email: coreAccount.email || null,
    emailVerified: coreAccount.emailVerified || false,
    phoneNumber: coreAccount.phoneNumber || null,
    tenantId: coreAccount.tenantId || null,
    providerData,
    metadata: new UserMetadata(coreAccount.createdAt, coreAccount.lastLoginAt),
    isAnonymous
  };
  Object.assign(user, updates);
}
async function reload(user) {
  const userInternal = getModularInstance(user);
  await _reloadWithoutSaving(userInternal);
  await userInternal.auth._persistUserIfCurrent(userInternal);
  userInternal.auth._notifyListenersIfCurrent(userInternal);
}
function mergeProviderData(original, newData) {
  const deduped = original.filter((o2) => !newData.some((n2) => n2.providerId === o2.providerId));
  return [...deduped, ...newData];
}
function extractProviderData(providers) {
  return providers.map((_a2) => {
    var { providerId } = _a2, provider = __rest(_a2, ["providerId"]);
    return {
      providerId,
      uid: provider.rawId || "",
      displayName: provider.displayName || null,
      email: provider.email || null,
      phoneNumber: provider.phoneNumber || null,
      photoURL: provider.photoUrl || null
    };
  });
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function requestStsToken(auth, refreshToken) {
  const response = await _performFetchWithErrorHandling(auth, {}, async () => {
    const body = querystring({
      "grant_type": "refresh_token",
      "refresh_token": refreshToken
    }).slice(1);
    const { tokenApiHost, apiKey } = auth.config;
    const url = _getFinalTarget(auth, tokenApiHost, "/v1/token", `key=${apiKey}`);
    const headers = await auth._getAdditionalHeaders();
    headers["Content-Type"] = "application/x-www-form-urlencoded";
    return FetchProvider.fetch()(url, {
      method: "POST",
      headers,
      body
    });
  });
  return {
    accessToken: response.access_token,
    expiresIn: response.expires_in,
    refreshToken: response.refresh_token
  };
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class StsTokenManager {
  constructor() {
    this.refreshToken = null;
    this.accessToken = null;
    this.expirationTime = null;
  }
  get isExpired() {
    return !this.expirationTime || Date.now() > this.expirationTime - 3e4;
  }
  updateFromServerResponse(response) {
    _assert(response.idToken, "internal-error");
    _assert(typeof response.idToken !== "undefined", "internal-error");
    _assert(typeof response.refreshToken !== "undefined", "internal-error");
    const expiresIn = "expiresIn" in response && typeof response.expiresIn !== "undefined" ? Number(response.expiresIn) : _tokenExpiresIn(response.idToken);
    this.updateTokensAndExpiration(response.idToken, response.refreshToken, expiresIn);
  }
  async getToken(auth, forceRefresh = false) {
    _assert(!this.accessToken || this.refreshToken, auth, "user-token-expired");
    if (!forceRefresh && this.accessToken && !this.isExpired) {
      return this.accessToken;
    }
    if (this.refreshToken) {
      await this.refresh(auth, this.refreshToken);
      return this.accessToken;
    }
    return null;
  }
  clearRefreshToken() {
    this.refreshToken = null;
  }
  async refresh(auth, oldToken) {
    const { accessToken, refreshToken, expiresIn } = await requestStsToken(auth, oldToken);
    this.updateTokensAndExpiration(accessToken, refreshToken, Number(expiresIn));
  }
  updateTokensAndExpiration(accessToken, refreshToken, expiresInSec) {
    this.refreshToken = refreshToken || null;
    this.accessToken = accessToken || null;
    this.expirationTime = Date.now() + expiresInSec * 1e3;
  }
  static fromJSON(appName, object) {
    const { refreshToken, accessToken, expirationTime } = object;
    const manager = new StsTokenManager();
    if (refreshToken) {
      _assert(typeof refreshToken === "string", "internal-error", {
        appName
      });
      manager.refreshToken = refreshToken;
    }
    if (accessToken) {
      _assert(typeof accessToken === "string", "internal-error", {
        appName
      });
      manager.accessToken = accessToken;
    }
    if (expirationTime) {
      _assert(typeof expirationTime === "number", "internal-error", {
        appName
      });
      manager.expirationTime = expirationTime;
    }
    return manager;
  }
  toJSON() {
    return {
      refreshToken: this.refreshToken,
      accessToken: this.accessToken,
      expirationTime: this.expirationTime
    };
  }
  _assign(stsTokenManager) {
    this.accessToken = stsTokenManager.accessToken;
    this.refreshToken = stsTokenManager.refreshToken;
    this.expirationTime = stsTokenManager.expirationTime;
  }
  _clone() {
    return Object.assign(new StsTokenManager(), this.toJSON());
  }
  _performRefresh() {
    return debugFail("not implemented");
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function assertStringOrUndefined(assertion, appName) {
  _assert(typeof assertion === "string" || typeof assertion === "undefined", "internal-error", { appName });
}
class UserImpl {
  constructor(_a2) {
    var { uid: uid2, auth, stsTokenManager } = _a2, opt = __rest(_a2, ["uid", "auth", "stsTokenManager"]);
    this.providerId = "firebase";
    this.proactiveRefresh = new ProactiveRefresh(this);
    this.reloadUserInfo = null;
    this.reloadListener = null;
    this.uid = uid2;
    this.auth = auth;
    this.stsTokenManager = stsTokenManager;
    this.accessToken = stsTokenManager.accessToken;
    this.displayName = opt.displayName || null;
    this.email = opt.email || null;
    this.emailVerified = opt.emailVerified || false;
    this.phoneNumber = opt.phoneNumber || null;
    this.photoURL = opt.photoURL || null;
    this.isAnonymous = opt.isAnonymous || false;
    this.tenantId = opt.tenantId || null;
    this.providerData = opt.providerData ? [...opt.providerData] : [];
    this.metadata = new UserMetadata(opt.createdAt || void 0, opt.lastLoginAt || void 0);
  }
  async getIdToken(forceRefresh) {
    const accessToken = await _logoutIfInvalidated(this, this.stsTokenManager.getToken(this.auth, forceRefresh));
    _assert(accessToken, this.auth, "internal-error");
    if (this.accessToken !== accessToken) {
      this.accessToken = accessToken;
      await this.auth._persistUserIfCurrent(this);
      this.auth._notifyListenersIfCurrent(this);
    }
    return accessToken;
  }
  getIdTokenResult(forceRefresh) {
    return getIdTokenResult(this, forceRefresh);
  }
  reload() {
    return reload(this);
  }
  _assign(user) {
    if (this === user) {
      return;
    }
    _assert(this.uid === user.uid, this.auth, "internal-error");
    this.displayName = user.displayName;
    this.photoURL = user.photoURL;
    this.email = user.email;
    this.emailVerified = user.emailVerified;
    this.phoneNumber = user.phoneNumber;
    this.isAnonymous = user.isAnonymous;
    this.tenantId = user.tenantId;
    this.providerData = user.providerData.map((userInfo) => Object.assign({}, userInfo));
    this.metadata._copy(user.metadata);
    this.stsTokenManager._assign(user.stsTokenManager);
  }
  _clone(auth) {
    return new UserImpl(Object.assign(Object.assign({}, this), { auth, stsTokenManager: this.stsTokenManager._clone() }));
  }
  _onReload(callback) {
    _assert(!this.reloadListener, this.auth, "internal-error");
    this.reloadListener = callback;
    if (this.reloadUserInfo) {
      this._notifyReloadListener(this.reloadUserInfo);
      this.reloadUserInfo = null;
    }
  }
  _notifyReloadListener(userInfo) {
    if (this.reloadListener) {
      this.reloadListener(userInfo);
    } else {
      this.reloadUserInfo = userInfo;
    }
  }
  _startProactiveRefresh() {
    this.proactiveRefresh._start();
  }
  _stopProactiveRefresh() {
    this.proactiveRefresh._stop();
  }
  async _updateTokensIfNecessary(response, reload2 = false) {
    let tokensRefreshed = false;
    if (response.idToken && response.idToken !== this.stsTokenManager.accessToken) {
      this.stsTokenManager.updateFromServerResponse(response);
      tokensRefreshed = true;
    }
    if (reload2) {
      await _reloadWithoutSaving(this);
    }
    await this.auth._persistUserIfCurrent(this);
    if (tokensRefreshed) {
      this.auth._notifyListenersIfCurrent(this);
    }
  }
  async delete() {
    const idToken = await this.getIdToken();
    await _logoutIfInvalidated(this, deleteAccount(this.auth, { idToken }));
    this.stsTokenManager.clearRefreshToken();
    return this.auth.signOut();
  }
  toJSON() {
    return Object.assign(Object.assign({
      uid: this.uid,
      email: this.email || void 0,
      emailVerified: this.emailVerified,
      displayName: this.displayName || void 0,
      isAnonymous: this.isAnonymous,
      photoURL: this.photoURL || void 0,
      phoneNumber: this.phoneNumber || void 0,
      tenantId: this.tenantId || void 0,
      providerData: this.providerData.map((userInfo) => Object.assign({}, userInfo)),
      stsTokenManager: this.stsTokenManager.toJSON(),
      _redirectEventId: this._redirectEventId
    }, this.metadata.toJSON()), {
      apiKey: this.auth.config.apiKey,
      appName: this.auth.name
    });
  }
  get refreshToken() {
    return this.stsTokenManager.refreshToken || "";
  }
  static _fromJSON(auth, object) {
    var _a2, _b, _c2, _d, _e2, _f, _g, _h2;
    const displayName = (_a2 = object.displayName) !== null && _a2 !== void 0 ? _a2 : void 0;
    const email = (_b = object.email) !== null && _b !== void 0 ? _b : void 0;
    const phoneNumber = (_c2 = object.phoneNumber) !== null && _c2 !== void 0 ? _c2 : void 0;
    const photoURL = (_d = object.photoURL) !== null && _d !== void 0 ? _d : void 0;
    const tenantId = (_e2 = object.tenantId) !== null && _e2 !== void 0 ? _e2 : void 0;
    const _redirectEventId = (_f = object._redirectEventId) !== null && _f !== void 0 ? _f : void 0;
    const createdAt = (_g = object.createdAt) !== null && _g !== void 0 ? _g : void 0;
    const lastLoginAt = (_h2 = object.lastLoginAt) !== null && _h2 !== void 0 ? _h2 : void 0;
    const { uid: uid2, emailVerified, isAnonymous, providerData, stsTokenManager: plainObjectTokenManager } = object;
    _assert(uid2 && plainObjectTokenManager, auth, "internal-error");
    const stsTokenManager = StsTokenManager.fromJSON(this.name, plainObjectTokenManager);
    _assert(typeof uid2 === "string", auth, "internal-error");
    assertStringOrUndefined(displayName, auth.name);
    assertStringOrUndefined(email, auth.name);
    _assert(typeof emailVerified === "boolean", auth, "internal-error");
    _assert(typeof isAnonymous === "boolean", auth, "internal-error");
    assertStringOrUndefined(phoneNumber, auth.name);
    assertStringOrUndefined(photoURL, auth.name);
    assertStringOrUndefined(tenantId, auth.name);
    assertStringOrUndefined(_redirectEventId, auth.name);
    assertStringOrUndefined(createdAt, auth.name);
    assertStringOrUndefined(lastLoginAt, auth.name);
    const user = new UserImpl({
      uid: uid2,
      auth,
      email,
      emailVerified,
      displayName,
      isAnonymous,
      photoURL,
      phoneNumber,
      tenantId,
      stsTokenManager,
      createdAt,
      lastLoginAt
    });
    if (providerData && Array.isArray(providerData)) {
      user.providerData = providerData.map((userInfo) => Object.assign({}, userInfo));
    }
    if (_redirectEventId) {
      user._redirectEventId = _redirectEventId;
    }
    return user;
  }
  static async _fromIdTokenResponse(auth, idTokenResponse, isAnonymous = false) {
    const stsTokenManager = new StsTokenManager();
    stsTokenManager.updateFromServerResponse(idTokenResponse);
    const user = new UserImpl({
      uid: idTokenResponse.localId,
      auth,
      stsTokenManager,
      isAnonymous
    });
    await _reloadWithoutSaving(user);
    return user;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class InMemoryPersistence {
  constructor() {
    this.type = "NONE";
    this.storage = {};
  }
  async _isAvailable() {
    return true;
  }
  async _set(key, value) {
    this.storage[key] = value;
  }
  async _get(key) {
    const value = this.storage[key];
    return value === void 0 ? null : value;
  }
  async _remove(key) {
    delete this.storage[key];
  }
  _addListener(_key, _listener) {
    return;
  }
  _removeListener(_key, _listener) {
    return;
  }
}
InMemoryPersistence.type = "NONE";
const inMemoryPersistence = InMemoryPersistence;
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _persistenceKeyName(key, apiKey, appName) {
  return `${"firebase"}:${key}:${apiKey}:${appName}`;
}
class PersistenceUserManager {
  constructor(persistence, auth, userKey) {
    this.persistence = persistence;
    this.auth = auth;
    this.userKey = userKey;
    const { config: config2, name: name2 } = this.auth;
    this.fullUserKey = _persistenceKeyName(this.userKey, config2.apiKey, name2);
    this.fullPersistenceKey = _persistenceKeyName("persistence", config2.apiKey, name2);
    this.boundEventHandler = auth._onStorageEvent.bind(auth);
    this.persistence._addListener(this.fullUserKey, this.boundEventHandler);
  }
  setCurrentUser(user) {
    return this.persistence._set(this.fullUserKey, user.toJSON());
  }
  async getCurrentUser() {
    const blob = await this.persistence._get(this.fullUserKey);
    return blob ? UserImpl._fromJSON(this.auth, blob) : null;
  }
  removeCurrentUser() {
    return this.persistence._remove(this.fullUserKey);
  }
  savePersistenceForRedirect() {
    return this.persistence._set(this.fullPersistenceKey, this.persistence.type);
  }
  async setPersistence(newPersistence) {
    if (this.persistence === newPersistence) {
      return;
    }
    const currentUser = await this.getCurrentUser();
    await this.removeCurrentUser();
    this.persistence = newPersistence;
    if (currentUser) {
      return this.setCurrentUser(currentUser);
    }
  }
  delete() {
    this.persistence._removeListener(this.fullUserKey, this.boundEventHandler);
  }
  static async create(auth, persistenceHierarchy, userKey = "authUser") {
    if (!persistenceHierarchy.length) {
      return new PersistenceUserManager(_getInstance(inMemoryPersistence), auth, userKey);
    }
    const availablePersistences = (await Promise.all(persistenceHierarchy.map(async (persistence) => {
      if (await persistence._isAvailable()) {
        return persistence;
      }
      return void 0;
    }))).filter((persistence) => persistence);
    let selectedPersistence = availablePersistences[0] || _getInstance(inMemoryPersistence);
    const key = _persistenceKeyName(userKey, auth.config.apiKey, auth.name);
    let userToMigrate = null;
    for (const persistence of persistenceHierarchy) {
      try {
        const blob = await persistence._get(key);
        if (blob) {
          const user = UserImpl._fromJSON(auth, blob);
          if (persistence !== selectedPersistence) {
            userToMigrate = user;
          }
          selectedPersistence = persistence;
          break;
        }
      } catch (_a2) {
      }
    }
    const migrationHierarchy = availablePersistences.filter((p2) => p2._shouldAllowMigration);
    if (!selectedPersistence._shouldAllowMigration || !migrationHierarchy.length) {
      return new PersistenceUserManager(selectedPersistence, auth, userKey);
    }
    selectedPersistence = migrationHierarchy[0];
    if (userToMigrate) {
      await selectedPersistence._set(key, userToMigrate.toJSON());
    }
    await Promise.all(persistenceHierarchy.map(async (persistence) => {
      if (persistence !== selectedPersistence) {
        try {
          await persistence._remove(key);
        } catch (_a2) {
        }
      }
    }));
    return new PersistenceUserManager(selectedPersistence, auth, userKey);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _getBrowserName(userAgent) {
  const ua2 = userAgent.toLowerCase();
  if (ua2.includes("opera/") || ua2.includes("opr/") || ua2.includes("opios/")) {
    return "Opera";
  } else if (_isIEMobile(ua2)) {
    return "IEMobile";
  } else if (ua2.includes("msie") || ua2.includes("trident/")) {
    return "IE";
  } else if (ua2.includes("edge/")) {
    return "Edge";
  } else if (_isFirefox(ua2)) {
    return "Firefox";
  } else if (ua2.includes("silk/")) {
    return "Silk";
  } else if (_isBlackBerry(ua2)) {
    return "Blackberry";
  } else if (_isWebOS(ua2)) {
    return "Webos";
  } else if (_isSafari(ua2)) {
    return "Safari";
  } else if ((ua2.includes("chrome/") || _isChromeIOS(ua2)) && !ua2.includes("edge/")) {
    return "Chrome";
  } else if (_isAndroid(ua2)) {
    return "Android";
  } else {
    const re2 = /([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/;
    const matches = userAgent.match(re2);
    if ((matches === null || matches === void 0 ? void 0 : matches.length) === 2) {
      return matches[1];
    }
  }
  return "Other";
}
function _isFirefox(ua2 = getUA()) {
  return /firefox\//i.test(ua2);
}
function _isSafari(userAgent = getUA()) {
  const ua2 = userAgent.toLowerCase();
  return ua2.includes("safari/") && !ua2.includes("chrome/") && !ua2.includes("crios/") && !ua2.includes("android");
}
function _isChromeIOS(ua2 = getUA()) {
  return /crios\//i.test(ua2);
}
function _isIEMobile(ua2 = getUA()) {
  return /iemobile/i.test(ua2);
}
function _isAndroid(ua2 = getUA()) {
  return /android/i.test(ua2);
}
function _isBlackBerry(ua2 = getUA()) {
  return /blackberry/i.test(ua2);
}
function _isWebOS(ua2 = getUA()) {
  return /webos/i.test(ua2);
}
function _isIOS(ua2 = getUA()) {
  return /iphone|ipad|ipod/i.test(ua2) || /macintosh/i.test(ua2) && /mobile/i.test(ua2);
}
function _isIOSStandalone(ua2 = getUA()) {
  var _a2;
  return _isIOS(ua2) && !!((_a2 = window.navigator) === null || _a2 === void 0 ? void 0 : _a2.standalone);
}
function _isIE10() {
  return isIE() && document.documentMode === 10;
}
function _isMobileBrowser(ua2 = getUA()) {
  return _isIOS(ua2) || _isAndroid(ua2) || _isWebOS(ua2) || _isBlackBerry(ua2) || /windows phone/i.test(ua2) || _isIEMobile(ua2);
}
function _isIframe() {
  try {
    return !!(window && window !== window.top);
  } catch (e2) {
    return false;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _getClientVersion(clientPlatform, frameworks = []) {
  let reportedPlatform;
  switch (clientPlatform) {
    case "Browser":
      reportedPlatform = _getBrowserName(getUA());
      break;
    case "Worker":
      reportedPlatform = `${_getBrowserName(getUA())}-${clientPlatform}`;
      break;
    default:
      reportedPlatform = clientPlatform;
  }
  const reportedFrameworks = frameworks.length ? frameworks.join(",") : "FirebaseCore-web";
  return `${reportedPlatform}/${"JsCore"}/${SDK_VERSION}/${reportedFrameworks}`;
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AuthMiddlewareQueue {
  constructor(auth) {
    this.auth = auth;
    this.queue = [];
  }
  pushCallback(callback, onAbort) {
    const wrappedCallback = (user) => new Promise((resolve2, reject) => {
      try {
        const result = callback(user);
        resolve2(result);
      } catch (e2) {
        reject(e2);
      }
    });
    wrappedCallback.onAbort = onAbort;
    this.queue.push(wrappedCallback);
    const index = this.queue.length - 1;
    return () => {
      this.queue[index] = () => Promise.resolve();
    };
  }
  async runMiddleware(nextUser) {
    var _a2;
    if (this.auth.currentUser === nextUser) {
      return;
    }
    const onAbortStack = [];
    try {
      for (const beforeStateCallback of this.queue) {
        await beforeStateCallback(nextUser);
        if (beforeStateCallback.onAbort) {
          onAbortStack.push(beforeStateCallback.onAbort);
        }
      }
    } catch (e2) {
      onAbortStack.reverse();
      for (const onAbort of onAbortStack) {
        try {
          onAbort();
        } catch (_2) {
        }
      }
      throw this.auth._errorFactory.create("login-blocked", { originalMessage: (_a2 = e2) === null || _a2 === void 0 ? void 0 : _a2.message });
    }
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AuthImpl {
  constructor(app2, heartbeatServiceProvider, config2) {
    this.app = app2;
    this.heartbeatServiceProvider = heartbeatServiceProvider;
    this.config = config2;
    this.currentUser = null;
    this.emulatorConfig = null;
    this.operations = Promise.resolve();
    this.authStateSubscription = new Subscription(this);
    this.idTokenSubscription = new Subscription(this);
    this.beforeStateQueue = new AuthMiddlewareQueue(this);
    this.redirectUser = null;
    this.isProactiveRefreshEnabled = false;
    this._canInitEmulator = true;
    this._isInitialized = false;
    this._deleted = false;
    this._initializationPromise = null;
    this._popupRedirectResolver = null;
    this._errorFactory = _DEFAULT_AUTH_ERROR_FACTORY;
    this.lastNotifiedUid = void 0;
    this.languageCode = null;
    this.tenantId = null;
    this.settings = { appVerificationDisabledForTesting: false };
    this.frameworks = [];
    this.name = app2.name;
    this.clientVersion = config2.sdkClientVersion;
  }
  _initializeWithPersistence(persistenceHierarchy, popupRedirectResolver) {
    if (popupRedirectResolver) {
      this._popupRedirectResolver = _getInstance(popupRedirectResolver);
    }
    this._initializationPromise = this.queue(async () => {
      var _a2, _b;
      if (this._deleted) {
        return;
      }
      this.persistenceManager = await PersistenceUserManager.create(this, persistenceHierarchy);
      if (this._deleted) {
        return;
      }
      if ((_a2 = this._popupRedirectResolver) === null || _a2 === void 0 ? void 0 : _a2._shouldInitProactively) {
        try {
          await this._popupRedirectResolver._initialize(this);
        } catch (e2) {
        }
      }
      await this.initializeCurrentUser(popupRedirectResolver);
      this.lastNotifiedUid = ((_b = this.currentUser) === null || _b === void 0 ? void 0 : _b.uid) || null;
      if (this._deleted) {
        return;
      }
      this._isInitialized = true;
    });
    return this._initializationPromise;
  }
  async _onStorageEvent() {
    if (this._deleted) {
      return;
    }
    const user = await this.assertedPersistence.getCurrentUser();
    if (!this.currentUser && !user) {
      return;
    }
    if (this.currentUser && user && this.currentUser.uid === user.uid) {
      this._currentUser._assign(user);
      await this.currentUser.getIdToken();
      return;
    }
    await this._updateCurrentUser(user, true);
  }
  async initializeCurrentUser(popupRedirectResolver) {
    var _a2;
    const previouslyStoredUser = await this.assertedPersistence.getCurrentUser();
    let futureCurrentUser = previouslyStoredUser;
    let needsTocheckMiddleware = false;
    if (popupRedirectResolver && this.config.authDomain) {
      await this.getOrInitRedirectPersistenceManager();
      const redirectUserEventId = (_a2 = this.redirectUser) === null || _a2 === void 0 ? void 0 : _a2._redirectEventId;
      const storedUserEventId = futureCurrentUser === null || futureCurrentUser === void 0 ? void 0 : futureCurrentUser._redirectEventId;
      const result = await this.tryRedirectSignIn(popupRedirectResolver);
      if ((!redirectUserEventId || redirectUserEventId === storedUserEventId) && (result === null || result === void 0 ? void 0 : result.user)) {
        futureCurrentUser = result.user;
        needsTocheckMiddleware = true;
      }
    }
    if (!futureCurrentUser) {
      return this.directlySetCurrentUser(null);
    }
    if (!futureCurrentUser._redirectEventId) {
      if (needsTocheckMiddleware) {
        try {
          await this.beforeStateQueue.runMiddleware(futureCurrentUser);
        } catch (e2) {
          futureCurrentUser = previouslyStoredUser;
          this._popupRedirectResolver._overrideRedirectResult(this, () => Promise.reject(e2));
        }
      }
      if (futureCurrentUser) {
        return this.reloadAndSetCurrentUserOrClear(futureCurrentUser);
      } else {
        return this.directlySetCurrentUser(null);
      }
    }
    _assert(this._popupRedirectResolver, this, "argument-error");
    await this.getOrInitRedirectPersistenceManager();
    if (this.redirectUser && this.redirectUser._redirectEventId === futureCurrentUser._redirectEventId) {
      return this.directlySetCurrentUser(futureCurrentUser);
    }
    return this.reloadAndSetCurrentUserOrClear(futureCurrentUser);
  }
  async tryRedirectSignIn(redirectResolver) {
    let result = null;
    try {
      result = await this._popupRedirectResolver._completeRedirectFn(this, redirectResolver, true);
    } catch (e2) {
      await this._setRedirectUser(null);
    }
    return result;
  }
  async reloadAndSetCurrentUserOrClear(user) {
    var _a2;
    try {
      await _reloadWithoutSaving(user);
    } catch (e2) {
      if (((_a2 = e2) === null || _a2 === void 0 ? void 0 : _a2.code) !== `auth/${"network-request-failed"}`) {
        return this.directlySetCurrentUser(null);
      }
    }
    return this.directlySetCurrentUser(user);
  }
  useDeviceLanguage() {
    this.languageCode = _getUserLanguage();
  }
  async _delete() {
    this._deleted = true;
  }
  async updateCurrentUser(userExtern) {
    const user = userExtern ? getModularInstance(userExtern) : null;
    if (user) {
      _assert(user.auth.config.apiKey === this.config.apiKey, this, "invalid-user-token");
    }
    return this._updateCurrentUser(user && user._clone(this));
  }
  async _updateCurrentUser(user, skipBeforeStateCallbacks = false) {
    if (this._deleted) {
      return;
    }
    if (user) {
      _assert(this.tenantId === user.tenantId, this, "tenant-id-mismatch");
    }
    if (!skipBeforeStateCallbacks) {
      await this.beforeStateQueue.runMiddleware(user);
    }
    return this.queue(async () => {
      await this.directlySetCurrentUser(user);
      this.notifyAuthListeners();
    });
  }
  async signOut() {
    await this.beforeStateQueue.runMiddleware(null);
    if (this.redirectPersistenceManager || this._popupRedirectResolver) {
      await this._setRedirectUser(null);
    }
    return this._updateCurrentUser(null, true);
  }
  setPersistence(persistence) {
    return this.queue(async () => {
      await this.assertedPersistence.setPersistence(_getInstance(persistence));
    });
  }
  _getPersistence() {
    return this.assertedPersistence.persistence.type;
  }
  _updateErrorMap(errorMap) {
    this._errorFactory = new ErrorFactory("auth", "Firebase", errorMap());
  }
  onAuthStateChanged(nextOrObserver, error, completed) {
    return this.registerStateListener(this.authStateSubscription, nextOrObserver, error, completed);
  }
  beforeAuthStateChanged(callback, onAbort) {
    return this.beforeStateQueue.pushCallback(callback, onAbort);
  }
  onIdTokenChanged(nextOrObserver, error, completed) {
    return this.registerStateListener(this.idTokenSubscription, nextOrObserver, error, completed);
  }
  toJSON() {
    var _a2;
    return {
      apiKey: this.config.apiKey,
      authDomain: this.config.authDomain,
      appName: this.name,
      currentUser: (_a2 = this._currentUser) === null || _a2 === void 0 ? void 0 : _a2.toJSON()
    };
  }
  async _setRedirectUser(user, popupRedirectResolver) {
    const redirectManager = await this.getOrInitRedirectPersistenceManager(popupRedirectResolver);
    return user === null ? redirectManager.removeCurrentUser() : redirectManager.setCurrentUser(user);
  }
  async getOrInitRedirectPersistenceManager(popupRedirectResolver) {
    if (!this.redirectPersistenceManager) {
      const resolver = popupRedirectResolver && _getInstance(popupRedirectResolver) || this._popupRedirectResolver;
      _assert(resolver, this, "argument-error");
      this.redirectPersistenceManager = await PersistenceUserManager.create(this, [_getInstance(resolver._redirectPersistence)], "redirectUser");
      this.redirectUser = await this.redirectPersistenceManager.getCurrentUser();
    }
    return this.redirectPersistenceManager;
  }
  async _redirectUserForId(id2) {
    var _a2, _b;
    if (this._isInitialized) {
      await this.queue(async () => {
      });
    }
    if (((_a2 = this._currentUser) === null || _a2 === void 0 ? void 0 : _a2._redirectEventId) === id2) {
      return this._currentUser;
    }
    if (((_b = this.redirectUser) === null || _b === void 0 ? void 0 : _b._redirectEventId) === id2) {
      return this.redirectUser;
    }
    return null;
  }
  async _persistUserIfCurrent(user) {
    if (user === this.currentUser) {
      return this.queue(async () => this.directlySetCurrentUser(user));
    }
  }
  _notifyListenersIfCurrent(user) {
    if (user === this.currentUser) {
      this.notifyAuthListeners();
    }
  }
  _key() {
    return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`;
  }
  _startProactiveRefresh() {
    this.isProactiveRefreshEnabled = true;
    if (this.currentUser) {
      this._currentUser._startProactiveRefresh();
    }
  }
  _stopProactiveRefresh() {
    this.isProactiveRefreshEnabled = false;
    if (this.currentUser) {
      this._currentUser._stopProactiveRefresh();
    }
  }
  get _currentUser() {
    return this.currentUser;
  }
  notifyAuthListeners() {
    var _a2, _b;
    if (!this._isInitialized) {
      return;
    }
    this.idTokenSubscription.next(this.currentUser);
    const currentUid = (_b = (_a2 = this.currentUser) === null || _a2 === void 0 ? void 0 : _a2.uid) !== null && _b !== void 0 ? _b : null;
    if (this.lastNotifiedUid !== currentUid) {
      this.lastNotifiedUid = currentUid;
      this.authStateSubscription.next(this.currentUser);
    }
  }
  registerStateListener(subscription, nextOrObserver, error, completed) {
    if (this._deleted) {
      return () => {
      };
    }
    const cb2 = typeof nextOrObserver === "function" ? nextOrObserver : nextOrObserver.next.bind(nextOrObserver);
    const promise = this._isInitialized ? Promise.resolve() : this._initializationPromise;
    _assert(promise, this, "internal-error");
    promise.then(() => cb2(this.currentUser));
    if (typeof nextOrObserver === "function") {
      return subscription.addObserver(nextOrObserver, error, completed);
    } else {
      return subscription.addObserver(nextOrObserver);
    }
  }
  async directlySetCurrentUser(user) {
    if (this.currentUser && this.currentUser !== user) {
      this._currentUser._stopProactiveRefresh();
      if (user && this.isProactiveRefreshEnabled) {
        user._startProactiveRefresh();
      }
    }
    this.currentUser = user;
    if (user) {
      await this.assertedPersistence.setCurrentUser(user);
    } else {
      await this.assertedPersistence.removeCurrentUser();
    }
  }
  queue(action) {
    this.operations = this.operations.then(action, action);
    return this.operations;
  }
  get assertedPersistence() {
    _assert(this.persistenceManager, this, "internal-error");
    return this.persistenceManager;
  }
  _logFramework(framework) {
    if (!framework || this.frameworks.includes(framework)) {
      return;
    }
    this.frameworks.push(framework);
    this.frameworks.sort();
    this.clientVersion = _getClientVersion(this.config.clientPlatform, this._getFrameworks());
  }
  _getFrameworks() {
    return this.frameworks;
  }
  async _getAdditionalHeaders() {
    var _a2;
    const headers = {
      ["X-Client-Version"]: this.clientVersion
    };
    if (this.app.options.appId) {
      headers["X-Firebase-gmpid"] = this.app.options.appId;
    }
    const heartbeatsHeader = await ((_a2 = this.heartbeatServiceProvider.getImmediate({
      optional: true
    })) === null || _a2 === void 0 ? void 0 : _a2.getHeartbeatsHeader());
    if (heartbeatsHeader) {
      headers["X-Firebase-Client"] = heartbeatsHeader;
    }
    return headers;
  }
}
function _castAuth(auth) {
  return getModularInstance(auth);
}
class Subscription {
  constructor(auth) {
    this.auth = auth;
    this.observer = null;
    this.addObserver = createSubscribe((observer) => this.observer = observer);
  }
  get next() {
    _assert(this.observer, this.auth, "internal-error");
    return this.observer.next.bind(this.observer);
  }
}
function connectAuthEmulator(auth, url, options) {
  const authInternal = _castAuth(auth);
  _assert(authInternal._canInitEmulator, authInternal, "emulator-config-failed");
  _assert(/^https?:\/\//.test(url), authInternal, "invalid-emulator-scheme");
  const disableWarnings = !!(options === null || options === void 0 ? void 0 : options.disableWarnings);
  const protocol = extractProtocol(url);
  const { host, port } = extractHostAndPort(url);
  const portStr = port === null ? "" : `:${port}`;
  authInternal.config.emulator = { url: `${protocol}//${host}${portStr}/` };
  authInternal.settings.appVerificationDisabledForTesting = true;
  authInternal.emulatorConfig = Object.freeze({
    host,
    port,
    protocol: protocol.replace(":", ""),
    options: Object.freeze({ disableWarnings })
  });
  if (!disableWarnings) {
    emitEmulatorWarning();
  }
}
function extractProtocol(url) {
  const protocolEnd = url.indexOf(":");
  return protocolEnd < 0 ? "" : url.substr(0, protocolEnd + 1);
}
function extractHostAndPort(url) {
  const protocol = extractProtocol(url);
  const authority = /(\/\/)?([^?#/]+)/.exec(url.substr(protocol.length));
  if (!authority) {
    return { host: "", port: null };
  }
  const hostAndPort = authority[2].split("@").pop() || "";
  const bracketedIPv6 = /^(\[[^\]]+\])(:|$)/.exec(hostAndPort);
  if (bracketedIPv6) {
    const host = bracketedIPv6[1];
    return { host, port: parsePort(hostAndPort.substr(host.length + 1)) };
  } else {
    const [host, port] = hostAndPort.split(":");
    return { host, port: parsePort(port) };
  }
}
function parsePort(portStr) {
  if (!portStr) {
    return null;
  }
  const port = Number(portStr);
  if (isNaN(port)) {
    return null;
  }
  return port;
}
function emitEmulatorWarning() {
  function attachBanner() {
    const el = document.createElement("p");
    const sty = el.style;
    el.innerText = "Running in emulator mode. Do not use with production credentials.";
    sty.position = "fixed";
    sty.width = "100%";
    sty.backgroundColor = "#ffffff";
    sty.border = ".1em solid #000000";
    sty.color = "#b50000";
    sty.bottom = "0px";
    sty.left = "0px";
    sty.margin = "0px";
    sty.zIndex = "10000";
    sty.textAlign = "center";
    el.classList.add("firebase-emulator-warning");
    document.body.appendChild(el);
  }
  if (typeof console !== "undefined" && typeof console.info === "function") {
    console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials.");
  }
  if (typeof window !== "undefined" && typeof document !== "undefined") {
    if (document.readyState === "loading") {
      window.addEventListener("DOMContentLoaded", attachBanner);
    } else {
      attachBanner();
    }
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AuthCredential {
  constructor(providerId, signInMethod) {
    this.providerId = providerId;
    this.signInMethod = signInMethod;
  }
  toJSON() {
    return debugFail("not implemented");
  }
  _getIdTokenResponse(_auth) {
    return debugFail("not implemented");
  }
  _linkToIdToken(_auth, _idToken) {
    return debugFail("not implemented");
  }
  _getReauthenticationResolver(_auth) {
    return debugFail("not implemented");
  }
}
async function updateEmailPassword(auth, request) {
  return _performApiRequest(auth, "POST", "/v1/accounts:update", request);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function signInWithPassword(auth, request) {
  return _performSignInRequest(auth, "POST", "/v1/accounts:signInWithPassword", _addTidIfNecessary(auth, request));
}
async function sendOobCode(auth, request) {
  return _performApiRequest(auth, "POST", "/v1/accounts:sendOobCode", _addTidIfNecessary(auth, request));
}
async function sendSignInLinkToEmail$1(auth, request) {
  return sendOobCode(auth, request);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function signInWithEmailLink$1(auth, request) {
  return _performSignInRequest(auth, "POST", "/v1/accounts:signInWithEmailLink", _addTidIfNecessary(auth, request));
}
async function signInWithEmailLinkForLinking(auth, request) {
  return _performSignInRequest(auth, "POST", "/v1/accounts:signInWithEmailLink", _addTidIfNecessary(auth, request));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class EmailAuthCredential extends AuthCredential {
  constructor(_email, _password, signInMethod, _tenantId = null) {
    super("password", signInMethod);
    this._email = _email;
    this._password = _password;
    this._tenantId = _tenantId;
  }
  static _fromEmailAndPassword(email, password) {
    return new EmailAuthCredential(email, password, "password");
  }
  static _fromEmailAndCode(email, oobCode, tenantId = null) {
    return new EmailAuthCredential(email, oobCode, "emailLink", tenantId);
  }
  toJSON() {
    return {
      email: this._email,
      password: this._password,
      signInMethod: this.signInMethod,
      tenantId: this._tenantId
    };
  }
  static fromJSON(json) {
    const obj = typeof json === "string" ? JSON.parse(json) : json;
    if ((obj === null || obj === void 0 ? void 0 : obj.email) && (obj === null || obj === void 0 ? void 0 : obj.password)) {
      if (obj.signInMethod === "password") {
        return this._fromEmailAndPassword(obj.email, obj.password);
      } else if (obj.signInMethod === "emailLink") {
        return this._fromEmailAndCode(obj.email, obj.password, obj.tenantId);
      }
    }
    return null;
  }
  async _getIdTokenResponse(auth) {
    switch (this.signInMethod) {
      case "password":
        return signInWithPassword(auth, {
          returnSecureToken: true,
          email: this._email,
          password: this._password
        });
      case "emailLink":
        return signInWithEmailLink$1(auth, {
          email: this._email,
          oobCode: this._password
        });
      default:
        _fail(auth, "internal-error");
    }
  }
  async _linkToIdToken(auth, idToken) {
    switch (this.signInMethod) {
      case "password":
        return updateEmailPassword(auth, {
          idToken,
          returnSecureToken: true,
          email: this._email,
          password: this._password
        });
      case "emailLink":
        return signInWithEmailLinkForLinking(auth, {
          idToken,
          email: this._email,
          oobCode: this._password
        });
      default:
        _fail(auth, "internal-error");
    }
  }
  _getReauthenticationResolver(auth) {
    return this._getIdTokenResponse(auth);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function signInWithIdp(auth, request) {
  return _performSignInRequest(auth, "POST", "/v1/accounts:signInWithIdp", _addTidIfNecessary(auth, request));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const IDP_REQUEST_URI$1 = "http://localhost";
class OAuthCredential extends AuthCredential {
  constructor() {
    super(...arguments);
    this.pendingToken = null;
  }
  static _fromParams(params) {
    const cred = new OAuthCredential(params.providerId, params.signInMethod);
    if (params.idToken || params.accessToken) {
      if (params.idToken) {
        cred.idToken = params.idToken;
      }
      if (params.accessToken) {
        cred.accessToken = params.accessToken;
      }
      if (params.nonce && !params.pendingToken) {
        cred.nonce = params.nonce;
      }
      if (params.pendingToken) {
        cred.pendingToken = params.pendingToken;
      }
    } else if (params.oauthToken && params.oauthTokenSecret) {
      cred.accessToken = params.oauthToken;
      cred.secret = params.oauthTokenSecret;
    } else {
      _fail("argument-error");
    }
    return cred;
  }
  toJSON() {
    return {
      idToken: this.idToken,
      accessToken: this.accessToken,
      secret: this.secret,
      nonce: this.nonce,
      pendingToken: this.pendingToken,
      providerId: this.providerId,
      signInMethod: this.signInMethod
    };
  }
  static fromJSON(json) {
    const obj = typeof json === "string" ? JSON.parse(json) : json;
    const { providerId, signInMethod } = obj, rest = __rest(obj, ["providerId", "signInMethod"]);
    if (!providerId || !signInMethod) {
      return null;
    }
    const cred = new OAuthCredential(providerId, signInMethod);
    cred.idToken = rest.idToken || void 0;
    cred.accessToken = rest.accessToken || void 0;
    cred.secret = rest.secret;
    cred.nonce = rest.nonce;
    cred.pendingToken = rest.pendingToken || null;
    return cred;
  }
  _getIdTokenResponse(auth) {
    const request = this.buildRequest();
    return signInWithIdp(auth, request);
  }
  _linkToIdToken(auth, idToken) {
    const request = this.buildRequest();
    request.idToken = idToken;
    return signInWithIdp(auth, request);
  }
  _getReauthenticationResolver(auth) {
    const request = this.buildRequest();
    request.autoCreate = false;
    return signInWithIdp(auth, request);
  }
  buildRequest() {
    const request = {
      requestUri: IDP_REQUEST_URI$1,
      returnSecureToken: true
    };
    if (this.pendingToken) {
      request.pendingToken = this.pendingToken;
    } else {
      const postBody = {};
      if (this.idToken) {
        postBody["id_token"] = this.idToken;
      }
      if (this.accessToken) {
        postBody["access_token"] = this.accessToken;
      }
      if (this.secret) {
        postBody["oauth_token_secret"] = this.secret;
      }
      postBody["providerId"] = this.providerId;
      if (this.nonce && !this.pendingToken) {
        postBody["nonce"] = this.nonce;
      }
      request.postBody = querystring(postBody);
    }
    return request;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function parseMode(mode) {
  switch (mode) {
    case "recoverEmail":
      return "RECOVER_EMAIL";
    case "resetPassword":
      return "PASSWORD_RESET";
    case "signIn":
      return "EMAIL_SIGNIN";
    case "verifyEmail":
      return "VERIFY_EMAIL";
    case "verifyAndChangeEmail":
      return "VERIFY_AND_CHANGE_EMAIL";
    case "revertSecondFactorAddition":
      return "REVERT_SECOND_FACTOR_ADDITION";
    default:
      return null;
  }
}
function parseDeepLink(url) {
  const link = querystringDecode(extractQuerystring(url))["link"];
  const doubleDeepLink = link ? querystringDecode(extractQuerystring(link))["deep_link_id"] : null;
  const iOSDeepLink = querystringDecode(extractQuerystring(url))["deep_link_id"];
  const iOSDoubleDeepLink = iOSDeepLink ? querystringDecode(extractQuerystring(iOSDeepLink))["link"] : null;
  return iOSDoubleDeepLink || iOSDeepLink || doubleDeepLink || link || url;
}
class ActionCodeURL {
  constructor(actionLink) {
    var _a2, _b, _c2, _d, _e2, _f;
    const searchParams = querystringDecode(extractQuerystring(actionLink));
    const apiKey = (_a2 = searchParams["apiKey"]) !== null && _a2 !== void 0 ? _a2 : null;
    const code = (_b = searchParams["oobCode"]) !== null && _b !== void 0 ? _b : null;
    const operation = parseMode((_c2 = searchParams["mode"]) !== null && _c2 !== void 0 ? _c2 : null);
    _assert(apiKey && code && operation, "argument-error");
    this.apiKey = apiKey;
    this.operation = operation;
    this.code = code;
    this.continueUrl = (_d = searchParams["continueUrl"]) !== null && _d !== void 0 ? _d : null;
    this.languageCode = (_e2 = searchParams["languageCode"]) !== null && _e2 !== void 0 ? _e2 : null;
    this.tenantId = (_f = searchParams["tenantId"]) !== null && _f !== void 0 ? _f : null;
  }
  static parseLink(link) {
    const actionLink = parseDeepLink(link);
    try {
      return new ActionCodeURL(actionLink);
    } catch (_a2) {
      return null;
    }
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class EmailAuthProvider {
  constructor() {
    this.providerId = EmailAuthProvider.PROVIDER_ID;
  }
  static credential(email, password) {
    return EmailAuthCredential._fromEmailAndPassword(email, password);
  }
  static credentialWithLink(email, emailLink) {
    const actionCodeUrl = ActionCodeURL.parseLink(emailLink);
    _assert(actionCodeUrl, "argument-error");
    return EmailAuthCredential._fromEmailAndCode(email, actionCodeUrl.code, actionCodeUrl.tenantId);
  }
}
EmailAuthProvider.PROVIDER_ID = "password";
EmailAuthProvider.EMAIL_PASSWORD_SIGN_IN_METHOD = "password";
EmailAuthProvider.EMAIL_LINK_SIGN_IN_METHOD = "emailLink";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FederatedAuthProvider {
  constructor(providerId) {
    this.providerId = providerId;
    this.defaultLanguageCode = null;
    this.customParameters = {};
  }
  setDefaultLanguage(languageCode) {
    this.defaultLanguageCode = languageCode;
  }
  setCustomParameters(customOAuthParameters) {
    this.customParameters = customOAuthParameters;
    return this;
  }
  getCustomParameters() {
    return this.customParameters;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BaseOAuthProvider extends FederatedAuthProvider {
  constructor() {
    super(...arguments);
    this.scopes = [];
  }
  addScope(scope) {
    if (!this.scopes.includes(scope)) {
      this.scopes.push(scope);
    }
    return this;
  }
  getScopes() {
    return [...this.scopes];
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FacebookAuthProvider extends BaseOAuthProvider {
  constructor() {
    super("facebook.com");
  }
  static credential(accessToken) {
    return OAuthCredential._fromParams({
      providerId: FacebookAuthProvider.PROVIDER_ID,
      signInMethod: FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD,
      accessToken
    });
  }
  static credentialFromResult(userCredential) {
    return FacebookAuthProvider.credentialFromTaggedObject(userCredential);
  }
  static credentialFromError(error) {
    return FacebookAuthProvider.credentialFromTaggedObject(error.customData || {});
  }
  static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
    if (!tokenResponse || !("oauthAccessToken" in tokenResponse)) {
      return null;
    }
    if (!tokenResponse.oauthAccessToken) {
      return null;
    }
    try {
      return FacebookAuthProvider.credential(tokenResponse.oauthAccessToken);
    } catch (_a2) {
      return null;
    }
  }
}
FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD = "facebook.com";
FacebookAuthProvider.PROVIDER_ID = "facebook.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class GoogleAuthProvider extends BaseOAuthProvider {
  constructor() {
    super("google.com");
    this.addScope("profile");
  }
  static credential(idToken, accessToken) {
    return OAuthCredential._fromParams({
      providerId: GoogleAuthProvider.PROVIDER_ID,
      signInMethod: GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD,
      idToken,
      accessToken
    });
  }
  static credentialFromResult(userCredential) {
    return GoogleAuthProvider.credentialFromTaggedObject(userCredential);
  }
  static credentialFromError(error) {
    return GoogleAuthProvider.credentialFromTaggedObject(error.customData || {});
  }
  static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
    if (!tokenResponse) {
      return null;
    }
    const { oauthIdToken, oauthAccessToken } = tokenResponse;
    if (!oauthIdToken && !oauthAccessToken) {
      return null;
    }
    try {
      return GoogleAuthProvider.credential(oauthIdToken, oauthAccessToken);
    } catch (_a2) {
      return null;
    }
  }
}
GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD = "google.com";
GoogleAuthProvider.PROVIDER_ID = "google.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class GithubAuthProvider extends BaseOAuthProvider {
  constructor() {
    super("github.com");
  }
  static credential(accessToken) {
    return OAuthCredential._fromParams({
      providerId: GithubAuthProvider.PROVIDER_ID,
      signInMethod: GithubAuthProvider.GITHUB_SIGN_IN_METHOD,
      accessToken
    });
  }
  static credentialFromResult(userCredential) {
    return GithubAuthProvider.credentialFromTaggedObject(userCredential);
  }
  static credentialFromError(error) {
    return GithubAuthProvider.credentialFromTaggedObject(error.customData || {});
  }
  static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
    if (!tokenResponse || !("oauthAccessToken" in tokenResponse)) {
      return null;
    }
    if (!tokenResponse.oauthAccessToken) {
      return null;
    }
    try {
      return GithubAuthProvider.credential(tokenResponse.oauthAccessToken);
    } catch (_a2) {
      return null;
    }
  }
}
GithubAuthProvider.GITHUB_SIGN_IN_METHOD = "github.com";
GithubAuthProvider.PROVIDER_ID = "github.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TwitterAuthProvider extends BaseOAuthProvider {
  constructor() {
    super("twitter.com");
  }
  static credential(token, secret) {
    return OAuthCredential._fromParams({
      providerId: TwitterAuthProvider.PROVIDER_ID,
      signInMethod: TwitterAuthProvider.TWITTER_SIGN_IN_METHOD,
      oauthToken: token,
      oauthTokenSecret: secret
    });
  }
  static credentialFromResult(userCredential) {
    return TwitterAuthProvider.credentialFromTaggedObject(userCredential);
  }
  static credentialFromError(error) {
    return TwitterAuthProvider.credentialFromTaggedObject(error.customData || {});
  }
  static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
    if (!tokenResponse) {
      return null;
    }
    const { oauthAccessToken, oauthTokenSecret } = tokenResponse;
    if (!oauthAccessToken || !oauthTokenSecret) {
      return null;
    }
    try {
      return TwitterAuthProvider.credential(oauthAccessToken, oauthTokenSecret);
    } catch (_a2) {
      return null;
    }
  }
}
TwitterAuthProvider.TWITTER_SIGN_IN_METHOD = "twitter.com";
TwitterAuthProvider.PROVIDER_ID = "twitter.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UserCredentialImpl {
  constructor(params) {
    this.user = params.user;
    this.providerId = params.providerId;
    this._tokenResponse = params._tokenResponse;
    this.operationType = params.operationType;
  }
  static async _fromIdTokenResponse(auth, operationType, idTokenResponse, isAnonymous = false) {
    const user = await UserImpl._fromIdTokenResponse(auth, idTokenResponse, isAnonymous);
    const providerId = providerIdForResponse(idTokenResponse);
    const userCred = new UserCredentialImpl({
      user,
      providerId,
      _tokenResponse: idTokenResponse,
      operationType
    });
    return userCred;
  }
  static async _forOperation(user, operationType, response) {
    await user._updateTokensIfNecessary(response, true);
    const providerId = providerIdForResponse(response);
    return new UserCredentialImpl({
      user,
      providerId,
      _tokenResponse: response,
      operationType
    });
  }
}
function providerIdForResponse(response) {
  if (response.providerId) {
    return response.providerId;
  }
  if ("phoneNumber" in response) {
    return "phone";
  }
  return null;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MultiFactorError extends FirebaseError {
  constructor(auth, error, operationType, user) {
    var _a2;
    super(error.code, error.message);
    this.operationType = operationType;
    this.user = user;
    Object.setPrototypeOf(this, MultiFactorError.prototype);
    this.customData = {
      appName: auth.name,
      tenantId: (_a2 = auth.tenantId) !== null && _a2 !== void 0 ? _a2 : void 0,
      _serverResponse: error.customData._serverResponse,
      operationType
    };
  }
  static _fromErrorAndOperation(auth, error, operationType, user) {
    return new MultiFactorError(auth, error, operationType, user);
  }
}
function _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential, user) {
  const idTokenProvider = operationType === "reauthenticate" ? credential._getReauthenticationResolver(auth) : credential._getIdTokenResponse(auth);
  return idTokenProvider.catch((error) => {
    if (error.code === `auth/${"multi-factor-auth-required"}`) {
      throw MultiFactorError._fromErrorAndOperation(auth, error, operationType, user);
    }
    throw error;
  });
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function providerDataAsNames(providerData) {
  return new Set(providerData.map(({ providerId }) => providerId).filter((pid) => !!pid));
}
async function _link$1(user, credential, bypassAuthState = false) {
  const response = await _logoutIfInvalidated(user, credential._linkToIdToken(user.auth, await user.getIdToken()), bypassAuthState);
  return UserCredentialImpl._forOperation(user, "link", response);
}
async function _assertLinkedStatus(expected, user, provider) {
  await _reloadWithoutSaving(user);
  const providerIds = providerDataAsNames(user.providerData);
  const code = expected === false ? "provider-already-linked" : "no-such-provider";
  _assert(providerIds.has(provider) === expected, user.auth, code);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function _reauthenticate(user, credential, bypassAuthState = false) {
  var _a2;
  const { auth } = user;
  const operationType = "reauthenticate";
  try {
    const response = await _logoutIfInvalidated(user, _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential, user), bypassAuthState);
    _assert(response.idToken, auth, "internal-error");
    const parsed = _parseToken(response.idToken);
    _assert(parsed, auth, "internal-error");
    const { sub: localId } = parsed;
    _assert(user.uid === localId, auth, "user-mismatch");
    return UserCredentialImpl._forOperation(user, operationType, response);
  } catch (e2) {
    if (((_a2 = e2) === null || _a2 === void 0 ? void 0 : _a2.code) === `auth/${"user-not-found"}`) {
      _fail(auth, "user-mismatch");
    }
    throw e2;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function _signInWithCredential(auth, credential, bypassAuthState = false) {
  const operationType = "signIn";
  const response = await _processCredentialSavingMfaContextIfNecessary(auth, operationType, credential);
  const userCredential = await UserCredentialImpl._fromIdTokenResponse(auth, operationType, response);
  if (!bypassAuthState) {
    await auth._updateCurrentUser(userCredential.user);
  }
  return userCredential;
}
async function signInWithCredential(auth, credential) {
  return _signInWithCredential(_castAuth(auth), credential);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _setActionCodeSettingsOnRequest(auth, request, actionCodeSettings) {
  var _a2;
  _assert(((_a2 = actionCodeSettings.url) === null || _a2 === void 0 ? void 0 : _a2.length) > 0, auth, "invalid-continue-uri");
  _assert(typeof actionCodeSettings.dynamicLinkDomain === "undefined" || actionCodeSettings.dynamicLinkDomain.length > 0, auth, "invalid-dynamic-link-domain");
  request.continueUrl = actionCodeSettings.url;
  request.dynamicLinkDomain = actionCodeSettings.dynamicLinkDomain;
  request.canHandleCodeInApp = actionCodeSettings.handleCodeInApp;
  if (actionCodeSettings.iOS) {
    _assert(actionCodeSettings.iOS.bundleId.length > 0, auth, "missing-ios-bundle-id");
    request.iOSBundleId = actionCodeSettings.iOS.bundleId;
  }
  if (actionCodeSettings.android) {
    _assert(actionCodeSettings.android.packageName.length > 0, auth, "missing-android-pkg-name");
    request.androidInstallApp = actionCodeSettings.android.installApp;
    request.androidMinimumVersionCode = actionCodeSettings.android.minimumVersion;
    request.androidPackageName = actionCodeSettings.android.packageName;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function sendSignInLinkToEmail(auth, email, actionCodeSettings) {
  const authModular = getModularInstance(auth);
  const request = {
    requestType: "EMAIL_SIGNIN",
    email
  };
  _assert(actionCodeSettings.handleCodeInApp, authModular, "argument-error");
  if (actionCodeSettings) {
    _setActionCodeSettingsOnRequest(authModular, request, actionCodeSettings);
  }
  await sendSignInLinkToEmail$1(authModular, request);
}
function isSignInWithEmailLink(auth, emailLink) {
  const actionCodeUrl = ActionCodeURL.parseLink(emailLink);
  return (actionCodeUrl === null || actionCodeUrl === void 0 ? void 0 : actionCodeUrl.operation) === "EMAIL_SIGNIN";
}
async function signInWithEmailLink(auth, email, emailLink) {
  const authModular = getModularInstance(auth);
  const credential = EmailAuthProvider.credentialWithLink(email, emailLink || _getCurrentUrl());
  _assert(credential._tenantId === (authModular.tenantId || null), authModular, "tenant-id-mismatch");
  return signInWithCredential(authModular, credential);
}
const STORAGE_AVAILABLE_KEY = "__sak";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BrowserPersistenceClass {
  constructor(storageRetriever, type2) {
    this.storageRetriever = storageRetriever;
    this.type = type2;
  }
  _isAvailable() {
    try {
      if (!this.storage) {
        return Promise.resolve(false);
      }
      this.storage.setItem(STORAGE_AVAILABLE_KEY, "1");
      this.storage.removeItem(STORAGE_AVAILABLE_KEY);
      return Promise.resolve(true);
    } catch (_a2) {
      return Promise.resolve(false);
    }
  }
  _set(key, value) {
    this.storage.setItem(key, JSON.stringify(value));
    return Promise.resolve();
  }
  _get(key) {
    const json = this.storage.getItem(key);
    return Promise.resolve(json ? JSON.parse(json) : null);
  }
  _remove(key) {
    this.storage.removeItem(key);
    return Promise.resolve();
  }
  get storage() {
    return this.storageRetriever();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _iframeCannotSyncWebStorage() {
  const ua2 = getUA();
  return _isSafari(ua2) || _isIOS(ua2);
}
const _POLLING_INTERVAL_MS$1 = 1e3;
const IE10_LOCAL_STORAGE_SYNC_DELAY = 10;
class BrowserLocalPersistence extends BrowserPersistenceClass {
  constructor() {
    super(() => window.localStorage, "LOCAL");
    this.boundEventHandler = (event, poll) => this.onStorageEvent(event, poll);
    this.listeners = {};
    this.localCache = {};
    this.pollTimer = null;
    this.safariLocalStorageNotSynced = _iframeCannotSyncWebStorage() && _isIframe();
    this.fallbackToPolling = _isMobileBrowser();
    this._shouldAllowMigration = true;
  }
  forAllChangedKeys(cb2) {
    for (const key of Object.keys(this.listeners)) {
      const newValue = this.storage.getItem(key);
      const oldValue = this.localCache[key];
      if (newValue !== oldValue) {
        cb2(key, oldValue, newValue);
      }
    }
  }
  onStorageEvent(event, poll = false) {
    if (!event.key) {
      this.forAllChangedKeys((key2, _oldValue, newValue) => {
        this.notifyListeners(key2, newValue);
      });
      return;
    }
    const key = event.key;
    if (poll) {
      this.detachListener();
    } else {
      this.stopPolling();
    }
    if (this.safariLocalStorageNotSynced) {
      const storedValue2 = this.storage.getItem(key);
      if (event.newValue !== storedValue2) {
        if (event.newValue !== null) {
          this.storage.setItem(key, event.newValue);
        } else {
          this.storage.removeItem(key);
        }
      } else if (this.localCache[key] === event.newValue && !poll) {
        return;
      }
    }
    const triggerListeners = () => {
      const storedValue2 = this.storage.getItem(key);
      if (!poll && this.localCache[key] === storedValue2) {
        return;
      }
      this.notifyListeners(key, storedValue2);
    };
    const storedValue = this.storage.getItem(key);
    if (_isIE10() && storedValue !== event.newValue && event.newValue !== event.oldValue) {
      setTimeout(triggerListeners, IE10_LOCAL_STORAGE_SYNC_DELAY);
    } else {
      triggerListeners();
    }
  }
  notifyListeners(key, value) {
    this.localCache[key] = value;
    const listeners = this.listeners[key];
    if (listeners) {
      for (const listener of Array.from(listeners)) {
        listener(value ? JSON.parse(value) : value);
      }
    }
  }
  startPolling() {
    this.stopPolling();
    this.pollTimer = setInterval(() => {
      this.forAllChangedKeys((key, oldValue, newValue) => {
        this.onStorageEvent(
          new StorageEvent("storage", {
            key,
            oldValue,
            newValue
          }),
          true
        );
      });
    }, _POLLING_INTERVAL_MS$1);
  }
  stopPolling() {
    if (this.pollTimer) {
      clearInterval(this.pollTimer);
      this.pollTimer = null;
    }
  }
  attachListener() {
    window.addEventListener("storage", this.boundEventHandler);
  }
  detachListener() {
    window.removeEventListener("storage", this.boundEventHandler);
  }
  _addListener(key, listener) {
    if (Object.keys(this.listeners).length === 0) {
      if (this.fallbackToPolling) {
        this.startPolling();
      } else {
        this.attachListener();
      }
    }
    if (!this.listeners[key]) {
      this.listeners[key] = /* @__PURE__ */ new Set();
      this.localCache[key] = this.storage.getItem(key);
    }
    this.listeners[key].add(listener);
  }
  _removeListener(key, listener) {
    if (this.listeners[key]) {
      this.listeners[key].delete(listener);
      if (this.listeners[key].size === 0) {
        delete this.listeners[key];
      }
    }
    if (Object.keys(this.listeners).length === 0) {
      this.detachListener();
      this.stopPolling();
    }
  }
  async _set(key, value) {
    await super._set(key, value);
    this.localCache[key] = JSON.stringify(value);
  }
  async _get(key) {
    const value = await super._get(key);
    this.localCache[key] = JSON.stringify(value);
    return value;
  }
  async _remove(key) {
    await super._remove(key);
    delete this.localCache[key];
  }
}
BrowserLocalPersistence.type = "LOCAL";
const browserLocalPersistence = BrowserLocalPersistence;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BrowserSessionPersistence extends BrowserPersistenceClass {
  constructor() {
    super(() => window.sessionStorage, "SESSION");
  }
  _addListener(_key, _listener) {
    return;
  }
  _removeListener(_key, _listener) {
    return;
  }
}
BrowserSessionPersistence.type = "SESSION";
const browserSessionPersistence = BrowserSessionPersistence;
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _allSettled(promises) {
  return Promise.all(promises.map(async (promise) => {
    try {
      const value = await promise;
      return {
        fulfilled: true,
        value
      };
    } catch (reason) {
      return {
        fulfilled: false,
        reason
      };
    }
  }));
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Receiver {
  constructor(eventTarget) {
    this.eventTarget = eventTarget;
    this.handlersMap = {};
    this.boundEventHandler = this.handleEvent.bind(this);
  }
  static _getInstance(eventTarget) {
    const existingInstance = this.receivers.find((receiver) => receiver.isListeningto(eventTarget));
    if (existingInstance) {
      return existingInstance;
    }
    const newInstance = new Receiver(eventTarget);
    this.receivers.push(newInstance);
    return newInstance;
  }
  isListeningto(eventTarget) {
    return this.eventTarget === eventTarget;
  }
  async handleEvent(event) {
    const messageEvent = event;
    const { eventId, eventType, data } = messageEvent.data;
    const handlers2 = this.handlersMap[eventType];
    if (!(handlers2 === null || handlers2 === void 0 ? void 0 : handlers2.size)) {
      return;
    }
    messageEvent.ports[0].postMessage({
      status: "ack",
      eventId,
      eventType
    });
    const promises = Array.from(handlers2).map(async (handler) => handler(messageEvent.origin, data));
    const response = await _allSettled(promises);
    messageEvent.ports[0].postMessage({
      status: "done",
      eventId,
      eventType,
      response
    });
  }
  _subscribe(eventType, eventHandler) {
    if (Object.keys(this.handlersMap).length === 0) {
      this.eventTarget.addEventListener("message", this.boundEventHandler);
    }
    if (!this.handlersMap[eventType]) {
      this.handlersMap[eventType] = /* @__PURE__ */ new Set();
    }
    this.handlersMap[eventType].add(eventHandler);
  }
  _unsubscribe(eventType, eventHandler) {
    if (this.handlersMap[eventType] && eventHandler) {
      this.handlersMap[eventType].delete(eventHandler);
    }
    if (!eventHandler || this.handlersMap[eventType].size === 0) {
      delete this.handlersMap[eventType];
    }
    if (Object.keys(this.handlersMap).length === 0) {
      this.eventTarget.removeEventListener("message", this.boundEventHandler);
    }
  }
}
Receiver.receivers = [];
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _generateEventId(prefix = "", digits = 10) {
  let random2 = "";
  for (let i2 = 0; i2 < digits; i2++) {
    random2 += Math.floor(Math.random() * 10);
  }
  return prefix + random2;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Sender {
  constructor(target) {
    this.target = target;
    this.handlers = /* @__PURE__ */ new Set();
  }
  removeMessageHandler(handler) {
    if (handler.messageChannel) {
      handler.messageChannel.port1.removeEventListener("message", handler.onMessage);
      handler.messageChannel.port1.close();
    }
    this.handlers.delete(handler);
  }
  async _send(eventType, data, timeout = 50) {
    const messageChannel = typeof MessageChannel !== "undefined" ? new MessageChannel() : null;
    if (!messageChannel) {
      throw new Error("connection_unavailable");
    }
    let completionTimer;
    let handler;
    return new Promise((resolve2, reject) => {
      const eventId = _generateEventId("", 20);
      messageChannel.port1.start();
      const ackTimer = setTimeout(() => {
        reject(new Error("unsupported_event"));
      }, timeout);
      handler = {
        messageChannel,
        onMessage(event) {
          const messageEvent = event;
          if (messageEvent.data.eventId !== eventId) {
            return;
          }
          switch (messageEvent.data.status) {
            case "ack":
              clearTimeout(ackTimer);
              completionTimer = setTimeout(() => {
                reject(new Error("timeout"));
              }, 3e3);
              break;
            case "done":
              clearTimeout(completionTimer);
              resolve2(messageEvent.data.response);
              break;
            default:
              clearTimeout(ackTimer);
              clearTimeout(completionTimer);
              reject(new Error("invalid_response"));
              break;
          }
        }
      };
      this.handlers.add(handler);
      messageChannel.port1.addEventListener("message", handler.onMessage);
      this.target.postMessage({
        eventType,
        eventId,
        data
      }, [messageChannel.port2]);
    }).finally(() => {
      if (handler) {
        this.removeMessageHandler(handler);
      }
    });
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _window() {
  return window;
}
function _setWindowLocation(url) {
  _window().location.href = url;
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _isWorker() {
  return typeof _window()["WorkerGlobalScope"] !== "undefined" && typeof _window()["importScripts"] === "function";
}
async function _getActiveServiceWorker() {
  if (!(navigator === null || navigator === void 0 ? void 0 : navigator.serviceWorker)) {
    return null;
  }
  try {
    const registration = await navigator.serviceWorker.ready;
    return registration.active;
  } catch (_a2) {
    return null;
  }
}
function _getServiceWorkerController() {
  var _a2;
  return ((_a2 = navigator === null || navigator === void 0 ? void 0 : navigator.serviceWorker) === null || _a2 === void 0 ? void 0 : _a2.controller) || null;
}
function _getWorkerGlobalScope() {
  return _isWorker() ? self : null;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DB_NAME = "firebaseLocalStorageDb";
const DB_VERSION = 1;
const DB_OBJECTSTORE_NAME = "firebaseLocalStorage";
const DB_DATA_KEYPATH = "fbase_key";
class DBPromise {
  constructor(request) {
    this.request = request;
  }
  toPromise() {
    return new Promise((resolve2, reject) => {
      this.request.addEventListener("success", () => {
        resolve2(this.request.result);
      });
      this.request.addEventListener("error", () => {
        reject(this.request.error);
      });
    });
  }
}
function getObjectStore(db2, isReadWrite) {
  return db2.transaction([DB_OBJECTSTORE_NAME], isReadWrite ? "readwrite" : "readonly").objectStore(DB_OBJECTSTORE_NAME);
}
function _deleteDatabase() {
  const request = indexedDB.deleteDatabase(DB_NAME);
  return new DBPromise(request).toPromise();
}
function _openDatabase() {
  const request = indexedDB.open(DB_NAME, DB_VERSION);
  return new Promise((resolve2, reject) => {
    request.addEventListener("error", () => {
      reject(request.error);
    });
    request.addEventListener("upgradeneeded", () => {
      const db2 = request.result;
      try {
        db2.createObjectStore(DB_OBJECTSTORE_NAME, { keyPath: DB_DATA_KEYPATH });
      } catch (e2) {
        reject(e2);
      }
    });
    request.addEventListener("success", async () => {
      const db2 = request.result;
      if (!db2.objectStoreNames.contains(DB_OBJECTSTORE_NAME)) {
        db2.close();
        await _deleteDatabase();
        resolve2(await _openDatabase());
      } else {
        resolve2(db2);
      }
    });
  });
}
async function _putObject(db2, key, value) {
  const request = getObjectStore(db2, true).put({
    [DB_DATA_KEYPATH]: key,
    value
  });
  return new DBPromise(request).toPromise();
}
async function getObject(db2, key) {
  const request = getObjectStore(db2, false).get(key);
  const data = await new DBPromise(request).toPromise();
  return data === void 0 ? null : data.value;
}
function _deleteObject(db2, key) {
  const request = getObjectStore(db2, true).delete(key);
  return new DBPromise(request).toPromise();
}
const _POLLING_INTERVAL_MS = 800;
const _TRANSACTION_RETRY_COUNT = 3;
class IndexedDBLocalPersistence {
  constructor() {
    this.type = "LOCAL";
    this._shouldAllowMigration = true;
    this.listeners = {};
    this.localCache = {};
    this.pollTimer = null;
    this.pendingWrites = 0;
    this.receiver = null;
    this.sender = null;
    this.serviceWorkerReceiverAvailable = false;
    this.activeServiceWorker = null;
    this._workerInitializationPromise = this.initializeServiceWorkerMessaging().then(() => {
    }, () => {
    });
  }
  async _openDb() {
    if (this.db) {
      return this.db;
    }
    this.db = await _openDatabase();
    return this.db;
  }
  async _withRetries(op) {
    let numAttempts = 0;
    while (true) {
      try {
        const db2 = await this._openDb();
        return await op(db2);
      } catch (e2) {
        if (numAttempts++ > _TRANSACTION_RETRY_COUNT) {
          throw e2;
        }
        if (this.db) {
          this.db.close();
          this.db = void 0;
        }
      }
    }
  }
  async initializeServiceWorkerMessaging() {
    return _isWorker() ? this.initializeReceiver() : this.initializeSender();
  }
  async initializeReceiver() {
    this.receiver = Receiver._getInstance(_getWorkerGlobalScope());
    this.receiver._subscribe("keyChanged", async (_origin, data) => {
      const keys2 = await this._poll();
      return {
        keyProcessed: keys2.includes(data.key)
      };
    });
    this.receiver._subscribe("ping", async (_origin, _data) => {
      return ["keyChanged"];
    });
  }
  async initializeSender() {
    var _a2, _b;
    this.activeServiceWorker = await _getActiveServiceWorker();
    if (!this.activeServiceWorker) {
      return;
    }
    this.sender = new Sender(this.activeServiceWorker);
    const results = await this.sender._send("ping", {}, 800);
    if (!results) {
      return;
    }
    if (((_a2 = results[0]) === null || _a2 === void 0 ? void 0 : _a2.fulfilled) && ((_b = results[0]) === null || _b === void 0 ? void 0 : _b.value.includes("keyChanged"))) {
      this.serviceWorkerReceiverAvailable = true;
    }
  }
  async notifyServiceWorker(key) {
    if (!this.sender || !this.activeServiceWorker || _getServiceWorkerController() !== this.activeServiceWorker) {
      return;
    }
    try {
      await this.sender._send(
        "keyChanged",
        { key },
        this.serviceWorkerReceiverAvailable ? 800 : 50
      );
    } catch (_a2) {
    }
  }
  async _isAvailable() {
    try {
      if (!indexedDB) {
        return false;
      }
      const db2 = await _openDatabase();
      await _putObject(db2, STORAGE_AVAILABLE_KEY, "1");
      await _deleteObject(db2, STORAGE_AVAILABLE_KEY);
      return true;
    } catch (_a2) {
    }
    return false;
  }
  async _withPendingWrite(write) {
    this.pendingWrites++;
    try {
      await write();
    } finally {
      this.pendingWrites--;
    }
  }
  async _set(key, value) {
    return this._withPendingWrite(async () => {
      await this._withRetries((db2) => _putObject(db2, key, value));
      this.localCache[key] = value;
      return this.notifyServiceWorker(key);
    });
  }
  async _get(key) {
    const obj = await this._withRetries((db2) => getObject(db2, key));
    this.localCache[key] = obj;
    return obj;
  }
  async _remove(key) {
    return this._withPendingWrite(async () => {
      await this._withRetries((db2) => _deleteObject(db2, key));
      delete this.localCache[key];
      return this.notifyServiceWorker(key);
    });
  }
  async _poll() {
    const result = await this._withRetries((db2) => {
      const getAllRequest = getObjectStore(db2, false).getAll();
      return new DBPromise(getAllRequest).toPromise();
    });
    if (!result) {
      return [];
    }
    if (this.pendingWrites !== 0) {
      return [];
    }
    const keys2 = [];
    const keysInResult = /* @__PURE__ */ new Set();
    for (const { fbase_key: key, value } of result) {
      keysInResult.add(key);
      if (JSON.stringify(this.localCache[key]) !== JSON.stringify(value)) {
        this.notifyListeners(key, value);
        keys2.push(key);
      }
    }
    for (const localKey of Object.keys(this.localCache)) {
      if (this.localCache[localKey] && !keysInResult.has(localKey)) {
        this.notifyListeners(localKey, null);
        keys2.push(localKey);
      }
    }
    return keys2;
  }
  notifyListeners(key, newValue) {
    this.localCache[key] = newValue;
    const listeners = this.listeners[key];
    if (listeners) {
      for (const listener of Array.from(listeners)) {
        listener(newValue);
      }
    }
  }
  startPolling() {
    this.stopPolling();
    this.pollTimer = setInterval(async () => this._poll(), _POLLING_INTERVAL_MS);
  }
  stopPolling() {
    if (this.pollTimer) {
      clearInterval(this.pollTimer);
      this.pollTimer = null;
    }
  }
  _addListener(key, listener) {
    if (Object.keys(this.listeners).length === 0) {
      this.startPolling();
    }
    if (!this.listeners[key]) {
      this.listeners[key] = /* @__PURE__ */ new Set();
      void this._get(key);
    }
    this.listeners[key].add(listener);
  }
  _removeListener(key, listener) {
    if (this.listeners[key]) {
      this.listeners[key].delete(listener);
      if (this.listeners[key].size === 0) {
        delete this.listeners[key];
      }
    }
    if (Object.keys(this.listeners).length === 0) {
      this.stopPolling();
    }
  }
}
IndexedDBLocalPersistence.type = "LOCAL";
const indexedDBLocalPersistence = IndexedDBLocalPersistence;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getScriptParentElement() {
  var _a2, _b;
  return (_b = (_a2 = document.getElementsByTagName("head")) === null || _a2 === void 0 ? void 0 : _a2[0]) !== null && _b !== void 0 ? _b : document;
}
function _loadJS(url) {
  return new Promise((resolve2, reject) => {
    const el = document.createElement("script");
    el.setAttribute("src", url);
    el.onload = resolve2;
    el.onerror = (e2) => {
      const error = _createError("internal-error");
      error.customData = e2;
      reject(error);
    };
    el.type = "text/javascript";
    el.charset = "UTF-8";
    getScriptParentElement().appendChild(el);
  });
}
function _generateCallbackName(prefix) {
  return `__${prefix}${Math.floor(Math.random() * 1e6)}`;
}
new Delay(3e4, 6e4);
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _withDefaultResolver(auth, resolverOverride) {
  if (resolverOverride) {
    return _getInstance(resolverOverride);
  }
  _assert(auth._popupRedirectResolver, auth, "argument-error");
  return auth._popupRedirectResolver;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class IdpCredential extends AuthCredential {
  constructor(params) {
    super("custom", "custom");
    this.params = params;
  }
  _getIdTokenResponse(auth) {
    return signInWithIdp(auth, this._buildIdpRequest());
  }
  _linkToIdToken(auth, idToken) {
    return signInWithIdp(auth, this._buildIdpRequest(idToken));
  }
  _getReauthenticationResolver(auth) {
    return signInWithIdp(auth, this._buildIdpRequest());
  }
  _buildIdpRequest(idToken) {
    const request = {
      requestUri: this.params.requestUri,
      sessionId: this.params.sessionId,
      postBody: this.params.postBody,
      tenantId: this.params.tenantId,
      pendingToken: this.params.pendingToken,
      returnSecureToken: true,
      returnIdpCredential: true
    };
    if (idToken) {
      request.idToken = idToken;
    }
    return request;
  }
}
function _signIn(params) {
  return _signInWithCredential(params.auth, new IdpCredential(params), params.bypassAuthState);
}
function _reauth(params) {
  const { auth, user } = params;
  _assert(user, auth, "internal-error");
  return _reauthenticate(user, new IdpCredential(params), params.bypassAuthState);
}
async function _link(params) {
  const { auth, user } = params;
  _assert(user, auth, "internal-error");
  return _link$1(user, new IdpCredential(params), params.bypassAuthState);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AbstractPopupRedirectOperation {
  constructor(auth, filter, resolver, user, bypassAuthState = false) {
    this.auth = auth;
    this.resolver = resolver;
    this.user = user;
    this.bypassAuthState = bypassAuthState;
    this.pendingPromise = null;
    this.eventManager = null;
    this.filter = Array.isArray(filter) ? filter : [filter];
  }
  execute() {
    return new Promise(async (resolve2, reject) => {
      this.pendingPromise = { resolve: resolve2, reject };
      try {
        this.eventManager = await this.resolver._initialize(this.auth);
        await this.onExecution();
        this.eventManager.registerConsumer(this);
      } catch (e2) {
        this.reject(e2);
      }
    });
  }
  async onAuthEvent(event) {
    const { urlResponse, sessionId, postBody, tenantId, error, type: type2 } = event;
    if (error) {
      this.reject(error);
      return;
    }
    const params = {
      auth: this.auth,
      requestUri: urlResponse,
      sessionId,
      tenantId: tenantId || void 0,
      postBody: postBody || void 0,
      user: this.user,
      bypassAuthState: this.bypassAuthState
    };
    try {
      this.resolve(await this.getIdpTask(type2)(params));
    } catch (e2) {
      this.reject(e2);
    }
  }
  onError(error) {
    this.reject(error);
  }
  getIdpTask(type2) {
    switch (type2) {
      case "signInViaPopup":
      case "signInViaRedirect":
        return _signIn;
      case "linkViaPopup":
      case "linkViaRedirect":
        return _link;
      case "reauthViaPopup":
      case "reauthViaRedirect":
        return _reauth;
      default:
        _fail(this.auth, "internal-error");
    }
  }
  resolve(cred) {
    debugAssert(this.pendingPromise, "Pending promise was never set");
    this.pendingPromise.resolve(cred);
    this.unregisterAndCleanUp();
  }
  reject(error) {
    debugAssert(this.pendingPromise, "Pending promise was never set");
    this.pendingPromise.reject(error);
    this.unregisterAndCleanUp();
  }
  unregisterAndCleanUp() {
    if (this.eventManager) {
      this.eventManager.unregisterConsumer(this);
    }
    this.pendingPromise = null;
    this.cleanUp();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _POLL_WINDOW_CLOSE_TIMEOUT = new Delay(2e3, 1e4);
class PopupOperation extends AbstractPopupRedirectOperation {
  constructor(auth, filter, provider, resolver, user) {
    super(auth, filter, resolver, user);
    this.provider = provider;
    this.authWindow = null;
    this.pollId = null;
    if (PopupOperation.currentPopupAction) {
      PopupOperation.currentPopupAction.cancel();
    }
    PopupOperation.currentPopupAction = this;
  }
  async executeNotNull() {
    const result = await this.execute();
    _assert(result, this.auth, "internal-error");
    return result;
  }
  async onExecution() {
    debugAssert(this.filter.length === 1, "Popup operations only handle one event");
    const eventId = _generateEventId();
    this.authWindow = await this.resolver._openPopup(
      this.auth,
      this.provider,
      this.filter[0],
      eventId
    );
    this.authWindow.associatedEvent = eventId;
    this.resolver._originValidation(this.auth).catch((e2) => {
      this.reject(e2);
    });
    this.resolver._isIframeWebStorageSupported(this.auth, (isSupported) => {
      if (!isSupported) {
        this.reject(_createError(this.auth, "web-storage-unsupported"));
      }
    });
    this.pollUserCancellation();
  }
  get eventId() {
    var _a2;
    return ((_a2 = this.authWindow) === null || _a2 === void 0 ? void 0 : _a2.associatedEvent) || null;
  }
  cancel() {
    this.reject(_createError(this.auth, "cancelled-popup-request"));
  }
  cleanUp() {
    if (this.authWindow) {
      this.authWindow.close();
    }
    if (this.pollId) {
      window.clearTimeout(this.pollId);
    }
    this.authWindow = null;
    this.pollId = null;
    PopupOperation.currentPopupAction = null;
  }
  pollUserCancellation() {
    const poll = () => {
      var _a2, _b;
      if ((_b = (_a2 = this.authWindow) === null || _a2 === void 0 ? void 0 : _a2.window) === null || _b === void 0 ? void 0 : _b.closed) {
        this.pollId = window.setTimeout(() => {
          this.pollId = null;
          this.reject(_createError(this.auth, "popup-closed-by-user"));
        }, 2e3);
        return;
      }
      this.pollId = window.setTimeout(poll, _POLL_WINDOW_CLOSE_TIMEOUT.get());
    };
    poll();
  }
}
PopupOperation.currentPopupAction = null;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const PENDING_REDIRECT_KEY = "pendingRedirect";
const redirectOutcomeMap = /* @__PURE__ */ new Map();
class RedirectAction extends AbstractPopupRedirectOperation {
  constructor(auth, resolver, bypassAuthState = false) {
    super(auth, [
      "signInViaRedirect",
      "linkViaRedirect",
      "reauthViaRedirect",
      "unknown"
    ], resolver, void 0, bypassAuthState);
    this.eventId = null;
  }
  async execute() {
    let readyOutcome = redirectOutcomeMap.get(this.auth._key());
    if (!readyOutcome) {
      try {
        const hasPendingRedirect = await _getAndClearPendingRedirectStatus(this.resolver, this.auth);
        const result = hasPendingRedirect ? await super.execute() : null;
        readyOutcome = () => Promise.resolve(result);
      } catch (e2) {
        readyOutcome = () => Promise.reject(e2);
      }
      redirectOutcomeMap.set(this.auth._key(), readyOutcome);
    }
    if (!this.bypassAuthState) {
      redirectOutcomeMap.set(this.auth._key(), () => Promise.resolve(null));
    }
    return readyOutcome();
  }
  async onAuthEvent(event) {
    if (event.type === "signInViaRedirect") {
      return super.onAuthEvent(event);
    } else if (event.type === "unknown") {
      this.resolve(null);
      return;
    }
    if (event.eventId) {
      const user = await this.auth._redirectUserForId(event.eventId);
      if (user) {
        this.user = user;
        return super.onAuthEvent(event);
      } else {
        this.resolve(null);
      }
    }
  }
  async onExecution() {
  }
  cleanUp() {
  }
}
async function _getAndClearPendingRedirectStatus(resolver, auth) {
  const key = pendingRedirectKey(auth);
  const persistence = resolverPersistence(resolver);
  if (!await persistence._isAvailable()) {
    return false;
  }
  const hasPendingRedirect = await persistence._get(key) === "true";
  await persistence._remove(key);
  return hasPendingRedirect;
}
async function _setPendingRedirectStatus(resolver, auth) {
  return resolverPersistence(resolver)._set(pendingRedirectKey(auth), "true");
}
function _overrideRedirectResult(auth, result) {
  redirectOutcomeMap.set(auth._key(), result);
}
function resolverPersistence(resolver) {
  return _getInstance(resolver._redirectPersistence);
}
function pendingRedirectKey(auth) {
  return _persistenceKeyName(PENDING_REDIRECT_KEY, auth.config.apiKey, auth.name);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function signInWithRedirect(auth, provider, resolver) {
  return _signInWithRedirect(auth, provider, resolver);
}
async function _signInWithRedirect(auth, provider, resolver) {
  const authInternal = _castAuth(auth);
  _assertInstanceOf(auth, provider, FederatedAuthProvider);
  const resolverInternal = _withDefaultResolver(authInternal, resolver);
  await _setPendingRedirectStatus(resolverInternal, authInternal);
  return resolverInternal._openRedirect(authInternal, provider, "signInViaRedirect");
}
function linkWithRedirect(user, provider, resolver) {
  return _linkWithRedirect(user, provider, resolver);
}
async function _linkWithRedirect(user, provider, resolver) {
  const userInternal = getModularInstance(user);
  _assertInstanceOf(userInternal.auth, provider, FederatedAuthProvider);
  const resolverInternal = _withDefaultResolver(userInternal.auth, resolver);
  await _assertLinkedStatus(false, userInternal, provider.providerId);
  await _setPendingRedirectStatus(resolverInternal, userInternal.auth);
  const eventId = await prepareUserForRedirect(userInternal);
  return resolverInternal._openRedirect(userInternal.auth, provider, "linkViaRedirect", eventId);
}
async function getRedirectResult(auth, resolver) {
  await _castAuth(auth)._initializationPromise;
  return _getRedirectResult(auth, resolver, false);
}
async function _getRedirectResult(auth, resolverExtern, bypassAuthState = false) {
  const authInternal = _castAuth(auth);
  const resolver = _withDefaultResolver(authInternal, resolverExtern);
  const action = new RedirectAction(authInternal, resolver, bypassAuthState);
  const result = await action.execute();
  if (result && !bypassAuthState) {
    delete result.user._redirectEventId;
    await authInternal._persistUserIfCurrent(result.user);
    await authInternal._setRedirectUser(null, resolverExtern);
  }
  return result;
}
async function prepareUserForRedirect(user) {
  const eventId = _generateEventId(`${user.uid}:::`);
  user._redirectEventId = eventId;
  await user.auth._setRedirectUser(user);
  await user.auth._persistUserIfCurrent(user);
  return eventId;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const EVENT_DUPLICATION_CACHE_DURATION_MS = 10 * 60 * 1e3;
class AuthEventManager {
  constructor(auth) {
    this.auth = auth;
    this.cachedEventUids = /* @__PURE__ */ new Set();
    this.consumers = /* @__PURE__ */ new Set();
    this.queuedRedirectEvent = null;
    this.hasHandledPotentialRedirect = false;
    this.lastProcessedEventTime = Date.now();
  }
  registerConsumer(authEventConsumer) {
    this.consumers.add(authEventConsumer);
    if (this.queuedRedirectEvent && this.isEventForConsumer(this.queuedRedirectEvent, authEventConsumer)) {
      this.sendToConsumer(this.queuedRedirectEvent, authEventConsumer);
      this.saveEventToCache(this.queuedRedirectEvent);
      this.queuedRedirectEvent = null;
    }
  }
  unregisterConsumer(authEventConsumer) {
    this.consumers.delete(authEventConsumer);
  }
  onEvent(event) {
    if (this.hasEventBeenHandled(event)) {
      return false;
    }
    let handled = false;
    this.consumers.forEach((consumer) => {
      if (this.isEventForConsumer(event, consumer)) {
        handled = true;
        this.sendToConsumer(event, consumer);
        this.saveEventToCache(event);
      }
    });
    if (this.hasHandledPotentialRedirect || !isRedirectEvent(event)) {
      return handled;
    }
    this.hasHandledPotentialRedirect = true;
    if (!handled) {
      this.queuedRedirectEvent = event;
      handled = true;
    }
    return handled;
  }
  sendToConsumer(event, consumer) {
    var _a2;
    if (event.error && !isNullRedirectEvent(event)) {
      const code = ((_a2 = event.error.code) === null || _a2 === void 0 ? void 0 : _a2.split("auth/")[1]) || "internal-error";
      consumer.onError(_createError(this.auth, code));
    } else {
      consumer.onAuthEvent(event);
    }
  }
  isEventForConsumer(event, consumer) {
    const eventIdMatches = consumer.eventId === null || !!event.eventId && event.eventId === consumer.eventId;
    return consumer.filter.includes(event.type) && eventIdMatches;
  }
  hasEventBeenHandled(event) {
    if (Date.now() - this.lastProcessedEventTime >= EVENT_DUPLICATION_CACHE_DURATION_MS) {
      this.cachedEventUids.clear();
    }
    return this.cachedEventUids.has(eventUid(event));
  }
  saveEventToCache(event) {
    this.cachedEventUids.add(eventUid(event));
    this.lastProcessedEventTime = Date.now();
  }
}
function eventUid(e2) {
  return [e2.type, e2.eventId, e2.sessionId, e2.tenantId].filter((v2) => v2).join("-");
}
function isNullRedirectEvent({ type: type2, error }) {
  return type2 === "unknown" && (error === null || error === void 0 ? void 0 : error.code) === `auth/${"no-auth-event"}`;
}
function isRedirectEvent(event) {
  switch (event.type) {
    case "signInViaRedirect":
    case "linkViaRedirect":
    case "reauthViaRedirect":
      return true;
    case "unknown":
      return isNullRedirectEvent(event);
    default:
      return false;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function _getProjectConfig(auth, request = {}) {
  return _performApiRequest(auth, "GET", "/v1/projects", request);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const IP_ADDRESS_REGEX = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
const HTTP_REGEX = /^https?/;
async function _validateOrigin(auth) {
  if (auth.config.emulator) {
    return;
  }
  const { authorizedDomains } = await _getProjectConfig(auth);
  for (const domain of authorizedDomains) {
    try {
      if (matchDomain(domain)) {
        return;
      }
    } catch (_a2) {
    }
  }
  _fail(auth, "unauthorized-domain");
}
function matchDomain(expected) {
  const currentUrl = _getCurrentUrl();
  const { protocol, hostname } = new URL(currentUrl);
  if (expected.startsWith("chrome-extension://")) {
    const ceUrl = new URL(expected);
    if (ceUrl.hostname === "" && hostname === "") {
      return protocol === "chrome-extension:" && expected.replace("chrome-extension://", "") === currentUrl.replace("chrome-extension://", "");
    }
    return protocol === "chrome-extension:" && ceUrl.hostname === hostname;
  }
  if (!HTTP_REGEX.test(protocol)) {
    return false;
  }
  if (IP_ADDRESS_REGEX.test(expected)) {
    return hostname === expected;
  }
  const escapedDomainPattern = expected.replace(/\./g, "\\.");
  const re2 = new RegExp("^(.+\\." + escapedDomainPattern + "|" + escapedDomainPattern + ")$", "i");
  return re2.test(hostname);
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const NETWORK_TIMEOUT = new Delay(3e4, 6e4);
function resetUnloadedGapiModules() {
  const beacon = _window().___jsl;
  if (beacon === null || beacon === void 0 ? void 0 : beacon.H) {
    for (const hint of Object.keys(beacon.H)) {
      beacon.H[hint].r = beacon.H[hint].r || [];
      beacon.H[hint].L = beacon.H[hint].L || [];
      beacon.H[hint].r = [...beacon.H[hint].L];
      if (beacon.CP) {
        for (let i2 = 0; i2 < beacon.CP.length; i2++) {
          beacon.CP[i2] = null;
        }
      }
    }
  }
}
function loadGapi(auth) {
  return new Promise((resolve2, reject) => {
    var _a2, _b, _c2;
    function loadGapiIframe() {
      resetUnloadedGapiModules();
      gapi.load("gapi.iframes", {
        callback: () => {
          resolve2(gapi.iframes.getContext());
        },
        ontimeout: () => {
          resetUnloadedGapiModules();
          reject(_createError(auth, "network-request-failed"));
        },
        timeout: NETWORK_TIMEOUT.get()
      });
    }
    if ((_b = (_a2 = _window().gapi) === null || _a2 === void 0 ? void 0 : _a2.iframes) === null || _b === void 0 ? void 0 : _b.Iframe) {
      resolve2(gapi.iframes.getContext());
    } else if (!!((_c2 = _window().gapi) === null || _c2 === void 0 ? void 0 : _c2.load)) {
      loadGapiIframe();
    } else {
      const cbName = _generateCallbackName("iframefcb");
      _window()[cbName] = () => {
        if (!!gapi.load) {
          loadGapiIframe();
        } else {
          reject(_createError(auth, "network-request-failed"));
        }
      };
      return _loadJS(`https://apis.google.com/js/api.js?onload=${cbName}`).catch((e2) => reject(e2));
    }
  }).catch((error) => {
    cachedGApiLoader = null;
    throw error;
  });
}
let cachedGApiLoader = null;
function _loadGapi(auth) {
  cachedGApiLoader = cachedGApiLoader || loadGapi(auth);
  return cachedGApiLoader;
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const PING_TIMEOUT = new Delay(5e3, 15e3);
const IFRAME_PATH = "__/auth/iframe";
const EMULATED_IFRAME_PATH = "emulator/auth/iframe";
const IFRAME_ATTRIBUTES = {
  style: {
    position: "absolute",
    top: "-100px",
    width: "1px",
    height: "1px"
  },
  "aria-hidden": "true",
  tabindex: "-1"
};
const EID_FROM_APIHOST = /* @__PURE__ */ new Map([
  ["identitytoolkit.googleapis.com", "p"],
  ["staging-identitytoolkit.sandbox.googleapis.com", "s"],
  ["test-identitytoolkit.sandbox.googleapis.com", "t"]
]);
function getIframeUrl(auth) {
  const config2 = auth.config;
  _assert(config2.authDomain, auth, "auth-domain-config-required");
  const url = config2.emulator ? _emulatorUrl(config2, EMULATED_IFRAME_PATH) : `https://${auth.config.authDomain}/${IFRAME_PATH}`;
  const params = {
    apiKey: config2.apiKey,
    appName: auth.name,
    v: SDK_VERSION
  };
  const eid = EID_FROM_APIHOST.get(auth.config.apiHost);
  if (eid) {
    params.eid = eid;
  }
  const frameworks = auth._getFrameworks();
  if (frameworks.length) {
    params.fw = frameworks.join(",");
  }
  return `${url}?${querystring(params).slice(1)}`;
}
async function _openIframe(auth) {
  const context = await _loadGapi(auth);
  const gapi2 = _window().gapi;
  _assert(gapi2, auth, "internal-error");
  return context.open({
    where: document.body,
    url: getIframeUrl(auth),
    messageHandlersFilter: gapi2.iframes.CROSS_ORIGIN_IFRAMES_FILTER,
    attributes: IFRAME_ATTRIBUTES,
    dontclear: true
  }, (iframe) => new Promise(async (resolve2, reject) => {
    await iframe.restyle({
      setHideOnLeave: false
    });
    const networkError = _createError(auth, "network-request-failed");
    const networkErrorTimer = _window().setTimeout(() => {
      reject(networkError);
    }, PING_TIMEOUT.get());
    function clearTimerAndResolve() {
      _window().clearTimeout(networkErrorTimer);
      resolve2(iframe);
    }
    iframe.ping(clearTimerAndResolve).then(clearTimerAndResolve, () => {
      reject(networkError);
    });
  }));
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const BASE_POPUP_OPTIONS = {
  location: "yes",
  resizable: "yes",
  statusbar: "yes",
  toolbar: "no"
};
const DEFAULT_WIDTH = 500;
const DEFAULT_HEIGHT = 600;
const TARGET_BLANK = "_blank";
const FIREFOX_EMPTY_URL = "http://localhost";
class AuthPopup {
  constructor(window2) {
    this.window = window2;
    this.associatedEvent = null;
  }
  close() {
    if (this.window) {
      try {
        this.window.close();
      } catch (e2) {
      }
    }
  }
}
function _open(auth, url, name2, width = DEFAULT_WIDTH, height = DEFAULT_HEIGHT) {
  const top = Math.max((window.screen.availHeight - height) / 2, 0).toString();
  const left = Math.max((window.screen.availWidth - width) / 2, 0).toString();
  let target = "";
  const options = Object.assign(Object.assign({}, BASE_POPUP_OPTIONS), {
    width: width.toString(),
    height: height.toString(),
    top,
    left
  });
  const ua2 = getUA().toLowerCase();
  if (name2) {
    target = _isChromeIOS(ua2) ? TARGET_BLANK : name2;
  }
  if (_isFirefox(ua2)) {
    url = url || FIREFOX_EMPTY_URL;
    options.scrollbars = "yes";
  }
  const optionsString = Object.entries(options).reduce((accum, [key, value]) => `${accum}${key}=${value},`, "");
  if (_isIOSStandalone(ua2) && target !== "_self") {
    openAsNewWindowIOS(url || "", target);
    return new AuthPopup(null);
  }
  const newWin = window.open(url || "", target, optionsString);
  _assert(newWin, auth, "popup-blocked");
  try {
    newWin.focus();
  } catch (e2) {
  }
  return new AuthPopup(newWin);
}
function openAsNewWindowIOS(url, target) {
  const el = document.createElement("a");
  el.href = url;
  el.target = target;
  const click = document.createEvent("MouseEvent");
  click.initMouseEvent("click", true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 1, null);
  el.dispatchEvent(click);
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const WIDGET_PATH = "__/auth/handler";
const EMULATOR_WIDGET_PATH = "emulator/auth/handler";
function _getRedirectUrl(auth, provider, authType, redirectUrl, eventId, additionalParams) {
  _assert(auth.config.authDomain, auth, "auth-domain-config-required");
  _assert(auth.config.apiKey, auth, "invalid-api-key");
  const params = {
    apiKey: auth.config.apiKey,
    appName: auth.name,
    authType,
    redirectUrl,
    v: SDK_VERSION,
    eventId
  };
  if (provider instanceof FederatedAuthProvider) {
    provider.setDefaultLanguage(auth.languageCode);
    params.providerId = provider.providerId || "";
    if (!isEmpty(provider.getCustomParameters())) {
      params.customParameters = JSON.stringify(provider.getCustomParameters());
    }
    for (const [key, value] of Object.entries(additionalParams || {})) {
      params[key] = value;
    }
  }
  if (provider instanceof BaseOAuthProvider) {
    const scopes = provider.getScopes().filter((scope) => scope !== "");
    if (scopes.length > 0) {
      params.scopes = scopes.join(",");
    }
  }
  if (auth.tenantId) {
    params.tid = auth.tenantId;
  }
  const paramsDict = params;
  for (const key of Object.keys(paramsDict)) {
    if (paramsDict[key] === void 0) {
      delete paramsDict[key];
    }
  }
  return `${getHandlerBase(auth)}?${querystring(paramsDict).slice(1)}`;
}
function getHandlerBase({ config: config2 }) {
  if (!config2.emulator) {
    return `https://${config2.authDomain}/${WIDGET_PATH}`;
  }
  return _emulatorUrl(config2, EMULATOR_WIDGET_PATH);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const WEB_STORAGE_SUPPORT_KEY = "webStorageSupport";
class BrowserPopupRedirectResolver {
  constructor() {
    this.eventManagers = {};
    this.iframes = {};
    this.originValidationPromises = {};
    this._redirectPersistence = browserSessionPersistence;
    this._completeRedirectFn = _getRedirectResult;
    this._overrideRedirectResult = _overrideRedirectResult;
  }
  async _openPopup(auth, provider, authType, eventId) {
    var _a2;
    debugAssert((_a2 = this.eventManagers[auth._key()]) === null || _a2 === void 0 ? void 0 : _a2.manager, "_initialize() not called before _openPopup()");
    const url = _getRedirectUrl(auth, provider, authType, _getCurrentUrl(), eventId);
    return _open(auth, url, _generateEventId());
  }
  async _openRedirect(auth, provider, authType, eventId) {
    await this._originValidation(auth);
    _setWindowLocation(_getRedirectUrl(auth, provider, authType, _getCurrentUrl(), eventId));
    return new Promise(() => {
    });
  }
  _initialize(auth) {
    const key = auth._key();
    if (this.eventManagers[key]) {
      const { manager, promise: promise2 } = this.eventManagers[key];
      if (manager) {
        return Promise.resolve(manager);
      } else {
        debugAssert(promise2, "If manager is not set, promise should be");
        return promise2;
      }
    }
    const promise = this.initAndGetManager(auth);
    this.eventManagers[key] = { promise };
    promise.catch(() => {
      delete this.eventManagers[key];
    });
    return promise;
  }
  async initAndGetManager(auth) {
    const iframe = await _openIframe(auth);
    const manager = new AuthEventManager(auth);
    iframe.register("authEvent", (iframeEvent) => {
      _assert(iframeEvent === null || iframeEvent === void 0 ? void 0 : iframeEvent.authEvent, auth, "invalid-auth-event");
      const handled = manager.onEvent(iframeEvent.authEvent);
      return { status: handled ? "ACK" : "ERROR" };
    }, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER);
    this.eventManagers[auth._key()] = { manager };
    this.iframes[auth._key()] = iframe;
    return manager;
  }
  _isIframeWebStorageSupported(auth, cb2) {
    const iframe = this.iframes[auth._key()];
    iframe.send(WEB_STORAGE_SUPPORT_KEY, { type: WEB_STORAGE_SUPPORT_KEY }, (result) => {
      var _a2;
      const isSupported = (_a2 = result === null || result === void 0 ? void 0 : result[0]) === null || _a2 === void 0 ? void 0 : _a2[WEB_STORAGE_SUPPORT_KEY];
      if (isSupported !== void 0) {
        cb2(!!isSupported);
      }
      _fail(auth, "internal-error");
    }, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER);
  }
  _originValidation(auth) {
    const key = auth._key();
    if (!this.originValidationPromises[key]) {
      this.originValidationPromises[key] = _validateOrigin(auth);
    }
    return this.originValidationPromises[key];
  }
  get _shouldInitProactively() {
    return _isMobileBrowser() || _isSafari() || _isIOS();
  }
}
const browserPopupRedirectResolver = BrowserPopupRedirectResolver;
var name$2 = "@firebase/auth";
var version$2 = "0.20.5";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AuthInterop {
  constructor(auth) {
    this.auth = auth;
    this.internalListeners = /* @__PURE__ */ new Map();
  }
  getUid() {
    var _a2;
    this.assertAuthConfigured();
    return ((_a2 = this.auth.currentUser) === null || _a2 === void 0 ? void 0 : _a2.uid) || null;
  }
  async getToken(forceRefresh) {
    this.assertAuthConfigured();
    await this.auth._initializationPromise;
    if (!this.auth.currentUser) {
      return null;
    }
    const accessToken = await this.auth.currentUser.getIdToken(forceRefresh);
    return { accessToken };
  }
  addAuthTokenListener(listener) {
    this.assertAuthConfigured();
    if (this.internalListeners.has(listener)) {
      return;
    }
    const unsubscribe = this.auth.onIdTokenChanged((user) => {
      var _a2;
      listener(((_a2 = user) === null || _a2 === void 0 ? void 0 : _a2.stsTokenManager.accessToken) || null);
    });
    this.internalListeners.set(listener, unsubscribe);
    this.updateProactiveRefresh();
  }
  removeAuthTokenListener(listener) {
    this.assertAuthConfigured();
    const unsubscribe = this.internalListeners.get(listener);
    if (!unsubscribe) {
      return;
    }
    this.internalListeners.delete(listener);
    unsubscribe();
    this.updateProactiveRefresh();
  }
  assertAuthConfigured() {
    _assert(this.auth._initializationPromise, "dependent-sdk-initialized-before-auth");
  }
  updateProactiveRefresh() {
    if (this.internalListeners.size > 0) {
      this.auth._startProactiveRefresh();
    } else {
      this.auth._stopProactiveRefresh();
    }
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getVersionForPlatform(clientPlatform) {
  switch (clientPlatform) {
    case "Node":
      return "node";
    case "ReactNative":
      return "rn";
    case "Worker":
      return "webworker";
    case "Cordova":
      return "cordova";
    default:
      return void 0;
  }
}
function registerAuth(clientPlatform) {
  _registerComponent(new Component("auth", (container, { options: deps }) => {
    const app2 = container.getProvider("app").getImmediate();
    const heartbeatServiceProvider = container.getProvider("heartbeat");
    const { apiKey, authDomain } = app2.options;
    return ((app3, heartbeatServiceProvider2) => {
      _assert(apiKey && !apiKey.includes(":"), "invalid-api-key", { appName: app3.name });
      _assert(!(authDomain === null || authDomain === void 0 ? void 0 : authDomain.includes(":")), "argument-error", {
        appName: app3.name
      });
      const config2 = {
        apiKey,
        authDomain,
        clientPlatform,
        apiHost: "identitytoolkit.googleapis.com",
        tokenApiHost: "securetoken.googleapis.com",
        apiScheme: "https",
        sdkClientVersion: _getClientVersion(clientPlatform)
      };
      const authInstance = new AuthImpl(app3, heartbeatServiceProvider2, config2);
      _initializeAuthInstance(authInstance, deps);
      return authInstance;
    })(app2, heartbeatServiceProvider);
  }, "PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback((container, _instanceIdentifier, _instance) => {
    const authInternalProvider = container.getProvider("auth-internal");
    authInternalProvider.initialize();
  }));
  _registerComponent(new Component("auth-internal", (container) => {
    const auth = _castAuth(container.getProvider("auth").getImmediate());
    return ((auth2) => new AuthInterop(auth2))(auth);
  }, "PRIVATE").setInstantiationMode("EXPLICIT"));
  registerVersion(name$2, version$2, getVersionForPlatform(clientPlatform));
  registerVersion(name$2, version$2, "esm2017");
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getAuth(app2 = getApp()) {
  const provider = _getProvider(app2, "auth");
  if (provider.isInitialized()) {
    return provider.getImmediate();
  }
  return initializeAuth(app2, {
    popupRedirectResolver: browserPopupRedirectResolver,
    persistence: [
      indexedDBLocalPersistence,
      browserLocalPersistence,
      browserSessionPersistence
    ]
  });
}
registerAuth("Browser");
function getDevtoolsGlobalHook() {
  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function getTarget() {
  return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
}
const isProxyAvailable = typeof Proxy === "function";
const HOOK_SETUP = "devtools-plugin:setup";
const HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";
let supported;
let perf;
function isPerformanceSupported() {
  var _a2;
  if (supported !== void 0) {
    return supported;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported = true;
    perf = window.performance;
  } else if (typeof global !== "undefined" && ((_a2 = global.perf_hooks) === null || _a2 === void 0 ? void 0 : _a2.performance)) {
    supported = true;
    perf = global.perf_hooks.performance;
  } else {
    supported = false;
  }
  return supported;
}
function now() {
  return isPerformanceSupported() ? perf.now() : Date.now();
}
class ApiProxy {
  constructor(plugin2, hook) {
    this.target = null;
    this.targetQueue = [];
    this.onQueue = [];
    this.plugin = plugin2;
    this.hook = hook;
    const defaultSettings = {};
    if (plugin2.settings) {
      for (const id2 in plugin2.settings) {
        const item = plugin2.settings[id2];
        defaultSettings[id2] = item.defaultValue;
      }
    }
    const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin2.id}`;
    let currentSettings = Object.assign({}, defaultSettings);
    try {
      const raw = localStorage.getItem(localSettingsSaveId);
      const data = JSON.parse(raw);
      Object.assign(currentSettings, data);
    } catch (e2) {
    }
    this.fallbacks = {
      getSettings() {
        return currentSettings;
      },
      setSettings(value) {
        try {
          localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
        } catch (e2) {
        }
        currentSettings = value;
      },
      now() {
        return now();
      }
    };
    if (hook) {
      hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
        if (pluginId === this.plugin.id) {
          this.fallbacks.setSettings(value);
        }
      });
    }
    this.proxiedOn = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target.on[prop];
        } else {
          return (...args) => {
            this.onQueue.push({
              method: prop,
              args
            });
          };
        }
      }
    });
    this.proxiedTarget = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target[prop];
        } else if (prop === "on") {
          return this.proxiedOn;
        } else if (Object.keys(this.fallbacks).includes(prop)) {
          return (...args) => {
            this.targetQueue.push({
              method: prop,
              args,
              resolve: () => {
              }
            });
            return this.fallbacks[prop](...args);
          };
        } else {
          return (...args) => {
            return new Promise((resolve2) => {
              this.targetQueue.push({
                method: prop,
                args,
                resolve: resolve2
              });
            });
          };
        }
      }
    });
  }
  async setRealTarget(target) {
    this.target = target;
    for (const item of this.onQueue) {
      this.target.on[item.method](...item.args);
    }
    for (const item of this.targetQueue) {
      item.resolve(await this.target[item.method](...item.args));
    }
  }
}
function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
  const descriptor = pluginDescriptor;
  const target = getTarget();
  const hook = getDevtoolsGlobalHook();
  const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
  if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
    hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
  } else {
    const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
    const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
    list.push({
      pluginDescriptor: descriptor,
      setupFn,
      proxy
    });
    if (proxy)
      setupFn(proxy.proxiedTarget);
  }
}
/*!
  * pinia v2.0.14
  * (c) 2022 Eduardo San Martin Morote
  * @license MIT
  */
let activePinia;
const setActivePinia = (pinia2) => activePinia = pinia2;
const piniaSymbol = Symbol();
function isPlainObject$1(o2) {
  return o2 && typeof o2 === "object" && Object.prototype.toString.call(o2) === "[object Object]" && typeof o2.toJSON !== "function";
}
var MutationType;
(function(MutationType2) {
  MutationType2["direct"] = "direct";
  MutationType2["patchObject"] = "patch object";
  MutationType2["patchFunction"] = "patch function";
})(MutationType || (MutationType = {}));
function createPinia() {
  const scope = effectScope(true);
  const state = scope.run(() => ref$2({}));
  let _p = [];
  let toBeInstalled = [];
  const pinia2 = markRaw({
    install(app2) {
      setActivePinia(pinia2);
      {
        pinia2._a = app2;
        app2.provide(piniaSymbol, pinia2);
        app2.config.globalProperties.$pinia = pinia2;
        toBeInstalled.forEach((plugin2) => _p.push(plugin2));
        toBeInstalled = [];
      }
    },
    use(plugin2) {
      if (!this._a && !isVue2) {
        toBeInstalled.push(plugin2);
      } else {
        _p.push(plugin2);
      }
      return this;
    },
    _p,
    _a: null,
    _e: scope,
    _s: /* @__PURE__ */ new Map(),
    state
  });
  return pinia2;
}
const noop$2 = () => {
};
function addSubscription(subscriptions, callback, detached, onCleanup = noop$2) {
  subscriptions.push(callback);
  const removeSubscription = () => {
    const idx = subscriptions.indexOf(callback);
    if (idx > -1) {
      subscriptions.splice(idx, 1);
      onCleanup();
    }
  };
  if (!detached && getCurrentInstance()) {
    onUnmounted(removeSubscription);
  }
  return removeSubscription;
}
function triggerSubscriptions(subscriptions, ...args) {
  subscriptions.slice().forEach((callback) => {
    callback(...args);
  });
}
function mergeReactiveObjects(target, patchToApply) {
  for (const key in patchToApply) {
    if (!patchToApply.hasOwnProperty(key))
      continue;
    const subPatch = patchToApply[key];
    const targetValue = target[key];
    if (isPlainObject$1(targetValue) && isPlainObject$1(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
      target[key] = mergeReactiveObjects(targetValue, subPatch);
    } else {
      target[key] = subPatch;
    }
  }
  return target;
}
const skipHydrateSymbol = Symbol();
function shouldHydrate(obj) {
  return !isPlainObject$1(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
}
const { assign: assign$1 } = Object;
function isComputed(o2) {
  return !!(isRef(o2) && o2.effect);
}
function createOptionsStore(id2, options, pinia2, hot) {
  const { state, actions: actions2, getters } = options;
  const initialState = pinia2.state.value[id2];
  let store2;
  function setup() {
    if (!initialState && true) {
      {
        pinia2.state.value[id2] = state ? state() : {};
      }
    }
    const localState = toRefs(pinia2.state.value[id2]);
    return assign$1(localState, actions2, Object.keys(getters || {}).reduce((computedGetters, name2) => {
      computedGetters[name2] = markRaw(computed(() => {
        setActivePinia(pinia2);
        const store3 = pinia2._s.get(id2);
        return getters[name2].call(store3, store3);
      }));
      return computedGetters;
    }, {}));
  }
  store2 = createSetupStore(id2, setup, options, pinia2, hot, true);
  store2.$reset = function $reset() {
    const newState = state ? state() : {};
    this.$patch(($state) => {
      assign$1($state, newState);
    });
  };
  return store2;
}
function createSetupStore($id, setup, options = {}, pinia2, hot, isOptionsStore) {
  let scope;
  const optionsForPlugin = assign$1({ actions: {} }, options);
  const $subscribeOptions = {
    deep: true
  };
  let isListening;
  let isSyncListening;
  let subscriptions = markRaw([]);
  let actionSubscriptions = markRaw([]);
  let debuggerEvents;
  const initialState = pinia2.state.value[$id];
  if (!isOptionsStore && !initialState && true) {
    {
      pinia2.state.value[$id] = {};
    }
  }
  ref$2({});
  let activeListener;
  function $patch(partialStateOrMutator) {
    let subscriptionMutation;
    isListening = isSyncListening = false;
    if (typeof partialStateOrMutator === "function") {
      partialStateOrMutator(pinia2.state.value[$id]);
      subscriptionMutation = {
        type: MutationType.patchFunction,
        storeId: $id,
        events: debuggerEvents
      };
    } else {
      mergeReactiveObjects(pinia2.state.value[$id], partialStateOrMutator);
      subscriptionMutation = {
        type: MutationType.patchObject,
        payload: partialStateOrMutator,
        storeId: $id,
        events: debuggerEvents
      };
    }
    const myListenerId = activeListener = Symbol();
    nextTick().then(() => {
      if (activeListener === myListenerId) {
        isListening = true;
      }
    });
    isSyncListening = true;
    triggerSubscriptions(subscriptions, subscriptionMutation, pinia2.state.value[$id]);
  }
  const $reset = noop$2;
  function $dispose() {
    scope.stop();
    subscriptions = [];
    actionSubscriptions = [];
    pinia2._s.delete($id);
  }
  function wrapAction(name2, action) {
    return function() {
      setActivePinia(pinia2);
      const args = Array.from(arguments);
      const afterCallbackList = [];
      const onErrorCallbackList = [];
      function after(callback) {
        afterCallbackList.push(callback);
      }
      function onError(callback) {
        onErrorCallbackList.push(callback);
      }
      triggerSubscriptions(actionSubscriptions, {
        args,
        name: name2,
        store: store2,
        after,
        onError
      });
      let ret;
      try {
        ret = action.apply(this && this.$id === $id ? this : store2, args);
      } catch (error) {
        triggerSubscriptions(onErrorCallbackList, error);
        throw error;
      }
      if (ret instanceof Promise) {
        return ret.then((value) => {
          triggerSubscriptions(afterCallbackList, value);
          return value;
        }).catch((error) => {
          triggerSubscriptions(onErrorCallbackList, error);
          return Promise.reject(error);
        });
      }
      triggerSubscriptions(afterCallbackList, ret);
      return ret;
    };
  }
  const partialStore = {
    _p: pinia2,
    $id,
    $onAction: addSubscription.bind(null, actionSubscriptions),
    $patch,
    $reset,
    $subscribe(callback, options2 = {}) {
      const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
      const stopWatcher = scope.run(() => watch(() => pinia2.state.value[$id], (state) => {
        if (options2.flush === "sync" ? isSyncListening : isListening) {
          callback({
            storeId: $id,
            type: MutationType.direct,
            events: debuggerEvents
          }, state);
        }
      }, assign$1({}, $subscribeOptions, options2)));
      return removeSubscription;
    },
    $dispose
  };
  const store2 = reactive(assign$1(
    {},
    partialStore
  ));
  pinia2._s.set($id, store2);
  const setupStore = pinia2._e.run(() => {
    scope = effectScope();
    return scope.run(() => setup());
  });
  for (const key in setupStore) {
    const prop = setupStore[key];
    if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
      if (!isOptionsStore) {
        if (initialState && shouldHydrate(prop)) {
          if (isRef(prop)) {
            prop.value = initialState[key];
          } else {
            mergeReactiveObjects(prop, initialState[key]);
          }
        }
        {
          pinia2.state.value[$id][key] = prop;
        }
      }
    } else if (typeof prop === "function") {
      const actionValue = wrapAction(key, prop);
      {
        setupStore[key] = actionValue;
      }
      optionsForPlugin.actions[key] = prop;
    } else
      ;
  }
  {
    assign$1(store2, setupStore);
    assign$1(toRaw(store2), setupStore);
  }
  Object.defineProperty(store2, "$state", {
    get: () => pinia2.state.value[$id],
    set: (state) => {
      $patch(($state) => {
        assign$1($state, state);
      });
    }
  });
  pinia2._p.forEach((extender) => {
    {
      assign$1(store2, scope.run(() => extender({
        store: store2,
        app: pinia2._a,
        pinia: pinia2,
        options: optionsForPlugin
      })));
    }
  });
  if (initialState && isOptionsStore && options.hydrate) {
    options.hydrate(store2.$state, initialState);
  }
  isListening = true;
  isSyncListening = true;
  return store2;
}
function defineStore(idOrOptions, setup, setupOptions) {
  let id2;
  let options;
  const isSetupStore = typeof setup === "function";
  if (typeof idOrOptions === "string") {
    id2 = idOrOptions;
    options = isSetupStore ? setupOptions : setup;
  } else {
    options = idOrOptions;
    id2 = idOrOptions.id;
  }
  function useStore2(pinia2, hot) {
    const currentInstance2 = getCurrentInstance();
    pinia2 = pinia2 || currentInstance2 && inject(piniaSymbol);
    if (pinia2)
      setActivePinia(pinia2);
    pinia2 = activePinia;
    if (!pinia2._s.has(id2)) {
      if (isSetupStore) {
        createSetupStore(id2, setup, options, pinia2);
      } else {
        createOptionsStore(id2, options, pinia2);
      }
    }
    const store2 = pinia2._s.get(id2);
    return store2;
  }
  useStore2.$id = id2;
  return useStore2;
}
const _availableBreakpoints = ref$2([]);
const _defaultBreakpoint = ref$2(null);
const _defaultOrientation = ref$2(null);
const _defaultTheme = ref$2(null);
const _defaultMotion = ref$2(null);
const _mqState = reactive({
  current: ""
});
const _listeners = [];
const _isMounted = ref$2(false);
const availableBreakpoints = readonly(_availableBreakpoints);
const defaultBreakpoint = readonly(_defaultBreakpoint);
const defaultOrientation = readonly(_defaultOrientation);
const defaultTheme = readonly(_defaultTheme);
const defaultMotion = readonly(_defaultMotion);
const mqState = readonly(_mqState);
const setAvailableBreakpoints = (v2) => {
  _availableBreakpoints.value = v2;
};
const setDefaultBreakpoint = (v2) => {
  _defaultBreakpoint.value = v2;
};
const setDefaultOrientation = (v2) => {
  _defaultOrientation.value = v2;
};
const setDefaultTheme = (v2) => {
  _defaultTheme.value = v2;
};
const setDefaultMotion = (v2) => {
  _defaultMotion.value = v2;
};
const updateState = (v2 = defaultBreakpoint.value) => {
  _mqState.current = v2;
  const currentIndex = availableBreakpoints.value.findIndex((bp) => bp.name === v2);
  const allKeys = availableBreakpoints.value.map((bp) => bp.name);
  for (let i2 = 0; i2 < allKeys.length; i2++) {
    if (i2 > 0 && i2 < allKeys.length - 1) {
      const mKey = allKeys[i2] + "Minus";
      const pKey = allKeys[i2] + "Plus";
      _mqState[mKey] = currentIndex <= i2 ? true : false;
      _mqState[pKey] = currentIndex >= i2 ? true : false;
    }
    _mqState[allKeys[i2]] = allKeys[i2] === v2 ? true : false;
  }
};
const resetState = () => {
  const keys2 = Object.keys(_mqState);
  for (let key of keys2) {
    delete _mqState[key];
  }
  updateState();
  updateOrientationState();
  updateThemeState();
  updateMotionState();
};
const updateOrientationState = (v2 = defaultOrientation.value) => {
  _mqState.orientation = v2;
  _mqState.isLandscape = v2 === "landscape";
  _mqState.isPortrait = v2 === "portrait";
};
const updateThemeState = (v2 = defaultTheme.value || "light") => {
  _mqState.theme = v2;
  _mqState.isDark = v2 === "dark";
  _mqState.isLight = v2 === "light";
};
const updateMotionState = (v2 = defaultMotion.value || "no-preference") => {
  _mqState.motionPreference = v2;
  _mqState.isMotion = v2 === "no-preference";
  _mqState.isInert = v2 === "reduce";
};
function removeListeners() {
  while (_listeners.length > 0) {
    const listener = _listeners.shift();
    if (listener && typeof listener === "object") {
      const { mql, cb: cb2 } = listener;
      const supportsAEL = mql.addEventListener && typeof mql.addEventListener === "function";
      if (supportsAEL)
        mql.removeEventListener("change", cb2);
      else
        mql.removeListener(cb2);
    }
  }
}
function createMediaQueries() {
  const mediaQueries = availableBreakpoints.value.reduce((acc, curr, index, arr) => {
    const min = `(min-width: ${curr.min}px)`;
    const max = index < arr.length - 1 ? `(max-width: ${arr[index + 1].min - 1}px)` : null;
    const query = min + (max ? " and " + max : "");
    return Object.assign(acc, {
      [curr.name]: query
    });
  }, {});
  return mediaQueries;
}
function subscribeToMediaQuery(mediaQuery, callback) {
  if (typeof window === "undefined" || !window.matchMedia)
    return false;
  else if (typeof window !== "undefined" && !window.matchMedia) {
    console.error("Vue3 Mq: No MatchMedia support detected in this browser. Responsive breakpoints not available.");
    return false;
  } else {
    _isMounted.value = true;
    const mql = window.matchMedia(mediaQuery);
    const cb2 = ({ matches }) => {
      if (matches)
        callback();
    };
    _listeners.push({ mql, cb: cb2 });
    const supportsAEL = mql.addEventListener && typeof mql.addEventListener === "function";
    if (supportsAEL)
      mql.addEventListener("change", cb2);
    else
      mql.addListener(cb2);
    cb2(mql);
  }
}
const bootstrap5 = {
  xs: 0,
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200,
  xxl: 1400
};
const bootstrap4 = {
  xs: 0,
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200
};
const bootstrap3 = {
  xs: 0,
  sm: 768,
  md: 992,
  lg: 1200
};
const vuetify = {
  xs: 0,
  sm: 600,
  md: 960,
  lg: 1264,
  xl: 1904
};
const tailwind = {
  xs: 0,
  sm: 640,
  md: 768,
  lg: 1024,
  xl: 1280,
  xxl: 1536
};
const devices = {
  phone: 0,
  tablet: 768,
  laptop: 1370,
  desktop: 1906
};
const wordpress = {
  mobile: 0,
  small: 600,
  medium: 782,
  large: 960,
  xlarge: 1080,
  wide: 1280,
  huge: 1440
};
var presets = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bootstrap5,
  bootstrap4,
  bootstrap3,
  vuetify,
  tailwind,
  devices,
  wordpress
}, Symbol.toStringTag, { value: "Module" }));
const validatePreset = (preset) => {
  if (typeof preset === "string" && presets[preset])
    return presets[preset];
  else {
    const availablePresets = Object.keys(presets);
    console.error(`Vue3 Mq: "${preset}" is not a valid preset. Available options are: ${availablePresets.join(", ")}`);
    return false;
  }
};
const validateOrientation = (orientation) => {
  const isValid = ["landscape", "portrait"].includes(orientation);
  if (isValid === false) {
    console.error(`Vue3 Mq: "${orientation}" is not a valid default orientation. Reverting to unset value.`);
    return null;
  } else
    return orientation;
};
const validateTheme = (theme = null) => {
  const isValid = ["dark", "light"].includes(theme);
  if (isValid === false && theme !== null) {
    console.error(`Vue3 Mq: "${theme}" is not a valid default theme. Reverting to unset value.`);
    return null;
  } else
    return theme;
};
const validateMotion = (motion = null) => {
  const isValid = ["no-preference", "reduce"].includes(motion);
  if (isValid === false && motion !== null) {
    console.error(`Vue3 Mq: "${motion}" is not a valid default motion preference. Reverting to unset value.`);
    return null;
  } else
    return motion;
};
const sanitiseBreakpoints = (breakpoints) => {
  if (!breakpoints || typeof breakpoints !== "object")
    return false;
  const sanitisedBreakpoints = [];
  for (let key in breakpoints) {
    const bp = parseFloat(breakpoints[key]);
    if (!key || typeof key !== "string") {
      console.warn(`Vue3 Mq: Invalid or missing breakpoint key (${JSON.stringify(key)}). Skipping.`);
      continue;
    } else if (/^[^a-z]/i.test(key) || /[^a-zA-Z0-9_]/.test(key)) {
      console.warn(`Vue3 Mq: "${key}" is an invalid breakpoint key. Breakpoint keys must start with a letter and contain only alphanumeric characters and underscores. Skipping.`);
      continue;
    } else if (!bp && bp !== 0 || isNaN(bp) || bp < 0) {
      console.warn(`Vue3 Mq: "${key}: ${breakpoints[key]}" is not a valid breakpoint. Breakpoints should be a number of zero or above. Skipping.`);
      continue;
    }
    sanitisedBreakpoints.push({
      name: key,
      min: bp
    });
  }
  const hasZero = sanitisedBreakpoints.some((breakpoint) => breakpoint.min === 0);
  if (!hasZero) {
    console.warn(`Vue3 Mq: You have not declared a breakpoint with a minimum value of 0. There may be screen sizes to which Vue3Mq does not respond.`);
  }
  const uniqueValues = new Set(sanitisedBreakpoints.map((breakpoint) => breakpoint.min));
  if (uniqueValues.size < sanitisedBreakpoints.length) {
    console.warn(`Vue3 Mq: Your breakpoint configuration contains duplicate values. Behaviour may be unpredictable.`);
  }
  if (sanitisedBreakpoints.length === 0)
    return false;
  else
    return sanitisedBreakpoints.sort((a2, b2) => a2.min - b2.min);
};
function updateBreakpoints({ breakpoints, preset }) {
  const validatedPreset = validatePreset(preset);
  const sanitisedBreakpoints = sanitiseBreakpoints(breakpoints);
  if (validatedPreset === false && !sanitisedBreakpoints) {
    throw new TypeError("Vue3 Mq: You must provide a valid preset, or valid breakpoint settings.");
  } else {
    setAvailableBreakpoints(sanitisedBreakpoints ? sanitisedBreakpoints : sanitiseBreakpoints(validatedPreset));
  }
  removeListeners();
  resetState();
  const mediaQueries = createMediaQueries();
  for (const key in mediaQueries) {
    const mediaQuery = mediaQueries[key];
    const callback = () => {
      updateState(key);
    };
    subscribeToMediaQuery(mediaQuery, callback);
  }
  ["portrait", "landscape"].forEach((o2) => {
    const orientationCallback = () => {
      updateOrientationState(o2);
    };
    subscribeToMediaQuery(`(orientation: ${o2})`, orientationCallback);
  });
  ["light", "dark"].forEach((t2) => {
    const themeCallback = () => {
      updateThemeState(t2);
    };
    subscribeToMediaQuery(`(prefers-color-scheme: ${t2})`, themeCallback);
  });
  ["reduce", "no-preference"].forEach((m2) => {
    const motionCallback = () => {
      updateMotionState(m2);
    };
    subscribeToMediaQuery(`(prefers-reduced-motion: ${m2})`, motionCallback);
  });
}
function useMq() {
  const mq = inject("mq");
  if (!mq) {
    throw new Error("Vue3Mq is not installed in this app. Please follow the installation instructions and try again.");
  } else
    return mq;
}
const install = (app2, {
  preset = "bootstrap5",
  breakpoints,
  defaultBreakpoint: defaultBreakpoint2,
  defaultOrientation: defaultOrientation2 = "landscape",
  defaultMotion: defaultMotion2 = "no-preference",
  defaultTheme: defaultTheme2
} = {}) => {
  try {
    const validatedDefaultOrientation = validateOrientation(defaultOrientation2);
    const validatedDefaultTheme = validateTheme(defaultTheme2);
    const validatedDefaultMotion = validateMotion(defaultMotion2);
    setDefaultBreakpoint(defaultBreakpoint2);
    setDefaultOrientation(validatedDefaultOrientation);
    setDefaultTheme(validatedDefaultTheme);
    setDefaultMotion(validatedDefaultMotion);
    app2.provide("mq", mqState);
    app2.provide("updateBreakpoints", updateBreakpoints);
    updateBreakpoints({ breakpoints, preset });
  } catch (e2) {
    console.error(e2);
  }
};
var plugin = {
  install
};
/*!
 * OverlayScrollbars
 * Version: 2.0.1
 *
 * Copyright (c) Rene Haas | KingSora.
 * https://github.com/KingSora
 *
 * Released under the MIT license.
 */
function each(t2, n2) {
  if (isArrayLike(t2)) {
    for (let o2 = 0; o2 < t2.length; o2++) {
      if (false === n2(t2[o2], o2, t2)) {
        break;
      }
    }
  } else if (t2) {
    each(Object.keys(t2), (o2) => n2(t2[o2], o2, t2));
  }
  return t2;
}
function style(t2, n2) {
  const o2 = isString$1(n2);
  const s2 = isArray$2(n2) || o2;
  if (s2) {
    let s3 = o2 ? "" : {};
    if (t2) {
      const e2 = window.getComputedStyle(t2, null);
      s3 = o2 ? getCSSVal(t2, e2, n2) : n2.reduce((n3, o3) => {
        n3[o3] = getCSSVal(t2, e2, o3);
        return n3;
      }, s3);
    }
    return s3;
  }
  t2 && each(keys(n2), (o3) => setCSSVal(t2, o3, n2[o3]));
}
const createCache = (t2, n2) => {
  const { o: o2, u: s2, _: e2 } = t2;
  let c2 = o2;
  let r2;
  const cacheUpdateContextual = (t3, n3) => {
    const o3 = c2;
    const i2 = t3;
    const l2 = n3 || (s2 ? !s2(o3, i2) : o3 !== i2);
    if (l2 || e2) {
      c2 = i2;
      r2 = o3;
    }
    return [c2, l2, r2];
  };
  const cacheUpdateIsolated = (t3) => cacheUpdateContextual(n2(c2, r2), t3);
  const getCurrentCache = (t3) => [c2, !!t3, r2];
  return [n2 ? cacheUpdateIsolated : cacheUpdateContextual, getCurrentCache];
};
const isClient = () => "undefined" !== typeof window;
const t$1 = isClient() && Node.ELEMENT_NODE;
const { toString: n, hasOwnProperty: o } = Object.prototype;
const isUndefined = (t2) => void 0 === t2;
const isNull = (t2) => null === t2;
const type = (t2) => isUndefined(t2) || isNull(t2) ? `${t2}` : n.call(t2).replace(/^\[object (.+)\]$/, "$1").toLowerCase();
const isNumber = (t2) => "number" === typeof t2;
const isString$1 = (t2) => "string" === typeof t2;
const isBoolean = (t2) => "boolean" === typeof t2;
const isFunction = (t2) => "function" === typeof t2;
const isArray$2 = (t2) => Array.isArray(t2);
const isObject$2 = (t2) => "object" === typeof t2 && !isArray$2(t2) && !isNull(t2);
const isArrayLike = (t2) => {
  const n2 = !!t2 && t2.length;
  const o2 = isNumber(n2) && n2 > -1 && n2 % 1 == 0;
  return isArray$2(t2) || !isFunction(t2) && o2 ? n2 > 0 && isObject$2(t2) ? n2 - 1 in t2 : true : false;
};
const isPlainObject = (t2) => {
  if (!t2 || !isObject$2(t2) || "object" !== type(t2)) {
    return false;
  }
  let n2;
  const s2 = "constructor";
  const e2 = t2[s2];
  const c2 = e2 && e2.prototype;
  const r2 = o.call(t2, s2);
  const i2 = c2 && o.call(c2, "isPrototypeOf");
  if (e2 && !r2 && !i2) {
    return false;
  }
  for (n2 in t2) {
  }
  return isUndefined(n2) || o.call(t2, n2);
};
const isHTMLElement = (n2) => {
  const o2 = HTMLElement;
  return n2 ? o2 ? n2 instanceof o2 : n2.nodeType === t$1 : false;
};
const isElement = (n2) => {
  const o2 = Element;
  return n2 ? o2 ? n2 instanceof o2 : n2.nodeType === t$1 : false;
};
const indexOf = (t2, n2, o2) => t2.indexOf(n2, o2);
const push = (t2, n2, o2) => {
  !o2 && !isString$1(n2) && isArrayLike(n2) ? Array.prototype.push.apply(t2, n2) : t2.push(n2);
  return t2;
};
const from = (t2) => {
  const n2 = Array.from;
  const o2 = [];
  if (n2 && t2) {
    return n2(t2);
  }
  if (t2 instanceof Set) {
    t2.forEach((t3) => {
      push(o2, t3);
    });
  } else {
    each(t2, (t3) => {
      push(o2, t3);
    });
  }
  return o2;
};
const isEmptyArray = (t2) => !!t2 && 0 === t2.length;
const runEachAndClear = (t2, n2, o2) => {
  const runFn = (t3) => t3 && t3.apply(void 0, n2 || []);
  each(t2, runFn);
  !o2 && (t2.length = 0);
};
const hasOwnProperty = (t2, n2) => Object.prototype.hasOwnProperty.call(t2, n2);
const keys = (t2) => t2 ? Object.keys(t2) : [];
const assignDeep = (t2, n2, o2, s2, e2, c2, r2) => {
  const i2 = [n2, o2, s2, e2, c2, r2];
  if (("object" !== typeof t2 || isNull(t2)) && !isFunction(t2)) {
    t2 = {};
  }
  each(i2, (n3) => {
    each(keys(n3), (o3) => {
      const s3 = n3[o3];
      if (t2 === s3) {
        return true;
      }
      const e3 = isArray$2(s3);
      if (s3 && (isPlainObject(s3) || e3)) {
        const n4 = t2[o3];
        let c3 = n4;
        if (e3 && !isArray$2(n4)) {
          c3 = [];
        } else if (!e3 && !isPlainObject(n4)) {
          c3 = {};
        }
        t2[o3] = assignDeep(c3, s3);
      } else {
        t2[o3] = s3;
      }
    });
  });
  return t2;
};
const isEmptyObject = (t2) => {
  for (const n2 in t2) {
    return false;
  }
  return true;
};
const getSetProp = (t2, n2, o2, s2) => {
  if (isUndefined(s2)) {
    return o2 ? o2[t2] : n2;
  }
  o2 && (isString$1(s2) || isNumber(s2)) && (o2[t2] = s2);
};
const attr = (t2, n2, o2) => {
  if (isUndefined(o2)) {
    return t2 ? t2.getAttribute(n2) : null;
  }
  t2 && t2.setAttribute(n2, o2);
};
const attrClass = (t2, n2, o2, s2) => {
  if (o2) {
    const e2 = attr(t2, n2) || "";
    const c2 = new Set(e2.split(" "));
    c2[s2 ? "add" : "delete"](o2);
    attr(t2, n2, from(c2).join(" ").trim());
  }
};
const hasAttrClass = (t2, n2, o2) => {
  const s2 = attr(t2, n2) || "";
  const e2 = new Set(s2.split(" "));
  return e2.has(o2);
};
const removeAttr = (t2, n2) => {
  t2 && t2.removeAttribute(n2);
};
const scrollLeft = (t2, n2) => getSetProp("scrollLeft", 0, t2, n2);
const scrollTop = (t2, n2) => getSetProp("scrollTop", 0, t2, n2);
const s = isClient() && Element.prototype;
const find$2 = (t2, n2) => {
  const o2 = [];
  const s2 = n2 ? isElement(n2) ? n2 : null : document;
  return s2 ? push(o2, s2.querySelectorAll(t2)) : o2;
};
const findFirst = (t2, n2) => {
  const o2 = n2 ? isElement(n2) ? n2 : null : document;
  return o2 ? o2.querySelector(t2) : null;
};
const is$1 = (t2, n2) => {
  if (isElement(t2)) {
    const o2 = s.matches || s.msMatchesSelector;
    return o2.call(t2, n2);
  }
  return false;
};
const contents = (t2) => t2 ? from(t2.childNodes) : [];
const parent$1 = (t2) => t2 ? t2.parentElement : null;
const closest = (t2, n2) => {
  if (isElement(t2)) {
    const o2 = s.closest;
    if (o2) {
      return o2.call(t2, n2);
    }
    do {
      if (is$1(t2, n2)) {
        return t2;
      }
      t2 = parent$1(t2);
    } while (t2);
  }
  return null;
};
const liesBetween = (t2, n2, o2) => {
  const s2 = t2 && closest(t2, n2);
  const e2 = t2 && findFirst(o2, s2);
  const c2 = closest(e2, n2) === s2;
  return s2 && e2 ? s2 === t2 || e2 === t2 || c2 && closest(closest(t2, o2), n2) !== s2 : false;
};
const before = (t2, n2, o2) => {
  if (o2 && t2) {
    let s2 = n2;
    let e2;
    if (isArrayLike(o2)) {
      e2 = document.createDocumentFragment();
      each(o2, (t3) => {
        if (t3 === s2) {
          s2 = t3.previousSibling;
        }
        e2.appendChild(t3);
      });
    } else {
      e2 = o2;
    }
    if (n2) {
      if (!s2) {
        s2 = t2.firstChild;
      } else if (s2 !== n2) {
        s2 = s2.nextSibling;
      }
    }
    t2.insertBefore(e2, s2 || null);
  }
};
const appendChildren = (t2, n2) => {
  before(t2, null, n2);
};
const insertBefore = (t2, n2) => {
  before(parent$1(t2), t2, n2);
};
const insertAfter = (t2, n2) => {
  before(parent$1(t2), t2 && t2.nextSibling, n2);
};
const removeElements = (t2) => {
  if (isArrayLike(t2)) {
    each(from(t2), (t3) => removeElements(t3));
  } else if (t2) {
    const n2 = parent$1(t2);
    if (n2) {
      n2.removeChild(t2);
    }
  }
};
const createDiv = (t2) => {
  const n2 = document.createElement("div");
  if (t2) {
    attr(n2, "class", t2);
  }
  return n2;
};
const createDOM = (t2) => {
  const n2 = createDiv();
  n2.innerHTML = t2.trim();
  return each(contents(n2), (t3) => removeElements(t3));
};
const firstLetterToUpper = (t2) => t2.charAt(0).toUpperCase() + t2.slice(1);
const getDummyStyle = () => createDiv().style;
const e = ["-webkit-", "-moz-", "-o-", "-ms-"];
const c = ["WebKit", "Moz", "O", "MS", "webkit", "moz", "o", "ms"];
const r = {};
const i = {};
const cssProperty = (t2) => {
  let n2 = i[t2];
  if (hasOwnProperty(i, t2)) {
    return n2;
  }
  const o2 = firstLetterToUpper(t2);
  const s2 = getDummyStyle();
  each(e, (e2) => {
    const c2 = e2.replace(/-/g, "");
    const r2 = [t2, e2 + t2, c2 + o2, firstLetterToUpper(c2) + o2];
    return !(n2 = r2.find((t3) => void 0 !== s2[t3]));
  });
  return i[t2] = n2 || "";
};
const jsAPI = (t2) => {
  if (isClient()) {
    let n2 = r[t2] || window[t2];
    if (hasOwnProperty(r, t2)) {
      return n2;
    }
    each(c, (o2) => {
      n2 = n2 || window[o2 + firstLetterToUpper(t2)];
      return !n2;
    });
    r[t2] = n2;
    return n2;
  }
};
const l$1 = jsAPI("MutationObserver");
const a = jsAPI("IntersectionObserver");
const u = jsAPI("ResizeObserver");
const d = jsAPI("cancelAnimationFrame");
const f = jsAPI("requestAnimationFrame");
const _ = isClient() && window.setTimeout;
const h = isClient() && window.clearTimeout;
const equal = (t2, n2, o2, s2) => {
  if (t2 && n2) {
    let e2 = true;
    each(o2, (o3) => {
      const c2 = s2 ? s2(t2[o3]) : t2[o3];
      const r2 = s2 ? s2(n2[o3]) : n2[o3];
      if (c2 !== r2) {
        e2 = false;
      }
    });
    return e2;
  }
  return false;
};
const equalWH = (t2, n2) => equal(t2, n2, ["w", "h"]);
const equalXY = (t2, n2) => equal(t2, n2, ["x", "y"]);
const equalTRBL = (t2, n2) => equal(t2, n2, ["t", "r", "b", "l"]);
const equalBCRWH = (t2, n2, o2) => equal(t2, n2, ["width", "height"], o2 && ((t3) => Math.round(t3)));
const noop$1 = () => {
};
const selfClearTimeout = (t2) => {
  let n2;
  const o2 = t2 ? _ : f;
  const s2 = t2 ? h : d;
  return [(e2) => {
    s2(n2);
    n2 = o2(e2, isFunction(t2) ? t2() : t2);
  }, () => s2(n2)];
};
const debounce = (t2, n2) => {
  let o2;
  let s2;
  let e2;
  let c2 = noop$1;
  const { g: r2, v: i2, p: l2 } = n2 || {};
  const a2 = function invokeFunctionToDebounce(n3) {
    c2();
    h(o2);
    o2 = s2 = void 0;
    c2 = noop$1;
    t2.apply(this, n3);
  };
  const mergeParms = (t3) => l2 && s2 ? l2(s2, t3) : t3;
  const flush = () => {
    if (c2 !== noop$1) {
      a2(mergeParms(e2) || e2);
    }
  };
  const u2 = function debouncedFn() {
    const t3 = from(arguments);
    const n3 = isFunction(r2) ? r2() : r2;
    const l3 = isNumber(n3) && n3 >= 0;
    if (l3) {
      const r3 = isFunction(i2) ? i2() : i2;
      const l4 = isNumber(r3) && r3 >= 0;
      const u3 = n3 > 0 ? _ : f;
      const g = n3 > 0 ? h : d;
      const v2 = mergeParms(t3);
      const w2 = v2 || t3;
      const p2 = a2.bind(0, w2);
      c2();
      const b2 = u3(p2, n3);
      c2 = () => g(b2);
      if (l4 && !o2) {
        o2 = _(flush, r3);
      }
      s2 = e2 = w2;
    } else {
      a2(t3);
    }
  };
  u2.m = flush;
  return u2;
};
const v$1 = /[^\x20\t\r\n\f]+/g;
const classListAction = (t2, n2, o2) => {
  const s2 = t2 && t2.classList;
  let e2;
  let c2 = 0;
  let r2 = false;
  if (s2 && n2 && isString$1(n2)) {
    const t3 = n2.match(v$1) || [];
    r2 = t3.length > 0;
    while (e2 = t3[c2++]) {
      r2 = !!o2(s2, e2) && r2;
    }
  }
  return r2;
};
const hasClass = (t2, n2) => classListAction(t2, n2, (t3, n3) => t3.contains(n3));
const removeClass = (t2, n2) => {
  classListAction(t2, n2, (t3, n3) => t3.remove(n3));
};
const addClass = (t2, n2) => {
  classListAction(t2, n2, (t3, n3) => t3.add(n3));
  return removeClass.bind(0, t2, n2);
};
const w$1 = {
  opacity: 1,
  zindex: 1
};
const parseToZeroOrNumber = (t2, n2) => {
  const o2 = n2 ? parseFloat(t2) : parseInt(t2, 10);
  return o2 === o2 ? o2 : 0;
};
const adaptCSSVal = (t2, n2) => !w$1[t2.toLowerCase()] && isNumber(n2) ? `${n2}px` : n2;
const getCSSVal = (t2, n2, o2) => null != n2 ? n2[o2] || n2.getPropertyValue(o2) : t2.style[o2];
const setCSSVal = (t2, n2, o2) => {
  try {
    const { style: s2 } = t2;
    if (!isUndefined(s2[n2])) {
      s2[n2] = adaptCSSVal(n2, o2);
    } else {
      s2.setProperty(n2, o2);
    }
  } catch (s2) {
  }
};
const directionIsRTL = (t2) => "rtl" === style(t2, "direction");
const topRightBottomLeft = (t2, n2, o2) => {
  const s2 = n2 ? `${n2}-` : "";
  const e2 = o2 ? `-${o2}` : "";
  const c2 = `${s2}top${e2}`;
  const r2 = `${s2}right${e2}`;
  const i2 = `${s2}bottom${e2}`;
  const l2 = `${s2}left${e2}`;
  const a2 = style(t2, [c2, r2, i2, l2]);
  return {
    t: parseToZeroOrNumber(a2[c2], true),
    r: parseToZeroOrNumber(a2[r2], true),
    b: parseToZeroOrNumber(a2[i2], true),
    l: parseToZeroOrNumber(a2[l2], true)
  };
};
const { round: p$1 } = Math;
const b = {
  w: 0,
  h: 0
};
const offsetSize = (t2) => t2 ? {
  w: t2.offsetWidth,
  h: t2.offsetHeight
} : b;
const clientSize = (t2) => t2 ? {
  w: t2.clientWidth,
  h: t2.clientHeight
} : b;
const scrollSize = (t2) => t2 ? {
  w: t2.scrollWidth,
  h: t2.scrollHeight
} : b;
const fractionalSize = (t2) => {
  const n2 = parseFloat(style(t2, "height")) || 0;
  const o2 = parseFloat(style(t2, "width")) || 0;
  return {
    w: o2 - p$1(o2),
    h: n2 - p$1(n2)
  };
};
const getBoundingClientRect = (t2) => t2.getBoundingClientRect();
let m;
const supportPassiveEvents = () => {
  if (isUndefined(m)) {
    m = false;
    try {
      window.addEventListener("test", null, Object.defineProperty({}, "passive", {
        get() {
          m = true;
        }
      }));
    } catch (t2) {
    }
  }
  return m;
};
const splitEventNames = (t2) => t2.split(" ");
const off = (t2, n2, o2, s2) => {
  each(splitEventNames(n2), (n3) => {
    t2.removeEventListener(n3, o2, s2);
  });
};
const on$1 = (t2, n2, o2, s2) => {
  var e2;
  const c2 = supportPassiveEvents();
  const r2 = null != (e2 = c2 && s2 && s2.S) ? e2 : c2;
  const i2 = s2 && s2.$ || false;
  const l2 = s2 && s2.C || false;
  const a2 = [];
  const u2 = c2 ? {
    passive: r2,
    capture: i2
  } : i2;
  each(splitEventNames(n2), (n3) => {
    const s3 = l2 ? (e3) => {
      t2.removeEventListener(n3, s3, i2);
      o2 && o2(e3);
    } : o2;
    push(a2, off.bind(null, t2, n3, s3, i2));
    t2.addEventListener(n3, s3, u2);
  });
  return runEachAndClear.bind(0, a2);
};
const stopPropagation = (t2) => t2.stopPropagation();
const preventDefault = (t2) => t2.preventDefault();
const y$1 = {
  x: 0,
  y: 0
};
const absoluteCoordinates = (t2) => {
  const n2 = t2 ? getBoundingClientRect(t2) : 0;
  return n2 ? {
    x: n2.left + window.pageYOffset,
    y: n2.top + window.pageXOffset
  } : y$1;
};
const manageListener = (t2, n2) => {
  each(isArray$2(n2) ? n2 : [n2], t2);
};
const createEventListenerHub = (t2) => {
  const n2 = /* @__PURE__ */ new Map();
  const removeEvent = (t3, o2) => {
    if (t3) {
      const s2 = n2.get(t3);
      manageListener((t4) => {
        if (s2) {
          s2[t4 ? "delete" : "clear"](t4);
        }
      }, o2);
    } else {
      n2.forEach((t4) => {
        t4.clear();
      });
      n2.clear();
    }
  };
  const addEvent = (t3, o2) => {
    if (isString$1(t3)) {
      const s3 = n2.get(t3) || /* @__PURE__ */ new Set();
      n2.set(t3, s3);
      manageListener((t4) => {
        isFunction(t4) && s3.add(t4);
      }, o2);
      return removeEvent.bind(0, t3, o2);
    }
    if (isBoolean(o2) && o2) {
      removeEvent();
    }
    const s2 = keys(t3);
    const e2 = [];
    each(s2, (n3) => {
      const o3 = t3[n3];
      o3 && push(e2, addEvent(n3, o3));
    });
    return runEachAndClear.bind(0, e2);
  };
  const triggerEvent = (t3, o2) => {
    const s2 = n2.get(t3);
    each(from(s2), (t4) => {
      if (o2 && !isEmptyArray(o2)) {
        t4.apply(0, o2);
      } else {
        t4();
      }
    });
  };
  addEvent(t2 || {});
  return [addEvent, removeEvent, triggerEvent];
};
const opsStringify = (t2) => JSON.stringify(t2, (t3, n2) => {
  if (isFunction(n2)) {
    throw new Error();
  }
  return n2;
});
const S$1 = {
  paddingAbsolute: false,
  showNativeOverlaidScrollbars: false,
  update: {
    elementEvents: [["img", "load"]],
    debounce: [0, 33],
    attributes: null,
    ignoreMutation: null
  },
  overflow: {
    x: "scroll",
    y: "scroll"
  },
  scrollbars: {
    theme: "os-theme-dark",
    visibility: "auto",
    autoHide: "never",
    autoHideDelay: 1300,
    dragScroll: true,
    clickScroll: false,
    pointers: ["mouse", "touch", "pen"]
  }
};
const getOptionsDiff = (t2, n2) => {
  const o2 = {};
  const s2 = keys(n2).concat(keys(t2));
  each(s2, (s3) => {
    const e2 = t2[s3];
    const c2 = n2[s3];
    if (isObject$2(e2) && isObject$2(c2)) {
      assignDeep(o2[s3] = {}, getOptionsDiff(e2, c2));
      if (isEmptyObject(o2[s3])) {
        delete o2[s3];
      }
    } else if (hasOwnProperty(n2, s3) && c2 !== e2) {
      let t3 = true;
      if (isArray$2(e2) || isArray$2(c2)) {
        try {
          if (opsStringify(e2) === opsStringify(c2)) {
            t3 = false;
          }
        } catch (r2) {
        }
      }
      if (t3) {
        o2[s3] = c2;
      }
    }
  });
  return o2;
};
const x$2 = "os-environment";
const $$1 = `${x$2}-flexbox-glue`;
const C$2 = `${$$1}-max`;
const O$2 = "data-overlayscrollbars";
const z$2 = "data-overlayscrollbars-initialize";
const T$1 = `${O$2}-overflow-x`;
const E$1 = `${O$2}-overflow-y`;
const I$1 = "overflowVisible";
const A$1 = "scrollbarHidden";
const L$2 = "updating";
const H$2 = "os-padding";
const M$2 = "os-viewport";
const P$1 = `${M$2}-arrange`;
const D$2 = "os-content";
const R$1 = `${M$2}-scrollbar-hidden`;
const k$2 = `os-overflow-visible`;
const B$2 = "os-size-observer";
const V$1 = `${B$2}-appear`;
const Y$2 = `${B$2}-listener`;
const F$2 = "os-trinsic-observer";
const G$1 = "os-theme-none";
const X$2 = "os-scrollbar";
const U$2 = `${X$2}-rtl`;
const W$2 = `${X$2}-horizontal`;
const Z$2 = `${X$2}-vertical`;
const J$2 = `${X$2}-track`;
const K$2 = `${X$2}-handle`;
const Q$2 = `${X$2}-visible`;
const tt$1 = `${X$2}-cornerless`;
const nt$1 = `${X$2}-transitionless`;
const ot = `${X$2}-interaction`;
const st$1 = `${X$2}-unusable`;
const et = `${X$2}-auto-hidden`;
const ct$1 = `${X$2}-wheel`;
const rt$1 = `${J$2}-interactive`;
const it$1 = `${K$2}-interactive`;
const lt$1 = {};
const getPlugins = () => lt$1;
const addPlugin = (t2) => {
  const n2 = [];
  each(isArray$2(t2) ? t2 : [t2], (t3) => {
    const o2 = keys(t3);
    each(o2, (o3) => {
      push(n2, lt$1[o3] = t3[o3]);
    });
  });
  return n2;
};
const vt = "__osOptionsValidationPlugin";
const bt$1 = "__osSizeObserverPlugin";
const $t$1 = "__osScrollbarsHidingPlugin";
const Ot = "__osClickScrollPlugin";
let Tt$1;
const getNativeScrollbarSize = (t2, n2, o2, s2) => {
  appendChildren(t2, n2);
  const e2 = clientSize(n2);
  const c2 = offsetSize(n2);
  const r2 = fractionalSize(o2);
  s2 && removeElements(n2);
  return {
    x: c2.h - e2.h + r2.h,
    y: c2.w - e2.w + r2.w
  };
};
const getNativeScrollbarsHiding = (t2) => {
  let n2 = false;
  const o2 = addClass(t2, R$1);
  try {
    n2 = "none" === style(t2, cssProperty("scrollbar-width")) || "none" === window.getComputedStyle(t2, "::-webkit-scrollbar").getPropertyValue("display");
  } catch (s2) {
  }
  o2();
  return n2;
};
const getRtlScrollBehavior = (t2, n2) => {
  const o2 = "hidden";
  style(t2, {
    overflowX: o2,
    overflowY: o2,
    direction: "rtl"
  });
  scrollLeft(t2, 0);
  const s2 = absoluteCoordinates(t2);
  const e2 = absoluteCoordinates(n2);
  scrollLeft(t2, -999);
  const c2 = absoluteCoordinates(n2);
  return {
    i: s2.x === e2.x,
    n: e2.x !== c2.x
  };
};
const getFlexboxGlue = (t2, n2) => {
  const o2 = addClass(t2, $$1);
  const s2 = getBoundingClientRect(t2);
  const e2 = getBoundingClientRect(n2);
  const c2 = equalBCRWH(e2, s2, true);
  const r2 = addClass(t2, C$2);
  const i2 = getBoundingClientRect(t2);
  const l2 = getBoundingClientRect(n2);
  const a2 = equalBCRWH(l2, i2, true);
  o2();
  r2();
  return c2 && a2;
};
const createEnvironment = () => {
  const { body: t2 } = document;
  const n2 = createDOM(`<div class="${x$2}"><div></div></div>`);
  const o2 = n2[0];
  const s2 = o2.firstChild;
  const [e2, , c2] = createEventListenerHub();
  const [r2, i2] = createCache({
    o: getNativeScrollbarSize(t2, o2, s2),
    u: equalXY
  }, getNativeScrollbarSize.bind(0, t2, o2, s2, true));
  const [l2] = i2();
  const a2 = getNativeScrollbarsHiding(o2);
  const u2 = {
    x: 0 === l2.x,
    y: 0 === l2.y
  };
  const d2 = {
    elements: {
      host: null,
      padding: !a2,
      viewport: (t3) => a2 && t3 === t3.ownerDocument.body && t3,
      content: false
    },
    scrollbars: {
      slot: true
    },
    cancel: {
      nativeScrollbarsOverlaid: false,
      body: null
    }
  };
  const f2 = assignDeep({}, S$1);
  const _2 = assignDeep.bind(0, {}, f2);
  const h2 = assignDeep.bind(0, {}, d2);
  const g = {
    k: l2,
    A: u2,
    I: a2,
    L: "-1" === style(o2, "zIndex"),
    B: getRtlScrollBehavior(o2, s2),
    V: getFlexboxGlue(o2, s2),
    Y: e2.bind(0, "z"),
    j: e2.bind(0, "r"),
    N: h2,
    q: (t3) => assignDeep(d2, t3) && h2(),
    F: _2,
    G: (t3) => assignDeep(f2, t3) && _2(),
    X: assignDeep({}, d2),
    U: assignDeep({}, f2)
  };
  const v2 = window.addEventListener;
  const w2 = debounce((t3) => c2(t3 ? "z" : "r"), {
    g: 33,
    v: 99
  });
  removeAttr(o2, "style");
  removeElements(o2);
  v2("resize", w2.bind(0, false));
  if (!a2 && (!u2.x || !u2.y)) {
    let t3;
    v2("resize", () => {
      const n3 = getPlugins()[$t$1];
      t3 = t3 || n3 && n3.R();
      t3 && t3(g, r2, w2.bind(0, true));
    });
  }
  return g;
};
const getEnvironment = () => {
  if (!Tt$1) {
    Tt$1 = createEnvironment();
  }
  return Tt$1;
};
const resolveInitialization = (t2, n2) => isFunction(n2) ? n2.apply(0, t2) : n2;
const staticInitializationElement = (t2, n2, o2, s2) => {
  const e2 = isUndefined(s2) ? o2 : s2;
  const c2 = resolveInitialization(t2, e2);
  return c2 || n2.apply(0, t2);
};
const dynamicInitializationElement = (t2, n2, o2, s2) => {
  const e2 = isUndefined(s2) ? o2 : s2;
  const c2 = resolveInitialization(t2, e2);
  return !!c2 && (isHTMLElement(c2) ? c2 : n2.apply(0, t2));
};
const cancelInitialization = (t2, n2, o2) => {
  const { nativeScrollbarsOverlaid: s2, body: e2 } = o2 || {};
  const { A: c2, I: r2 } = getEnvironment();
  const { nativeScrollbarsOverlaid: i2, body: l2 } = n2;
  const a2 = null != s2 ? s2 : i2;
  const u2 = isUndefined(e2) ? l2 : e2;
  const d2 = (c2.x || c2.y) && a2;
  const f2 = t2 && (isNull(u2) ? !r2 : u2);
  return !!d2 || !!f2;
};
const Et$1 = /* @__PURE__ */ new WeakMap();
const addInstance = (t2, n2) => {
  Et$1.set(t2, n2);
};
const removeInstance = (t2) => {
  Et$1.delete(t2);
};
const getInstance = (t2) => Et$1.get(t2);
const getPropByPath = (t2, n2) => t2 ? n2.split(".").reduce((t3, n3) => t3 && hasOwnProperty(t3, n3) ? t3[n3] : void 0, t2) : void 0;
const createOptionCheck = (t2, n2, o2) => (s2) => [getPropByPath(t2, s2), o2 || void 0 !== getPropByPath(n2, s2)];
const createState = (t2) => {
  let n2 = t2;
  return [() => n2, (t3) => {
    n2 = assignDeep({}, n2, t3);
  }];
};
const It$1 = "tabindex";
const At$1 = createDiv.bind(0, "");
const unwrap$1 = (t2) => {
  appendChildren(parent$1(t2), contents(t2));
  removeElements(t2);
};
const createStructureSetupElements = (t2) => {
  const n2 = getEnvironment();
  const { N: o2, I: s2 } = n2;
  const e2 = getPlugins()[$t$1];
  const c2 = e2 && e2.T;
  const { elements: r2 } = o2();
  const { host: i2, padding: l2, viewport: a2, content: u2 } = r2;
  const d2 = isHTMLElement(t2);
  const f2 = d2 ? {} : t2;
  const { elements: _2 } = f2;
  const { host: h2, padding: g, viewport: v2, content: w2 } = _2 || {};
  const p2 = d2 ? t2 : f2.target;
  const b2 = is$1(p2, "textarea");
  const m2 = p2.ownerDocument;
  const y2 = m2.documentElement;
  const S2 = p2 === m2.body;
  const x2 = m2.defaultView;
  const $2 = staticInitializationElement.bind(0, [p2]);
  const C2 = dynamicInitializationElement.bind(0, [p2]);
  const I2 = resolveInitialization.bind(0, [p2]);
  const A2 = $2.bind(0, At$1, a2);
  const L2 = C2.bind(0, At$1, u2);
  const P2 = A2(v2);
  const k2 = P2 === p2;
  const B2 = k2 && S2;
  const V2 = !k2 && L2(w2);
  const Y2 = !k2 && isHTMLElement(P2) && P2 === V2;
  const j2 = Y2 && !!I2(u2);
  const N2 = j2 ? A2() : P2;
  const q2 = j2 ? V2 : L2();
  const F2 = Y2 ? N2 : P2;
  const G2 = B2 ? y2 : F2;
  const X2 = b2 ? $2(At$1, i2, h2) : p2;
  const U2 = B2 ? G2 : X2;
  const W2 = Y2 ? q2 : V2;
  const Z2 = m2.activeElement;
  const J2 = !k2 && x2.top === x2 && Z2 === p2;
  const K2 = {
    W: p2,
    Z: U2,
    J: G2,
    K: !k2 && C2(At$1, l2, g),
    tt: W2,
    nt: !k2 && !s2 && c2 && c2(n2),
    ot: B2 ? y2 : G2,
    st: B2 ? m2 : G2,
    et: x2,
    ct: m2,
    rt: b2,
    it: S2,
    lt: d2,
    ut: k2,
    dt: Y2,
    ft: (t3, n3) => k2 ? hasAttrClass(G2, O$2, n3) : hasClass(G2, t3),
    _t: (t3, n3, o3) => k2 ? attrClass(G2, O$2, n3, o3) : (o3 ? addClass : removeClass)(G2, t3)
  };
  const Q2 = keys(K2).reduce((t3, n3) => {
    const o3 = K2[n3];
    return push(t3, o3 && !parent$1(o3) ? o3 : false);
  }, []);
  const elementIsGenerated = (t3) => t3 ? indexOf(Q2, t3) > -1 : null;
  const { W: tt2, Z: nt2, K: ot2, J: st2, tt: et2, nt: ct2 } = K2;
  const rt2 = [() => {
    removeAttr(nt2, O$2);
    removeAttr(nt2, z$2);
    removeAttr(tt2, z$2);
    if (S2) {
      removeAttr(y2, O$2);
      removeAttr(y2, z$2);
    }
  }];
  const it2 = b2 && elementIsGenerated(nt2);
  let lt2 = b2 ? tt2 : contents([et2, st2, ot2, nt2, tt2].find((t3) => false === elementIsGenerated(t3)));
  const at2 = B2 ? tt2 : et2 || st2;
  const appendElements = () => {
    attr(nt2, O$2, k2 ? "viewport" : "host");
    const t3 = addClass(ot2, H$2);
    const n3 = addClass(st2, !k2 && M$2);
    const o3 = addClass(et2, D$2);
    const e3 = S2 && !k2 ? addClass(parent$1(p2), R$1) : noop$1;
    if (it2) {
      insertAfter(tt2, nt2);
      push(rt2, () => {
        insertAfter(nt2, tt2);
        removeElements(nt2);
      });
    }
    appendChildren(at2, lt2);
    appendChildren(nt2, ot2);
    appendChildren(ot2 || nt2, !k2 && st2);
    appendChildren(st2, et2);
    push(rt2, () => {
      e3();
      removeAttr(st2, T$1);
      removeAttr(st2, E$1);
      if (elementIsGenerated(et2)) {
        unwrap$1(et2);
      }
      if (elementIsGenerated(st2)) {
        unwrap$1(st2);
      }
      if (elementIsGenerated(ot2)) {
        unwrap$1(ot2);
      }
      t3();
      n3();
      o3();
    });
    if (s2 && !k2) {
      push(rt2, removeClass.bind(0, st2, R$1));
    }
    if (ct2) {
      insertBefore(st2, ct2);
      push(rt2, removeElements.bind(0, ct2));
    }
    if (J2) {
      const t4 = attr(st2, It$1);
      attr(st2, It$1, "-1");
      st2.focus();
      const revertViewportTabIndex = () => t4 ? attr(st2, It$1, t4) : removeAttr(st2, It$1);
      const n4 = on$1(m2, "pointerdown keydown", () => {
        revertViewportTabIndex();
        n4();
      });
      push(rt2, [revertViewportTabIndex, n4]);
    } else if (Z2 && Z2.focus) {
      Z2.focus();
    }
    lt2 = 0;
  };
  return [K2, appendElements, runEachAndClear.bind(0, rt2)];
};
const createTrinsicUpdateSegment = (t2, n2) => {
  const { tt: o2 } = t2;
  const [s2] = n2;
  return (t3) => {
    const { V: n3 } = getEnvironment();
    const { ht: e2 } = s2();
    const { gt: c2 } = t3;
    const r2 = (o2 || !n3) && c2;
    if (r2) {
      style(o2, {
        height: e2 ? "" : "100%"
      });
    }
    return {
      vt: r2,
      wt: r2
    };
  };
};
const createPaddingUpdateSegment = (t2, n2) => {
  const [o2, s2] = n2;
  const { Z: e2, K: c2, J: r2, ut: i2 } = t2;
  const [l2, a2] = createCache({
    u: equalTRBL,
    o: topRightBottomLeft()
  }, topRightBottomLeft.bind(0, e2, "padding", ""));
  return (t3, n3, e3) => {
    let [u2, d2] = a2(e3);
    const { I: f2, V: _2 } = getEnvironment();
    const { bt: h2 } = o2();
    const { vt: g, wt: v2, yt: w2 } = t3;
    const [p2, b2] = n3("paddingAbsolute");
    const m2 = !_2 && v2;
    if (g || d2 || m2) {
      [u2, d2] = l2(e3);
    }
    const y2 = !i2 && (b2 || w2 || d2);
    if (y2) {
      const t4 = !p2 || !c2 && !f2;
      const n4 = u2.r + u2.l;
      const o3 = u2.t + u2.b;
      const e4 = {
        marginRight: t4 && !h2 ? -n4 : 0,
        marginBottom: t4 ? -o3 : 0,
        marginLeft: t4 && h2 ? -n4 : 0,
        top: t4 ? -u2.t : 0,
        right: t4 ? h2 ? -u2.r : "auto" : 0,
        left: t4 ? h2 ? "auto" : -u2.l : 0,
        width: t4 ? `calc(100% + ${n4}px)` : ""
      };
      const i3 = {
        paddingTop: t4 ? u2.t : 0,
        paddingRight: t4 ? u2.r : 0,
        paddingBottom: t4 ? u2.b : 0,
        paddingLeft: t4 ? u2.l : 0
      };
      style(c2 || r2, e4);
      style(r2, i3);
      s2({
        K: u2,
        St: !t4,
        M: c2 ? i3 : assignDeep({}, e4, i3)
      });
    }
    return {
      xt: y2
    };
  };
};
const { max: Lt$1 } = Math;
const Ht = Lt$1.bind(0, 0);
const Mt = "visible";
const Pt$1 = "hidden";
const Dt = 42;
const Rt$1 = {
  u: equalWH,
  o: {
    w: 0,
    h: 0
  }
};
const kt = {
  u: equalXY,
  o: {
    x: Pt$1,
    y: Pt$1
  }
};
const getOverflowAmount = (t2, n2) => {
  const o2 = window.devicePixelRatio % 1 !== 0 ? 1 : 0;
  const s2 = {
    w: Ht(t2.w - n2.w),
    h: Ht(t2.h - n2.h)
  };
  return {
    w: s2.w > o2 ? s2.w : 0,
    h: s2.h > o2 ? s2.h : 0
  };
};
const conditionalClass = (t2, n2, o2) => o2 ? addClass(t2, n2) : removeClass(t2, n2);
const overflowIsVisible = (t2) => 0 === t2.indexOf(Mt);
const createOverflowUpdateSegment = (t2, n2) => {
  const [o2, s2] = n2;
  const { Z: e2, K: c2, J: r2, nt: i2, ut: l2, _t: a2, it: u2, et: d2 } = t2;
  const { k: f2, V: _2, I: h2, A: g } = getEnvironment();
  const v2 = getPlugins()[$t$1];
  const w2 = !l2 && !h2 && (g.x || g.y);
  const p2 = u2 && l2;
  const [b2, m2] = createCache(Rt$1, fractionalSize.bind(0, r2));
  const [y2, S2] = createCache(Rt$1, scrollSize.bind(0, r2));
  const [x2, $2] = createCache(Rt$1);
  const [C2, z2] = createCache(Rt$1);
  const [L2] = createCache(kt);
  const fixFlexboxGlue = (t3, n3) => {
    style(r2, {
      height: ""
    });
    if (n3) {
      const { St: n4, K: s3 } = o2();
      const { $t: c3, P: i3 } = t3;
      const l3 = fractionalSize(e2);
      const a3 = clientSize(e2);
      const u3 = "content-box" === style(r2, "boxSizing");
      const d3 = n4 || u3 ? s3.b + s3.t : 0;
      const f3 = !(g.x && u3);
      style(r2, {
        height: a3.h + l3.h + (c3.x && f3 ? i3.x : 0) - d3
      });
    }
  };
  const getViewportOverflowState = (t3, n3) => {
    const o3 = !h2 && !t3 ? Dt : 0;
    const getStatePerAxis = (t4, s4, e4) => {
      const c4 = style(r2, t4);
      const i4 = n3 ? n3[t4] : c4;
      const l4 = "scroll" === i4;
      const a4 = s4 ? o3 : e4;
      const u4 = l4 && !h2 ? a4 : 0;
      const d4 = s4 && !!o3;
      return [c4, l4, u4, d4];
    };
    const [s3, e3, c3, i3] = getStatePerAxis("overflowX", g.x, f2.x);
    const [l3, a3, u3, d3] = getStatePerAxis("overflowY", g.y, f2.y);
    return {
      Ct: {
        x: s3,
        y: l3
      },
      $t: {
        x: e3,
        y: a3
      },
      P: {
        x: c3,
        y: u3
      },
      D: {
        x: i3,
        y: d3
      }
    };
  };
  const setViewportOverflowState = (t3, n3, o3, s3) => {
    const setAxisOverflowStyle = (t4, n4) => {
      const o4 = overflowIsVisible(t4);
      const s4 = n4 && o4 && t4.replace(`${Mt}-`, "") || "";
      return [n4 && !o4 ? t4 : "", overflowIsVisible(s4) ? "hidden" : s4];
    };
    const [e3, c3] = setAxisOverflowStyle(o3.x, n3.x);
    const [r3, i3] = setAxisOverflowStyle(o3.y, n3.y);
    s3.overflowX = c3 && r3 ? c3 : e3;
    s3.overflowY = i3 && e3 ? i3 : r3;
    return getViewportOverflowState(t3, s3);
  };
  const hideNativeScrollbars = (t3, n3, s3, e3) => {
    const { P: c3, D: r3 } = t3;
    const { x: i3, y: l3 } = r3;
    const { x: a3, y: u3 } = c3;
    const { M: d3 } = o2();
    const f3 = n3 ? "marginLeft" : "marginRight";
    const _3 = n3 ? "paddingLeft" : "paddingRight";
    const h3 = d3[f3];
    const g2 = d3.marginBottom;
    const v3 = d3[_3];
    const w3 = d3.paddingBottom;
    e3.width = `calc(100% + ${u3 + -1 * h3}px)`;
    e3[f3] = -u3 + h3;
    e3.marginBottom = -a3 + g2;
    if (s3) {
      e3[_3] = v3 + (l3 ? u3 : 0);
      e3.paddingBottom = w3 + (i3 ? a3 : 0);
    }
  };
  const [H2, M2] = v2 ? v2.H(w2, _2, r2, i2, o2, getViewportOverflowState, hideNativeScrollbars) : [() => w2, () => [noop$1]];
  return (t3, n3, i3) => {
    const { vt: u3, Ot: f3, wt: v3, xt: w3, gt: P2, yt: D2 } = t3;
    const { ht: B2, bt: V2 } = o2();
    const [Y2, j2] = n3("showNativeOverlaidScrollbars");
    const [N2, q2] = n3("overflow");
    const F2 = Y2 && g.x && g.y;
    const G2 = !l2 && !_2 && (u3 || v3 || f3 || j2 || P2);
    const X2 = overflowIsVisible(N2.x);
    const U2 = overflowIsVisible(N2.y);
    const W2 = X2 || U2;
    let Z2 = m2(i3);
    let J2 = S2(i3);
    let K2 = $2(i3);
    let Q2 = z2(i3);
    let tt2;
    if (j2 && h2) {
      a2(R$1, A$1, !F2);
    }
    if (G2) {
      tt2 = getViewportOverflowState(F2);
      fixFlexboxGlue(tt2, B2);
    }
    if (u3 || w3 || v3 || D2 || j2) {
      if (W2) {
        a2(k$2, I$1, false);
      }
      const [t4, n4] = M2(F2, V2, tt2);
      const [o3, s3] = Z2 = b2(i3);
      const [e3, c3] = J2 = y2(i3);
      const l3 = clientSize(r2);
      let u4 = e3;
      let f4 = l3;
      t4();
      if ((c3 || s3 || j2) && n4 && !F2 && H2(n4, e3, o3, V2)) {
        f4 = clientSize(r2);
        u4 = scrollSize(r2);
      }
      const _3 = {
        w: Ht(Lt$1(e3.w, u4.w) + o3.w),
        h: Ht(Lt$1(e3.h, u4.h) + o3.h)
      };
      const h3 = {
        w: Ht((p2 ? d2.innerWidth : f4.w + Ht(l3.w - e3.w)) + o3.w),
        h: Ht((p2 ? d2.innerHeight + o3.h : f4.h + Ht(l3.h - e3.h)) + o3.h)
      };
      Q2 = C2(h3);
      K2 = x2(getOverflowAmount(_3, h3), i3);
    }
    const [nt2, ot2] = Q2;
    const [st2, et2] = K2;
    const [ct2, rt2] = J2;
    const [it2, lt2] = Z2;
    const at2 = {
      x: st2.w > 0,
      y: st2.h > 0
    };
    const ut2 = X2 && U2 && (at2.x || at2.y) || X2 && at2.x && !at2.y || U2 && at2.y && !at2.x;
    if (w3 || D2 || lt2 || rt2 || ot2 || et2 || q2 || j2 || G2) {
      const t4 = {
        marginRight: 0,
        marginBottom: 0,
        marginLeft: 0,
        width: "",
        overflowY: "",
        overflowX: ""
      };
      const n4 = setViewportOverflowState(F2, at2, N2, t4);
      const o3 = H2(n4, ct2, it2, V2);
      if (!l2) {
        hideNativeScrollbars(n4, V2, o3, t4);
      }
      if (G2) {
        fixFlexboxGlue(n4, B2);
      }
      if (l2) {
        attr(e2, T$1, t4.overflowX);
        attr(e2, E$1, t4.overflowY);
      } else {
        style(r2, t4);
      }
    }
    attrClass(e2, O$2, I$1, ut2);
    conditionalClass(c2, k$2, ut2);
    !l2 && conditionalClass(r2, k$2, W2);
    const [dt2, ft2] = L2(getViewportOverflowState(F2).Ct);
    s2({
      Ct: dt2,
      zt: {
        x: nt2.w,
        y: nt2.h
      },
      Tt: {
        x: st2.w,
        y: st2.h
      },
      Et: at2
    });
    return {
      It: ft2,
      At: ot2,
      Lt: et2
    };
  };
};
const prepareUpdateHints = (t2, n2, o2) => {
  const s2 = {};
  const e2 = n2 || {};
  const c2 = keys(t2).concat(keys(e2));
  each(c2, (n3) => {
    const c3 = t2[n3];
    const r2 = e2[n3];
    s2[n3] = !!(o2 || c3 || r2);
  });
  return s2;
};
const createStructureSetupUpdate = (t2, n2) => {
  const { W: o2, J: s2, _t: e2, ut: c2 } = t2;
  const { I: r2, A: i2, V: l2 } = getEnvironment();
  const a2 = !r2 && (i2.x || i2.y);
  const u2 = [createTrinsicUpdateSegment(t2, n2), createPaddingUpdateSegment(t2, n2), createOverflowUpdateSegment(t2, n2)];
  return (t3, n3, r3) => {
    const i3 = prepareUpdateHints(assignDeep({
      vt: false,
      xt: false,
      yt: false,
      gt: false,
      At: false,
      Lt: false,
      It: false,
      Ot: false,
      wt: false
    }, n3), {}, r3);
    const d2 = a2 || !l2;
    const f2 = d2 && scrollLeft(s2);
    const _2 = d2 && scrollTop(s2);
    e2("", L$2, true);
    let h2 = i3;
    each(u2, (n4) => {
      h2 = prepareUpdateHints(h2, n4(h2, t3, !!r3) || {}, r3);
    });
    scrollLeft(s2, f2);
    scrollTop(s2, _2);
    e2("", L$2);
    if (!c2) {
      scrollLeft(o2, 0);
      scrollTop(o2, 0);
    }
    return h2;
  };
};
const createEventContentChange = (t2, n2, o2) => {
  let s2;
  let e2 = false;
  const destroy = () => {
    e2 = true;
  };
  const updateElements = (c2) => {
    if (o2) {
      const r2 = o2.reduce((n3, o3) => {
        if (o3) {
          const [s3, e3] = o3;
          const r3 = e3 && s3 && (c2 ? c2(s3) : find$2(s3, t2));
          if (r3 && r3.length && e3 && isString$1(e3)) {
            push(n3, [r3, e3.trim()], true);
          }
        }
        return n3;
      }, []);
      each(r2, (o3) => each(o3[0], (c3) => {
        const r3 = o3[1];
        const i2 = s2.get(c3) || [];
        const l2 = t2.contains(c3);
        if (l2) {
          const t3 = on$1(c3, r3, (o4) => {
            if (e2) {
              t3();
              s2.delete(c3);
            } else {
              n2(o4);
            }
          });
          s2.set(c3, push(i2, t3));
        } else {
          runEachAndClear(i2);
          s2.delete(c3);
        }
      }));
    }
  };
  if (o2) {
    s2 = /* @__PURE__ */ new WeakMap();
    updateElements();
  }
  return [destroy, updateElements];
};
const createDOMObserver = (t2, n2, o2, s2) => {
  let e2 = false;
  const { Ht: c2, Mt: r2, Pt: i2, Dt: a2, Rt: u2, kt: d2 } = s2 || {};
  const f2 = debounce(() => {
    if (e2) {
      o2(true);
    }
  }, {
    g: 33,
    v: 99
  });
  const [_2, h2] = createEventContentChange(t2, f2, i2);
  const g = c2 || [];
  const v2 = r2 || [];
  const w2 = g.concat(v2);
  const observerCallback = (e3, c3) => {
    const r3 = u2 || noop$1;
    const i3 = d2 || noop$1;
    const l2 = /* @__PURE__ */ new Set();
    const f3 = /* @__PURE__ */ new Set();
    let _3 = false;
    let g2 = false;
    each(e3, (o3) => {
      const { attributeName: e4, target: c4, type: u3, oldValue: d3, addedNodes: h3, removedNodes: w3 } = o3;
      const p3 = "attributes" === u3;
      const b2 = "childList" === u3;
      const m2 = t2 === c4;
      const y2 = p3 && isString$1(e4) ? attr(c4, e4) : 0;
      const S2 = 0 !== y2 && d3 !== y2;
      const x2 = indexOf(v2, e4) > -1 && S2;
      if (n2 && (b2 || !m2)) {
        const n3 = !p3;
        const u4 = p3 && S2;
        const f4 = u4 && a2 && is$1(c4, a2);
        const _4 = f4 ? !r3(c4, e4, d3, y2) : n3 || u4;
        const v3 = _4 && !i3(o3, !!f4, t2, s2);
        each(h3, (t3) => l2.add(t3));
        each(w3, (t3) => l2.add(t3));
        g2 = g2 || v3;
      }
      if (!n2 && m2 && S2 && !r3(c4, e4, d3, y2)) {
        f3.add(e4);
        _3 = _3 || x2;
      }
    });
    if (l2.size > 0) {
      h2((t3) => from(l2).reduce((n3, o3) => {
        push(n3, find$2(t3, o3));
        return is$1(o3, t3) ? push(n3, o3) : n3;
      }, []));
    }
    if (n2) {
      !c3 && g2 && o2(false);
      return [false];
    }
    if (f3.size > 0 || _3) {
      const t3 = [from(f3), _3];
      !c3 && o2.apply(0, t3);
      return t3;
    }
  };
  const p2 = new l$1((t3) => observerCallback(t3));
  p2.observe(t2, {
    attributes: true,
    attributeOldValue: true,
    attributeFilter: w2,
    subtree: n2,
    childList: n2,
    characterData: n2
  });
  e2 = true;
  return [() => {
    if (e2) {
      _2();
      p2.disconnect();
      e2 = false;
    }
  }, () => {
    if (e2) {
      f2.m();
      const t3 = p2.takeRecords();
      return !isEmptyArray(t3) && observerCallback(t3, true);
    }
  }];
};
const Bt$1 = 3333333;
const domRectHasDimensions = (t2) => t2 && (t2.height || t2.width);
const createSizeObserver = (t2, n2, o2) => {
  const { Bt: s2 = false, Vt: e2 = false } = o2 || {};
  const c2 = getPlugins()[bt$1];
  const { B: r2 } = getEnvironment();
  const i2 = createDOM(`<div class="${B$2}"><div class="${Y$2}"></div></div>`);
  const l2 = i2[0];
  const a2 = l2.firstChild;
  const d2 = directionIsRTL.bind(0, t2);
  const [f2] = createCache({
    o: void 0,
    _: true,
    u: (t3, n3) => !(!t3 || !domRectHasDimensions(t3) && domRectHasDimensions(n3))
  });
  const onSizeChangedCallbackProxy = (t3) => {
    const o3 = isArray$2(t3) && t3.length > 0 && isObject$2(t3[0]);
    const e3 = !o3 && isBoolean(t3[0]);
    let c3 = false;
    let i3 = false;
    let a3 = true;
    if (o3) {
      const [n3, , o4] = f2(t3.pop().contentRect);
      const s3 = domRectHasDimensions(n3);
      const e4 = domRectHasDimensions(o4);
      c3 = !o4 || !s3;
      i3 = !e4 && s3;
      a3 = !c3;
    } else if (e3) {
      [, a3] = t3;
    } else {
      i3 = true === t3;
    }
    if (s2 && a3) {
      const n3 = e3 ? t3[0] : directionIsRTL(l2);
      scrollLeft(l2, n3 ? r2.n ? -Bt$1 : r2.i ? 0 : Bt$1 : Bt$1);
      scrollTop(l2, Bt$1);
    }
    if (!c3) {
      n2({
        vt: !e3,
        Yt: e3 ? t3 : void 0,
        Vt: !!i3
      });
    }
  };
  const _2 = [];
  let h2 = e2 ? onSizeChangedCallbackProxy : false;
  return [() => {
    runEachAndClear(_2);
    removeElements(l2);
  }, () => {
    if (u) {
      const t3 = new u(onSizeChangedCallbackProxy);
      t3.observe(a2);
      push(_2, () => {
        t3.disconnect();
      });
    } else if (c2) {
      const [t3, n3] = c2.O(a2, onSizeChangedCallbackProxy, e2);
      h2 = t3;
      push(_2, n3);
    }
    if (s2) {
      const [t3] = createCache({
        o: !d2()
      }, d2);
      push(_2, on$1(l2, "scroll", (n3) => {
        const o3 = t3();
        const [s3, e3] = o3;
        if (e3) {
          removeClass(a2, "ltr rtl");
          if (s3) {
            addClass(a2, "rtl");
          } else {
            addClass(a2, "ltr");
          }
          onSizeChangedCallbackProxy(o3);
        }
        stopPropagation(n3);
      }));
    }
    if (h2) {
      addClass(l2, V$1);
      push(_2, on$1(l2, "animationstart", h2, {
        C: !!u
      }));
    }
    if (u || c2) {
      appendChildren(t2, l2);
    }
  }];
};
const isHeightIntrinsic = (t2) => 0 === t2.h || t2.isIntersecting || t2.intersectionRatio > 0;
const createTrinsicObserver = (t2, n2) => {
  let o2;
  const s2 = createDiv(F$2);
  const e2 = [];
  const [c2] = createCache({
    o: false
  });
  const triggerOnTrinsicChangedCallback = (t3, o3) => {
    if (t3) {
      const s3 = c2(isHeightIntrinsic(t3));
      const [, e3] = s3;
      if (e3) {
        !o3 && n2(s3);
        return [s3];
      }
    }
  };
  const intersectionObserverCallback = (t3, n3) => {
    if (t3 && t3.length > 0) {
      return triggerOnTrinsicChangedCallback(t3.pop(), n3);
    }
  };
  return [() => {
    runEachAndClear(e2);
    removeElements(s2);
  }, () => {
    if (a) {
      o2 = new a((t3) => intersectionObserverCallback(t3), {
        root: t2
      });
      o2.observe(s2);
      push(e2, () => {
        o2.disconnect();
      });
    } else {
      const onSizeChanged = () => {
        const t4 = offsetSize(s2);
        triggerOnTrinsicChangedCallback(t4);
      };
      const [t3, n3] = createSizeObserver(s2, onSizeChanged);
      push(e2, t3);
      n3();
      onSizeChanged();
    }
    appendChildren(t2, s2);
  }, () => {
    if (o2) {
      return intersectionObserverCallback(o2.takeRecords(), true);
    }
  }];
};
const Vt = `[${O$2}]`;
const Yt$1 = `.${M$2}`;
const jt$1 = ["tabindex"];
const Nt = ["wrap", "cols", "rows"];
const qt$1 = ["id", "class", "style", "open"];
const createStructureSetupObservers = (t2, n2, o2) => {
  let s2;
  let e2;
  let c2;
  const { Z: r2, J: i2, tt: l2, rt: a2, ut: d2, ft: f2, _t: _2 } = t2;
  const { V: h2 } = getEnvironment();
  const [g] = createCache({
    u: equalWH,
    o: {
      w: 0,
      h: 0
    }
  }, () => {
    const t3 = f2(k$2, I$1);
    const n3 = f2(P$1, "");
    const o3 = n3 && scrollLeft(i2);
    const s3 = n3 && scrollTop(i2);
    _2(k$2, I$1);
    _2(P$1, "");
    _2("", L$2, true);
    const e3 = scrollSize(l2);
    const c3 = scrollSize(i2);
    const r3 = fractionalSize(i2);
    _2(k$2, I$1, t3);
    _2(P$1, "", n3);
    _2("", L$2);
    scrollLeft(i2, o3);
    scrollTop(i2, s3);
    return {
      w: c3.w + e3.w + r3.w,
      h: c3.h + e3.h + r3.h
    };
  });
  const v2 = a2 ? Nt : qt$1.concat(Nt);
  const w2 = debounce(o2, {
    g: () => s2,
    v: () => e2,
    p(t3, n3) {
      const [o3] = t3;
      const [s3] = n3;
      return [keys(o3).concat(keys(s3)).reduce((t4, n4) => {
        t4[n4] = o3[n4] || s3[n4];
        return t4;
      }, {})];
    }
  });
  const updateViewportAttrsFromHost = (t3) => {
    each(t3 || jt$1, (t4) => {
      if (indexOf(jt$1, t4) > -1) {
        const n3 = attr(r2, t4);
        if (isString$1(n3)) {
          attr(i2, t4, n3);
        } else {
          removeAttr(i2, t4);
        }
      }
    });
  };
  const onTrinsicChanged = (t3, s3) => {
    const [e3, c3] = t3;
    const r3 = {
      gt: c3
    };
    n2({
      ht: e3
    });
    !s3 && o2(r3);
    return r3;
  };
  const onSizeChanged = ({ vt: t3, Yt: s3, Vt: e3 }) => {
    const c3 = !t3 || e3 ? o2 : w2;
    let r3 = false;
    if (s3) {
      const [t4, o3] = s3;
      r3 = o3;
      n2({
        bt: t4
      });
    }
    c3({
      vt: t3,
      yt: r3
    });
  };
  const onContentMutation = (t3, n3) => {
    const [, s3] = g();
    const e3 = {
      wt: s3
    };
    const c3 = t3 ? o2 : w2;
    if (s3) {
      !n3 && c3(e3);
    }
    return e3;
  };
  const onHostMutation = (t3, n3, o3) => {
    const s3 = {
      Ot: n3
    };
    if (n3) {
      !o3 && w2(s3);
    } else if (!d2) {
      updateViewportAttrsFromHost(t3);
    }
    return s3;
  };
  const [p2, b2, m2] = l2 || !h2 ? createTrinsicObserver(r2, onTrinsicChanged) : [noop$1, noop$1, noop$1];
  const [y2, S2] = !d2 ? createSizeObserver(r2, onSizeChanged, {
    Vt: true,
    Bt: true
  }) : [noop$1, noop$1];
  const [x2, $2] = createDOMObserver(r2, false, onHostMutation, {
    Mt: qt$1,
    Ht: qt$1.concat(jt$1)
  });
  const C2 = d2 && u && new u(onSizeChanged.bind(0, {
    vt: true
  }));
  C2 && C2.observe(r2);
  updateViewportAttrsFromHost();
  return [() => {
    p2();
    y2();
    c2 && c2[0]();
    C2 && C2.disconnect();
    x2();
  }, () => {
    S2();
    b2();
  }, () => {
    const t3 = {};
    const n3 = $2();
    const o3 = m2();
    const s3 = c2 && c2[1]();
    if (n3) {
      assignDeep(t3, onHostMutation.apply(0, push(n3, true)));
    }
    if (o3) {
      assignDeep(t3, onTrinsicChanged.apply(0, push(o3, true)));
    }
    if (s3) {
      assignDeep(t3, onContentMutation.apply(0, push(s3, true)));
    }
    return t3;
  }, (t3) => {
    const [n3] = t3("update.ignoreMutation");
    const [o3, r3] = t3("update.attributes");
    const [a3, u2] = t3("update.elementEvents");
    const [f3, _3] = t3("update.debounce");
    const h3 = u2 || r3;
    const ignoreMutationFromOptions = (t4) => isFunction(n3) && n3(t4);
    if (h3) {
      if (c2) {
        c2[1]();
        c2[0]();
      }
      c2 = createDOMObserver(l2 || i2, true, onContentMutation, {
        Ht: v2.concat(o3 || []),
        Pt: a3,
        Dt: Vt,
        kt: (t4, n4) => {
          const { target: o4, attributeName: s3 } = t4;
          const e3 = !n4 && s3 && !d2 ? liesBetween(o4, Vt, Yt$1) : false;
          return e3 || !!closest(o4, `.${X$2}`) || !!ignoreMutationFromOptions(t4);
        }
      });
    }
    if (_3) {
      w2.m();
      if (isArray$2(f3)) {
        const t4 = f3[0];
        const n4 = f3[1];
        s2 = isNumber(t4) && t4;
        e2 = isNumber(n4) && n4;
      } else if (isNumber(f3)) {
        s2 = f3;
        e2 = false;
      } else {
        s2 = false;
        e2 = false;
      }
    }
  }];
};
const Ft = {
  x: 0,
  y: 0
};
const Gt$1 = {
  K: {
    t: 0,
    r: 0,
    b: 0,
    l: 0
  },
  St: false,
  M: {
    marginRight: 0,
    marginBottom: 0,
    marginLeft: 0,
    paddingTop: 0,
    paddingRight: 0,
    paddingBottom: 0,
    paddingLeft: 0
  },
  zt: Ft,
  Tt: Ft,
  Ct: {
    x: "hidden",
    y: "hidden"
  },
  Et: {
    x: false,
    y: false
  },
  ht: false,
  bt: false
};
const createStructureSetup = (t2, n2) => {
  const o2 = createOptionCheck(n2, {});
  const s2 = createState(Gt$1);
  const [e2, c2, r2] = createEventListenerHub();
  const [i2, l2] = s2;
  const [a2, u2, d2] = createStructureSetupElements(t2);
  const f2 = createStructureSetupUpdate(a2, s2);
  const triggerUpdateEvent = (t3, n3, o3) => {
    const s3 = keys(t3).some((n4) => t3[n4]);
    const e3 = s3 || !isEmptyObject(n3) || o3;
    if (e3) {
      r2("u", [t3, n3, o3]);
    }
    return e3;
  };
  const [_2, h2, g, v2] = createStructureSetupObservers(a2, l2, (t3) => triggerUpdateEvent(f2(o2, t3), {}, false));
  const w2 = i2.bind(0);
  w2.jt = (t3) => e2("u", t3);
  w2.Nt = () => {
    const { W: t3, J: n3 } = a2;
    const o3 = scrollLeft(t3);
    const s3 = scrollTop(t3);
    h2();
    u2();
    scrollLeft(n3, o3);
    scrollTop(n3, s3);
  };
  w2.qt = a2;
  return [(t3, o3) => {
    const s3 = createOptionCheck(n2, t3, o3);
    v2(s3);
    return triggerUpdateEvent(f2(s3, g(), o3), t3, !!o3);
  }, w2, () => {
    c2();
    _2();
    d2();
  }];
};
const { round: Xt$1 } = Math;
const getScale = (t2) => {
  const { width: n2, height: o2 } = getBoundingClientRect(t2);
  const { w: s2, h: e2 } = offsetSize(t2);
  return {
    x: Xt$1(n2) / s2 || 1,
    y: Xt$1(o2) / e2 || 1
  };
};
const continuePointerDown = (t2, n2, o2) => {
  const s2 = n2.scrollbars;
  const { button: e2, isPrimary: c2, pointerType: r2 } = t2;
  const { pointers: i2 } = s2;
  return 0 === e2 && c2 && s2[o2 ? "dragScroll" : "clickScroll"] && (i2 || []).includes(r2);
};
const createRootClickStopPropagationEvents = (t2, n2) => on$1(t2, "mousedown", on$1.bind(0, n2, "click", stopPropagation, {
  C: true,
  $: true
}), {
  $: true
});
const createInteractiveScrollEvents = (t2, n2, o2, s2, e2, c2) => {
  const { B: r2 } = getEnvironment();
  const { Ft: i2, Gt: l2, Xt: a2 } = o2;
  const u2 = `scroll${c2 ? "Left" : "Top"}`;
  const d2 = `client${c2 ? "X" : "Y"}`;
  const f2 = c2 ? "width" : "height";
  const _2 = c2 ? "left" : "top";
  const h2 = c2 ? "w" : "h";
  const g = c2 ? "x" : "y";
  const createRelativeHandleMove = (t3, n3) => (o3) => {
    const { Tt: d3 } = e2();
    const f3 = offsetSize(l2)[h2] - offsetSize(i2)[h2];
    const _3 = n3 * o3 / f3;
    const v2 = _3 * d3[g];
    const w2 = directionIsRTL(a2);
    const p2 = w2 && c2 ? r2.n || r2.i ? 1 : -1 : 1;
    s2[u2] = t3 + v2 * p2;
  };
  return on$1(l2, "pointerdown", (o3) => {
    const e3 = closest(o3.target, `.${K$2}`) === i2;
    if (continuePointerDown(o3, t2, e3)) {
      const t3 = !e3 && o3.shiftKey;
      const getHandleRect = () => getBoundingClientRect(i2);
      const getTrackRect = () => getBoundingClientRect(l2);
      const getHandleOffset = (t4, n3) => (t4 || getHandleRect())[_2] - (n3 || getTrackRect())[_2];
      const c3 = createRelativeHandleMove(s2[u2] || 0, 1 / getScale(s2)[g]);
      const r3 = o3[d2];
      const a3 = getHandleRect();
      const h3 = getTrackRect();
      const v2 = a3[f2];
      const w2 = getHandleOffset(a3, h3) + v2 / 2;
      const p2 = r3 - h3[_2];
      const b2 = e3 ? 0 : p2 - w2;
      const m2 = [on$1(n2, "selectstart", (t4) => preventDefault(t4), {
        S: false
      }), on$1(l2, "pointermove", (n3) => {
        const o4 = n3[d2] - r3;
        if (e3 || t3) {
          c3(b2 + o4);
        }
      })];
      if (t3) {
        c3(b2);
      } else if (!e3) {
        const t4 = getPlugins()[Ot];
        if (t4) {
          push(m2, t4.O(c3, getHandleOffset, b2, v2, p2));
        }
      }
      on$1(l2, "pointerup", (t4) => {
        runEachAndClear(m2);
        l2.releasePointerCapture(t4.pointerId);
      }, {
        C: true
      });
      l2.setPointerCapture(o3.pointerId);
    }
  });
};
const createScrollbarsSetupEvents = (t2, n2) => (o2, s2, e2, c2, r2, i2) => {
  const { Xt: l2 } = o2;
  const [a2, u2] = selfClearTimeout(333);
  const d2 = !!r2.scrollBy;
  let f2 = true;
  return runEachAndClear.bind(0, [on$1(l2, "pointerenter", () => {
    s2(ot, true);
  }), on$1(l2, "pointerleave pointercancel", () => {
    s2(ot);
  }), on$1(l2, "wheel", (t3) => {
    const { deltaX: n3, deltaY: o3, deltaMode: e3 } = t3;
    if (d2 && f2 && 0 === e3 && parent$1(l2) === c2) {
      r2.scrollBy({
        left: n3,
        top: o3,
        behavior: "smooth"
      });
    }
    f2 = false;
    s2(ct$1, true);
    a2(() => {
      f2 = true;
      s2(ct$1);
    });
    preventDefault(t3);
  }, {
    S: false,
    $: true
  }), createRootClickStopPropagationEvents(l2, e2), createInteractiveScrollEvents(t2, e2, o2, r2, n2, i2), u2]);
};
const { min: Ut$1, max: Wt, abs: Zt$1, round: Jt$1 } = Math;
const getScrollbarHandleLengthRatio = (t2, n2, o2, s2) => {
  if (s2) {
    const t3 = o2 ? "x" : "y";
    const { Tt: n3, zt: e3 } = s2;
    const c3 = e3[t3];
    const r3 = n3[t3];
    return Wt(0, Ut$1(1, c3 / (c3 + r3)));
  }
  const e2 = o2 ? "w" : "h";
  const c2 = offsetSize(t2)[e2];
  const r2 = offsetSize(n2)[e2];
  return Wt(0, Ut$1(1, c2 / r2));
};
const getScrollbarHandleOffsetRatio = (t2, n2, o2, s2, e2, c2) => {
  const { B: r2 } = getEnvironment();
  const i2 = c2 ? "x" : "y";
  const l2 = c2 ? "Left" : "Top";
  const { Tt: a2 } = s2;
  const u2 = Jt$1(a2[i2]);
  const d2 = Zt$1(o2[`scroll${l2}`]);
  const f2 = c2 && e2;
  const _2 = r2.i ? d2 : u2 - d2;
  const h2 = f2 ? _2 : d2;
  const g = Ut$1(1, h2 / u2);
  const v2 = getScrollbarHandleLengthRatio(t2, n2, c2);
  return 1 / v2 * (1 - v2) * g;
};
const createScrollbarsSetupElements = (t2, n2, o2) => {
  const { N: s2 } = getEnvironment();
  const { scrollbars: e2 } = s2();
  const { slot: c2 } = e2;
  const { ct: r2, W: i2, Z: l2, J: a2, lt: u2, ot: d2, it: f2, ut: h2 } = n2;
  const { scrollbars: g } = u2 ? {} : t2;
  const { slot: v2 } = g || {};
  const w2 = dynamicInitializationElement([i2, l2, a2], () => h2 && f2 ? i2 : l2, c2, v2);
  const scrollbarStructureAddRemoveClass = (t3, n3, o3) => {
    const s3 = o3 ? addClass : removeClass;
    each(t3, (t4) => {
      s3(t4.Xt, n3);
    });
  };
  const scrollbarsHandleStyle = (t3, n3) => {
    each(t3, (t4) => {
      const [o3, s3] = n3(t4);
      style(o3, s3);
    });
  };
  const scrollbarStructureRefreshHandleLength = (t3, n3, o3) => {
    scrollbarsHandleStyle(t3, (t4) => {
      const { Ft: s3, Gt: e3 } = t4;
      return [s3, {
        [o3 ? "width" : "height"]: `${(100 * getScrollbarHandleLengthRatio(s3, e3, o3, n3)).toFixed(3)}%`
      }];
    });
  };
  const scrollbarStructureRefreshHandleOffset = (t3, n3, o3) => {
    const s3 = o3 ? "X" : "Y";
    scrollbarsHandleStyle(t3, (t4) => {
      const { Ft: e3, Gt: c3, Xt: r3 } = t4;
      const i3 = getScrollbarHandleOffsetRatio(e3, c3, d2, n3, directionIsRTL(r3), o3);
      const l3 = i3 === i3;
      return [e3, {
        transform: l3 ? `translate${s3}(${(100 * i3).toFixed(3)}%)` : ""
      }];
    });
  };
  const p2 = [];
  const b2 = [];
  const m2 = [];
  const scrollbarsAddRemoveClass = (t3, n3, o3) => {
    const s3 = isBoolean(o3);
    const e3 = s3 ? o3 : true;
    const c3 = s3 ? !o3 : true;
    e3 && scrollbarStructureAddRemoveClass(b2, t3, n3);
    c3 && scrollbarStructureAddRemoveClass(m2, t3, n3);
  };
  const refreshScrollbarsHandleLength = (t3) => {
    scrollbarStructureRefreshHandleLength(b2, t3, true);
    scrollbarStructureRefreshHandleLength(m2, t3);
  };
  const refreshScrollbarsHandleOffset = (t3) => {
    scrollbarStructureRefreshHandleOffset(b2, t3, true);
    scrollbarStructureRefreshHandleOffset(m2, t3);
  };
  const generateScrollbarDOM = (t3) => {
    const n3 = t3 ? W$2 : Z$2;
    const s3 = t3 ? b2 : m2;
    const e3 = isEmptyArray(s3) ? nt$1 : "";
    const c3 = createDiv(`${X$2} ${n3} ${e3}`);
    const i3 = createDiv(J$2);
    const a3 = createDiv(K$2);
    const u3 = {
      Xt: c3,
      Gt: i3,
      Ft: a3
    };
    appendChildren(c3, i3);
    appendChildren(i3, a3);
    push(s3, u3);
    push(p2, [removeElements.bind(0, c3), o2(u3, scrollbarsAddRemoveClass, r2, l2, d2, t3)]);
    return u3;
  };
  const y2 = generateScrollbarDOM.bind(0, true);
  const S2 = generateScrollbarDOM.bind(0, false);
  const appendElements = () => {
    appendChildren(w2, b2[0].Xt);
    appendChildren(w2, m2[0].Xt);
    _(() => {
      scrollbarsAddRemoveClass(nt$1);
    }, 300);
  };
  y2();
  S2();
  return [{
    Ut: refreshScrollbarsHandleLength,
    Wt: refreshScrollbarsHandleOffset,
    Zt: scrollbarsAddRemoveClass,
    Jt: {
      Kt: b2,
      Qt: y2,
      tn: scrollbarsHandleStyle.bind(0, b2)
    },
    nn: {
      Kt: m2,
      Qt: S2,
      tn: scrollbarsHandleStyle.bind(0, m2)
    }
  }, appendElements, runEachAndClear.bind(0, p2)];
};
const createScrollbarsSetup = (t2, n2, o2, s2) => {
  let e2;
  let c2;
  let r2;
  let i2;
  let l2;
  let a2 = 0;
  const u2 = createState({});
  const [d2] = u2;
  const [f2, _2] = selfClearTimeout();
  const [h2, g] = selfClearTimeout();
  const [v2, w2] = selfClearTimeout(100);
  const [p2, b2] = selfClearTimeout(100);
  const [m2, y2] = selfClearTimeout(() => a2);
  const [S2, x2, $2] = createScrollbarsSetupElements(t2, o2.qt, createScrollbarsSetupEvents(n2, o2));
  const { Z: C2, J: O2, ot: z2, st: T2, ut: E2, it: I2 } = o2.qt;
  const { Jt: A2, nn: L2, Zt: H2, Ut: M2, Wt: P2 } = S2;
  const { tn: D2 } = A2;
  const { tn: R2 } = L2;
  const styleScrollbarPosition = (t3) => {
    const { Xt: n3 } = t3;
    const o3 = E2 && !I2 && parent$1(n3) === O2 && n3;
    return [o3, {
      transform: o3 ? `translate(${scrollLeft(z2)}px, ${scrollTop(z2)}px)` : ""
    }];
  };
  const manageScrollbarsAutoHide = (t3, n3) => {
    y2();
    if (t3) {
      H2(et);
    } else {
      const hide = () => H2(et, true);
      if (a2 > 0 && !n3) {
        m2(hide);
      } else {
        hide();
      }
    }
  };
  const onHostMouseEnter = () => {
    i2 = c2;
    i2 && manageScrollbarsAutoHide(true);
  };
  const k2 = [w2, y2, b2, g, _2, $2, on$1(C2, "pointerover", onHostMouseEnter, {
    C: true
  }), on$1(C2, "pointerenter", onHostMouseEnter), on$1(C2, "pointerleave", () => {
    i2 = false;
    c2 && manageScrollbarsAutoHide(false);
  }), on$1(C2, "pointermove", () => {
    e2 && f2(() => {
      w2();
      manageScrollbarsAutoHide(true);
      p2(() => {
        e2 && manageScrollbarsAutoHide(false);
      });
    });
  }), on$1(T2, "scroll", (t3) => {
    h2(() => {
      P2(o2());
      r2 && manageScrollbarsAutoHide(true);
      v2(() => {
        r2 && !i2 && manageScrollbarsAutoHide(false);
      });
    });
    s2(t3);
    E2 && D2(styleScrollbarPosition);
    E2 && R2(styleScrollbarPosition);
  })];
  const B2 = d2.bind(0);
  B2.qt = S2;
  B2.Nt = x2;
  return [(t3, s3, i3) => {
    const { At: u3, Lt: d3, It: f3, yt: _3 } = i3;
    const { A: h3 } = getEnvironment();
    const g2 = createOptionCheck(n2, t3, s3);
    const v3 = o2();
    const { Tt: w3, Ct: p3, bt: b3 } = v3;
    const [m3, y3] = g2("showNativeOverlaidScrollbars");
    const [S3, x3] = g2("scrollbars.theme");
    const [$3, C3] = g2("scrollbars.visibility");
    const [O3, z3] = g2("scrollbars.autoHide");
    const [T3] = g2("scrollbars.autoHideDelay");
    const [E3, A3] = g2("scrollbars.dragScroll");
    const [L3, D3] = g2("scrollbars.clickScroll");
    const R3 = u3 || d3 || _3;
    const k3 = f3 || C3;
    const B3 = m3 && h3.x && h3.y;
    const setScrollbarVisibility = (t4, n3) => {
      const o3 = "visible" === $3 || "auto" === $3 && "scroll" === t4;
      H2(Q$2, o3, n3);
      return o3;
    };
    a2 = T3;
    if (y3) {
      H2(G$1, B3);
    }
    if (x3) {
      H2(l2);
      H2(S3, true);
      l2 = S3;
    }
    if (z3) {
      e2 = "move" === O3;
      c2 = "leave" === O3;
      r2 = "never" !== O3;
      manageScrollbarsAutoHide(!r2, true);
    }
    if (A3) {
      H2(it$1, E3);
    }
    if (D3) {
      H2(rt$1, L3);
    }
    if (k3) {
      const t4 = setScrollbarVisibility(p3.x, true);
      const n3 = setScrollbarVisibility(p3.y, false);
      const o3 = t4 && n3;
      H2(tt$1, !o3);
    }
    if (R3) {
      M2(v3);
      P2(v3);
      H2(st$1, !w3.x, true);
      H2(st$1, !w3.y, false);
      H2(U$2, b3 && !I2);
    }
  }, B2, runEachAndClear.bind(0, k2)];
};
const invokePluginInstance = (t2, n2, o2) => {
  if (isFunction(t2)) {
    t2(n2 || void 0, o2 || void 0);
  }
};
const OverlayScrollbars = (t2, n2, o2) => {
  const { F: s2, N: e2, Y: c2, j: r2 } = getEnvironment();
  const i2 = getPlugins();
  const l2 = isHTMLElement(t2);
  const a2 = l2 ? t2 : t2.target;
  const u2 = getInstance(a2);
  if (n2 && !u2) {
    let u3 = false;
    const validateOptions = (t3) => {
      const n3 = getPlugins()[vt];
      const o3 = n3 && n3.O;
      return o3 ? o3(t3, true) : t3;
    };
    const d2 = assignDeep({}, s2(), validateOptions(n2));
    const [f2, _2, h2] = createEventListenerHub(o2);
    const [g, v2, w2] = createStructureSetup(t2, d2);
    const [p2, b2, m2] = createScrollbarsSetup(t2, d2, v2, (t3) => h2("scroll", [$2, t3]));
    const update3 = (t3, n3) => g(t3, !!n3);
    const y2 = update3.bind(0, {}, true);
    const S2 = c2(y2);
    const x2 = r2(y2);
    const destroy = (t3) => {
      removeInstance(a2);
      S2();
      x2();
      m2();
      w2();
      u3 = true;
      h2("destroyed", [$2, !!t3]);
      _2();
    };
    const $2 = {
      options(t3, n3) {
        if (t3) {
          const o3 = n3 ? s2() : {};
          const e3 = getOptionsDiff(d2, assignDeep(o3, validateOptions(t3)));
          if (!isEmptyObject(e3)) {
            assignDeep(d2, e3);
            update3(e3);
          }
        }
        return assignDeep({}, d2);
      },
      on: f2,
      off: (t3, n3) => {
        t3 && n3 && _2(t3, n3);
      },
      state() {
        const { zt: t3, Tt: n3, Ct: o3, Et: s3, K: e3, St: c3, bt: r3 } = v2();
        return assignDeep({}, {
          overflowEdge: t3,
          overflowAmount: n3,
          overflowStyle: o3,
          hasOverflow: s3,
          padding: e3,
          paddingAbsolute: c3,
          directionRTL: r3,
          destroyed: u3
        });
      },
      elements() {
        const { W: t3, Z: n3, K: o3, J: s3, tt: e3, ot: c3, st: r3 } = v2.qt;
        const { Jt: i3, nn: l3 } = b2.qt;
        const translateScrollbarStructure = (t4) => {
          const { Ft: n4, Gt: o4, Xt: s4 } = t4;
          return {
            scrollbar: s4,
            track: o4,
            handle: n4
          };
        };
        const translateScrollbarsSetupElement = (t4) => {
          const { Kt: n4, Qt: o4 } = t4;
          const s4 = translateScrollbarStructure(n4[0]);
          return assignDeep({}, s4, {
            clone: () => {
              const t5 = translateScrollbarStructure(o4());
              p2({}, true, {});
              return t5;
            }
          });
        };
        return assignDeep({}, {
          target: t3,
          host: n3,
          padding: o3 || s3,
          viewport: s3,
          content: e3 || s3,
          scrollOffsetElement: c3,
          scrollEventElement: r3,
          scrollbarHorizontal: translateScrollbarsSetupElement(i3),
          scrollbarVertical: translateScrollbarsSetupElement(l3)
        });
      },
      update: (t3) => update3({}, t3),
      destroy: destroy.bind(0)
    };
    v2.jt((t3, n3, o3) => {
      p2(n3, o3, t3);
    });
    addInstance(a2, $2);
    each(keys(i2), (t3) => invokePluginInstance(i2[t3], 0, $2));
    if (cancelInitialization(v2.qt.it, e2().cancel, !l2 && t2.cancel)) {
      destroy(true);
      return $2;
    }
    v2.Nt();
    b2.Nt();
    h2("initialized", [$2]);
    v2.jt((t3, n3, o3) => {
      const { vt: s3, yt: e3, gt: c3, At: r3, Lt: i3, It: l3, wt: a3, Ot: u4 } = t3;
      h2("updated", [$2, {
        updateHints: {
          sizeChanged: s3,
          directionChanged: e3,
          heightIntrinsicChanged: c3,
          overflowEdgeChanged: r3,
          overflowAmountChanged: i3,
          overflowStyleChanged: l3,
          contentMutation: a3,
          hostMutation: u4
        },
        changedOptions: n3,
        force: o3
      }]);
    });
    $2.update(true);
    return $2;
  }
  return u2;
};
OverlayScrollbars.plugin = (t2) => {
  each(addPlugin(t2), (t3) => invokePluginInstance(t3, OverlayScrollbars));
};
OverlayScrollbars.valid = (t2) => {
  const n2 = t2 && t2.elements;
  const o2 = isFunction(n2) && n2();
  return isPlainObject(o2) && !!getInstance(o2.target);
};
OverlayScrollbars.env = () => {
  const { k: t2, A: n2, I: o2, B: s2, V: e2, L: c2, X: r2, U: i2, N: l2, q: a2, F: u2, G: d2 } = getEnvironment();
  return assignDeep({}, {
    scrollbarsSize: t2,
    scrollbarsOverlaid: n2,
    scrollbarsHiding: o2,
    rtlScrollBehavior: s2,
    flexboxGlue: e2,
    cssCustomProperties: c2,
    staticDefaultInitialization: r2,
    staticDefaultOptions: i2,
    getDefaultInitialization: l2,
    setDefaultInitialization: a2,
    getDefaultOptions: u2,
    setDefaultOptions: d2
  });
};
const _sfc_main$3 = defineComponent({
  setup() {
    const scrollable = ref$2();
    onMounted(() => {
      OverlayScrollbars(scrollable.value, {
        scrollbars: {
          autoHide: "leave",
          autoHideDelay: 200
        }
      });
    });
    return {
      scrollable
    };
  }
});
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _hoisted_1 = {
  ref: "scrollable",
  class: "overflow-auto"
};
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1, [
    renderSlot(_ctx.$slots, "default")
  ], 512);
}
const CoreScrollable = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$2]]);
const _sfc_main$2 = {
  props: {
    scope: String
  },
  computed: {
    appendable() {
      return this.$packageManager.getComponents(this.scope, "append");
    },
    prependable() {
      return this.$packageManager.getComponents(this.scope, "prepend");
    }
  },
  created() {
    [...this.appendable, ...this.prependable].forEach((component) => {
      this.$options.components[component.name] = component;
    });
  }
};
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, [
    (openBlock(true), createElementBlock(Fragment, null, renderList($options.prependable, (component) => {
      return openBlock(), createBlock(resolveDynamicComponent(component.name), {
        key: component.name
      });
    }), 128)),
    renderSlot(_ctx.$slots, "default"),
    (openBlock(true), createElementBlock(Fragment, null, renderList($options.appendable, (component) => {
      return openBlock(), createBlock(resolveDynamicComponent(component.name), {
        key: component.name
      });
    }), 128))
  ]);
}
const Extendable = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$1]]);
const useAppearance = () => {
  const appearance = useColorMode({
    emitAuto: true,
    modes: {
      october: "dark october"
    }
  });
  return {
    appearance
  };
};
/*!
  * vue-router v4.1.5
  * (c) 2022 Eduardo San Martin Morote
  * @license MIT
  */
const isBrowser = typeof window !== "undefined";
function isESModule(obj) {
  return obj.__esModule || obj[Symbol.toStringTag] === "Module";
}
const assign = Object.assign;
function applyToParams(fn2, params) {
  const newParams = {};
  for (const key in params) {
    const value = params[key];
    newParams[key] = isArray$1(value) ? value.map(fn2) : fn2(value);
  }
  return newParams;
}
const noop = () => {
};
const isArray$1 = Array.isArray;
const TRAILING_SLASH_RE = /\/$/;
const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, "");
function parseURL(parseQuery2, location2, currentLocation = "/") {
  let path, query = {}, searchString = "", hash = "";
  const hashPos = location2.indexOf("#");
  let searchPos = location2.indexOf("?");
  if (hashPos < searchPos && hashPos >= 0) {
    searchPos = -1;
  }
  if (searchPos > -1) {
    path = location2.slice(0, searchPos);
    searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
    query = parseQuery2(searchString);
  }
  if (hashPos > -1) {
    path = path || location2.slice(0, hashPos);
    hash = location2.slice(hashPos, location2.length);
  }
  path = resolveRelativePath(path != null ? path : location2, currentLocation);
  return {
    fullPath: path + (searchString && "?") + searchString + hash,
    path,
    query,
    hash
  };
}
function stringifyURL(stringifyQuery2, location2) {
  const query = location2.query ? stringifyQuery2(location2.query) : "";
  return location2.path + (query && "?") + query + (location2.hash || "");
}
function stripBase(pathname, base) {
  if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))
    return pathname;
  return pathname.slice(base.length) || "/";
}
function isSameRouteLocation(stringifyQuery2, a2, b2) {
  const aLastIndex = a2.matched.length - 1;
  const bLastIndex = b2.matched.length - 1;
  return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a2.matched[aLastIndex], b2.matched[bLastIndex]) && isSameRouteLocationParams(a2.params, b2.params) && stringifyQuery2(a2.query) === stringifyQuery2(b2.query) && a2.hash === b2.hash;
}
function isSameRouteRecord(a2, b2) {
  return (a2.aliasOf || a2) === (b2.aliasOf || b2);
}
function isSameRouteLocationParams(a2, b2) {
  if (Object.keys(a2).length !== Object.keys(b2).length)
    return false;
  for (const key in a2) {
    if (!isSameRouteLocationParamsValue(a2[key], b2[key]))
      return false;
  }
  return true;
}
function isSameRouteLocationParamsValue(a2, b2) {
  return isArray$1(a2) ? isEquivalentArray(a2, b2) : isArray$1(b2) ? isEquivalentArray(b2, a2) : a2 === b2;
}
function isEquivalentArray(a2, b2) {
  return isArray$1(b2) ? a2.length === b2.length && a2.every((value, i2) => value === b2[i2]) : a2.length === 1 && a2[0] === b2;
}
function resolveRelativePath(to2, from2) {
  if (to2.startsWith("/"))
    return to2;
  if (!to2)
    return from2;
  const fromSegments = from2.split("/");
  const toSegments = to2.split("/");
  let position = fromSegments.length - 1;
  let toPosition;
  let segment;
  for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
    segment = toSegments[toPosition];
    if (segment === ".")
      continue;
    if (segment === "..") {
      if (position > 1)
        position--;
    } else
      break;
  }
  return fromSegments.slice(0, position).join("/") + "/" + toSegments.slice(toPosition - (toPosition === toSegments.length ? 1 : 0)).join("/");
}
var NavigationType;
(function(NavigationType2) {
  NavigationType2["pop"] = "pop";
  NavigationType2["push"] = "push";
})(NavigationType || (NavigationType = {}));
var NavigationDirection;
(function(NavigationDirection2) {
  NavigationDirection2["back"] = "back";
  NavigationDirection2["forward"] = "forward";
  NavigationDirection2["unknown"] = "";
})(NavigationDirection || (NavigationDirection = {}));
function normalizeBase(base) {
  if (!base) {
    if (isBrowser) {
      const baseEl = document.querySelector("base");
      base = baseEl && baseEl.getAttribute("href") || "/";
      base = base.replace(/^\w+:\/\/[^\/]+/, "");
    } else {
      base = "/";
    }
  }
  if (base[0] !== "/" && base[0] !== "#")
    base = "/" + base;
  return removeTrailingSlash(base);
}
const BEFORE_HASH_RE = /^[^#]+#/;
function createHref(base, location2) {
  return base.replace(BEFORE_HASH_RE, "#") + location2;
}
function getElementPosition(el, offset) {
  const docRect = document.documentElement.getBoundingClientRect();
  const elRect = el.getBoundingClientRect();
  return {
    behavior: offset.behavior,
    left: elRect.left - docRect.left - (offset.left || 0),
    top: elRect.top - docRect.top - (offset.top || 0)
  };
}
const computeScrollPosition = () => ({
  left: window.pageXOffset,
  top: window.pageYOffset
});
function scrollToPosition(position) {
  let scrollToOptions;
  if ("el" in position) {
    const positionEl = position.el;
    const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
    const el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
    if (!el) {
      return;
    }
    scrollToOptions = getElementPosition(el, position);
  } else {
    scrollToOptions = position;
  }
  if ("scrollBehavior" in document.documentElement.style)
    window.scrollTo(scrollToOptions);
  else {
    window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);
  }
}
function getScrollKey(path, delta) {
  const position = history.state ? history.state.position - delta : -1;
  return position + path;
}
const scrollPositions = /* @__PURE__ */ new Map();
function saveScrollPosition(key, scrollPosition) {
  scrollPositions.set(key, scrollPosition);
}
function getSavedScrollPosition(key) {
  const scroll = scrollPositions.get(key);
  scrollPositions.delete(key);
  return scroll;
}
let createBaseLocation = () => location.protocol + "//" + location.host;
function createCurrentLocation(base, location2) {
  const { pathname, search, hash } = location2;
  const hashPos = base.indexOf("#");
  if (hashPos > -1) {
    let slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;
    let pathFromHash = hash.slice(slicePos);
    if (pathFromHash[0] !== "/")
      pathFromHash = "/" + pathFromHash;
    return stripBase(pathFromHash, "");
  }
  const path = stripBase(pathname, base);
  return path + search + hash;
}
function useHistoryListeners(base, historyState, currentLocation, replace) {
  let listeners = [];
  let teardowns = [];
  let pauseState = null;
  const popStateHandler = ({ state }) => {
    const to2 = createCurrentLocation(base, location);
    const from2 = currentLocation.value;
    const fromState = historyState.value;
    let delta = 0;
    if (state) {
      currentLocation.value = to2;
      historyState.value = state;
      if (pauseState && pauseState === from2) {
        pauseState = null;
        return;
      }
      delta = fromState ? state.position - fromState.position : 0;
    } else {
      replace(to2);
    }
    listeners.forEach((listener) => {
      listener(currentLocation.value, from2, {
        delta,
        type: NavigationType.pop,
        direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
      });
    });
  };
  function pauseListeners() {
    pauseState = currentLocation.value;
  }
  function listen(callback) {
    listeners.push(callback);
    const teardown = () => {
      const index = listeners.indexOf(callback);
      if (index > -1)
        listeners.splice(index, 1);
    };
    teardowns.push(teardown);
    return teardown;
  }
  function beforeUnloadListener() {
    const { history: history2 } = window;
    if (!history2.state)
      return;
    history2.replaceState(assign({}, history2.state, { scroll: computeScrollPosition() }), "");
  }
  function destroy() {
    for (const teardown of teardowns)
      teardown();
    teardowns = [];
    window.removeEventListener("popstate", popStateHandler);
    window.removeEventListener("beforeunload", beforeUnloadListener);
  }
  window.addEventListener("popstate", popStateHandler);
  window.addEventListener("beforeunload", beforeUnloadListener);
  return {
    pauseListeners,
    listen,
    destroy
  };
}
function buildState(back, current, forward, replaced = false, computeScroll = false) {
  return {
    back,
    current,
    forward,
    replaced,
    position: window.history.length,
    scroll: computeScroll ? computeScrollPosition() : null
  };
}
function useHistoryStateNavigation(base) {
  const { history: history2, location: location2 } = window;
  const currentLocation = {
    value: createCurrentLocation(base, location2)
  };
  const historyState = { value: history2.state };
  if (!historyState.value) {
    changeLocation(currentLocation.value, {
      back: null,
      current: currentLocation.value,
      forward: null,
      position: history2.length - 1,
      replaced: true,
      scroll: null
    }, true);
  }
  function changeLocation(to2, state, replace2) {
    const hashIndex = base.indexOf("#");
    const url = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base : base.slice(hashIndex)) + to2 : createBaseLocation() + base + to2;
    try {
      history2[replace2 ? "replaceState" : "pushState"](state, "", url);
      historyState.value = state;
    } catch (err) {
      {
        console.error(err);
      }
      location2[replace2 ? "replace" : "assign"](url);
    }
  }
  function replace(to2, data) {
    const state = assign({}, history2.state, buildState(
      historyState.value.back,
      to2,
      historyState.value.forward,
      true
    ), data, { position: historyState.value.position });
    changeLocation(to2, state, true);
    currentLocation.value = to2;
  }
  function push2(to2, data) {
    const currentState = assign(
      {},
      historyState.value,
      history2.state,
      {
        forward: to2,
        scroll: computeScrollPosition()
      }
    );
    changeLocation(currentState.current, currentState, true);
    const state = assign({}, buildState(currentLocation.value, to2, null), { position: currentState.position + 1 }, data);
    changeLocation(to2, state, false);
    currentLocation.value = to2;
  }
  return {
    location: currentLocation,
    state: historyState,
    push: push2,
    replace
  };
}
function createWebHistory(base) {
  base = normalizeBase(base);
  const historyNavigation = useHistoryStateNavigation(base);
  const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
  function go(delta, triggerListeners = true) {
    if (!triggerListeners)
      historyListeners.pauseListeners();
    history.go(delta);
  }
  const routerHistory = assign({
    location: "",
    base,
    go,
    createHref: createHref.bind(null, base)
  }, historyNavigation, historyListeners);
  Object.defineProperty(routerHistory, "location", {
    enumerable: true,
    get: () => historyNavigation.location.value
  });
  Object.defineProperty(routerHistory, "state", {
    enumerable: true,
    get: () => historyNavigation.state.value
  });
  return routerHistory;
}
function isRouteLocation(route) {
  return typeof route === "string" || route && typeof route === "object";
}
function isRouteName(name2) {
  return typeof name2 === "string" || typeof name2 === "symbol";
}
const START_LOCATION_NORMALIZED = {
  path: "/",
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0
};
const NavigationFailureSymbol = Symbol("");
var NavigationFailureType;
(function(NavigationFailureType2) {
  NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
  NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
  NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
})(NavigationFailureType || (NavigationFailureType = {}));
function createRouterError(type2, params) {
  {
    return assign(new Error(), {
      type: type2,
      [NavigationFailureSymbol]: true
    }, params);
  }
}
function isNavigationFailure(error, type2) {
  return error instanceof Error && NavigationFailureSymbol in error && (type2 == null || !!(error.type & type2));
}
const BASE_PARAM_PATTERN = "[^/]+?";
const BASE_PATH_PARSER_OPTIONS = {
  sensitive: false,
  strict: false,
  start: true,
  end: true
};
const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
function tokensToParser(segments, extraOptions) {
  const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
  const score = [];
  let pattern = options.start ? "^" : "";
  const keys2 = [];
  for (const segment of segments) {
    const segmentScores = segment.length ? [] : [90];
    if (options.strict && !segment.length)
      pattern += "/";
    for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
      const token = segment[tokenIndex];
      let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
      if (token.type === 0) {
        if (!tokenIndex)
          pattern += "/";
        pattern += token.value.replace(REGEX_CHARS_RE, "\\$&");
        subSegmentScore += 40;
      } else if (token.type === 1) {
        const { value, repeatable, optional, regexp } = token;
        keys2.push({
          name: value,
          repeatable,
          optional
        });
        const re3 = regexp ? regexp : BASE_PARAM_PATTERN;
        if (re3 !== BASE_PARAM_PATTERN) {
          subSegmentScore += 10;
          try {
            new RegExp(`(${re3})`);
          } catch (err) {
            throw new Error(`Invalid custom RegExp for param "${value}" (${re3}): ` + err.message);
          }
        }
        let subPattern = repeatable ? `((?:${re3})(?:/(?:${re3}))*)` : `(${re3})`;
        if (!tokenIndex)
          subPattern = optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
        if (optional)
          subPattern += "?";
        pattern += subPattern;
        subSegmentScore += 20;
        if (optional)
          subSegmentScore += -8;
        if (repeatable)
          subSegmentScore += -20;
        if (re3 === ".*")
          subSegmentScore += -50;
      }
      segmentScores.push(subSegmentScore);
    }
    score.push(segmentScores);
  }
  if (options.strict && options.end) {
    const i2 = score.length - 1;
    score[i2][score[i2].length - 1] += 0.7000000000000001;
  }
  if (!options.strict)
    pattern += "/?";
  if (options.end)
    pattern += "$";
  else if (options.strict)
    pattern += "(?:/|$)";
  const re2 = new RegExp(pattern, options.sensitive ? "" : "i");
  function parse2(path) {
    const match = path.match(re2);
    const params = {};
    if (!match)
      return null;
    for (let i2 = 1; i2 < match.length; i2++) {
      const value = match[i2] || "";
      const key = keys2[i2 - 1];
      params[key.name] = value && key.repeatable ? value.split("/") : value;
    }
    return params;
  }
  function stringify(params) {
    let path = "";
    let avoidDuplicatedSlash = false;
    for (const segment of segments) {
      if (!avoidDuplicatedSlash || !path.endsWith("/"))
        path += "/";
      avoidDuplicatedSlash = false;
      for (const token of segment) {
        if (token.type === 0) {
          path += token.value;
        } else if (token.type === 1) {
          const { value, repeatable, optional } = token;
          const param = value in params ? params[value] : "";
          if (isArray$1(param) && !repeatable) {
            throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
          }
          const text = isArray$1(param) ? param.join("/") : param;
          if (!text) {
            if (optional) {
              if (segment.length < 2) {
                if (path.endsWith("/"))
                  path = path.slice(0, -1);
                else
                  avoidDuplicatedSlash = true;
              }
            } else
              throw new Error(`Missing required param "${value}"`);
          }
          path += text;
        }
      }
    }
    return path || "/";
  }
  return {
    re: re2,
    score,
    keys: keys2,
    parse: parse2,
    stringify
  };
}
function compareScoreArray(a2, b2) {
  let i2 = 0;
  while (i2 < a2.length && i2 < b2.length) {
    const diff = b2[i2] - a2[i2];
    if (diff)
      return diff;
    i2++;
  }
  if (a2.length < b2.length) {
    return a2.length === 1 && a2[0] === 40 + 40 ? -1 : 1;
  } else if (a2.length > b2.length) {
    return b2.length === 1 && b2[0] === 40 + 40 ? 1 : -1;
  }
  return 0;
}
function comparePathParserScore(a2, b2) {
  let i2 = 0;
  const aScore = a2.score;
  const bScore = b2.score;
  while (i2 < aScore.length && i2 < bScore.length) {
    const comp = compareScoreArray(aScore[i2], bScore[i2]);
    if (comp)
      return comp;
    i2++;
  }
  if (Math.abs(bScore.length - aScore.length) === 1) {
    if (isLastScoreNegative(aScore))
      return 1;
    if (isLastScoreNegative(bScore))
      return -1;
  }
  return bScore.length - aScore.length;
}
function isLastScoreNegative(score) {
  const last = score[score.length - 1];
  return score.length > 0 && last[last.length - 1] < 0;
}
const ROOT_TOKEN = {
  type: 0,
  value: ""
};
const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
function tokenizePath(path) {
  if (!path)
    return [[]];
  if (path === "/")
    return [[ROOT_TOKEN]];
  if (!path.startsWith("/")) {
    throw new Error(`Invalid path "${path}"`);
  }
  function crash(message) {
    throw new Error(`ERR (${state})/"${buffer}": ${message}`);
  }
  let state = 0;
  let previousState = state;
  const tokens = [];
  let segment;
  function finalizeSegment() {
    if (segment)
      tokens.push(segment);
    segment = [];
  }
  let i2 = 0;
  let char;
  let buffer = "";
  let customRe = "";
  function consumeBuffer() {
    if (!buffer)
      return;
    if (state === 0) {
      segment.push({
        type: 0,
        value: buffer
      });
    } else if (state === 1 || state === 2 || state === 3) {
      if (segment.length > 1 && (char === "*" || char === "+"))
        crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);
      segment.push({
        type: 1,
        value: buffer,
        regexp: customRe,
        repeatable: char === "*" || char === "+",
        optional: char === "*" || char === "?"
      });
    } else {
      crash("Invalid state to consume buffer");
    }
    buffer = "";
  }
  function addCharToBuffer() {
    buffer += char;
  }
  while (i2 < path.length) {
    char = path[i2++];
    if (char === "\\" && state !== 2) {
      previousState = state;
      state = 4;
      continue;
    }
    switch (state) {
      case 0:
        if (char === "/") {
          if (buffer) {
            consumeBuffer();
          }
          finalizeSegment();
        } else if (char === ":") {
          consumeBuffer();
          state = 1;
        } else {
          addCharToBuffer();
        }
        break;
      case 4:
        addCharToBuffer();
        state = previousState;
        break;
      case 1:
        if (char === "(") {
          state = 2;
        } else if (VALID_PARAM_RE.test(char)) {
          addCharToBuffer();
        } else {
          consumeBuffer();
          state = 0;
          if (char !== "*" && char !== "?" && char !== "+")
            i2--;
        }
        break;
      case 2:
        if (char === ")") {
          if (customRe[customRe.length - 1] == "\\")
            customRe = customRe.slice(0, -1) + char;
          else
            state = 3;
        } else {
          customRe += char;
        }
        break;
      case 3:
        consumeBuffer();
        state = 0;
        if (char !== "*" && char !== "?" && char !== "+")
          i2--;
        customRe = "";
        break;
      default:
        crash("Unknown state");
        break;
    }
  }
  if (state === 2)
    crash(`Unfinished custom RegExp for param "${buffer}"`);
  consumeBuffer();
  finalizeSegment();
  return tokens;
}
function createRouteRecordMatcher(record, parent2, options) {
  const parser = tokensToParser(tokenizePath(record.path), options);
  const matcher = assign(parser, {
    record,
    parent: parent2,
    children: [],
    alias: []
  });
  if (parent2) {
    if (!matcher.record.aliasOf === !parent2.record.aliasOf)
      parent2.children.push(matcher);
  }
  return matcher;
}
function createRouterMatcher(routes, globalOptions) {
  const matchers = [];
  const matcherMap = /* @__PURE__ */ new Map();
  globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
  function getRecordMatcher(name2) {
    return matcherMap.get(name2);
  }
  function addRoute(record, parent2, originalRecord) {
    const isRootAdd = !originalRecord;
    const mainNormalizedRecord = normalizeRouteRecord(record);
    mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
    const options = mergeOptions(globalOptions, record);
    const normalizedRecords = [
      mainNormalizedRecord
    ];
    if ("alias" in record) {
      const aliases = typeof record.alias === "string" ? [record.alias] : record.alias;
      for (const alias of aliases) {
        normalizedRecords.push(assign({}, mainNormalizedRecord, {
          components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
          path: alias,
          aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
        }));
      }
    }
    let matcher;
    let originalMatcher;
    for (const normalizedRecord of normalizedRecords) {
      const { path } = normalizedRecord;
      if (parent2 && path[0] !== "/") {
        const parentPath = parent2.record.path;
        const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
        normalizedRecord.path = parent2.record.path + (path && connectingSlash + path);
      }
      matcher = createRouteRecordMatcher(normalizedRecord, parent2, options);
      if (originalRecord) {
        originalRecord.alias.push(matcher);
      } else {
        originalMatcher = originalMatcher || matcher;
        if (originalMatcher !== matcher)
          originalMatcher.alias.push(matcher);
        if (isRootAdd && record.name && !isAliasRecord(matcher))
          removeRoute(record.name);
      }
      if (mainNormalizedRecord.children) {
        const children = mainNormalizedRecord.children;
        for (let i2 = 0; i2 < children.length; i2++) {
          addRoute(children[i2], matcher, originalRecord && originalRecord.children[i2]);
        }
      }
      originalRecord = originalRecord || matcher;
      insertMatcher(matcher);
    }
    return originalMatcher ? () => {
      removeRoute(originalMatcher);
    } : noop;
  }
  function removeRoute(matcherRef) {
    if (isRouteName(matcherRef)) {
      const matcher = matcherMap.get(matcherRef);
      if (matcher) {
        matcherMap.delete(matcherRef);
        matchers.splice(matchers.indexOf(matcher), 1);
        matcher.children.forEach(removeRoute);
        matcher.alias.forEach(removeRoute);
      }
    } else {
      const index = matchers.indexOf(matcherRef);
      if (index > -1) {
        matchers.splice(index, 1);
        if (matcherRef.record.name)
          matcherMap.delete(matcherRef.record.name);
        matcherRef.children.forEach(removeRoute);
        matcherRef.alias.forEach(removeRoute);
      }
    }
  }
  function getRoutes() {
    return matchers;
  }
  function insertMatcher(matcher) {
    let i2 = 0;
    while (i2 < matchers.length && comparePathParserScore(matcher, matchers[i2]) >= 0 && (matcher.record.path !== matchers[i2].record.path || !isRecordChildOf(matcher, matchers[i2])))
      i2++;
    matchers.splice(i2, 0, matcher);
    if (matcher.record.name && !isAliasRecord(matcher))
      matcherMap.set(matcher.record.name, matcher);
  }
  function resolve2(location2, currentLocation) {
    let matcher;
    let params = {};
    let path;
    let name2;
    if ("name" in location2 && location2.name) {
      matcher = matcherMap.get(location2.name);
      if (!matcher)
        throw createRouterError(1, {
          location: location2
        });
      name2 = matcher.record.name;
      params = assign(
        paramsFromLocation(
          currentLocation.params,
          matcher.keys.filter((k2) => !k2.optional).map((k2) => k2.name)
        ),
        location2.params && paramsFromLocation(location2.params, matcher.keys.map((k2) => k2.name))
      );
      path = matcher.stringify(params);
    } else if ("path" in location2) {
      path = location2.path;
      matcher = matchers.find((m2) => m2.re.test(path));
      if (matcher) {
        params = matcher.parse(path);
        name2 = matcher.record.name;
      }
    } else {
      matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m2) => m2.re.test(currentLocation.path));
      if (!matcher)
        throw createRouterError(1, {
          location: location2,
          currentLocation
        });
      name2 = matcher.record.name;
      params = assign({}, currentLocation.params, location2.params);
      path = matcher.stringify(params);
    }
    const matched = [];
    let parentMatcher = matcher;
    while (parentMatcher) {
      matched.unshift(parentMatcher.record);
      parentMatcher = parentMatcher.parent;
    }
    return {
      name: name2,
      path,
      params,
      matched,
      meta: mergeMetaFields(matched)
    };
  }
  routes.forEach((route) => addRoute(route));
  return { addRoute, resolve: resolve2, removeRoute, getRoutes, getRecordMatcher };
}
function paramsFromLocation(params, keys2) {
  const newParams = {};
  for (const key of keys2) {
    if (key in params)
      newParams[key] = params[key];
  }
  return newParams;
}
function normalizeRouteRecord(record) {
  return {
    path: record.path,
    redirect: record.redirect,
    name: record.name,
    meta: record.meta || {},
    aliasOf: void 0,
    beforeEnter: record.beforeEnter,
    props: normalizeRecordProps(record),
    children: record.children || [],
    instances: {},
    leaveGuards: /* @__PURE__ */ new Set(),
    updateGuards: /* @__PURE__ */ new Set(),
    enterCallbacks: {},
    components: "components" in record ? record.components || null : record.component && { default: record.component }
  };
}
function normalizeRecordProps(record) {
  const propsObject = {};
  const props = record.props || false;
  if ("component" in record) {
    propsObject.default = props;
  } else {
    for (const name2 in record.components)
      propsObject[name2] = typeof props === "boolean" ? props : props[name2];
  }
  return propsObject;
}
function isAliasRecord(record) {
  while (record) {
    if (record.record.aliasOf)
      return true;
    record = record.parent;
  }
  return false;
}
function mergeMetaFields(matched) {
  return matched.reduce((meta, record) => assign(meta, record.meta), {});
}
function mergeOptions(defaults, partialOptions) {
  const options = {};
  for (const key in defaults) {
    options[key] = key in partialOptions ? partialOptions[key] : defaults[key];
  }
  return options;
}
function isRecordChildOf(record, parent2) {
  return parent2.children.some((child2) => child2 === record || isRecordChildOf(record, child2));
}
const HASH_RE = /#/g;
const AMPERSAND_RE = /&/g;
const SLASH_RE = /\//g;
const EQUAL_RE = /=/g;
const IM_RE = /\?/g;
const PLUS_RE = /\+/g;
const ENC_BRACKET_OPEN_RE = /%5B/g;
const ENC_BRACKET_CLOSE_RE = /%5D/g;
const ENC_CARET_RE = /%5E/g;
const ENC_BACKTICK_RE = /%60/g;
const ENC_CURLY_OPEN_RE = /%7B/g;
const ENC_PIPE_RE = /%7C/g;
const ENC_CURLY_CLOSE_RE = /%7D/g;
const ENC_SPACE_RE = /%20/g;
function commonEncode(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
}
function encodeHash(text) {
  return commonEncode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryValue(text) {
  return commonEncode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function encodePath(text) {
  return commonEncode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
}
function encodeParam(text) {
  return text == null ? "" : encodePath(text).replace(SLASH_RE, "%2F");
}
function decode$1(text) {
  try {
    return decodeURIComponent("" + text);
  } catch (err) {
  }
  return "" + text;
}
function parseQuery(search) {
  const query = {};
  if (search === "" || search === "?")
    return query;
  const hasLeadingIM = search[0] === "?";
  const searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
  for (let i2 = 0; i2 < searchParams.length; ++i2) {
    const searchParam = searchParams[i2].replace(PLUS_RE, " ");
    const eqPos = searchParam.indexOf("=");
    const key = decode$1(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
    const value = eqPos < 0 ? null : decode$1(searchParam.slice(eqPos + 1));
    if (key in query) {
      let currentValue = query[key];
      if (!isArray$1(currentValue)) {
        currentValue = query[key] = [currentValue];
      }
      currentValue.push(value);
    } else {
      query[key] = value;
    }
  }
  return query;
}
function stringifyQuery(query) {
  let search = "";
  for (let key in query) {
    const value = query[key];
    key = encodeQueryKey(key);
    if (value == null) {
      if (value !== void 0) {
        search += (search.length ? "&" : "") + key;
      }
      continue;
    }
    const values = isArray$1(value) ? value.map((v2) => v2 && encodeQueryValue(v2)) : [value && encodeQueryValue(value)];
    values.forEach((value2) => {
      if (value2 !== void 0) {
        search += (search.length ? "&" : "") + key;
        if (value2 != null)
          search += "=" + value2;
      }
    });
  }
  return search;
}
function normalizeQuery(query) {
  const normalizedQuery = {};
  for (const key in query) {
    const value = query[key];
    if (value !== void 0) {
      normalizedQuery[key] = isArray$1(value) ? value.map((v2) => v2 == null ? null : "" + v2) : value == null ? value : "" + value;
    }
  }
  return normalizedQuery;
}
const matchedRouteKey = Symbol("");
const viewDepthKey = Symbol("");
const routerKey = Symbol("");
const routeLocationKey = Symbol("");
const routerViewLocationKey = Symbol("");
function useCallbacks() {
  let handlers2 = [];
  function add2(handler) {
    handlers2.push(handler);
    return () => {
      const i2 = handlers2.indexOf(handler);
      if (i2 > -1)
        handlers2.splice(i2, 1);
    };
  }
  function reset2() {
    handlers2 = [];
  }
  return {
    add: add2,
    list: () => handlers2,
    reset: reset2
  };
}
function guardToPromiseFn(guard, to2, from2, record, name2) {
  const enterCallbackArray = record && (record.enterCallbacks[name2] = record.enterCallbacks[name2] || []);
  return () => new Promise((resolve2, reject) => {
    const next = (valid) => {
      if (valid === false) {
        reject(createRouterError(4, {
          from: from2,
          to: to2
        }));
      } else if (valid instanceof Error) {
        reject(valid);
      } else if (isRouteLocation(valid)) {
        reject(createRouterError(2, {
          from: to2,
          to: valid
        }));
      } else {
        if (enterCallbackArray && record.enterCallbacks[name2] === enterCallbackArray && typeof valid === "function") {
          enterCallbackArray.push(valid);
        }
        resolve2();
      }
    };
    const guardReturn = guard.call(record && record.instances[name2], to2, from2, next);
    let guardCall = Promise.resolve(guardReturn);
    if (guard.length < 3)
      guardCall = guardCall.then(next);
    guardCall.catch((err) => reject(err));
  });
}
function extractComponentsGuards(matched, guardType, to2, from2) {
  const guards = [];
  for (const record of matched) {
    for (const name2 in record.components) {
      let rawComponent = record.components[name2];
      if (guardType !== "beforeRouteEnter" && !record.instances[name2])
        continue;
      if (isRouteComponent(rawComponent)) {
        const options = rawComponent.__vccOpts || rawComponent;
        const guard = options[guardType];
        guard && guards.push(guardToPromiseFn(guard, to2, from2, record, name2));
      } else {
        let componentPromise = rawComponent();
        guards.push(() => componentPromise.then((resolved) => {
          if (!resolved)
            return Promise.reject(new Error(`Couldn't resolve component "${name2}" at "${record.path}"`));
          const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
          record.components[name2] = resolvedComponent;
          const options = resolvedComponent.__vccOpts || resolvedComponent;
          const guard = options[guardType];
          return guard && guardToPromiseFn(guard, to2, from2, record, name2)();
        }));
      }
    }
  }
  return guards;
}
function isRouteComponent(component) {
  return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
}
function useLink(props) {
  const router2 = inject(routerKey);
  const currentRoute = inject(routeLocationKey);
  const route = computed(() => router2.resolve(unref(props.to)));
  const activeRecordIndex = computed(() => {
    const { matched } = route.value;
    const { length } = matched;
    const routeMatched = matched[length - 1];
    const currentMatched = currentRoute.matched;
    if (!routeMatched || !currentMatched.length)
      return -1;
    const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
    if (index > -1)
      return index;
    const parentRecordPath = getOriginalPath(matched[length - 2]);
    return length > 1 && getOriginalPath(routeMatched) === parentRecordPath && currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index;
  });
  const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
  const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
  function navigate(e2 = {}) {
    if (guardEvent(e2)) {
      return router2[unref(props.replace) ? "replace" : "push"](
        unref(props.to)
      ).catch(noop);
    }
    return Promise.resolve();
  }
  return {
    route,
    href: computed(() => route.value.href),
    isActive,
    isExactActive,
    navigate
  };
}
const RouterLinkImpl = /* @__PURE__ */ defineComponent({
  name: "RouterLink",
  compatConfig: { MODE: 3 },
  props: {
    to: {
      type: [String, Object],
      required: true
    },
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    custom: Boolean,
    ariaCurrentValue: {
      type: String,
      default: "page"
    }
  },
  useLink,
  setup(props, { slots }) {
    const link = reactive(useLink(props));
    const { options } = inject(routerKey);
    const elClass = computed(() => ({
      [getLinkClass(props.activeClass, options.linkActiveClass, "router-link-active")]: link.isActive,
      [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link.isExactActive
    }));
    return () => {
      const children = slots.default && slots.default(link);
      return props.custom ? children : h$1("a", {
        "aria-current": link.isExactActive ? props.ariaCurrentValue : null,
        href: link.href,
        onClick: link.navigate,
        class: elClass.value
      }, children);
    };
  }
});
const RouterLink = RouterLinkImpl;
function guardEvent(e2) {
  if (e2.metaKey || e2.altKey || e2.ctrlKey || e2.shiftKey)
    return;
  if (e2.defaultPrevented)
    return;
  if (e2.button !== void 0 && e2.button !== 0)
    return;
  if (e2.currentTarget && e2.currentTarget.getAttribute) {
    const target = e2.currentTarget.getAttribute("target");
    if (/\b_blank\b/i.test(target))
      return;
  }
  if (e2.preventDefault)
    e2.preventDefault();
  return true;
}
function includesParams(outer, inner) {
  for (const key in inner) {
    const innerValue = inner[key];
    const outerValue = outer[key];
    if (typeof innerValue === "string") {
      if (innerValue !== outerValue)
        return false;
    } else {
      if (!isArray$1(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i2) => value !== outerValue[i2]))
        return false;
    }
  }
  return true;
}
function getOriginalPath(record) {
  return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
}
const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
const RouterViewImpl = /* @__PURE__ */ defineComponent({
  name: "RouterView",
  inheritAttrs: false,
  props: {
    name: {
      type: String,
      default: "default"
    },
    route: Object
  },
  compatConfig: { MODE: 3 },
  setup(props, { attrs, slots }) {
    const injectedRoute = inject(routerViewLocationKey);
    const routeToDisplay = computed(() => props.route || injectedRoute.value);
    const injectedDepth = inject(viewDepthKey, 0);
    const depth = computed(() => {
      let initialDepth = unref(injectedDepth);
      const { matched } = routeToDisplay.value;
      let matchedRoute;
      while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) {
        initialDepth++;
      }
      return initialDepth;
    });
    const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth.value]);
    provide(viewDepthKey, computed(() => depth.value + 1));
    provide(matchedRouteKey, matchedRouteRef);
    provide(routerViewLocationKey, routeToDisplay);
    const viewRef = ref$2();
    watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to2, name2], [oldInstance, from2, oldName]) => {
      if (to2) {
        to2.instances[name2] = instance;
        if (from2 && from2 !== to2 && instance && instance === oldInstance) {
          if (!to2.leaveGuards.size) {
            to2.leaveGuards = from2.leaveGuards;
          }
          if (!to2.updateGuards.size) {
            to2.updateGuards = from2.updateGuards;
          }
        }
      }
      if (instance && to2 && (!from2 || !isSameRouteRecord(to2, from2) || !oldInstance)) {
        (to2.enterCallbacks[name2] || []).forEach((callback) => callback(instance));
      }
    }, { flush: "post" });
    return () => {
      const route = routeToDisplay.value;
      const currentName = props.name;
      const matchedRoute = matchedRouteRef.value;
      const ViewComponent = matchedRoute && matchedRoute.components[currentName];
      if (!ViewComponent) {
        return normalizeSlot(slots.default, { Component: ViewComponent, route });
      }
      const routePropsOption = matchedRoute.props[currentName];
      const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
      const onVnodeUnmounted = (vnode) => {
        if (vnode.component.isUnmounted) {
          matchedRoute.instances[currentName] = null;
        }
      };
      const component = h$1(ViewComponent, assign({}, routeProps, attrs, {
        onVnodeUnmounted,
        ref: viewRef
      }));
      return normalizeSlot(slots.default, { Component: component, route }) || component;
    };
  }
});
function normalizeSlot(slot, data) {
  if (!slot)
    return null;
  const slotContent = slot(data);
  return slotContent.length === 1 ? slotContent[0] : slotContent;
}
const RouterView = RouterViewImpl;
function createRouter(options) {
  const matcher = createRouterMatcher(options.routes, options);
  const parseQuery$1 = options.parseQuery || parseQuery;
  const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
  const routerHistory = options.history;
  const beforeGuards = useCallbacks();
  const beforeResolveGuards = useCallbacks();
  const afterGuards = useCallbacks();
  const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
  let pendingLocation = START_LOCATION_NORMALIZED;
  if (isBrowser && options.scrollBehavior && "scrollRestoration" in history) {
    history.scrollRestoration = "manual";
  }
  const normalizeParams = applyToParams.bind(null, (paramValue) => "" + paramValue);
  const encodeParams = applyToParams.bind(null, encodeParam);
  const decodeParams = applyToParams.bind(null, decode$1);
  function addRoute(parentOrRoute, route) {
    let parent2;
    let record;
    if (isRouteName(parentOrRoute)) {
      parent2 = matcher.getRecordMatcher(parentOrRoute);
      record = route;
    } else {
      record = parentOrRoute;
    }
    return matcher.addRoute(record, parent2);
  }
  function removeRoute(name2) {
    const recordMatcher = matcher.getRecordMatcher(name2);
    if (recordMatcher) {
      matcher.removeRoute(recordMatcher);
    }
  }
  function getRoutes() {
    return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
  }
  function hasRoute(name2) {
    return !!matcher.getRecordMatcher(name2);
  }
  function resolve2(rawLocation, currentLocation) {
    currentLocation = assign({}, currentLocation || currentRoute.value);
    if (typeof rawLocation === "string") {
      const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
      const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
      const href2 = routerHistory.createHref(locationNormalized.fullPath);
      return assign(locationNormalized, matchedRoute2, {
        params: decodeParams(matchedRoute2.params),
        hash: decode$1(locationNormalized.hash),
        redirectedFrom: void 0,
        href: href2
      });
    }
    let matcherLocation;
    if ("path" in rawLocation) {
      matcherLocation = assign({}, rawLocation, {
        path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
      });
    } else {
      const targetParams = assign({}, rawLocation.params);
      for (const key in targetParams) {
        if (targetParams[key] == null) {
          delete targetParams[key];
        }
      }
      matcherLocation = assign({}, rawLocation, {
        params: encodeParams(rawLocation.params)
      });
      currentLocation.params = encodeParams(currentLocation.params);
    }
    const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
    const hash = rawLocation.hash || "";
    matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
    const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {
      hash: encodeHash(hash),
      path: matchedRoute.path
    }));
    const href = routerHistory.createHref(fullPath);
    return assign({
      fullPath,
      hash,
      query: stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
    }, matchedRoute, {
      redirectedFrom: void 0,
      href
    });
  }
  function locationAsObject(to2) {
    return typeof to2 === "string" ? parseURL(parseQuery$1, to2, currentRoute.value.path) : assign({}, to2);
  }
  function checkCanceledNavigation(to2, from2) {
    if (pendingLocation !== to2) {
      return createRouterError(8, {
        from: from2,
        to: to2
      });
    }
  }
  function push2(to2) {
    return pushWithRedirect(to2);
  }
  function replace(to2) {
    return push2(assign(locationAsObject(to2), { replace: true }));
  }
  function handleRedirectRecord(to2) {
    const lastMatched = to2.matched[to2.matched.length - 1];
    if (lastMatched && lastMatched.redirect) {
      const { redirect } = lastMatched;
      let newTargetLocation = typeof redirect === "function" ? redirect(to2) : redirect;
      if (typeof newTargetLocation === "string") {
        newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : { path: newTargetLocation };
        newTargetLocation.params = {};
      }
      return assign({
        query: to2.query,
        hash: to2.hash,
        params: "path" in newTargetLocation ? {} : to2.params
      }, newTargetLocation);
    }
  }
  function pushWithRedirect(to2, redirectedFrom) {
    const targetLocation = pendingLocation = resolve2(to2);
    const from2 = currentRoute.value;
    const data = to2.state;
    const force = to2.force;
    const replace2 = to2.replace === true;
    const shouldRedirect = handleRedirectRecord(targetLocation);
    if (shouldRedirect)
      return pushWithRedirect(
        assign(locationAsObject(shouldRedirect), {
          state: typeof shouldRedirect === "object" ? assign({}, data, shouldRedirect.state) : data,
          force,
          replace: replace2
        }),
        redirectedFrom || targetLocation
      );
    const toLocation = targetLocation;
    toLocation.redirectedFrom = redirectedFrom;
    let failure;
    if (!force && isSameRouteLocation(stringifyQuery$1, from2, targetLocation)) {
      failure = createRouterError(16, { to: toLocation, from: from2 });
      handleScroll(
        from2,
        from2,
        true,
        false
      );
    }
    return (failure ? Promise.resolve(failure) : navigate(toLocation, from2)).catch((error) => isNavigationFailure(error) ? isNavigationFailure(error, 2) ? error : markAsReady(error) : triggerError(error, toLocation, from2)).then((failure2) => {
      if (failure2) {
        if (isNavigationFailure(failure2, 2)) {
          return pushWithRedirect(
            assign({
              replace: replace2
            }, locationAsObject(failure2.to), {
              state: typeof failure2.to === "object" ? assign({}, data, failure2.to.state) : data,
              force
            }),
            redirectedFrom || toLocation
          );
        }
      } else {
        failure2 = finalizeNavigation(toLocation, from2, true, replace2, data);
      }
      triggerAfterEach(toLocation, from2, failure2);
      return failure2;
    });
  }
  function checkCanceledNavigationAndReject(to2, from2) {
    const error = checkCanceledNavigation(to2, from2);
    return error ? Promise.reject(error) : Promise.resolve();
  }
  function navigate(to2, from2) {
    let guards;
    const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to2, from2);
    guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to2, from2);
    for (const record of leavingRecords) {
      record.leaveGuards.forEach((guard) => {
        guards.push(guardToPromiseFn(guard, to2, from2));
      });
    }
    const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to2, from2);
    guards.push(canceledNavigationCheck);
    return runGuardQueue(guards).then(() => {
      guards = [];
      for (const guard of beforeGuards.list()) {
        guards.push(guardToPromiseFn(guard, to2, from2));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to2, from2);
      for (const record of updatingRecords) {
        record.updateGuards.forEach((guard) => {
          guards.push(guardToPromiseFn(guard, to2, from2));
        });
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const record of to2.matched) {
        if (record.beforeEnter && !from2.matched.includes(record)) {
          if (isArray$1(record.beforeEnter)) {
            for (const beforeEnter of record.beforeEnter)
              guards.push(guardToPromiseFn(beforeEnter, to2, from2));
          } else {
            guards.push(guardToPromiseFn(record.beforeEnter, to2, from2));
          }
        }
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      to2.matched.forEach((record) => record.enterCallbacks = {});
      guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to2, from2);
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const guard of beforeResolveGuards.list()) {
        guards.push(guardToPromiseFn(guard, to2, from2));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).catch((err) => isNavigationFailure(err, 8) ? err : Promise.reject(err));
  }
  function triggerAfterEach(to2, from2, failure) {
    for (const guard of afterGuards.list())
      guard(to2, from2, failure);
  }
  function finalizeNavigation(toLocation, from2, isPush, replace2, data) {
    const error = checkCanceledNavigation(toLocation, from2);
    if (error)
      return error;
    const isFirstNavigation = from2 === START_LOCATION_NORMALIZED;
    const state = !isBrowser ? {} : history.state;
    if (isPush) {
      if (replace2 || isFirstNavigation)
        routerHistory.replace(toLocation.fullPath, assign({
          scroll: isFirstNavigation && state && state.scroll
        }, data));
      else
        routerHistory.push(toLocation.fullPath, data);
    }
    currentRoute.value = toLocation;
    handleScroll(toLocation, from2, isPush, isFirstNavigation);
    markAsReady();
  }
  let removeHistoryListener;
  function setupListeners() {
    if (removeHistoryListener)
      return;
    removeHistoryListener = routerHistory.listen((to2, _from, info) => {
      if (!router2.listening)
        return;
      const toLocation = resolve2(to2);
      const shouldRedirect = handleRedirectRecord(toLocation);
      if (shouldRedirect) {
        pushWithRedirect(assign(shouldRedirect, { replace: true }), toLocation).catch(noop);
        return;
      }
      pendingLocation = toLocation;
      const from2 = currentRoute.value;
      if (isBrowser) {
        saveScrollPosition(getScrollKey(from2.fullPath, info.delta), computeScrollPosition());
      }
      navigate(toLocation, from2).catch((error) => {
        if (isNavigationFailure(error, 4 | 8)) {
          return error;
        }
        if (isNavigationFailure(error, 2)) {
          pushWithRedirect(
            error.to,
            toLocation
          ).then((failure) => {
            if (isNavigationFailure(failure, 4 | 16) && !info.delta && info.type === NavigationType.pop) {
              routerHistory.go(-1, false);
            }
          }).catch(noop);
          return Promise.reject();
        }
        if (info.delta) {
          routerHistory.go(-info.delta, false);
        }
        return triggerError(error, toLocation, from2);
      }).then((failure) => {
        failure = failure || finalizeNavigation(
          toLocation,
          from2,
          false
        );
        if (failure) {
          if (info.delta && !isNavigationFailure(failure, 8)) {
            routerHistory.go(-info.delta, false);
          } else if (info.type === NavigationType.pop && isNavigationFailure(failure, 4 | 16)) {
            routerHistory.go(-1, false);
          }
        }
        triggerAfterEach(toLocation, from2, failure);
      }).catch(noop);
    });
  }
  let readyHandlers = useCallbacks();
  let errorHandlers = useCallbacks();
  let ready;
  function triggerError(error, to2, from2) {
    markAsReady(error);
    const list = errorHandlers.list();
    if (list.length) {
      list.forEach((handler) => handler(error, to2, from2));
    } else {
      console.error(error);
    }
    return Promise.reject(error);
  }
  function isReady() {
    if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
      return Promise.resolve();
    return new Promise((resolve3, reject) => {
      readyHandlers.add([resolve3, reject]);
    });
  }
  function markAsReady(err) {
    if (!ready) {
      ready = !err;
      setupListeners();
      readyHandlers.list().forEach(([resolve3, reject]) => err ? reject(err) : resolve3());
      readyHandlers.reset();
    }
    return err;
  }
  function handleScroll(to2, from2, isPush, isFirstNavigation) {
    const { scrollBehavior } = options;
    if (!isBrowser || !scrollBehavior)
      return Promise.resolve();
    const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to2.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
    return nextTick().then(() => scrollBehavior(to2, from2, scrollPosition)).then((position) => position && scrollToPosition(position)).catch((err) => triggerError(err, to2, from2));
  }
  const go = (delta) => routerHistory.go(delta);
  let started;
  const installedApps = /* @__PURE__ */ new Set();
  const router2 = {
    currentRoute,
    listening: true,
    addRoute,
    removeRoute,
    hasRoute,
    getRoutes,
    resolve: resolve2,
    options,
    push: push2,
    replace,
    go,
    back: () => go(-1),
    forward: () => go(1),
    beforeEach: beforeGuards.add,
    beforeResolve: beforeResolveGuards.add,
    afterEach: afterGuards.add,
    onError: errorHandlers.add,
    isReady,
    install(app2) {
      const router3 = this;
      app2.component("RouterLink", RouterLink);
      app2.component("RouterView", RouterView);
      app2.config.globalProperties.$router = router3;
      Object.defineProperty(app2.config.globalProperties, "$route", {
        enumerable: true,
        get: () => unref(currentRoute)
      });
      if (isBrowser && !started && currentRoute.value === START_LOCATION_NORMALIZED) {
        started = true;
        push2(routerHistory.location).catch((err) => {
        });
      }
      const reactiveRoute = {};
      for (const key in START_LOCATION_NORMALIZED) {
        reactiveRoute[key] = computed(() => currentRoute.value[key]);
      }
      app2.provide(routerKey, router3);
      app2.provide(routeLocationKey, reactive(reactiveRoute));
      app2.provide(routerViewLocationKey, currentRoute);
      const unmountApp = app2.unmount;
      installedApps.add(app2);
      app2.unmount = function() {
        installedApps.delete(app2);
        if (installedApps.size < 1) {
          pendingLocation = START_LOCATION_NORMALIZED;
          removeHistoryListener && removeHistoryListener();
          removeHistoryListener = null;
          currentRoute.value = START_LOCATION_NORMALIZED;
          started = false;
          ready = false;
        }
        unmountApp();
      };
    }
  };
  return router2;
}
function runGuardQueue(guards) {
  return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());
}
function extractChangingRecords(to2, from2) {
  const leavingRecords = [];
  const updatingRecords = [];
  const enteringRecords = [];
  const len = Math.max(from2.matched.length, to2.matched.length);
  for (let i2 = 0; i2 < len; i2++) {
    const recordFrom = from2.matched[i2];
    if (recordFrom) {
      if (to2.matched.find((record) => isSameRouteRecord(record, recordFrom)))
        updatingRecords.push(recordFrom);
      else
        leavingRecords.push(recordFrom);
    }
    const recordTo = to2.matched[i2];
    if (recordTo) {
      if (!from2.matched.find((record) => isSameRouteRecord(record, recordTo))) {
        enteringRecords.push(recordTo);
      }
    }
  }
  return [leavingRecords, updatingRecords, enteringRecords];
}
function useRouter() {
  return inject(routerKey);
}
function useRoute() {
  return inject(routeLocationKey);
}
/*!
 * vuex v4.0.2
 * (c) 2021 Evan You
 * @license MIT
 */
var storeKey = "store";
function useStore(key) {
  if (key === void 0)
    key = null;
  return inject(key !== null ? key : storeKey);
}
function forEachValue(obj, fn2) {
  Object.keys(obj).forEach(function(key) {
    return fn2(obj[key], key);
  });
}
function isObject$1(obj) {
  return obj !== null && typeof obj === "object";
}
function isPromise(val) {
  return val && typeof val.then === "function";
}
function partial(fn2, arg) {
  return function() {
    return fn2(arg);
  };
}
function genericSubscribe(fn2, subs, options) {
  if (subs.indexOf(fn2) < 0) {
    options && options.prepend ? subs.unshift(fn2) : subs.push(fn2);
  }
  return function() {
    var i2 = subs.indexOf(fn2);
    if (i2 > -1) {
      subs.splice(i2, 1);
    }
  };
}
function resetStore(store2, hot) {
  store2._actions = /* @__PURE__ */ Object.create(null);
  store2._mutations = /* @__PURE__ */ Object.create(null);
  store2._wrappedGetters = /* @__PURE__ */ Object.create(null);
  store2._modulesNamespaceMap = /* @__PURE__ */ Object.create(null);
  var state = store2.state;
  installModule(store2, state, [], store2._modules.root, true);
  resetStoreState(store2, state, hot);
}
function resetStoreState(store2, state, hot) {
  var oldState = store2._state;
  store2.getters = {};
  store2._makeLocalGettersCache = /* @__PURE__ */ Object.create(null);
  var wrappedGetters = store2._wrappedGetters;
  var computedObj = {};
  forEachValue(wrappedGetters, function(fn2, key) {
    computedObj[key] = partial(fn2, store2);
    Object.defineProperty(store2.getters, key, {
      get: function() {
        return computedObj[key]();
      },
      enumerable: true
    });
  });
  store2._state = reactive({
    data: state
  });
  if (store2.strict) {
    enableStrictMode(store2);
  }
  if (oldState) {
    if (hot) {
      store2._withCommit(function() {
        oldState.data = null;
      });
    }
  }
}
function installModule(store2, rootState, path, module, hot) {
  var isRoot = !path.length;
  var namespace = store2._modules.getNamespace(path);
  if (module.namespaced) {
    if (store2._modulesNamespaceMap[namespace] && false) {
      console.error("[vuex] duplicate namespace " + namespace + " for the namespaced module " + path.join("/"));
    }
    store2._modulesNamespaceMap[namespace] = module;
  }
  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];
    store2._withCommit(function() {
      parentState[moduleName] = module.state;
    });
  }
  var local = module.context = makeLocalContext(store2, namespace, path);
  module.forEachMutation(function(mutation, key) {
    var namespacedType = namespace + key;
    registerMutation(store2, namespacedType, mutation, local);
  });
  module.forEachAction(function(action, key) {
    var type2 = action.root ? key : namespace + key;
    var handler = action.handler || action;
    registerAction(store2, type2, handler, local);
  });
  module.forEachGetter(function(getter, key) {
    var namespacedType = namespace + key;
    registerGetter(store2, namespacedType, getter, local);
  });
  module.forEachChild(function(child2, key) {
    installModule(store2, rootState, path.concat(key), child2, hot);
  });
}
function makeLocalContext(store2, namespace, path) {
  var noNamespace = namespace === "";
  var local = {
    dispatch: noNamespace ? store2.dispatch : function(_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type2 = args.type;
      if (!options || !options.root) {
        type2 = namespace + type2;
      }
      return store2.dispatch(type2, payload);
    },
    commit: noNamespace ? store2.commit : function(_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type2 = args.type;
      if (!options || !options.root) {
        type2 = namespace + type2;
      }
      store2.commit(type2, payload, options);
    }
  };
  Object.defineProperties(local, {
    getters: {
      get: noNamespace ? function() {
        return store2.getters;
      } : function() {
        return makeLocalGetters(store2, namespace);
      }
    },
    state: {
      get: function() {
        return getNestedState(store2.state, path);
      }
    }
  });
  return local;
}
function makeLocalGetters(store2, namespace) {
  if (!store2._makeLocalGettersCache[namespace]) {
    var gettersProxy = {};
    var splitPos = namespace.length;
    Object.keys(store2.getters).forEach(function(type2) {
      if (type2.slice(0, splitPos) !== namespace) {
        return;
      }
      var localType = type2.slice(splitPos);
      Object.defineProperty(gettersProxy, localType, {
        get: function() {
          return store2.getters[type2];
        },
        enumerable: true
      });
    });
    store2._makeLocalGettersCache[namespace] = gettersProxy;
  }
  return store2._makeLocalGettersCache[namespace];
}
function registerMutation(store2, type2, handler, local) {
  var entry = store2._mutations[type2] || (store2._mutations[type2] = []);
  entry.push(function wrappedMutationHandler(payload) {
    handler.call(store2, local.state, payload);
  });
}
function registerAction(store2, type2, handler, local) {
  var entry = store2._actions[type2] || (store2._actions[type2] = []);
  entry.push(function wrappedActionHandler(payload) {
    var res = handler.call(store2, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store2.getters,
      rootState: store2.state
    }, payload);
    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }
    if (store2._devtoolHook) {
      return res.catch(function(err) {
        store2._devtoolHook.emit("vuex:error", err);
        throw err;
      });
    } else {
      return res;
    }
  });
}
function registerGetter(store2, type2, rawGetter, local) {
  if (store2._wrappedGetters[type2]) {
    return;
  }
  store2._wrappedGetters[type2] = function wrappedGetter(store3) {
    return rawGetter(
      local.state,
      local.getters,
      store3.state,
      store3.getters
    );
  };
}
function enableStrictMode(store2) {
  watch(function() {
    return store2._state.data;
  }, function() {
  }, { deep: true, flush: "sync" });
}
function getNestedState(state, path) {
  return path.reduce(function(state2, key) {
    return state2[key];
  }, state);
}
function unifyObjectStyle(type2, payload, options) {
  if (isObject$1(type2) && type2.type) {
    options = payload;
    payload = type2;
    type2 = type2.type;
  }
  return { type: type2, payload, options };
}
var LABEL_VUEX_BINDINGS = "vuex bindings";
var MUTATIONS_LAYER_ID = "vuex:mutations";
var ACTIONS_LAYER_ID = "vuex:actions";
var INSPECTOR_ID = "vuex";
var actionId = 0;
function addDevtools(app2, store2) {
  setupDevtoolsPlugin(
    {
      id: "org.vuejs.vuex",
      app: app2,
      label: "Vuex",
      homepage: "https://next.vuex.vuejs.org/",
      logo: "https://vuejs.org/images/icons/favicon-96x96.png",
      packageName: "vuex",
      componentStateTypes: [LABEL_VUEX_BINDINGS]
    },
    function(api) {
      api.addTimelineLayer({
        id: MUTATIONS_LAYER_ID,
        label: "Vuex Mutations",
        color: COLOR_LIME_500
      });
      api.addTimelineLayer({
        id: ACTIONS_LAYER_ID,
        label: "Vuex Actions",
        color: COLOR_LIME_500
      });
      api.addInspector({
        id: INSPECTOR_ID,
        label: "Vuex",
        icon: "storage",
        treeFilterPlaceholder: "Filter stores..."
      });
      api.on.getInspectorTree(function(payload) {
        if (payload.app === app2 && payload.inspectorId === INSPECTOR_ID) {
          if (payload.filter) {
            var nodes = [];
            flattenStoreForInspectorTree(nodes, store2._modules.root, payload.filter, "");
            payload.rootNodes = nodes;
          } else {
            payload.rootNodes = [
              formatStoreForInspectorTree(store2._modules.root, "")
            ];
          }
        }
      });
      api.on.getInspectorState(function(payload) {
        if (payload.app === app2 && payload.inspectorId === INSPECTOR_ID) {
          var modulePath = payload.nodeId;
          makeLocalGetters(store2, modulePath);
          payload.state = formatStoreForInspectorState(
            getStoreModule(store2._modules, modulePath),
            modulePath === "root" ? store2.getters : store2._makeLocalGettersCache,
            modulePath
          );
        }
      });
      api.on.editInspectorState(function(payload) {
        if (payload.app === app2 && payload.inspectorId === INSPECTOR_ID) {
          var modulePath = payload.nodeId;
          var path = payload.path;
          if (modulePath !== "root") {
            path = modulePath.split("/").filter(Boolean).concat(path);
          }
          store2._withCommit(function() {
            payload.set(store2._state.data, path, payload.state.value);
          });
        }
      });
      store2.subscribe(function(mutation, state) {
        var data = {};
        if (mutation.payload) {
          data.payload = mutation.payload;
        }
        data.state = state;
        api.notifyComponentUpdate();
        api.sendInspectorTree(INSPECTOR_ID);
        api.sendInspectorState(INSPECTOR_ID);
        api.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: {
            time: Date.now(),
            title: mutation.type,
            data
          }
        });
      });
      store2.subscribeAction({
        before: function(action, state) {
          var data = {};
          if (action.payload) {
            data.payload = action.payload;
          }
          action._id = actionId++;
          action._time = Date.now();
          data.state = state;
          api.addTimelineEvent({
            layerId: ACTIONS_LAYER_ID,
            event: {
              time: action._time,
              title: action.type,
              groupId: action._id,
              subtitle: "start",
              data
            }
          });
        },
        after: function(action, state) {
          var data = {};
          var duration = Date.now() - action._time;
          data.duration = {
            _custom: {
              type: "duration",
              display: duration + "ms",
              tooltip: "Action duration",
              value: duration
            }
          };
          if (action.payload) {
            data.payload = action.payload;
          }
          data.state = state;
          api.addTimelineEvent({
            layerId: ACTIONS_LAYER_ID,
            event: {
              time: Date.now(),
              title: action.type,
              groupId: action._id,
              subtitle: "end",
              data
            }
          });
        }
      });
    }
  );
}
var COLOR_LIME_500 = 8702998;
var COLOR_DARK = 6710886;
var COLOR_WHITE = 16777215;
var TAG_NAMESPACED = {
  label: "namespaced",
  textColor: COLOR_WHITE,
  backgroundColor: COLOR_DARK
};
function extractNameFromPath(path) {
  return path && path !== "root" ? path.split("/").slice(-2, -1)[0] : "Root";
}
function formatStoreForInspectorTree(module, path) {
  return {
    id: path || "root",
    label: extractNameFromPath(path),
    tags: module.namespaced ? [TAG_NAMESPACED] : [],
    children: Object.keys(module._children).map(
      function(moduleName) {
        return formatStoreForInspectorTree(
          module._children[moduleName],
          path + moduleName + "/"
        );
      }
    )
  };
}
function flattenStoreForInspectorTree(result, module, filter, path) {
  if (path.includes(filter)) {
    result.push({
      id: path || "root",
      label: path.endsWith("/") ? path.slice(0, path.length - 1) : path || "Root",
      tags: module.namespaced ? [TAG_NAMESPACED] : []
    });
  }
  Object.keys(module._children).forEach(function(moduleName) {
    flattenStoreForInspectorTree(result, module._children[moduleName], filter, path + moduleName + "/");
  });
}
function formatStoreForInspectorState(module, getters, path) {
  getters = path === "root" ? getters : getters[path];
  var gettersKeys = Object.keys(getters);
  var storeState = {
    state: Object.keys(module.state).map(function(key) {
      return {
        key,
        editable: true,
        value: module.state[key]
      };
    })
  };
  if (gettersKeys.length) {
    var tree = transformPathsToObjectTree(getters);
    storeState.getters = Object.keys(tree).map(function(key) {
      return {
        key: key.endsWith("/") ? extractNameFromPath(key) : key,
        editable: false,
        value: canThrow(function() {
          return tree[key];
        })
      };
    });
  }
  return storeState;
}
function transformPathsToObjectTree(getters) {
  var result = {};
  Object.keys(getters).forEach(function(key) {
    var path = key.split("/");
    if (path.length > 1) {
      var target = result;
      var leafKey = path.pop();
      path.forEach(function(p2) {
        if (!target[p2]) {
          target[p2] = {
            _custom: {
              value: {},
              display: p2,
              tooltip: "Module",
              abstract: true
            }
          };
        }
        target = target[p2]._custom.value;
      });
      target[leafKey] = canThrow(function() {
        return getters[key];
      });
    } else {
      result[key] = canThrow(function() {
        return getters[key];
      });
    }
  });
  return result;
}
function getStoreModule(moduleMap, path) {
  var names = path.split("/").filter(function(n2) {
    return n2;
  });
  return names.reduce(
    function(module, moduleName, i2) {
      var child2 = module[moduleName];
      if (!child2) {
        throw new Error('Missing module "' + moduleName + '" for path "' + path + '".');
      }
      return i2 === names.length - 1 ? child2 : child2._children;
    },
    path === "root" ? moduleMap : moduleMap.root._children
  );
}
function canThrow(cb2) {
  try {
    return cb2();
  } catch (e2) {
    return e2;
  }
}
var Module = function Module2(rawModule, runtime) {
  this.runtime = runtime;
  this._children = /* @__PURE__ */ Object.create(null);
  this._rawModule = rawModule;
  var rawState = rawModule.state;
  this.state = (typeof rawState === "function" ? rawState() : rawState) || {};
};
var prototypeAccessors$1 = { namespaced: { configurable: true } };
prototypeAccessors$1.namespaced.get = function() {
  return !!this._rawModule.namespaced;
};
Module.prototype.addChild = function addChild(key, module) {
  this._children[key] = module;
};
Module.prototype.removeChild = function removeChild(key) {
  delete this._children[key];
};
Module.prototype.getChild = function getChild(key) {
  return this._children[key];
};
Module.prototype.hasChild = function hasChild(key) {
  return key in this._children;
};
Module.prototype.update = function update(rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;
  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }
  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }
  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};
Module.prototype.forEachChild = function forEachChild(fn2) {
  forEachValue(this._children, fn2);
};
Module.prototype.forEachGetter = function forEachGetter(fn2) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn2);
  }
};
Module.prototype.forEachAction = function forEachAction(fn2) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn2);
  }
};
Module.prototype.forEachMutation = function forEachMutation(fn2) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn2);
  }
};
Object.defineProperties(Module.prototype, prototypeAccessors$1);
var ModuleCollection = function ModuleCollection2(rawRootModule) {
  this.register([], rawRootModule, false);
};
ModuleCollection.prototype.get = function get2(path) {
  return path.reduce(function(module, key) {
    return module.getChild(key);
  }, this.root);
};
ModuleCollection.prototype.getNamespace = function getNamespace(path) {
  var module = this.root;
  return path.reduce(function(namespace, key) {
    module = module.getChild(key);
    return namespace + (module.namespaced ? key + "/" : "");
  }, "");
};
ModuleCollection.prototype.update = function update$1(rawRootModule) {
  update2([], this.root, rawRootModule);
};
ModuleCollection.prototype.register = function register(path, rawModule, runtime) {
  var this$1$1 = this;
  if (runtime === void 0)
    runtime = true;
  var newModule = new Module(rawModule, runtime);
  if (path.length === 0) {
    this.root = newModule;
  } else {
    var parent2 = this.get(path.slice(0, -1));
    parent2.addChild(path[path.length - 1], newModule);
  }
  if (rawModule.modules) {
    forEachValue(rawModule.modules, function(rawChildModule, key) {
      this$1$1.register(path.concat(key), rawChildModule, runtime);
    });
  }
};
ModuleCollection.prototype.unregister = function unregister(path) {
  var parent2 = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  var child2 = parent2.getChild(key);
  if (!child2) {
    return;
  }
  if (!child2.runtime) {
    return;
  }
  parent2.removeChild(key);
};
ModuleCollection.prototype.isRegistered = function isRegistered(path) {
  var parent2 = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  if (parent2) {
    return parent2.hasChild(key);
  }
  return false;
};
function update2(path, targetModule, newModule) {
  targetModule.update(newModule);
  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        return;
      }
      update2(
        path.concat(key),
        targetModule.getChild(key),
        newModule.modules[key]
      );
    }
  }
}
function createStore(options) {
  return new Store(options);
}
var Store = function Store2(options) {
  var this$1$1 = this;
  if (options === void 0)
    options = {};
  var plugins = options.plugins;
  if (plugins === void 0)
    plugins = [];
  var strict = options.strict;
  if (strict === void 0)
    strict = false;
  var devtools = options.devtools;
  this._committing = false;
  this._actions = /* @__PURE__ */ Object.create(null);
  this._actionSubscribers = [];
  this._mutations = /* @__PURE__ */ Object.create(null);
  this._wrappedGetters = /* @__PURE__ */ Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = /* @__PURE__ */ Object.create(null);
  this._subscribers = [];
  this._makeLocalGettersCache = /* @__PURE__ */ Object.create(null);
  this._devtools = devtools;
  var store2 = this;
  var ref2 = this;
  var dispatch2 = ref2.dispatch;
  var commit2 = ref2.commit;
  this.dispatch = function boundDispatch(type2, payload) {
    return dispatch2.call(store2, type2, payload);
  };
  this.commit = function boundCommit(type2, payload, options2) {
    return commit2.call(store2, type2, payload, options2);
  };
  this.strict = strict;
  var state = this._modules.root.state;
  installModule(this, state, [], this._modules.root);
  resetStoreState(this, state);
  plugins.forEach(function(plugin2) {
    return plugin2(this$1$1);
  });
};
var prototypeAccessors = { state: { configurable: true } };
Store.prototype.install = function install2(app2, injectKey) {
  app2.provide(injectKey || storeKey, this);
  app2.config.globalProperties.$store = this;
  var useDevtools = this._devtools !== void 0 ? this._devtools : false;
  if (useDevtools) {
    addDevtools(app2, this);
  }
};
prototypeAccessors.state.get = function() {
  return this._state.data;
};
prototypeAccessors.state.set = function(v2) {
};
Store.prototype.commit = function commit(_type, _payload, _options) {
  var this$1$1 = this;
  var ref2 = unifyObjectStyle(_type, _payload, _options);
  var type2 = ref2.type;
  var payload = ref2.payload;
  var mutation = { type: type2, payload };
  var entry = this._mutations[type2];
  if (!entry) {
    return;
  }
  this._withCommit(function() {
    entry.forEach(function commitIterator(handler) {
      handler(payload);
    });
  });
  this._subscribers.slice().forEach(function(sub) {
    return sub(mutation, this$1$1.state);
  });
};
Store.prototype.dispatch = function dispatch(_type, _payload) {
  var this$1$1 = this;
  var ref2 = unifyObjectStyle(_type, _payload);
  var type2 = ref2.type;
  var payload = ref2.payload;
  var action = { type: type2, payload };
  var entry = this._actions[type2];
  if (!entry) {
    return;
  }
  try {
    this._actionSubscribers.slice().filter(function(sub) {
      return sub.before;
    }).forEach(function(sub) {
      return sub.before(action, this$1$1.state);
    });
  } catch (e2) {
  }
  var result = entry.length > 1 ? Promise.all(entry.map(function(handler) {
    return handler(payload);
  })) : entry[0](payload);
  return new Promise(function(resolve2, reject) {
    result.then(function(res) {
      try {
        this$1$1._actionSubscribers.filter(function(sub) {
          return sub.after;
        }).forEach(function(sub) {
          return sub.after(action, this$1$1.state);
        });
      } catch (e2) {
      }
      resolve2(res);
    }, function(error) {
      try {
        this$1$1._actionSubscribers.filter(function(sub) {
          return sub.error;
        }).forEach(function(sub) {
          return sub.error(action, this$1$1.state, error);
        });
      } catch (e2) {
      }
      reject(error);
    });
  });
};
Store.prototype.subscribe = function subscribe(fn2, options) {
  return genericSubscribe(fn2, this._subscribers, options);
};
Store.prototype.subscribeAction = function subscribeAction(fn2, options) {
  var subs = typeof fn2 === "function" ? { before: fn2 } : fn2;
  return genericSubscribe(subs, this._actionSubscribers, options);
};
Store.prototype.watch = function watch$1(getter, cb2, options) {
  var this$1$1 = this;
  return watch(function() {
    return getter(this$1$1.state, this$1$1.getters);
  }, cb2, Object.assign({}, options));
};
Store.prototype.replaceState = function replaceState(state) {
  var this$1$1 = this;
  this._withCommit(function() {
    this$1$1._state.data = state;
  });
};
Store.prototype.registerModule = function registerModule(path, rawModule, options) {
  if (options === void 0)
    options = {};
  if (typeof path === "string") {
    path = [path];
  }
  this._modules.register(path, rawModule);
  installModule(this, this.state, path, this._modules.get(path), options.preserveState);
  resetStoreState(this, this.state);
};
Store.prototype.unregisterModule = function unregisterModule(path) {
  var this$1$1 = this;
  if (typeof path === "string") {
    path = [path];
  }
  this._modules.unregister(path);
  this._withCommit(function() {
    var parentState = getNestedState(this$1$1.state, path.slice(0, -1));
    delete parentState[path[path.length - 1]];
  });
  resetStore(this);
};
Store.prototype.hasModule = function hasModule(path) {
  if (typeof path === "string") {
    path = [path];
  }
  return this._modules.isRegistered(path);
};
Store.prototype.hotUpdate = function hotUpdate(newOptions) {
  this._modules.update(newOptions);
  resetStore(this, true);
};
Store.prototype._withCommit = function _withCommit(fn2) {
  var committing = this._committing;
  this._committing = true;
  fn2();
  this._committing = committing;
};
Object.defineProperties(Store.prototype, prototypeAccessors);
const useRecentDocs = defineStore("recentDocs", {
  state: () => ({
    ids: []
  }),
  actions: {
    add(addId) {
      if (!this.ids.includes(addId)) {
        this.ids.push(addId);
      }
    },
    remove(removeId) {
      this.ids = this.ids.filter((id2) => id2 !== removeId);
    }
  },
  caching: false
});
var commonjsGlobal$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var k$1, goog = goog || {}, l = commonjsGlobal$1 || self;
function aa$1() {
}
function ba$1(a2) {
  var b2 = typeof a2;
  b2 = "object" != b2 ? b2 : a2 ? Array.isArray(a2) ? "array" : b2 : "null";
  return "array" == b2 || "object" == b2 && "number" == typeof a2.length;
}
function p(a2) {
  var b2 = typeof a2;
  return "object" == b2 && null != a2 || "function" == b2;
}
function da(a2) {
  return Object.prototype.hasOwnProperty.call(a2, ea) && a2[ea] || (a2[ea] = ++fa);
}
var ea = "closure_uid_" + (1e9 * Math.random() >>> 0), fa = 0;
function ha(a2, b2, c2) {
  return a2.call.apply(a2.bind, arguments);
}
function ia(a2, b2, c2) {
  if (!a2)
    throw Error();
  if (2 < arguments.length) {
    var d2 = Array.prototype.slice.call(arguments, 2);
    return function() {
      var e2 = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(e2, d2);
      return a2.apply(b2, e2);
    };
  }
  return function() {
    return a2.apply(b2, arguments);
  };
}
function q(a2, b2, c2) {
  Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? q = ha : q = ia;
  return q.apply(null, arguments);
}
function ja(a2, b2) {
  var c2 = Array.prototype.slice.call(arguments, 1);
  return function() {
    var d2 = c2.slice();
    d2.push.apply(d2, arguments);
    return a2.apply(this, d2);
  };
}
function t(a2, b2) {
  function c2() {
  }
  c2.prototype = b2.prototype;
  a2.Z = b2.prototype;
  a2.prototype = new c2();
  a2.prototype.constructor = a2;
  a2.Vb = function(d2, e2, f2) {
    for (var h2 = Array(arguments.length - 2), n2 = 2; n2 < arguments.length; n2++)
      h2[n2 - 2] = arguments[n2];
    return b2.prototype[e2].apply(d2, h2);
  };
}
function v() {
  this.s = this.s;
  this.o = this.o;
}
var ka$1 = 0;
v.prototype.s = false;
v.prototype.na = function() {
  if (!this.s && (this.s = true, this.M(), 0 != ka$1)) {
    da(this);
  }
};
v.prototype.M = function() {
  if (this.o)
    for (; this.o.length; )
      this.o.shift()();
};
const ma$1 = Array.prototype.indexOf ? function(a2, b2) {
  return Array.prototype.indexOf.call(a2, b2, void 0);
} : function(a2, b2) {
  if ("string" === typeof a2)
    return "string" !== typeof b2 || 1 != b2.length ? -1 : a2.indexOf(b2, 0);
  for (let c2 = 0; c2 < a2.length; c2++)
    if (c2 in a2 && a2[c2] === b2)
      return c2;
  return -1;
}, na$1 = Array.prototype.forEach ? function(a2, b2, c2) {
  Array.prototype.forEach.call(a2, b2, c2);
} : function(a2, b2, c2) {
  const d2 = a2.length, e2 = "string" === typeof a2 ? a2.split("") : a2;
  for (let f2 = 0; f2 < d2; f2++)
    f2 in e2 && b2.call(c2, e2[f2], f2, a2);
};
function oa(a2) {
  a: {
    var b2 = pa$1;
    const c2 = a2.length, d2 = "string" === typeof a2 ? a2.split("") : a2;
    for (let e2 = 0; e2 < c2; e2++)
      if (e2 in d2 && b2.call(void 0, d2[e2], e2, a2)) {
        b2 = e2;
        break a;
      }
    b2 = -1;
  }
  return 0 > b2 ? null : "string" === typeof a2 ? a2.charAt(b2) : a2[b2];
}
function qa(a2) {
  return Array.prototype.concat.apply([], arguments);
}
function ra(a2) {
  const b2 = a2.length;
  if (0 < b2) {
    const c2 = Array(b2);
    for (let d2 = 0; d2 < b2; d2++)
      c2[d2] = a2[d2];
    return c2;
  }
  return [];
}
function sa$1(a2) {
  return /^[\s\xa0]*$/.test(a2);
}
var ta = String.prototype.trim ? function(a2) {
  return a2.trim();
} : function(a2) {
  return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a2)[1];
};
function w(a2, b2) {
  return -1 != a2.indexOf(b2);
}
function ua(a2, b2) {
  return a2 < b2 ? -1 : a2 > b2 ? 1 : 0;
}
var x$1;
a: {
  var va$1 = l.navigator;
  if (va$1) {
    var wa$1 = va$1.userAgent;
    if (wa$1) {
      x$1 = wa$1;
      break a;
    }
  }
  x$1 = "";
}
function xa(a2, b2, c2) {
  for (const d2 in a2)
    b2.call(c2, a2[d2], d2, a2);
}
function ya$1(a2) {
  const b2 = {};
  for (const c2 in a2)
    b2[c2] = a2[c2];
  return b2;
}
var za = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function Aa$1(a2, b2) {
  let c2, d2;
  for (let e2 = 1; e2 < arguments.length; e2++) {
    d2 = arguments[e2];
    for (c2 in d2)
      a2[c2] = d2[c2];
    for (let f2 = 0; f2 < za.length; f2++)
      c2 = za[f2], Object.prototype.hasOwnProperty.call(d2, c2) && (a2[c2] = d2[c2]);
  }
}
function Ca(a2) {
  Ca[" "](a2);
  return a2;
}
Ca[" "] = aa$1;
function Fa$1(a2) {
  var b2 = Ga;
  return Object.prototype.hasOwnProperty.call(b2, 9) ? b2[9] : b2[9] = a2(9);
}
var Ha = w(x$1, "Opera"), y = w(x$1, "Trident") || w(x$1, "MSIE"), Ia$1 = w(x$1, "Edge"), Ja = Ia$1 || y, Ka = w(x$1, "Gecko") && !(w(x$1.toLowerCase(), "webkit") && !w(x$1, "Edge")) && !(w(x$1, "Trident") || w(x$1, "MSIE")) && !w(x$1, "Edge"), La$1 = w(x$1.toLowerCase(), "webkit") && !w(x$1, "Edge");
function Ma() {
  var a2 = l.document;
  return a2 ? a2.documentMode : void 0;
}
var Na$1;
a: {
  var Oa = "", Pa$1 = function() {
    var a2 = x$1;
    if (Ka)
      return /rv:([^\);]+)(\)|;)/.exec(a2);
    if (Ia$1)
      return /Edge\/([\d\.]+)/.exec(a2);
    if (y)
      return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a2);
    if (La$1)
      return /WebKit\/(\S+)/.exec(a2);
    if (Ha)
      return /(?:Version)[ \/]?(\S+)/.exec(a2);
  }();
  Pa$1 && (Oa = Pa$1 ? Pa$1[1] : "");
  if (y) {
    var Qa = Ma();
    if (null != Qa && Qa > parseFloat(Oa)) {
      Na$1 = String(Qa);
      break a;
    }
  }
  Na$1 = Oa;
}
var Ga = {};
function Ra$1() {
  return Fa$1(function() {
    let a2 = 0;
    const b2 = ta(String(Na$1)).split("."), c2 = ta("9").split("."), d2 = Math.max(b2.length, c2.length);
    for (let h2 = 0; 0 == a2 && h2 < d2; h2++) {
      var e2 = b2[h2] || "", f2 = c2[h2] || "";
      do {
        e2 = /(\d*)(\D*)(.*)/.exec(e2) || ["", "", "", ""];
        f2 = /(\d*)(\D*)(.*)/.exec(f2) || ["", "", "", ""];
        if (0 == e2[0].length && 0 == f2[0].length)
          break;
        a2 = ua(0 == e2[1].length ? 0 : parseInt(e2[1], 10), 0 == f2[1].length ? 0 : parseInt(f2[1], 10)) || ua(0 == e2[2].length, 0 == f2[2].length) || ua(e2[2], f2[2]);
        e2 = e2[3];
        f2 = f2[3];
      } while (0 == a2);
    }
    return 0 <= a2;
  });
}
var Sa;
if (l.document && y) {
  var Ta = Ma();
  Sa = Ta ? Ta : parseInt(Na$1, 10) || void 0;
} else
  Sa = void 0;
var Ua$1 = Sa;
var Va$1 = function() {
  if (!l.addEventListener || !Object.defineProperty)
    return false;
  var a2 = false, b2 = Object.defineProperty({}, "passive", { get: function() {
    a2 = true;
  } });
  try {
    l.addEventListener("test", aa$1, b2), l.removeEventListener("test", aa$1, b2);
  } catch (c2) {
  }
  return a2;
}();
function z$1(a2, b2) {
  this.type = a2;
  this.g = this.target = b2;
  this.defaultPrevented = false;
}
z$1.prototype.h = function() {
  this.defaultPrevented = true;
};
function A(a2, b2) {
  z$1.call(this, a2 ? a2.type : "");
  this.relatedTarget = this.g = this.target = null;
  this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0;
  this.key = "";
  this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = false;
  this.state = null;
  this.pointerId = 0;
  this.pointerType = "";
  this.i = null;
  if (a2) {
    var c2 = this.type = a2.type, d2 = a2.changedTouches && a2.changedTouches.length ? a2.changedTouches[0] : null;
    this.target = a2.target || a2.srcElement;
    this.g = b2;
    if (b2 = a2.relatedTarget) {
      if (Ka) {
        a: {
          try {
            Ca(b2.nodeName);
            var e2 = true;
            break a;
          } catch (f2) {
          }
          e2 = false;
        }
        e2 || (b2 = null);
      }
    } else
      "mouseover" == c2 ? b2 = a2.fromElement : "mouseout" == c2 && (b2 = a2.toElement);
    this.relatedTarget = b2;
    d2 ? (this.clientX = void 0 !== d2.clientX ? d2.clientX : d2.pageX, this.clientY = void 0 !== d2.clientY ? d2.clientY : d2.pageY, this.screenX = d2.screenX || 0, this.screenY = d2.screenY || 0) : (this.clientX = void 0 !== a2.clientX ? a2.clientX : a2.pageX, this.clientY = void 0 !== a2.clientY ? a2.clientY : a2.pageY, this.screenX = a2.screenX || 0, this.screenY = a2.screenY || 0);
    this.button = a2.button;
    this.key = a2.key || "";
    this.ctrlKey = a2.ctrlKey;
    this.altKey = a2.altKey;
    this.shiftKey = a2.shiftKey;
    this.metaKey = a2.metaKey;
    this.pointerId = a2.pointerId || 0;
    this.pointerType = "string" === typeof a2.pointerType ? a2.pointerType : Wa[a2.pointerType] || "";
    this.state = a2.state;
    this.i = a2;
    a2.defaultPrevented && A.Z.h.call(this);
  }
}
t(A, z$1);
var Wa = { 2: "touch", 3: "pen", 4: "mouse" };
A.prototype.h = function() {
  A.Z.h.call(this);
  var a2 = this.i;
  a2.preventDefault ? a2.preventDefault() : a2.returnValue = false;
};
var B$1 = "closure_listenable_" + (1e6 * Math.random() | 0);
var Xa = 0;
function Ya(a2, b2, c2, d2, e2) {
  this.listener = a2;
  this.proxy = null;
  this.src = b2;
  this.type = c2;
  this.capture = !!d2;
  this.ia = e2;
  this.key = ++Xa;
  this.ca = this.fa = false;
}
function Za$1(a2) {
  a2.ca = true;
  a2.listener = null;
  a2.proxy = null;
  a2.src = null;
  a2.ia = null;
}
function $a$1(a2) {
  this.src = a2;
  this.g = {};
  this.h = 0;
}
$a$1.prototype.add = function(a2, b2, c2, d2, e2) {
  var f2 = a2.toString();
  a2 = this.g[f2];
  a2 || (a2 = this.g[f2] = [], this.h++);
  var h2 = ab(a2, b2, d2, e2);
  -1 < h2 ? (b2 = a2[h2], c2 || (b2.fa = false)) : (b2 = new Ya(b2, this.src, f2, !!d2, e2), b2.fa = c2, a2.push(b2));
  return b2;
};
function bb(a2, b2) {
  var c2 = b2.type;
  if (c2 in a2.g) {
    var d2 = a2.g[c2], e2 = ma$1(d2, b2), f2;
    (f2 = 0 <= e2) && Array.prototype.splice.call(d2, e2, 1);
    f2 && (Za$1(b2), 0 == a2.g[c2].length && (delete a2.g[c2], a2.h--));
  }
}
function ab(a2, b2, c2, d2) {
  for (var e2 = 0; e2 < a2.length; ++e2) {
    var f2 = a2[e2];
    if (!f2.ca && f2.listener == b2 && f2.capture == !!c2 && f2.ia == d2)
      return e2;
  }
  return -1;
}
var cb = "closure_lm_" + (1e6 * Math.random() | 0), db = {};
function fb(a2, b2, c2, d2, e2) {
  if (d2 && d2.once)
    return gb(a2, b2, c2, d2, e2);
  if (Array.isArray(b2)) {
    for (var f2 = 0; f2 < b2.length; f2++)
      fb(a2, b2[f2], c2, d2, e2);
    return null;
  }
  c2 = hb(c2);
  return a2 && a2[B$1] ? a2.N(b2, c2, p(d2) ? !!d2.capture : !!d2, e2) : ib(a2, b2, c2, false, d2, e2);
}
function ib(a2, b2, c2, d2, e2, f2) {
  if (!b2)
    throw Error("Invalid event type");
  var h2 = p(e2) ? !!e2.capture : !!e2, n2 = jb(a2);
  n2 || (a2[cb] = n2 = new $a$1(a2));
  c2 = n2.add(b2, c2, d2, h2, f2);
  if (c2.proxy)
    return c2;
  d2 = kb();
  c2.proxy = d2;
  d2.src = a2;
  d2.listener = c2;
  if (a2.addEventListener)
    Va$1 || (e2 = h2), void 0 === e2 && (e2 = false), a2.addEventListener(b2.toString(), d2, e2);
  else if (a2.attachEvent)
    a2.attachEvent(lb(b2.toString()), d2);
  else if (a2.addListener && a2.removeListener)
    a2.addListener(d2);
  else
    throw Error("addEventListener and attachEvent are unavailable.");
  return c2;
}
function kb() {
  function a2(c2) {
    return b2.call(a2.src, a2.listener, c2);
  }
  var b2 = mb;
  return a2;
}
function gb(a2, b2, c2, d2, e2) {
  if (Array.isArray(b2)) {
    for (var f2 = 0; f2 < b2.length; f2++)
      gb(a2, b2[f2], c2, d2, e2);
    return null;
  }
  c2 = hb(c2);
  return a2 && a2[B$1] ? a2.O(b2, c2, p(d2) ? !!d2.capture : !!d2, e2) : ib(a2, b2, c2, true, d2, e2);
}
function nb(a2, b2, c2, d2, e2) {
  if (Array.isArray(b2))
    for (var f2 = 0; f2 < b2.length; f2++)
      nb(a2, b2[f2], c2, d2, e2);
  else
    (d2 = p(d2) ? !!d2.capture : !!d2, c2 = hb(c2), a2 && a2[B$1]) ? (a2 = a2.i, b2 = String(b2).toString(), b2 in a2.g && (f2 = a2.g[b2], c2 = ab(f2, c2, d2, e2), -1 < c2 && (Za$1(f2[c2]), Array.prototype.splice.call(f2, c2, 1), 0 == f2.length && (delete a2.g[b2], a2.h--)))) : a2 && (a2 = jb(a2)) && (b2 = a2.g[b2.toString()], a2 = -1, b2 && (a2 = ab(b2, c2, d2, e2)), (c2 = -1 < a2 ? b2[a2] : null) && ob(c2));
}
function ob(a2) {
  if ("number" !== typeof a2 && a2 && !a2.ca) {
    var b2 = a2.src;
    if (b2 && b2[B$1])
      bb(b2.i, a2);
    else {
      var c2 = a2.type, d2 = a2.proxy;
      b2.removeEventListener ? b2.removeEventListener(c2, d2, a2.capture) : b2.detachEvent ? b2.detachEvent(lb(c2), d2) : b2.addListener && b2.removeListener && b2.removeListener(d2);
      (c2 = jb(b2)) ? (bb(c2, a2), 0 == c2.h && (c2.src = null, b2[cb] = null)) : Za$1(a2);
    }
  }
}
function lb(a2) {
  return a2 in db ? db[a2] : db[a2] = "on" + a2;
}
function mb(a2, b2) {
  if (a2.ca)
    a2 = true;
  else {
    b2 = new A(b2, this);
    var c2 = a2.listener, d2 = a2.ia || a2.src;
    a2.fa && ob(a2);
    a2 = c2.call(d2, b2);
  }
  return a2;
}
function jb(a2) {
  a2 = a2[cb];
  return a2 instanceof $a$1 ? a2 : null;
}
var pb = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
function hb(a2) {
  if ("function" === typeof a2)
    return a2;
  a2[pb] || (a2[pb] = function(b2) {
    return a2.handleEvent(b2);
  });
  return a2[pb];
}
function C$1() {
  v.call(this);
  this.i = new $a$1(this);
  this.P = this;
  this.I = null;
}
t(C$1, v);
C$1.prototype[B$1] = true;
C$1.prototype.removeEventListener = function(a2, b2, c2, d2) {
  nb(this, a2, b2, c2, d2);
};
function D$1(a2, b2) {
  var c2, d2 = a2.I;
  if (d2)
    for (c2 = []; d2; d2 = d2.I)
      c2.push(d2);
  a2 = a2.P;
  d2 = b2.type || b2;
  if ("string" === typeof b2)
    b2 = new z$1(b2, a2);
  else if (b2 instanceof z$1)
    b2.target = b2.target || a2;
  else {
    var e2 = b2;
    b2 = new z$1(d2, a2);
    Aa$1(b2, e2);
  }
  e2 = true;
  if (c2)
    for (var f2 = c2.length - 1; 0 <= f2; f2--) {
      var h2 = b2.g = c2[f2];
      e2 = qb(h2, d2, true, b2) && e2;
    }
  h2 = b2.g = a2;
  e2 = qb(h2, d2, true, b2) && e2;
  e2 = qb(h2, d2, false, b2) && e2;
  if (c2)
    for (f2 = 0; f2 < c2.length; f2++)
      h2 = b2.g = c2[f2], e2 = qb(h2, d2, false, b2) && e2;
}
C$1.prototype.M = function() {
  C$1.Z.M.call(this);
  if (this.i) {
    var a2 = this.i, c2;
    for (c2 in a2.g) {
      for (var d2 = a2.g[c2], e2 = 0; e2 < d2.length; e2++)
        Za$1(d2[e2]);
      delete a2.g[c2];
      a2.h--;
    }
  }
  this.I = null;
};
C$1.prototype.N = function(a2, b2, c2, d2) {
  return this.i.add(String(a2), b2, false, c2, d2);
};
C$1.prototype.O = function(a2, b2, c2, d2) {
  return this.i.add(String(a2), b2, true, c2, d2);
};
function qb(a2, b2, c2, d2) {
  b2 = a2.i.g[String(b2)];
  if (!b2)
    return true;
  b2 = b2.concat();
  for (var e2 = true, f2 = 0; f2 < b2.length; ++f2) {
    var h2 = b2[f2];
    if (h2 && !h2.ca && h2.capture == c2) {
      var n2 = h2.listener, u2 = h2.ia || h2.src;
      h2.fa && bb(a2.i, h2);
      e2 = false !== n2.call(u2, d2) && e2;
    }
  }
  return e2 && !d2.defaultPrevented;
}
var rb = l.JSON.stringify;
function sb() {
  var a2 = tb;
  let b2 = null;
  a2.g && (b2 = a2.g, a2.g = a2.g.next, a2.g || (a2.h = null), b2.next = null);
  return b2;
}
class ub {
  constructor() {
    this.h = this.g = null;
  }
  add(a2, b2) {
    const c2 = vb.get();
    c2.set(a2, b2);
    this.h ? this.h.next = c2 : this.g = c2;
    this.h = c2;
  }
}
var vb = new class {
  constructor(a2, b2) {
    this.i = a2;
    this.j = b2;
    this.h = 0;
    this.g = null;
  }
  get() {
    let a2;
    0 < this.h ? (this.h--, a2 = this.g, this.g = a2.next, a2.next = null) : a2 = this.i();
    return a2;
  }
}(() => new wb(), (a2) => a2.reset());
class wb {
  constructor() {
    this.next = this.g = this.h = null;
  }
  set(a2, b2) {
    this.h = a2;
    this.g = b2;
    this.next = null;
  }
  reset() {
    this.next = this.g = this.h = null;
  }
}
function yb(a2) {
  l.setTimeout(() => {
    throw a2;
  }, 0);
}
function zb(a2, b2) {
  Ab || Bb();
  Cb || (Ab(), Cb = true);
  tb.add(a2, b2);
}
var Ab;
function Bb() {
  var a2 = l.Promise.resolve(void 0);
  Ab = function() {
    a2.then(Db);
  };
}
var Cb = false, tb = new ub();
function Db() {
  for (var a2; a2 = sb(); ) {
    try {
      a2.h.call(a2.g);
    } catch (c2) {
      yb(c2);
    }
    var b2 = vb;
    b2.j(a2);
    100 > b2.h && (b2.h++, a2.next = b2.g, b2.g = a2);
  }
  Cb = false;
}
function Eb(a2, b2) {
  C$1.call(this);
  this.h = a2 || 1;
  this.g = b2 || l;
  this.j = q(this.kb, this);
  this.l = Date.now();
}
t(Eb, C$1);
k$1 = Eb.prototype;
k$1.da = false;
k$1.S = null;
k$1.kb = function() {
  if (this.da) {
    var a2 = Date.now() - this.l;
    0 < a2 && a2 < 0.8 * this.h ? this.S = this.g.setTimeout(this.j, this.h - a2) : (this.S && (this.g.clearTimeout(this.S), this.S = null), D$1(this, "tick"), this.da && (Fb(this), this.start()));
  }
};
k$1.start = function() {
  this.da = true;
  this.S || (this.S = this.g.setTimeout(this.j, this.h), this.l = Date.now());
};
function Fb(a2) {
  a2.da = false;
  a2.S && (a2.g.clearTimeout(a2.S), a2.S = null);
}
k$1.M = function() {
  Eb.Z.M.call(this);
  Fb(this);
  delete this.g;
};
function Gb(a2, b2, c2) {
  if ("function" === typeof a2)
    c2 && (a2 = q(a2, c2));
  else if (a2 && "function" == typeof a2.handleEvent)
    a2 = q(a2.handleEvent, a2);
  else
    throw Error("Invalid listener argument");
  return 2147483647 < Number(b2) ? -1 : l.setTimeout(a2, b2 || 0);
}
function Hb(a2) {
  a2.g = Gb(() => {
    a2.g = null;
    a2.i && (a2.i = false, Hb(a2));
  }, a2.j);
  const b2 = a2.h;
  a2.h = null;
  a2.m.apply(null, b2);
}
class Ib extends v {
  constructor(a2, b2) {
    super();
    this.m = a2;
    this.j = b2;
    this.h = null;
    this.i = false;
    this.g = null;
  }
  l(a2) {
    this.h = arguments;
    this.g ? this.i = true : Hb(this);
  }
  M() {
    super.M();
    this.g && (l.clearTimeout(this.g), this.g = null, this.i = false, this.h = null);
  }
}
function E(a2) {
  v.call(this);
  this.h = a2;
  this.g = {};
}
t(E, v);
var Jb = [];
function Kb(a2, b2, c2, d2) {
  Array.isArray(c2) || (c2 && (Jb[0] = c2.toString()), c2 = Jb);
  for (var e2 = 0; e2 < c2.length; e2++) {
    var f2 = fb(b2, c2[e2], d2 || a2.handleEvent, false, a2.h || a2);
    if (!f2)
      break;
    a2.g[f2.key] = f2;
  }
}
function Lb(a2) {
  xa(a2.g, function(b2, c2) {
    this.g.hasOwnProperty(c2) && ob(b2);
  }, a2);
  a2.g = {};
}
E.prototype.M = function() {
  E.Z.M.call(this);
  Lb(this);
};
E.prototype.handleEvent = function() {
  throw Error("EventHandler.handleEvent not implemented");
};
function Mb() {
  this.g = true;
}
Mb.prototype.Aa = function() {
  this.g = false;
};
function Nb(a2, b2, c2, d2, e2, f2) {
  a2.info(function() {
    if (a2.g)
      if (f2) {
        var h2 = "";
        for (var n2 = f2.split("&"), u2 = 0; u2 < n2.length; u2++) {
          var m2 = n2[u2].split("=");
          if (1 < m2.length) {
            var r2 = m2[0];
            m2 = m2[1];
            var G2 = r2.split("_");
            h2 = 2 <= G2.length && "type" == G2[1] ? h2 + (r2 + "=" + m2 + "&") : h2 + (r2 + "=redacted&");
          }
        }
      } else
        h2 = null;
    else
      h2 = f2;
    return "XMLHTTP REQ (" + d2 + ") [attempt " + e2 + "]: " + b2 + "\n" + c2 + "\n" + h2;
  });
}
function Ob(a2, b2, c2, d2, e2, f2, h2) {
  a2.info(function() {
    return "XMLHTTP RESP (" + d2 + ") [ attempt " + e2 + "]: " + b2 + "\n" + c2 + "\n" + f2 + " " + h2;
  });
}
function F$1(a2, b2, c2, d2) {
  a2.info(function() {
    return "XMLHTTP TEXT (" + b2 + "): " + Pb(a2, c2) + (d2 ? " " + d2 : "");
  });
}
function Qb(a2, b2) {
  a2.info(function() {
    return "TIMEOUT: " + b2;
  });
}
Mb.prototype.info = function() {
};
function Pb(a2, b2) {
  if (!a2.g)
    return b2;
  if (!b2)
    return null;
  try {
    var c2 = JSON.parse(b2);
    if (c2) {
      for (a2 = 0; a2 < c2.length; a2++)
        if (Array.isArray(c2[a2])) {
          var d2 = c2[a2];
          if (!(2 > d2.length)) {
            var e2 = d2[1];
            if (Array.isArray(e2) && !(1 > e2.length)) {
              var f2 = e2[0];
              if ("noop" != f2 && "stop" != f2 && "close" != f2)
                for (var h2 = 1; h2 < e2.length; h2++)
                  e2[h2] = "";
            }
          }
        }
    }
    return rb(c2);
  } catch (n2) {
    return b2;
  }
}
var H$1 = {}, Rb = null;
function Sb() {
  return Rb = Rb || new C$1();
}
H$1.Ma = "serverreachability";
function Tb(a2) {
  z$1.call(this, H$1.Ma, a2);
}
t(Tb, z$1);
function I(a2) {
  const b2 = Sb();
  D$1(b2, new Tb(b2));
}
H$1.STAT_EVENT = "statevent";
function Ub(a2, b2) {
  z$1.call(this, H$1.STAT_EVENT, a2);
  this.stat = b2;
}
t(Ub, z$1);
function J$1(a2) {
  const b2 = Sb();
  D$1(b2, new Ub(b2, a2));
}
H$1.Na = "timingevent";
function Vb(a2, b2) {
  z$1.call(this, H$1.Na, a2);
  this.size = b2;
}
t(Vb, z$1);
function K$1(a2, b2) {
  if ("function" !== typeof a2)
    throw Error("Fn must not be null and must be a function");
  return l.setTimeout(function() {
    a2();
  }, b2);
}
var Wb = { NO_ERROR: 0, lb: 1, yb: 2, xb: 3, sb: 4, wb: 5, zb: 6, Ja: 7, TIMEOUT: 8, Cb: 9 };
var Xb = { qb: "complete", Mb: "success", Ka: "error", Ja: "abort", Eb: "ready", Fb: "readystatechange", TIMEOUT: "timeout", Ab: "incrementaldata", Db: "progress", tb: "downloadprogress", Ub: "uploadprogress" };
function Yb() {
}
Yb.prototype.h = null;
function Zb(a2) {
  return a2.h || (a2.h = a2.i());
}
function $b() {
}
var L$1 = { OPEN: "a", pb: "b", Ka: "c", Bb: "d" };
function ac$1() {
  z$1.call(this, "d");
}
t(ac$1, z$1);
function bc$1() {
  z$1.call(this, "c");
}
t(bc$1, z$1);
var cc$1;
function dc$1() {
}
t(dc$1, Yb);
dc$1.prototype.g = function() {
  return new XMLHttpRequest();
};
dc$1.prototype.i = function() {
  return {};
};
cc$1 = new dc$1();
function M$1(a2, b2, c2, d2) {
  this.l = a2;
  this.j = b2;
  this.m = c2;
  this.X = d2 || 1;
  this.V = new E(this);
  this.P = ec$1;
  a2 = Ja ? 125 : void 0;
  this.W = new Eb(a2);
  this.H = null;
  this.i = false;
  this.s = this.A = this.v = this.K = this.F = this.Y = this.B = null;
  this.D = [];
  this.g = null;
  this.C = 0;
  this.o = this.u = null;
  this.N = -1;
  this.I = false;
  this.O = 0;
  this.L = null;
  this.aa = this.J = this.$ = this.U = false;
  this.h = new fc$1();
}
function fc$1() {
  this.i = null;
  this.g = "";
  this.h = false;
}
var ec$1 = 45e3, gc$1 = {}, hc$1 = {};
k$1 = M$1.prototype;
k$1.setTimeout = function(a2) {
  this.P = a2;
};
function ic$1(a2, b2, c2) {
  a2.K = 1;
  a2.v = jc(N$1(b2));
  a2.s = c2;
  a2.U = true;
  kc(a2, null);
}
function kc(a2, b2) {
  a2.F = Date.now();
  lc$1(a2);
  a2.A = N$1(a2.v);
  var c2 = a2.A, d2 = a2.X;
  Array.isArray(d2) || (d2 = [String(d2)]);
  mc(c2.h, "t", d2);
  a2.C = 0;
  c2 = a2.l.H;
  a2.h = new fc$1();
  a2.g = nc$1(a2.l, c2 ? b2 : null, !a2.s);
  0 < a2.O && (a2.L = new Ib(q(a2.Ia, a2, a2.g), a2.O));
  Kb(a2.V, a2.g, "readystatechange", a2.gb);
  b2 = a2.H ? ya$1(a2.H) : {};
  a2.s ? (a2.u || (a2.u = "POST"), b2["Content-Type"] = "application/x-www-form-urlencoded", a2.g.ea(a2.A, a2.u, a2.s, b2)) : (a2.u = "GET", a2.g.ea(a2.A, a2.u, null, b2));
  I();
  Nb(a2.j, a2.u, a2.A, a2.m, a2.X, a2.s);
}
k$1.gb = function(a2) {
  a2 = a2.target;
  const b2 = this.L;
  b2 && 3 == O$1(a2) ? b2.l() : this.Ia(a2);
};
k$1.Ia = function(a2) {
  try {
    if (a2 == this.g)
      a: {
        const r2 = O$1(this.g);
        var b2 = this.g.Da();
        const G2 = this.g.ba();
        if (!(3 > r2) && (3 != r2 || Ja || this.g && (this.h.h || this.g.ga() || oc$1(this.g)))) {
          this.I || 4 != r2 || 7 == b2 || (8 == b2 || 0 >= G2 ? I(3) : I(2));
          pc$1(this);
          var c2 = this.g.ba();
          this.N = c2;
          b:
            if (qc$1(this)) {
              var d2 = oc$1(this.g);
              a2 = "";
              var e2 = d2.length, f2 = 4 == O$1(this.g);
              if (!this.h.i) {
                if ("undefined" === typeof TextDecoder) {
                  P(this);
                  rc$1(this);
                  var h2 = "";
                  break b;
                }
                this.h.i = new l.TextDecoder();
              }
              for (b2 = 0; b2 < e2; b2++)
                this.h.h = true, a2 += this.h.i.decode(d2[b2], { stream: f2 && b2 == e2 - 1 });
              d2.splice(
                0,
                e2
              );
              this.h.g += a2;
              this.C = 0;
              h2 = this.h.g;
            } else
              h2 = this.g.ga();
          this.i = 200 == c2;
          Ob(this.j, this.u, this.A, this.m, this.X, r2, c2);
          if (this.i) {
            if (this.$ && !this.J) {
              b: {
                if (this.g) {
                  var n2, u2 = this.g;
                  if ((n2 = u2.g ? u2.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !sa$1(n2)) {
                    var m2 = n2;
                    break b;
                  }
                }
                m2 = null;
              }
              if (c2 = m2)
                F$1(this.j, this.m, c2, "Initial handshake response via X-HTTP-Initial-Response"), this.J = true, sc$1(this, c2);
              else {
                this.i = false;
                this.o = 3;
                J$1(12);
                P(this);
                rc$1(this);
                break a;
              }
            }
            this.U ? (tc(this, r2, h2), Ja && this.i && 3 == r2 && (Kb(this.V, this.W, "tick", this.fb), this.W.start())) : (F$1(this.j, this.m, h2, null), sc$1(this, h2));
            4 == r2 && P(this);
            this.i && !this.I && (4 == r2 ? uc$1(this.l, this) : (this.i = false, lc$1(this)));
          } else
            400 == c2 && 0 < h2.indexOf("Unknown SID") ? (this.o = 3, J$1(12)) : (this.o = 0, J$1(13)), P(this), rc$1(this);
        }
      }
  } catch (r2) {
  } finally {
  }
};
function qc$1(a2) {
  return a2.g ? "GET" == a2.u && 2 != a2.K && a2.l.Ba : false;
}
function tc(a2, b2, c2) {
  let d2 = true, e2;
  for (; !a2.I && a2.C < c2.length; )
    if (e2 = vc(a2, c2), e2 == hc$1) {
      4 == b2 && (a2.o = 4, J$1(14), d2 = false);
      F$1(a2.j, a2.m, null, "[Incomplete Response]");
      break;
    } else if (e2 == gc$1) {
      a2.o = 4;
      J$1(15);
      F$1(a2.j, a2.m, c2, "[Invalid Chunk]");
      d2 = false;
      break;
    } else
      F$1(a2.j, a2.m, e2, null), sc$1(a2, e2);
  qc$1(a2) && e2 != hc$1 && e2 != gc$1 && (a2.h.g = "", a2.C = 0);
  4 != b2 || 0 != c2.length || a2.h.h || (a2.o = 1, J$1(16), d2 = false);
  a2.i = a2.i && d2;
  d2 ? 0 < c2.length && !a2.aa && (a2.aa = true, b2 = a2.l, b2.g == a2 && b2.$ && !b2.L && (b2.h.info("Great, no buffering proxy detected. Bytes received: " + c2.length), wc$1(b2), b2.L = true, J$1(11))) : (F$1(
    a2.j,
    a2.m,
    c2,
    "[Invalid Chunked Response]"
  ), P(a2), rc$1(a2));
}
k$1.fb = function() {
  if (this.g) {
    var a2 = O$1(this.g), b2 = this.g.ga();
    this.C < b2.length && (pc$1(this), tc(this, a2, b2), this.i && 4 != a2 && lc$1(this));
  }
};
function vc(a2, b2) {
  var c2 = a2.C, d2 = b2.indexOf("\n", c2);
  if (-1 == d2)
    return hc$1;
  c2 = Number(b2.substring(c2, d2));
  if (isNaN(c2))
    return gc$1;
  d2 += 1;
  if (d2 + c2 > b2.length)
    return hc$1;
  b2 = b2.substr(d2, c2);
  a2.C = d2 + c2;
  return b2;
}
k$1.cancel = function() {
  this.I = true;
  P(this);
};
function lc$1(a2) {
  a2.Y = Date.now() + a2.P;
  xc(a2, a2.P);
}
function xc(a2, b2) {
  if (null != a2.B)
    throw Error("WatchDog timer not null");
  a2.B = K$1(q(a2.eb, a2), b2);
}
function pc$1(a2) {
  a2.B && (l.clearTimeout(a2.B), a2.B = null);
}
k$1.eb = function() {
  this.B = null;
  const a2 = Date.now();
  0 <= a2 - this.Y ? (Qb(this.j, this.A), 2 != this.K && (I(), J$1(17)), P(this), this.o = 2, rc$1(this)) : xc(this, this.Y - a2);
};
function rc$1(a2) {
  0 == a2.l.G || a2.I || uc$1(a2.l, a2);
}
function P(a2) {
  pc$1(a2);
  var b2 = a2.L;
  b2 && "function" == typeof b2.na && b2.na();
  a2.L = null;
  Fb(a2.W);
  Lb(a2.V);
  a2.g && (b2 = a2.g, a2.g = null, b2.abort(), b2.na());
}
function sc$1(a2, b2) {
  try {
    var c2 = a2.l;
    if (0 != c2.G && (c2.g == a2 || yc$1(c2.i, a2))) {
      if (c2.I = a2.N, !a2.J && yc$1(c2.i, a2) && 3 == c2.G) {
        try {
          var d2 = c2.Ca.g.parse(b2);
        } catch (m2) {
          d2 = null;
        }
        if (Array.isArray(d2) && 3 == d2.length) {
          var e2 = d2;
          if (0 == e2[0])
            a: {
              if (!c2.u) {
                if (c2.g)
                  if (c2.g.F + 3e3 < a2.F)
                    zc$1(c2), Ac$1(c2);
                  else
                    break a;
                Bc$1(c2);
                J$1(18);
              }
            }
          else
            c2.ta = e2[1], 0 < c2.ta - c2.U && 37500 > e2[2] && c2.N && 0 == c2.A && !c2.v && (c2.v = K$1(q(c2.ab, c2), 6e3));
          if (1 >= Cc(c2.i) && c2.ka) {
            try {
              c2.ka();
            } catch (m2) {
            }
            c2.ka = void 0;
          }
        } else
          Q$1(c2, 11);
      } else if ((a2.J || c2.g == a2) && zc$1(c2), !sa$1(b2))
        for (e2 = c2.Ca.g.parse(b2), b2 = 0; b2 < e2.length; b2++) {
          let m2 = e2[b2];
          c2.U = m2[0];
          m2 = m2[1];
          if (2 == c2.G)
            if ("c" == m2[0]) {
              c2.J = m2[1];
              c2.la = m2[2];
              const r2 = m2[3];
              null != r2 && (c2.ma = r2, c2.h.info("VER=" + c2.ma));
              const G2 = m2[4];
              null != G2 && (c2.za = G2, c2.h.info("SVER=" + c2.za));
              const Da2 = m2[5];
              null != Da2 && "number" === typeof Da2 && 0 < Da2 && (d2 = 1.5 * Da2, c2.K = d2, c2.h.info("backChannelRequestTimeoutMs_=" + d2));
              d2 = c2;
              const ca = a2.g;
              if (ca) {
                const Ea2 = ca.g ? ca.g.getResponseHeader("X-Client-Wire-Protocol") : null;
                if (Ea2) {
                  var f2 = d2.i;
                  !f2.g && (w(Ea2, "spdy") || w(Ea2, "quic") || w(Ea2, "h2")) && (f2.j = f2.l, f2.g = /* @__PURE__ */ new Set(), f2.h && (Dc(f2, f2.h), f2.h = null));
                }
                if (d2.D) {
                  const xb = ca.g ? ca.g.getResponseHeader("X-HTTP-Session-Id") : null;
                  xb && (d2.sa = xb, R(d2.F, d2.D, xb));
                }
              }
              c2.G = 3;
              c2.j && c2.j.xa();
              c2.$ && (c2.O = Date.now() - a2.F, c2.h.info("Handshake RTT: " + c2.O + "ms"));
              d2 = c2;
              var h2 = a2;
              d2.oa = Ec$1(d2, d2.H ? d2.la : null, d2.W);
              if (h2.J) {
                Fc$1(d2.i, h2);
                var n2 = h2, u2 = d2.K;
                u2 && n2.setTimeout(u2);
                n2.B && (pc$1(n2), lc$1(n2));
                d2.g = h2;
              } else
                Gc$1(d2);
              0 < c2.l.length && Hc$1(c2);
            } else
              "stop" != m2[0] && "close" != m2[0] || Q$1(c2, 7);
          else
            3 == c2.G && ("stop" == m2[0] || "close" == m2[0] ? "stop" == m2[0] ? Q$1(c2, 7) : Ic$1(c2) : "noop" != m2[0] && c2.j && c2.j.wa(m2), c2.A = 0);
        }
    }
    I(4);
  } catch (m2) {
  }
}
function Jc$1(a2) {
  if (a2.R && "function" == typeof a2.R)
    return a2.R();
  if ("string" === typeof a2)
    return a2.split("");
  if (ba$1(a2)) {
    for (var b2 = [], c2 = a2.length, d2 = 0; d2 < c2; d2++)
      b2.push(a2[d2]);
    return b2;
  }
  b2 = [];
  c2 = 0;
  for (d2 in a2)
    b2[c2++] = a2[d2];
  return b2;
}
function Kc(a2, b2) {
  if (a2.forEach && "function" == typeof a2.forEach)
    a2.forEach(b2, void 0);
  else if (ba$1(a2) || "string" === typeof a2)
    na$1(a2, b2, void 0);
  else {
    if (a2.T && "function" == typeof a2.T)
      var c2 = a2.T();
    else if (a2.R && "function" == typeof a2.R)
      c2 = void 0;
    else if (ba$1(a2) || "string" === typeof a2) {
      c2 = [];
      for (var d2 = a2.length, e2 = 0; e2 < d2; e2++)
        c2.push(e2);
    } else
      for (e2 in c2 = [], d2 = 0, a2)
        c2[d2++] = e2;
    d2 = Jc$1(a2);
    e2 = d2.length;
    for (var f2 = 0; f2 < e2; f2++)
      b2.call(void 0, d2[f2], c2 && c2[f2], a2);
  }
}
function S(a2, b2) {
  this.h = {};
  this.g = [];
  this.i = 0;
  var c2 = arguments.length;
  if (1 < c2) {
    if (c2 % 2)
      throw Error("Uneven number of arguments");
    for (var d2 = 0; d2 < c2; d2 += 2)
      this.set(arguments[d2], arguments[d2 + 1]);
  } else if (a2)
    if (a2 instanceof S)
      for (c2 = a2.T(), d2 = 0; d2 < c2.length; d2++)
        this.set(c2[d2], a2.get(c2[d2]));
    else
      for (d2 in a2)
        this.set(d2, a2[d2]);
}
k$1 = S.prototype;
k$1.R = function() {
  Lc(this);
  for (var a2 = [], b2 = 0; b2 < this.g.length; b2++)
    a2.push(this.h[this.g[b2]]);
  return a2;
};
k$1.T = function() {
  Lc(this);
  return this.g.concat();
};
function Lc(a2) {
  if (a2.i != a2.g.length) {
    for (var b2 = 0, c2 = 0; b2 < a2.g.length; ) {
      var d2 = a2.g[b2];
      T(a2.h, d2) && (a2.g[c2++] = d2);
      b2++;
    }
    a2.g.length = c2;
  }
  if (a2.i != a2.g.length) {
    var e2 = {};
    for (c2 = b2 = 0; b2 < a2.g.length; )
      d2 = a2.g[b2], T(e2, d2) || (a2.g[c2++] = d2, e2[d2] = 1), b2++;
    a2.g.length = c2;
  }
}
k$1.get = function(a2, b2) {
  return T(this.h, a2) ? this.h[a2] : b2;
};
k$1.set = function(a2, b2) {
  T(this.h, a2) || (this.i++, this.g.push(a2));
  this.h[a2] = b2;
};
k$1.forEach = function(a2, b2) {
  for (var c2 = this.T(), d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2], f2 = this.get(e2);
    a2.call(b2, f2, e2, this);
  }
};
function T(a2, b2) {
  return Object.prototype.hasOwnProperty.call(a2, b2);
}
var Mc$1 = /^(?:([^:/?#.]+):)?(?:\/\/(?:([^\\/?#]*)@)?([^\\/?#]*?)(?::([0-9]+))?(?=[\\/?#]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/;
function Nc(a2, b2) {
  if (a2) {
    a2 = a2.split("&");
    for (var c2 = 0; c2 < a2.length; c2++) {
      var d2 = a2[c2].indexOf("="), e2 = null;
      if (0 <= d2) {
        var f2 = a2[c2].substring(0, d2);
        e2 = a2[c2].substring(d2 + 1);
      } else
        f2 = a2[c2];
      b2(f2, e2 ? decodeURIComponent(e2.replace(/\+/g, " ")) : "");
    }
  }
}
function U$1(a2, b2) {
  this.i = this.s = this.j = "";
  this.m = null;
  this.o = this.l = "";
  this.g = false;
  if (a2 instanceof U$1) {
    this.g = void 0 !== b2 ? b2 : a2.g;
    Oc(this, a2.j);
    this.s = a2.s;
    Pc$1(this, a2.i);
    Qc(this, a2.m);
    this.l = a2.l;
    b2 = a2.h;
    var c2 = new Rc$1();
    c2.i = b2.i;
    b2.g && (c2.g = new S(b2.g), c2.h = b2.h);
    Sc(this, c2);
    this.o = a2.o;
  } else
    a2 && (c2 = String(a2).match(Mc$1)) ? (this.g = !!b2, Oc(this, c2[1] || "", true), this.s = Tc$1(c2[2] || ""), Pc$1(this, c2[3] || "", true), Qc(this, c2[4]), this.l = Tc$1(c2[5] || "", true), Sc(this, c2[6] || "", true), this.o = Tc$1(c2[7] || "")) : (this.g = !!b2, this.h = new Rc$1(null, this.g));
}
U$1.prototype.toString = function() {
  var a2 = [], b2 = this.j;
  b2 && a2.push(Uc(b2, Vc, true), ":");
  var c2 = this.i;
  if (c2 || "file" == b2)
    a2.push("//"), (b2 = this.s) && a2.push(Uc(b2, Vc, true), "@"), a2.push(encodeURIComponent(String(c2)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), c2 = this.m, null != c2 && a2.push(":", String(c2));
  if (c2 = this.l)
    this.i && "/" != c2.charAt(0) && a2.push("/"), a2.push(Uc(c2, "/" == c2.charAt(0) ? Wc : Xc$1, true));
  (c2 = this.h.toString()) && a2.push("?", c2);
  (c2 = this.o) && a2.push("#", Uc(c2, Yc$1));
  return a2.join("");
};
function N$1(a2) {
  return new U$1(a2);
}
function Oc(a2, b2, c2) {
  a2.j = c2 ? Tc$1(b2, true) : b2;
  a2.j && (a2.j = a2.j.replace(/:$/, ""));
}
function Pc$1(a2, b2, c2) {
  a2.i = c2 ? Tc$1(b2, true) : b2;
}
function Qc(a2, b2) {
  if (b2) {
    b2 = Number(b2);
    if (isNaN(b2) || 0 > b2)
      throw Error("Bad port number " + b2);
    a2.m = b2;
  } else
    a2.m = null;
}
function Sc(a2, b2, c2) {
  b2 instanceof Rc$1 ? (a2.h = b2, Zc(a2.h, a2.g)) : (c2 || (b2 = Uc(b2, $c)), a2.h = new Rc$1(b2, a2.g));
}
function R(a2, b2, c2) {
  a2.h.set(b2, c2);
}
function jc(a2) {
  R(a2, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36));
  return a2;
}
function ad(a2) {
  return a2 instanceof U$1 ? N$1(a2) : new U$1(a2, void 0);
}
function bd(a2, b2, c2, d2) {
  var e2 = new U$1(null, void 0);
  a2 && Oc(e2, a2);
  b2 && Pc$1(e2, b2);
  c2 && Qc(e2, c2);
  d2 && (e2.l = d2);
  return e2;
}
function Tc$1(a2, b2) {
  return a2 ? b2 ? decodeURI(a2.replace(/%25/g, "%2525")) : decodeURIComponent(a2) : "";
}
function Uc(a2, b2, c2) {
  return "string" === typeof a2 ? (a2 = encodeURI(a2).replace(b2, cd), c2 && (a2 = a2.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), a2) : null;
}
function cd(a2) {
  a2 = a2.charCodeAt(0);
  return "%" + (a2 >> 4 & 15).toString(16) + (a2 & 15).toString(16);
}
var Vc = /[#\/\?@]/g, Xc$1 = /[#\?:]/g, Wc = /[#\?]/g, $c = /[#\?@]/g, Yc$1 = /#/g;
function Rc$1(a2, b2) {
  this.h = this.g = null;
  this.i = a2 || null;
  this.j = !!b2;
}
function V(a2) {
  a2.g || (a2.g = new S(), a2.h = 0, a2.i && Nc(a2.i, function(b2, c2) {
    a2.add(decodeURIComponent(b2.replace(/\+/g, " ")), c2);
  }));
}
k$1 = Rc$1.prototype;
k$1.add = function(a2, b2) {
  V(this);
  this.i = null;
  a2 = W$1(this, a2);
  var c2 = this.g.get(a2);
  c2 || this.g.set(a2, c2 = []);
  c2.push(b2);
  this.h += 1;
  return this;
};
function dd(a2, b2) {
  V(a2);
  b2 = W$1(a2, b2);
  T(a2.g.h, b2) && (a2.i = null, a2.h -= a2.g.get(b2).length, a2 = a2.g, T(a2.h, b2) && (delete a2.h[b2], a2.i--, a2.g.length > 2 * a2.i && Lc(a2)));
}
function ed(a2, b2) {
  V(a2);
  b2 = W$1(a2, b2);
  return T(a2.g.h, b2);
}
k$1.forEach = function(a2, b2) {
  V(this);
  this.g.forEach(function(c2, d2) {
    na$1(c2, function(e2) {
      a2.call(b2, e2, d2, this);
    }, this);
  }, this);
};
k$1.T = function() {
  V(this);
  for (var a2 = this.g.R(), b2 = this.g.T(), c2 = [], d2 = 0; d2 < b2.length; d2++)
    for (var e2 = a2[d2], f2 = 0; f2 < e2.length; f2++)
      c2.push(b2[d2]);
  return c2;
};
k$1.R = function(a2) {
  V(this);
  var b2 = [];
  if ("string" === typeof a2)
    ed(this, a2) && (b2 = qa(b2, this.g.get(W$1(this, a2))));
  else {
    a2 = this.g.R();
    for (var c2 = 0; c2 < a2.length; c2++)
      b2 = qa(b2, a2[c2]);
  }
  return b2;
};
k$1.set = function(a2, b2) {
  V(this);
  this.i = null;
  a2 = W$1(this, a2);
  ed(this, a2) && (this.h -= this.g.get(a2).length);
  this.g.set(a2, [b2]);
  this.h += 1;
  return this;
};
k$1.get = function(a2, b2) {
  if (!a2)
    return b2;
  a2 = this.R(a2);
  return 0 < a2.length ? String(a2[0]) : b2;
};
function mc(a2, b2, c2) {
  dd(a2, b2);
  0 < c2.length && (a2.i = null, a2.g.set(W$1(a2, b2), ra(c2)), a2.h += c2.length);
}
k$1.toString = function() {
  if (this.i)
    return this.i;
  if (!this.g)
    return "";
  for (var a2 = [], b2 = this.g.T(), c2 = 0; c2 < b2.length; c2++) {
    var d2 = b2[c2], e2 = encodeURIComponent(String(d2));
    d2 = this.R(d2);
    for (var f2 = 0; f2 < d2.length; f2++) {
      var h2 = e2;
      "" !== d2[f2] && (h2 += "=" + encodeURIComponent(String(d2[f2])));
      a2.push(h2);
    }
  }
  return this.i = a2.join("&");
};
function W$1(a2, b2) {
  b2 = String(b2);
  a2.j && (b2 = b2.toLowerCase());
  return b2;
}
function Zc(a2, b2) {
  b2 && !a2.j && (V(a2), a2.i = null, a2.g.forEach(function(c2, d2) {
    var e2 = d2.toLowerCase();
    d2 != e2 && (dd(this, d2), mc(this, e2, c2));
  }, a2));
  a2.j = b2;
}
var fd = class {
  constructor(a2, b2) {
    this.h = a2;
    this.g = b2;
  }
};
function gd(a2) {
  this.l = a2 || hd;
  l.PerformanceNavigationTiming ? (a2 = l.performance.getEntriesByType("navigation"), a2 = 0 < a2.length && ("hq" == a2[0].nextHopProtocol || "h2" == a2[0].nextHopProtocol)) : a2 = !!(l.g && l.g.Ea && l.g.Ea() && l.g.Ea().Zb);
  this.j = a2 ? this.l : 1;
  this.g = null;
  1 < this.j && (this.g = /* @__PURE__ */ new Set());
  this.h = null;
  this.i = [];
}
var hd = 10;
function id(a2) {
  return a2.h ? true : a2.g ? a2.g.size >= a2.j : false;
}
function Cc(a2) {
  return a2.h ? 1 : a2.g ? a2.g.size : 0;
}
function yc$1(a2, b2) {
  return a2.h ? a2.h == b2 : a2.g ? a2.g.has(b2) : false;
}
function Dc(a2, b2) {
  a2.g ? a2.g.add(b2) : a2.h = b2;
}
function Fc$1(a2, b2) {
  a2.h && a2.h == b2 ? a2.h = null : a2.g && a2.g.has(b2) && a2.g.delete(b2);
}
gd.prototype.cancel = function() {
  this.i = jd(this);
  if (this.h)
    this.h.cancel(), this.h = null;
  else if (this.g && 0 !== this.g.size) {
    for (const a2 of this.g.values())
      a2.cancel();
    this.g.clear();
  }
};
function jd(a2) {
  if (null != a2.h)
    return a2.i.concat(a2.h.D);
  if (null != a2.g && 0 !== a2.g.size) {
    let b2 = a2.i;
    for (const c2 of a2.g.values())
      b2 = b2.concat(c2.D);
    return b2;
  }
  return ra(a2.i);
}
function kd() {
}
kd.prototype.stringify = function(a2) {
  return l.JSON.stringify(a2, void 0);
};
kd.prototype.parse = function(a2) {
  return l.JSON.parse(a2, void 0);
};
function ld() {
  this.g = new kd();
}
function md(a2, b2, c2) {
  const d2 = c2 || "";
  try {
    Kc(a2, function(e2, f2) {
      let h2 = e2;
      p(e2) && (h2 = rb(e2));
      b2.push(d2 + f2 + "=" + encodeURIComponent(h2));
    });
  } catch (e2) {
    throw b2.push(d2 + "type=" + encodeURIComponent("_badmap")), e2;
  }
}
function nd(a2, b2) {
  const c2 = new Mb();
  if (l.Image) {
    const d2 = new Image();
    d2.onload = ja(od, c2, d2, "TestLoadImage: loaded", true, b2);
    d2.onerror = ja(od, c2, d2, "TestLoadImage: error", false, b2);
    d2.onabort = ja(od, c2, d2, "TestLoadImage: abort", false, b2);
    d2.ontimeout = ja(od, c2, d2, "TestLoadImage: timeout", false, b2);
    l.setTimeout(function() {
      if (d2.ontimeout)
        d2.ontimeout();
    }, 1e4);
    d2.src = a2;
  } else
    b2(false);
}
function od(a2, b2, c2, d2, e2) {
  try {
    b2.onload = null, b2.onerror = null, b2.onabort = null, b2.ontimeout = null, e2(d2);
  } catch (f2) {
  }
}
function pd(a2) {
  this.l = a2.$b || null;
  this.j = a2.ib || false;
}
t(pd, Yb);
pd.prototype.g = function() {
  return new qd(this.l, this.j);
};
pd.prototype.i = function(a2) {
  return function() {
    return a2;
  };
}({});
function qd(a2, b2) {
  C$1.call(this);
  this.D = a2;
  this.u = b2;
  this.m = void 0;
  this.readyState = rd;
  this.status = 0;
  this.responseType = this.responseText = this.response = this.statusText = "";
  this.onreadystatechange = null;
  this.v = new Headers();
  this.h = null;
  this.C = "GET";
  this.B = "";
  this.g = false;
  this.A = this.j = this.l = null;
}
t(qd, C$1);
var rd = 0;
k$1 = qd.prototype;
k$1.open = function(a2, b2) {
  if (this.readyState != rd)
    throw this.abort(), Error("Error reopening a connection");
  this.C = a2;
  this.B = b2;
  this.readyState = 1;
  sd(this);
};
k$1.send = function(a2) {
  if (1 != this.readyState)
    throw this.abort(), Error("need to call open() first. ");
  this.g = true;
  const b2 = { headers: this.v, method: this.C, credentials: this.m, cache: void 0 };
  a2 && (b2.body = a2);
  (this.D || l).fetch(new Request(this.B, b2)).then(this.Va.bind(this), this.ha.bind(this));
};
k$1.abort = function() {
  this.response = this.responseText = "";
  this.v = new Headers();
  this.status = 0;
  this.j && this.j.cancel("Request was aborted.");
  1 <= this.readyState && this.g && 4 != this.readyState && (this.g = false, td(this));
  this.readyState = rd;
};
k$1.Va = function(a2) {
  if (this.g && (this.l = a2, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = a2.headers, this.readyState = 2, sd(this)), this.g && (this.readyState = 3, sd(this), this.g)))
    if ("arraybuffer" === this.responseType)
      a2.arrayBuffer().then(this.Ta.bind(this), this.ha.bind(this));
    else if ("undefined" !== typeof l.ReadableStream && "body" in a2) {
      this.j = a2.body.getReader();
      if (this.u) {
        if (this.responseType)
          throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');
        this.response = [];
      } else
        this.response = this.responseText = "", this.A = new TextDecoder();
      ud(this);
    } else
      a2.text().then(this.Ua.bind(this), this.ha.bind(this));
};
function ud(a2) {
  a2.j.read().then(a2.Sa.bind(a2)).catch(a2.ha.bind(a2));
}
k$1.Sa = function(a2) {
  if (this.g) {
    if (this.u && a2.value)
      this.response.push(a2.value);
    else if (!this.u) {
      var b2 = a2.value ? a2.value : new Uint8Array(0);
      if (b2 = this.A.decode(b2, { stream: !a2.done }))
        this.response = this.responseText += b2;
    }
    a2.done ? td(this) : sd(this);
    3 == this.readyState && ud(this);
  }
};
k$1.Ua = function(a2) {
  this.g && (this.response = this.responseText = a2, td(this));
};
k$1.Ta = function(a2) {
  this.g && (this.response = a2, td(this));
};
k$1.ha = function() {
  this.g && td(this);
};
function td(a2) {
  a2.readyState = 4;
  a2.l = null;
  a2.j = null;
  a2.A = null;
  sd(a2);
}
k$1.setRequestHeader = function(a2, b2) {
  this.v.append(a2, b2);
};
k$1.getResponseHeader = function(a2) {
  return this.h ? this.h.get(a2.toLowerCase()) || "" : "";
};
k$1.getAllResponseHeaders = function() {
  if (!this.h)
    return "";
  const a2 = [], b2 = this.h.entries();
  for (var c2 = b2.next(); !c2.done; )
    c2 = c2.value, a2.push(c2[0] + ": " + c2[1]), c2 = b2.next();
  return a2.join("\r\n");
};
function sd(a2) {
  a2.onreadystatechange && a2.onreadystatechange.call(a2);
}
Object.defineProperty(qd.prototype, "withCredentials", { get: function() {
  return "include" === this.m;
}, set: function(a2) {
  this.m = a2 ? "include" : "same-origin";
} });
var vd = l.JSON.parse;
function X$1(a2) {
  C$1.call(this);
  this.headers = new S();
  this.u = a2 || null;
  this.h = false;
  this.C = this.g = null;
  this.H = "";
  this.m = 0;
  this.j = "";
  this.l = this.F = this.v = this.D = false;
  this.B = 0;
  this.A = null;
  this.J = wd;
  this.K = this.L = false;
}
t(X$1, C$1);
var wd = "", xd = /^https?$/i, yd = ["POST", "PUT"];
k$1 = X$1.prototype;
k$1.ea = function(a2, b2, c2, d2) {
  if (this.g)
    throw Error("[goog.net.XhrIo] Object is active with another request=" + this.H + "; newUri=" + a2);
  b2 = b2 ? b2.toUpperCase() : "GET";
  this.H = a2;
  this.j = "";
  this.m = 0;
  this.D = false;
  this.h = true;
  this.g = this.u ? this.u.g() : cc$1.g();
  this.C = this.u ? Zb(this.u) : Zb(cc$1);
  this.g.onreadystatechange = q(this.Fa, this);
  try {
    this.F = true, this.g.open(b2, String(a2), true), this.F = false;
  } catch (f2) {
    zd(this, f2);
    return;
  }
  a2 = c2 || "";
  const e2 = new S(this.headers);
  d2 && Kc(d2, function(f2, h2) {
    e2.set(h2, f2);
  });
  d2 = oa(e2.T());
  c2 = l.FormData && a2 instanceof l.FormData;
  !(0 <= ma$1(yd, b2)) || d2 || c2 || e2.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
  e2.forEach(function(f2, h2) {
    this.g.setRequestHeader(h2, f2);
  }, this);
  this.J && (this.g.responseType = this.J);
  "withCredentials" in this.g && this.g.withCredentials !== this.L && (this.g.withCredentials = this.L);
  try {
    Ad(this), 0 < this.B && ((this.K = Bd(this.g)) ? (this.g.timeout = this.B, this.g.ontimeout = q(this.pa, this)) : this.A = Gb(this.pa, this.B, this)), this.v = true, this.g.send(a2), this.v = false;
  } catch (f2) {
    zd(this, f2);
  }
};
function Bd(a2) {
  return y && Ra$1() && "number" === typeof a2.timeout && void 0 !== a2.ontimeout;
}
function pa$1(a2) {
  return "content-type" == a2.toLowerCase();
}
k$1.pa = function() {
  "undefined" != typeof goog && this.g && (this.j = "Timed out after " + this.B + "ms, aborting", this.m = 8, D$1(this, "timeout"), this.abort(8));
};
function zd(a2, b2) {
  a2.h = false;
  a2.g && (a2.l = true, a2.g.abort(), a2.l = false);
  a2.j = b2;
  a2.m = 5;
  Cd(a2);
  Dd(a2);
}
function Cd(a2) {
  a2.D || (a2.D = true, D$1(a2, "complete"), D$1(a2, "error"));
}
k$1.abort = function(a2) {
  this.g && this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false, this.m = a2 || 7, D$1(this, "complete"), D$1(this, "abort"), Dd(this));
};
k$1.M = function() {
  this.g && (this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false), Dd(this, true));
  X$1.Z.M.call(this);
};
k$1.Fa = function() {
  this.s || (this.F || this.v || this.l ? Ed(this) : this.cb());
};
k$1.cb = function() {
  Ed(this);
};
function Ed(a2) {
  if (a2.h && "undefined" != typeof goog && (!a2.C[1] || 4 != O$1(a2) || 2 != a2.ba())) {
    if (a2.v && 4 == O$1(a2))
      Gb(a2.Fa, 0, a2);
    else if (D$1(a2, "readystatechange"), 4 == O$1(a2)) {
      a2.h = false;
      try {
        const n2 = a2.ba();
        a:
          switch (n2) {
            case 200:
            case 201:
            case 202:
            case 204:
            case 206:
            case 304:
            case 1223:
              var b2 = true;
              break a;
            default:
              b2 = false;
          }
        var c2;
        if (!(c2 = b2)) {
          var d2;
          if (d2 = 0 === n2) {
            var e2 = String(a2.H).match(Mc$1)[1] || null;
            if (!e2 && l.self && l.self.location) {
              var f2 = l.self.location.protocol;
              e2 = f2.substr(0, f2.length - 1);
            }
            d2 = !xd.test(e2 ? e2.toLowerCase() : "");
          }
          c2 = d2;
        }
        if (c2)
          D$1(a2, "complete"), D$1(
            a2,
            "success"
          );
        else {
          a2.m = 6;
          try {
            var h2 = 2 < O$1(a2) ? a2.g.statusText : "";
          } catch (u2) {
            h2 = "";
          }
          a2.j = h2 + " [" + a2.ba() + "]";
          Cd(a2);
        }
      } finally {
        Dd(a2);
      }
    }
  }
}
function Dd(a2, b2) {
  if (a2.g) {
    Ad(a2);
    const c2 = a2.g, d2 = a2.C[0] ? aa$1 : null;
    a2.g = null;
    a2.C = null;
    b2 || D$1(a2, "ready");
    try {
      c2.onreadystatechange = d2;
    } catch (e2) {
    }
  }
}
function Ad(a2) {
  a2.g && a2.K && (a2.g.ontimeout = null);
  a2.A && (l.clearTimeout(a2.A), a2.A = null);
}
function O$1(a2) {
  return a2.g ? a2.g.readyState : 0;
}
k$1.ba = function() {
  try {
    return 2 < O$1(this) ? this.g.status : -1;
  } catch (a2) {
    return -1;
  }
};
k$1.ga = function() {
  try {
    return this.g ? this.g.responseText : "";
  } catch (a2) {
    return "";
  }
};
k$1.Qa = function(a2) {
  if (this.g) {
    var b2 = this.g.responseText;
    a2 && 0 == b2.indexOf(a2) && (b2 = b2.substring(a2.length));
    return vd(b2);
  }
};
function oc$1(a2) {
  try {
    if (!a2.g)
      return null;
    if ("response" in a2.g)
      return a2.g.response;
    switch (a2.J) {
      case wd:
      case "text":
        return a2.g.responseText;
      case "arraybuffer":
        if ("mozResponseArrayBuffer" in a2.g)
          return a2.g.mozResponseArrayBuffer;
    }
    return null;
  } catch (b2) {
    return null;
  }
}
k$1.Da = function() {
  return this.m;
};
k$1.La = function() {
  return "string" === typeof this.j ? this.j : String(this.j);
};
function Fd(a2) {
  let b2 = "";
  xa(a2, function(c2, d2) {
    b2 += d2;
    b2 += ":";
    b2 += c2;
    b2 += "\r\n";
  });
  return b2;
}
function Gd(a2, b2, c2) {
  a: {
    for (d2 in c2) {
      var d2 = false;
      break a;
    }
    d2 = true;
  }
  d2 || (c2 = Fd(c2), "string" === typeof a2 ? null != c2 && encodeURIComponent(String(c2)) : R(a2, b2, c2));
}
function Hd(a2, b2, c2) {
  return c2 && c2.internalChannelParams ? c2.internalChannelParams[a2] || b2 : b2;
}
function Id(a2) {
  this.za = 0;
  this.l = [];
  this.h = new Mb();
  this.la = this.oa = this.F = this.W = this.g = this.sa = this.D = this.aa = this.o = this.P = this.s = null;
  this.Za = this.V = 0;
  this.Xa = Hd("failFast", false, a2);
  this.N = this.v = this.u = this.m = this.j = null;
  this.X = true;
  this.I = this.ta = this.U = -1;
  this.Y = this.A = this.C = 0;
  this.Pa = Hd("baseRetryDelayMs", 5e3, a2);
  this.$a = Hd("retryDelaySeedMs", 1e4, a2);
  this.Ya = Hd("forwardChannelMaxRetries", 2, a2);
  this.ra = Hd("forwardChannelRequestTimeoutMs", 2e4, a2);
  this.qa = a2 && a2.xmlHttpFactory || void 0;
  this.Ba = a2 && a2.Yb || false;
  this.K = void 0;
  this.H = a2 && a2.supportsCrossDomainXhr || false;
  this.J = "";
  this.i = new gd(a2 && a2.concurrentRequestLimit);
  this.Ca = new ld();
  this.ja = a2 && a2.fastHandshake || false;
  this.Ra = a2 && a2.Wb || false;
  a2 && a2.Aa && this.h.Aa();
  a2 && a2.forceLongPolling && (this.X = false);
  this.$ = !this.ja && this.X && a2 && a2.detectBufferingProxy || false;
  this.ka = void 0;
  this.O = 0;
  this.L = false;
  this.B = null;
  this.Wa = !a2 || false !== a2.Xb;
}
k$1 = Id.prototype;
k$1.ma = 8;
k$1.G = 1;
function Ic$1(a2) {
  Jd(a2);
  if (3 == a2.G) {
    var b2 = a2.V++, c2 = N$1(a2.F);
    R(c2, "SID", a2.J);
    R(c2, "RID", b2);
    R(c2, "TYPE", "terminate");
    Kd(a2, c2);
    b2 = new M$1(a2, a2.h, b2, void 0);
    b2.K = 2;
    b2.v = jc(N$1(c2));
    c2 = false;
    l.navigator && l.navigator.sendBeacon && (c2 = l.navigator.sendBeacon(b2.v.toString(), ""));
    !c2 && l.Image && (new Image().src = b2.v, c2 = true);
    c2 || (b2.g = nc$1(b2.l, null), b2.g.ea(b2.v));
    b2.F = Date.now();
    lc$1(b2);
  }
  Ld(a2);
}
k$1.hb = function(a2) {
  try {
    this.h.info("Origin Trials invoked: " + a2);
  } catch (b2) {
  }
};
function Ac$1(a2) {
  a2.g && (wc$1(a2), a2.g.cancel(), a2.g = null);
}
function Jd(a2) {
  Ac$1(a2);
  a2.u && (l.clearTimeout(a2.u), a2.u = null);
  zc$1(a2);
  a2.i.cancel();
  a2.m && ("number" === typeof a2.m && l.clearTimeout(a2.m), a2.m = null);
}
function Md(a2, b2) {
  a2.l.push(new fd(a2.Za++, b2));
  3 == a2.G && Hc$1(a2);
}
function Hc$1(a2) {
  id(a2.i) || a2.m || (a2.m = true, zb(a2.Ha, a2), a2.C = 0);
}
function Nd(a2, b2) {
  if (Cc(a2.i) >= a2.i.j - (a2.m ? 1 : 0))
    return false;
  if (a2.m)
    return a2.l = b2.D.concat(a2.l), true;
  if (1 == a2.G || 2 == a2.G || a2.C >= (a2.Xa ? 0 : a2.Ya))
    return false;
  a2.m = K$1(q(a2.Ha, a2, b2), Od(a2, a2.C));
  a2.C++;
  return true;
}
k$1.Ha = function(a2) {
  if (this.m)
    if (this.m = null, 1 == this.G) {
      if (!a2) {
        this.V = Math.floor(1e5 * Math.random());
        a2 = this.V++;
        const e2 = new M$1(this, this.h, a2, void 0);
        let f2 = this.s;
        this.P && (f2 ? (f2 = ya$1(f2), Aa$1(f2, this.P)) : f2 = this.P);
        null === this.o && (e2.H = f2);
        if (this.ja)
          a: {
            var b2 = 0;
            for (var c2 = 0; c2 < this.l.length; c2++) {
              b: {
                var d2 = this.l[c2];
                if ("__data__" in d2.g && (d2 = d2.g.__data__, "string" === typeof d2)) {
                  d2 = d2.length;
                  break b;
                }
                d2 = void 0;
              }
              if (void 0 === d2)
                break;
              b2 += d2;
              if (4096 < b2) {
                b2 = c2;
                break a;
              }
              if (4096 === b2 || c2 === this.l.length - 1) {
                b2 = c2 + 1;
                break a;
              }
            }
            b2 = 1e3;
          }
        else
          b2 = 1e3;
        b2 = Pd(this, e2, b2);
        c2 = N$1(this.F);
        R(c2, "RID", a2);
        R(c2, "CVER", 22);
        this.D && R(c2, "X-HTTP-Session-Id", this.D);
        Kd(this, c2);
        this.o && f2 && Gd(c2, this.o, f2);
        Dc(this.i, e2);
        this.Ra && R(c2, "TYPE", "init");
        this.ja ? (R(c2, "$req", b2), R(c2, "SID", "null"), e2.$ = true, ic$1(e2, c2, null)) : ic$1(e2, c2, b2);
        this.G = 2;
      }
    } else
      3 == this.G && (a2 ? Qd(this, a2) : 0 == this.l.length || id(this.i) || Qd(this));
};
function Qd(a2, b2) {
  var c2;
  b2 ? c2 = b2.m : c2 = a2.V++;
  const d2 = N$1(a2.F);
  R(d2, "SID", a2.J);
  R(d2, "RID", c2);
  R(d2, "AID", a2.U);
  Kd(a2, d2);
  a2.o && a2.s && Gd(d2, a2.o, a2.s);
  c2 = new M$1(a2, a2.h, c2, a2.C + 1);
  null === a2.o && (c2.H = a2.s);
  b2 && (a2.l = b2.D.concat(a2.l));
  b2 = Pd(a2, c2, 1e3);
  c2.setTimeout(Math.round(0.5 * a2.ra) + Math.round(0.5 * a2.ra * Math.random()));
  Dc(a2.i, c2);
  ic$1(c2, d2, b2);
}
function Kd(a2, b2) {
  a2.j && Kc({}, function(c2, d2) {
    R(b2, d2, c2);
  });
}
function Pd(a2, b2, c2) {
  c2 = Math.min(a2.l.length, c2);
  var d2 = a2.j ? q(a2.j.Oa, a2.j, a2) : null;
  a: {
    var e2 = a2.l;
    let f2 = -1;
    for (; ; ) {
      const h2 = ["count=" + c2];
      -1 == f2 ? 0 < c2 ? (f2 = e2[0].h, h2.push("ofs=" + f2)) : f2 = 0 : h2.push("ofs=" + f2);
      let n2 = true;
      for (let u2 = 0; u2 < c2; u2++) {
        let m2 = e2[u2].h;
        const r2 = e2[u2].g;
        m2 -= f2;
        if (0 > m2)
          f2 = Math.max(0, e2[u2].h - 100), n2 = false;
        else
          try {
            md(r2, h2, "req" + m2 + "_");
          } catch (G2) {
            d2 && d2(r2);
          }
      }
      if (n2) {
        d2 = h2.join("&");
        break a;
      }
    }
  }
  a2 = a2.l.splice(0, c2);
  b2.D = a2;
  return d2;
}
function Gc$1(a2) {
  a2.g || a2.u || (a2.Y = 1, zb(a2.Ga, a2), a2.A = 0);
}
function Bc$1(a2) {
  if (a2.g || a2.u || 3 <= a2.A)
    return false;
  a2.Y++;
  a2.u = K$1(q(a2.Ga, a2), Od(a2, a2.A));
  a2.A++;
  return true;
}
k$1.Ga = function() {
  this.u = null;
  Rd(this);
  if (this.$ && !(this.L || null == this.g || 0 >= this.O)) {
    var a2 = 2 * this.O;
    this.h.info("BP detection timer enabled: " + a2);
    this.B = K$1(q(this.bb, this), a2);
  }
};
k$1.bb = function() {
  this.B && (this.B = null, this.h.info("BP detection timeout reached."), this.h.info("Buffering proxy detected and switch to long-polling!"), this.N = false, this.L = true, J$1(10), Ac$1(this), Rd(this));
};
function wc$1(a2) {
  null != a2.B && (l.clearTimeout(a2.B), a2.B = null);
}
function Rd(a2) {
  a2.g = new M$1(a2, a2.h, "rpc", a2.Y);
  null === a2.o && (a2.g.H = a2.s);
  a2.g.O = 0;
  var b2 = N$1(a2.oa);
  R(b2, "RID", "rpc");
  R(b2, "SID", a2.J);
  R(b2, "CI", a2.N ? "0" : "1");
  R(b2, "AID", a2.U);
  Kd(a2, b2);
  R(b2, "TYPE", "xmlhttp");
  a2.o && a2.s && Gd(b2, a2.o, a2.s);
  a2.K && a2.g.setTimeout(a2.K);
  var c2 = a2.g;
  a2 = a2.la;
  c2.K = 1;
  c2.v = jc(N$1(b2));
  c2.s = null;
  c2.U = true;
  kc(c2, a2);
}
k$1.ab = function() {
  null != this.v && (this.v = null, Ac$1(this), Bc$1(this), J$1(19));
};
function zc$1(a2) {
  null != a2.v && (l.clearTimeout(a2.v), a2.v = null);
}
function uc$1(a2, b2) {
  var c2 = null;
  if (a2.g == b2) {
    zc$1(a2);
    wc$1(a2);
    a2.g = null;
    var d2 = 2;
  } else if (yc$1(a2.i, b2))
    c2 = b2.D, Fc$1(a2.i, b2), d2 = 1;
  else
    return;
  a2.I = b2.N;
  if (0 != a2.G) {
    if (b2.i)
      if (1 == d2) {
        c2 = b2.s ? b2.s.length : 0;
        b2 = Date.now() - b2.F;
        var e2 = a2.C;
        d2 = Sb();
        D$1(d2, new Vb(d2, c2));
        Hc$1(a2);
      } else
        Gc$1(a2);
    else if (e2 = b2.o, 3 == e2 || 0 == e2 && 0 < a2.I || !(1 == d2 && Nd(a2, b2) || 2 == d2 && Bc$1(a2)))
      switch (c2 && 0 < c2.length && (b2 = a2.i, b2.i = b2.i.concat(c2)), e2) {
        case 1:
          Q$1(a2, 5);
          break;
        case 4:
          Q$1(a2, 10);
          break;
        case 3:
          Q$1(a2, 6);
          break;
        default:
          Q$1(a2, 2);
      }
  }
}
function Od(a2, b2) {
  let c2 = a2.Pa + Math.floor(Math.random() * a2.$a);
  a2.j || (c2 *= 2);
  return c2 * b2;
}
function Q$1(a2, b2) {
  a2.h.info("Error code " + b2);
  if (2 == b2) {
    var c2 = null;
    a2.j && (c2 = null);
    var d2 = q(a2.jb, a2);
    c2 || (c2 = new U$1("//www.google.com/images/cleardot.gif"), l.location && "http" == l.location.protocol || Oc(c2, "https"), jc(c2));
    nd(c2.toString(), d2);
  } else
    J$1(2);
  a2.G = 0;
  a2.j && a2.j.va(b2);
  Ld(a2);
  Jd(a2);
}
k$1.jb = function(a2) {
  a2 ? (this.h.info("Successfully pinged google.com"), J$1(2)) : (this.h.info("Failed to ping google.com"), J$1(1));
};
function Ld(a2) {
  a2.G = 0;
  a2.I = -1;
  if (a2.j) {
    if (0 != jd(a2.i).length || 0 != a2.l.length)
      a2.i.i.length = 0, ra(a2.l), a2.l.length = 0;
    a2.j.ua();
  }
}
function Ec$1(a2, b2, c2) {
  let d2 = ad(c2);
  if ("" != d2.i)
    b2 && Pc$1(d2, b2 + "." + d2.i), Qc(d2, d2.m);
  else {
    const e2 = l.location;
    d2 = bd(e2.protocol, b2 ? b2 + "." + e2.hostname : e2.hostname, +e2.port, c2);
  }
  a2.aa && xa(a2.aa, function(e2, f2) {
    R(d2, f2, e2);
  });
  b2 = a2.D;
  c2 = a2.sa;
  b2 && c2 && R(d2, b2, c2);
  R(d2, "VER", a2.ma);
  Kd(a2, d2);
  return d2;
}
function nc$1(a2, b2, c2) {
  if (b2 && !a2.H)
    throw Error("Can't create secondary domain capable XhrIo object.");
  b2 = c2 && a2.Ba && !a2.qa ? new X$1(new pd({ ib: true })) : new X$1(a2.qa);
  b2.L = a2.H;
  return b2;
}
function Sd() {
}
k$1 = Sd.prototype;
k$1.xa = function() {
};
k$1.wa = function() {
};
k$1.va = function() {
};
k$1.ua = function() {
};
k$1.Oa = function() {
};
function Td() {
  if (y && !(10 <= Number(Ua$1)))
    throw Error("Environmental error: no available transport.");
}
Td.prototype.g = function(a2, b2) {
  return new Y$1(a2, b2);
};
function Y$1(a2, b2) {
  C$1.call(this);
  this.g = new Id(b2);
  this.l = a2;
  this.h = b2 && b2.messageUrlParams || null;
  a2 = b2 && b2.messageHeaders || null;
  b2 && b2.clientProtocolHeaderRequired && (a2 ? a2["X-Client-Protocol"] = "webchannel" : a2 = { "X-Client-Protocol": "webchannel" });
  this.g.s = a2;
  a2 = b2 && b2.initMessageHeaders || null;
  b2 && b2.messageContentType && (a2 ? a2["X-WebChannel-Content-Type"] = b2.messageContentType : a2 = { "X-WebChannel-Content-Type": b2.messageContentType });
  b2 && b2.ya && (a2 ? a2["X-WebChannel-Client-Profile"] = b2.ya : a2 = { "X-WebChannel-Client-Profile": b2.ya });
  this.g.P = a2;
  (a2 = b2 && b2.httpHeadersOverwriteParam) && !sa$1(a2) && (this.g.o = a2);
  this.A = b2 && b2.supportsCrossDomainXhr || false;
  this.v = b2 && b2.sendRawJson || false;
  (b2 = b2 && b2.httpSessionIdParam) && !sa$1(b2) && (this.g.D = b2, a2 = this.h, null !== a2 && b2 in a2 && (a2 = this.h, b2 in a2 && delete a2[b2]));
  this.j = new Z$1(this);
}
t(Y$1, C$1);
Y$1.prototype.m = function() {
  this.g.j = this.j;
  this.A && (this.g.H = true);
  var a2 = this.g, b2 = this.l, c2 = this.h || void 0;
  a2.Wa && (a2.h.info("Origin Trials enabled."), zb(q(a2.hb, a2, b2)));
  J$1(0);
  a2.W = b2;
  a2.aa = c2 || {};
  a2.N = a2.X;
  a2.F = Ec$1(a2, null, a2.W);
  Hc$1(a2);
};
Y$1.prototype.close = function() {
  Ic$1(this.g);
};
Y$1.prototype.u = function(a2) {
  if ("string" === typeof a2) {
    var b2 = {};
    b2.__data__ = a2;
    Md(this.g, b2);
  } else
    this.v ? (b2 = {}, b2.__data__ = rb(a2), Md(this.g, b2)) : Md(this.g, a2);
};
Y$1.prototype.M = function() {
  this.g.j = null;
  delete this.j;
  Ic$1(this.g);
  delete this.g;
  Y$1.Z.M.call(this);
};
function Ud(a2) {
  ac$1.call(this);
  var b2 = a2.__sm__;
  if (b2) {
    a: {
      for (const c2 in b2) {
        a2 = c2;
        break a;
      }
      a2 = void 0;
    }
    if (this.i = a2)
      a2 = this.i, b2 = null !== b2 && a2 in b2 ? b2[a2] : void 0;
    this.data = b2;
  } else
    this.data = a2;
}
t(Ud, ac$1);
function Vd() {
  bc$1.call(this);
  this.status = 1;
}
t(Vd, bc$1);
function Z$1(a2) {
  this.g = a2;
}
t(Z$1, Sd);
Z$1.prototype.xa = function() {
  D$1(this.g, "a");
};
Z$1.prototype.wa = function(a2) {
  D$1(this.g, new Ud(a2));
};
Z$1.prototype.va = function(a2) {
  D$1(this.g, new Vd());
};
Z$1.prototype.ua = function() {
  D$1(this.g, "b");
};
Td.prototype.createWebChannel = Td.prototype.g;
Y$1.prototype.send = Y$1.prototype.u;
Y$1.prototype.open = Y$1.prototype.m;
Y$1.prototype.close = Y$1.prototype.close;
Wb.NO_ERROR = 0;
Wb.TIMEOUT = 8;
Wb.HTTP_ERROR = 6;
Xb.COMPLETE = "complete";
$b.EventType = L$1;
L$1.OPEN = "a";
L$1.CLOSE = "b";
L$1.ERROR = "c";
L$1.MESSAGE = "d";
C$1.prototype.listen = C$1.prototype.N;
X$1.prototype.listenOnce = X$1.prototype.O;
X$1.prototype.getLastError = X$1.prototype.La;
X$1.prototype.getLastErrorCode = X$1.prototype.Da;
X$1.prototype.getStatus = X$1.prototype.ba;
X$1.prototype.getResponseJson = X$1.prototype.Qa;
X$1.prototype.getResponseText = X$1.prototype.ga;
X$1.prototype.send = X$1.prototype.ea;
var createWebChannelTransport = function() {
  return new Td();
};
var getStatEventTarget = function() {
  return Sb();
};
var ErrorCode$1 = Wb;
var EventType = Xb;
var Event$1 = H$1;
var Stat = { rb: 0, ub: 1, vb: 2, Ob: 3, Tb: 4, Qb: 5, Rb: 6, Pb: 7, Nb: 8, Sb: 9, PROXY: 10, NOPROXY: 11, Lb: 12, Hb: 13, Ib: 14, Gb: 15, Jb: 16, Kb: 17, nb: 18, mb: 19, ob: 20 };
var FetchXmlHttpFactory = pd;
var WebChannel = $b;
var XhrIo = X$1;
const D = "@firebase/firestore";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class C {
  constructor(t2) {
    this.uid = t2;
  }
  isAuthenticated() {
    return null != this.uid;
  }
  toKey() {
    return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
  }
  isEqual(t2) {
    return t2.uid === this.uid;
  }
}
C.UNAUTHENTICATED = new C(null), C.GOOGLE_CREDENTIALS = new C("google-credentials-uid"), C.FIRST_PARTY = new C("first-party-uid"), C.MOCK_USER = new C("mock-user");
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let x = "9.9.0";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const N = new Logger("@firebase/firestore");
function k() {
  return N.logLevel;
}
function O(t2) {
  N.setLogLevel(t2);
}
function M(t2, ...e2) {
  if (N.logLevel <= LogLevel.DEBUG) {
    const n2 = e2.map(B);
    N.debug(`Firestore (${x}): ${t2}`, ...n2);
  }
}
function F(t2, ...e2) {
  if (N.logLevel <= LogLevel.ERROR) {
    const n2 = e2.map(B);
    N.error(`Firestore (${x}): ${t2}`, ...n2);
  }
}
function $(t2, ...e2) {
  if (N.logLevel <= LogLevel.WARN) {
    const n2 = e2.map(B);
    N.warn(`Firestore (${x}): ${t2}`, ...n2);
  }
}
function B(t2) {
  if ("string" == typeof t2)
    return t2;
  try {
    return e2 = t2, JSON.stringify(e2);
  } catch (e3) {
    return t2;
  }
  /**
  * @license
  * Copyright 2020 Google LLC
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
  var e2;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function L(t2 = "Unexpected state") {
  const e2 = `FIRESTORE (${x}) INTERNAL ASSERTION FAILED: ` + t2;
  throw F(e2), new Error(e2);
}
function U(t2, e2) {
  t2 || L();
}
function K(t2, e2) {
  return t2;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const G = {
  OK: "ok",
  CANCELLED: "cancelled",
  UNKNOWN: "unknown",
  INVALID_ARGUMENT: "invalid-argument",
  DEADLINE_EXCEEDED: "deadline-exceeded",
  NOT_FOUND: "not-found",
  ALREADY_EXISTS: "already-exists",
  PERMISSION_DENIED: "permission-denied",
  UNAUTHENTICATED: "unauthenticated",
  RESOURCE_EXHAUSTED: "resource-exhausted",
  FAILED_PRECONDITION: "failed-precondition",
  ABORTED: "aborted",
  OUT_OF_RANGE: "out-of-range",
  UNIMPLEMENTED: "unimplemented",
  INTERNAL: "internal",
  UNAVAILABLE: "unavailable",
  DATA_LOSS: "data-loss"
};
class Q extends FirebaseError {
  constructor(t2, e2) {
    super(t2, e2), this.code = t2, this.message = e2, this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class j {
  constructor() {
    this.promise = new Promise((t2, e2) => {
      this.resolve = t2, this.reject = e2;
    });
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class W {
  constructor(t2, e2) {
    this.user = e2, this.type = "OAuth", this.headers = /* @__PURE__ */ new Map(), this.headers.set("Authorization", `Bearer ${t2}`);
  }
}
class z {
  getToken() {
    return Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(t2, e2) {
    t2.enqueueRetryable(() => e2(C.UNAUTHENTICATED));
  }
  shutdown() {
  }
}
class H {
  constructor(t2) {
    this.token = t2, this.changeListener = null;
  }
  getToken() {
    return Promise.resolve(this.token);
  }
  invalidateToken() {
  }
  start(t2, e2) {
    this.changeListener = e2, t2.enqueueRetryable(() => e2(this.token.user));
  }
  shutdown() {
    this.changeListener = null;
  }
}
class J {
  constructor(t2) {
    this.t = t2, this.currentUser = C.UNAUTHENTICATED, this.i = 0, this.forceRefresh = false, this.auth = null;
  }
  start(t2, e2) {
    let n2 = this.i;
    const s2 = (t3) => this.i !== n2 ? (n2 = this.i, e2(t3)) : Promise.resolve();
    let i2 = new j();
    this.o = () => {
      this.i++, this.currentUser = this.u(), i2.resolve(), i2 = new j(), t2.enqueueRetryable(() => s2(this.currentUser));
    };
    const r2 = () => {
      const e3 = i2;
      t2.enqueueRetryable(async () => {
        await e3.promise, await s2(this.currentUser);
      });
    }, o2 = (t3) => {
      M("FirebaseAuthCredentialsProvider", "Auth detected"), this.auth = t3, this.auth.addAuthTokenListener(this.o), r2();
    };
    this.t.onInit((t3) => o2(t3)), setTimeout(() => {
      if (!this.auth) {
        const t3 = this.t.getImmediate({
          optional: true
        });
        t3 ? o2(t3) : (M("FirebaseAuthCredentialsProvider", "Auth not yet detected"), i2.resolve(), i2 = new j());
      }
    }, 0), r2();
  }
  getToken() {
    const t2 = this.i, e2 = this.forceRefresh;
    return this.forceRefresh = false, this.auth ? this.auth.getToken(e2).then((e3) => this.i !== t2 ? (M("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : e3 ? (U("string" == typeof e3.accessToken), new W(e3.accessToken, this.currentUser)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = true;
  }
  shutdown() {
    this.auth && this.auth.removeAuthTokenListener(this.o);
  }
  u() {
    const t2 = this.auth && this.auth.getUid();
    return U(null === t2 || "string" == typeof t2), new C(t2);
  }
}
class Y {
  constructor(t2, e2, n2) {
    this.type = "FirstParty", this.user = C.FIRST_PARTY, this.headers = /* @__PURE__ */ new Map(), this.headers.set("X-Goog-AuthUser", e2);
    const s2 = t2.auth.getAuthHeaderValueForFirstParty([]);
    s2 && this.headers.set("Authorization", s2), n2 && this.headers.set("X-Goog-Iam-Authorization-Token", n2);
  }
}
class X {
  constructor(t2, e2, n2) {
    this.h = t2, this.l = e2, this.m = n2;
  }
  getToken() {
    return Promise.resolve(new Y(this.h, this.l, this.m));
  }
  start(t2, e2) {
    t2.enqueueRetryable(() => e2(C.FIRST_PARTY));
  }
  shutdown() {
  }
  invalidateToken() {
  }
}
class Z {
  constructor(t2) {
    this.value = t2, this.type = "AppCheck", this.headers = /* @__PURE__ */ new Map(), t2 && t2.length > 0 && this.headers.set("x-firebase-appcheck", this.value);
  }
}
class tt {
  constructor(t2) {
    this.g = t2, this.forceRefresh = false, this.appCheck = null, this.p = null;
  }
  start(t2, e2) {
    const n2 = (t3) => {
      null != t3.error && M("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${t3.error.message}`);
      const n3 = t3.token !== this.p;
      return this.p = t3.token, M("FirebaseAppCheckTokenProvider", `Received ${n3 ? "new" : "existing"} token.`), n3 ? e2(t3.token) : Promise.resolve();
    };
    this.o = (e3) => {
      t2.enqueueRetryable(() => n2(e3));
    };
    const s2 = (t3) => {
      M("FirebaseAppCheckTokenProvider", "AppCheck detected"), this.appCheck = t3, this.appCheck.addTokenListener(this.o);
    };
    this.g.onInit((t3) => s2(t3)), setTimeout(() => {
      if (!this.appCheck) {
        const t3 = this.g.getImmediate({
          optional: true
        });
        t3 ? s2(t3) : M("FirebaseAppCheckTokenProvider", "AppCheck not yet detected");
      }
    }, 0);
  }
  getToken() {
    const t2 = this.forceRefresh;
    return this.forceRefresh = false, this.appCheck ? this.appCheck.getToken(t2).then((t3) => t3 ? (U("string" == typeof t3.token), this.p = t3.token, new Z(t3.token)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = true;
  }
  shutdown() {
    this.appCheck && this.appCheck.removeTokenListener(this.o);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function nt(t2) {
  const e2 = "undefined" != typeof self && (self.crypto || self.msCrypto), n2 = new Uint8Array(t2);
  if (e2 && "function" == typeof e2.getRandomValues)
    e2.getRandomValues(n2);
  else
    for (let e3 = 0; e3 < t2; e3++)
      n2[e3] = Math.floor(256 * Math.random());
  return n2;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class st {
  static I() {
    const t2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", e2 = Math.floor(256 / t2.length) * t2.length;
    let n2 = "";
    for (; n2.length < 20; ) {
      const s2 = nt(40);
      for (let i2 = 0; i2 < s2.length; ++i2)
        n2.length < 20 && s2[i2] < e2 && (n2 += t2.charAt(s2[i2] % t2.length));
    }
    return n2;
  }
}
function it(t2, e2) {
  return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
}
function rt(t2, e2, n2) {
  return t2.length === e2.length && t2.every((t3, s2) => n2(t3, e2[s2]));
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ut {
  constructor(t2, e2) {
    if (this.seconds = t2, this.nanoseconds = e2, e2 < 0)
      throw new Q(G.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e2);
    if (e2 >= 1e9)
      throw new Q(G.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e2);
    if (t2 < -62135596800)
      throw new Q(G.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
    if (t2 >= 253402300800)
      throw new Q(G.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
  }
  static now() {
    return ut.fromMillis(Date.now());
  }
  static fromDate(t2) {
    return ut.fromMillis(t2.getTime());
  }
  static fromMillis(t2) {
    const e2 = Math.floor(t2 / 1e3), n2 = Math.floor(1e6 * (t2 - 1e3 * e2));
    return new ut(e2, n2);
  }
  toDate() {
    return new Date(this.toMillis());
  }
  toMillis() {
    return 1e3 * this.seconds + this.nanoseconds / 1e6;
  }
  _compareTo(t2) {
    return this.seconds === t2.seconds ? it(this.nanoseconds, t2.nanoseconds) : it(this.seconds, t2.seconds);
  }
  isEqual(t2) {
    return t2.seconds === this.seconds && t2.nanoseconds === this.nanoseconds;
  }
  toString() {
    return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
  }
  toJSON() {
    return {
      seconds: this.seconds,
      nanoseconds: this.nanoseconds
    };
  }
  valueOf() {
    const t2 = this.seconds - -62135596800;
    return String(t2).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ct {
  constructor(t2) {
    this.timestamp = t2;
  }
  static fromTimestamp(t2) {
    return new ct(t2);
  }
  static min() {
    return new ct(new ut(0, 0));
  }
  static max() {
    return new ct(new ut(253402300799, 999999999));
  }
  compareTo(t2) {
    return this.timestamp._compareTo(t2.timestamp);
  }
  isEqual(t2) {
    return this.timestamp.isEqual(t2.timestamp);
  }
  toMicroseconds() {
    return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
  }
  toString() {
    return "SnapshotVersion(" + this.timestamp.toString() + ")";
  }
  toTimestamp() {
    return this.timestamp;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class at {
  constructor(t2, e2, n2) {
    void 0 === e2 ? e2 = 0 : e2 > t2.length && L(), void 0 === n2 ? n2 = t2.length - e2 : n2 > t2.length - e2 && L(), this.segments = t2, this.offset = e2, this.len = n2;
  }
  get length() {
    return this.len;
  }
  isEqual(t2) {
    return 0 === at.comparator(this, t2);
  }
  child(t2) {
    const e2 = this.segments.slice(this.offset, this.limit());
    return t2 instanceof at ? t2.forEach((t3) => {
      e2.push(t3);
    }) : e2.push(t2), this.construct(e2);
  }
  limit() {
    return this.offset + this.length;
  }
  popFirst(t2) {
    return t2 = void 0 === t2 ? 1 : t2, this.construct(this.segments, this.offset + t2, this.length - t2);
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1);
  }
  firstSegment() {
    return this.segments[this.offset];
  }
  lastSegment() {
    return this.get(this.length - 1);
  }
  get(t2) {
    return this.segments[this.offset + t2];
  }
  isEmpty() {
    return 0 === this.length;
  }
  isPrefixOf(t2) {
    if (t2.length < this.length)
      return false;
    for (let e2 = 0; e2 < this.length; e2++)
      if (this.get(e2) !== t2.get(e2))
        return false;
    return true;
  }
  isImmediateParentOf(t2) {
    if (this.length + 1 !== t2.length)
      return false;
    for (let e2 = 0; e2 < this.length; e2++)
      if (this.get(e2) !== t2.get(e2))
        return false;
    return true;
  }
  forEach(t2) {
    for (let e2 = this.offset, n2 = this.limit(); e2 < n2; e2++)
      t2(this.segments[e2]);
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit());
  }
  static comparator(t2, e2) {
    const n2 = Math.min(t2.length, e2.length);
    for (let s2 = 0; s2 < n2; s2++) {
      const n3 = t2.get(s2), i2 = e2.get(s2);
      if (n3 < i2)
        return -1;
      if (n3 > i2)
        return 1;
    }
    return t2.length < e2.length ? -1 : t2.length > e2.length ? 1 : 0;
  }
}
class ht extends at {
  construct(t2, e2, n2) {
    return new ht(t2, e2, n2);
  }
  canonicalString() {
    return this.toArray().join("/");
  }
  toString() {
    return this.canonicalString();
  }
  static fromString(...t2) {
    const e2 = [];
    for (const n2 of t2) {
      if (n2.indexOf("//") >= 0)
        throw new Q(G.INVALID_ARGUMENT, `Invalid segment (${n2}). Paths must not contain // in them.`);
      e2.push(...n2.split("/").filter((t3) => t3.length > 0));
    }
    return new ht(e2);
  }
  static emptyPath() {
    return new ht([]);
  }
}
const lt = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
class ft extends at {
  construct(t2, e2, n2) {
    return new ft(t2, e2, n2);
  }
  static isValidIdentifier(t2) {
    return lt.test(t2);
  }
  canonicalString() {
    return this.toArray().map((t2) => (t2 = t2.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), ft.isValidIdentifier(t2) || (t2 = "`" + t2 + "`"), t2)).join(".");
  }
  toString() {
    return this.canonicalString();
  }
  isKeyField() {
    return 1 === this.length && "__name__" === this.get(0);
  }
  static keyField() {
    return new ft(["__name__"]);
  }
  static fromServerFormat(t2) {
    const e2 = [];
    let n2 = "", s2 = 0;
    const i2 = () => {
      if (0 === n2.length)
        throw new Q(G.INVALID_ARGUMENT, `Invalid field path (${t2}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
      e2.push(n2), n2 = "";
    };
    let r2 = false;
    for (; s2 < t2.length; ) {
      const e3 = t2[s2];
      if ("\\" === e3) {
        if (s2 + 1 === t2.length)
          throw new Q(G.INVALID_ARGUMENT, "Path has trailing escape character: " + t2);
        const e4 = t2[s2 + 1];
        if ("\\" !== e4 && "." !== e4 && "`" !== e4)
          throw new Q(G.INVALID_ARGUMENT, "Path has invalid escape sequence: " + t2);
        n2 += e4, s2 += 2;
      } else
        "`" === e3 ? (r2 = !r2, s2++) : "." !== e3 || r2 ? (n2 += e3, s2++) : (i2(), s2++);
    }
    if (i2(), r2)
      throw new Q(G.INVALID_ARGUMENT, "Unterminated ` in path: " + t2);
    return new ft(e2);
  }
  static emptyPath() {
    return new ft([]);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class dt {
  constructor(t2) {
    this.path = t2;
  }
  static fromPath(t2) {
    return new dt(ht.fromString(t2));
  }
  static fromName(t2) {
    return new dt(ht.fromString(t2).popFirst(5));
  }
  static empty() {
    return new dt(ht.emptyPath());
  }
  get collectionGroup() {
    return this.path.popLast().lastSegment();
  }
  hasCollectionId(t2) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === t2;
  }
  getCollectionGroup() {
    return this.path.get(this.path.length - 2);
  }
  getCollectionPath() {
    return this.path.popLast();
  }
  isEqual(t2) {
    return null !== t2 && 0 === ht.comparator(this.path, t2.path);
  }
  toString() {
    return this.path.toString();
  }
  static comparator(t2, e2) {
    return ht.comparator(t2.path, e2.path);
  }
  static isDocumentKey(t2) {
    return t2.length % 2 == 0;
  }
  static fromSegments(t2) {
    return new dt(new ht(t2.slice()));
  }
}
function pt(t2, e2) {
  const n2 = t2.toTimestamp().seconds, s2 = t2.toTimestamp().nanoseconds + 1, i2 = ct.fromTimestamp(1e9 === s2 ? new ut(n2 + 1, 0) : new ut(n2, s2));
  return new Tt(i2, dt.empty(), e2);
}
function It(t2) {
  return new Tt(t2.readTime, t2.key, -1);
}
class Tt {
  constructor(t2, e2, n2) {
    this.readTime = t2, this.documentKey = e2, this.largestBatchId = n2;
  }
  static min() {
    return new Tt(ct.min(), dt.empty(), -1);
  }
  static max() {
    return new Tt(ct.max(), dt.empty(), -1);
  }
}
function Et(t2, e2) {
  let n2 = t2.readTime.compareTo(e2.readTime);
  return 0 !== n2 ? n2 : (n2 = dt.comparator(t2.documentKey, e2.documentKey), 0 !== n2 ? n2 : it(t2.largestBatchId, e2.largestBatchId));
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const At = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
class Rt {
  constructor() {
    this.onCommittedListeners = [];
  }
  addOnCommittedListener(t2) {
    this.onCommittedListeners.push(t2);
  }
  raiseOnCommittedEvent() {
    this.onCommittedListeners.forEach((t2) => t2());
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function bt(t2) {
  if (t2.code !== G.FAILED_PRECONDITION || t2.message !== At)
    throw t2;
  M("LocalStore", "Unexpectedly lost primary lease");
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Pt {
  constructor(t2) {
    this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = false, this.callbackAttached = false, t2((t3) => {
      this.isDone = true, this.result = t3, this.nextCallback && this.nextCallback(t3);
    }, (t3) => {
      this.isDone = true, this.error = t3, this.catchCallback && this.catchCallback(t3);
    });
  }
  catch(t2) {
    return this.next(void 0, t2);
  }
  next(t2, e2) {
    return this.callbackAttached && L(), this.callbackAttached = true, this.isDone ? this.error ? this.wrapFailure(e2, this.error) : this.wrapSuccess(t2, this.result) : new Pt((n2, s2) => {
      this.nextCallback = (e3) => {
        this.wrapSuccess(t2, e3).next(n2, s2);
      }, this.catchCallback = (t3) => {
        this.wrapFailure(e2, t3).next(n2, s2);
      };
    });
  }
  toPromise() {
    return new Promise((t2, e2) => {
      this.next(t2, e2);
    });
  }
  wrapUserFunction(t2) {
    try {
      const e2 = t2();
      return e2 instanceof Pt ? e2 : Pt.resolve(e2);
    } catch (t3) {
      return Pt.reject(t3);
    }
  }
  wrapSuccess(t2, e2) {
    return t2 ? this.wrapUserFunction(() => t2(e2)) : Pt.resolve(e2);
  }
  wrapFailure(t2, e2) {
    return t2 ? this.wrapUserFunction(() => t2(e2)) : Pt.reject(e2);
  }
  static resolve(t2) {
    return new Pt((e2, n2) => {
      e2(t2);
    });
  }
  static reject(t2) {
    return new Pt((e2, n2) => {
      n2(t2);
    });
  }
  static waitFor(t2) {
    return new Pt((e2, n2) => {
      let s2 = 0, i2 = 0, r2 = false;
      t2.forEach((t3) => {
        ++s2, t3.next(() => {
          ++i2, r2 && i2 === s2 && e2();
        }, (t4) => n2(t4));
      }), r2 = true, i2 === s2 && e2();
    });
  }
  static or(t2) {
    let e2 = Pt.resolve(false);
    for (const n2 of t2)
      e2 = e2.next((t3) => t3 ? Pt.resolve(t3) : n2());
    return e2;
  }
  static forEach(t2, e2) {
    const n2 = [];
    return t2.forEach((t3, s2) => {
      n2.push(e2.call(this, t3, s2));
    }), this.waitFor(n2);
  }
  static mapArray(t2, e2) {
    return new Pt((n2, s2) => {
      const i2 = t2.length, r2 = new Array(i2);
      let o2 = 0;
      for (let u2 = 0; u2 < i2; u2++) {
        const c2 = u2;
        e2(t2[c2]).next((t3) => {
          r2[c2] = t3, ++o2, o2 === i2 && n2(r2);
        }, (t3) => s2(t3));
      }
    });
  }
  static doWhile(t2, e2) {
    return new Pt((n2, s2) => {
      const i2 = () => {
        true === t2() ? e2().next(() => {
          i2();
        }, s2) : n2();
      };
      i2();
    });
  }
}
function Ct(t2) {
  return "IndexedDbTransactionError" === t2.name;
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class $t {
  constructor(t2, e2) {
    this.previousValue = t2, e2 && (e2.sequenceNumberHandler = (t3) => this.it(t3), this.rt = (t3) => e2.writeSequenceNumber(t3));
  }
  it(t2) {
    return this.previousValue = Math.max(t2, this.previousValue), this.previousValue;
  }
  next() {
    const t2 = ++this.previousValue;
    return this.rt && this.rt(t2), t2;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Bt(t2) {
  let e2 = 0;
  for (const n2 in t2)
    Object.prototype.hasOwnProperty.call(t2, n2) && e2++;
  return e2;
}
function Lt(t2, e2) {
  for (const n2 in t2)
    Object.prototype.hasOwnProperty.call(t2, n2) && e2(n2, t2[n2]);
}
function Ut(t2) {
  for (const e2 in t2)
    if (Object.prototype.hasOwnProperty.call(t2, e2))
      return false;
  return true;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
$t.ot = -1;
class qt {
  constructor(t2, e2) {
    this.comparator = t2, this.root = e2 || Gt.EMPTY;
  }
  insert(t2, e2) {
    return new qt(this.comparator, this.root.insert(t2, e2, this.comparator).copy(null, null, Gt.BLACK, null, null));
  }
  remove(t2) {
    return new qt(this.comparator, this.root.remove(t2, this.comparator).copy(null, null, Gt.BLACK, null, null));
  }
  get(t2) {
    let e2 = this.root;
    for (; !e2.isEmpty(); ) {
      const n2 = this.comparator(t2, e2.key);
      if (0 === n2)
        return e2.value;
      n2 < 0 ? e2 = e2.left : n2 > 0 && (e2 = e2.right);
    }
    return null;
  }
  indexOf(t2) {
    let e2 = 0, n2 = this.root;
    for (; !n2.isEmpty(); ) {
      const s2 = this.comparator(t2, n2.key);
      if (0 === s2)
        return e2 + n2.left.size;
      s2 < 0 ? n2 = n2.left : (e2 += n2.left.size + 1, n2 = n2.right);
    }
    return -1;
  }
  isEmpty() {
    return this.root.isEmpty();
  }
  get size() {
    return this.root.size;
  }
  minKey() {
    return this.root.minKey();
  }
  maxKey() {
    return this.root.maxKey();
  }
  inorderTraversal(t2) {
    return this.root.inorderTraversal(t2);
  }
  forEach(t2) {
    this.inorderTraversal((e2, n2) => (t2(e2, n2), false));
  }
  toString() {
    const t2 = [];
    return this.inorderTraversal((e2, n2) => (t2.push(`${e2}:${n2}`), false)), `{${t2.join(", ")}}`;
  }
  reverseTraversal(t2) {
    return this.root.reverseTraversal(t2);
  }
  getIterator() {
    return new Kt(this.root, null, this.comparator, false);
  }
  getIteratorFrom(t2) {
    return new Kt(this.root, t2, this.comparator, false);
  }
  getReverseIterator() {
    return new Kt(this.root, null, this.comparator, true);
  }
  getReverseIteratorFrom(t2) {
    return new Kt(this.root, t2, this.comparator, true);
  }
}
class Kt {
  constructor(t2, e2, n2, s2) {
    this.isReverse = s2, this.nodeStack = [];
    let i2 = 1;
    for (; !t2.isEmpty(); )
      if (i2 = e2 ? n2(t2.key, e2) : 1, e2 && s2 && (i2 *= -1), i2 < 0)
        t2 = this.isReverse ? t2.left : t2.right;
      else {
        if (0 === i2) {
          this.nodeStack.push(t2);
          break;
        }
        this.nodeStack.push(t2), t2 = this.isReverse ? t2.right : t2.left;
      }
  }
  getNext() {
    let t2 = this.nodeStack.pop();
    const e2 = {
      key: t2.key,
      value: t2.value
    };
    if (this.isReverse)
      for (t2 = t2.left; !t2.isEmpty(); )
        this.nodeStack.push(t2), t2 = t2.right;
    else
      for (t2 = t2.right; !t2.isEmpty(); )
        this.nodeStack.push(t2), t2 = t2.left;
    return e2;
  }
  hasNext() {
    return this.nodeStack.length > 0;
  }
  peek() {
    if (0 === this.nodeStack.length)
      return null;
    const t2 = this.nodeStack[this.nodeStack.length - 1];
    return {
      key: t2.key,
      value: t2.value
    };
  }
}
class Gt {
  constructor(t2, e2, n2, s2, i2) {
    this.key = t2, this.value = e2, this.color = null != n2 ? n2 : Gt.RED, this.left = null != s2 ? s2 : Gt.EMPTY, this.right = null != i2 ? i2 : Gt.EMPTY, this.size = this.left.size + 1 + this.right.size;
  }
  copy(t2, e2, n2, s2, i2) {
    return new Gt(null != t2 ? t2 : this.key, null != e2 ? e2 : this.value, null != n2 ? n2 : this.color, null != s2 ? s2 : this.left, null != i2 ? i2 : this.right);
  }
  isEmpty() {
    return false;
  }
  inorderTraversal(t2) {
    return this.left.inorderTraversal(t2) || t2(this.key, this.value) || this.right.inorderTraversal(t2);
  }
  reverseTraversal(t2) {
    return this.right.reverseTraversal(t2) || t2(this.key, this.value) || this.left.reverseTraversal(t2);
  }
  min() {
    return this.left.isEmpty() ? this : this.left.min();
  }
  minKey() {
    return this.min().key;
  }
  maxKey() {
    return this.right.isEmpty() ? this.key : this.right.maxKey();
  }
  insert(t2, e2, n2) {
    let s2 = this;
    const i2 = n2(t2, s2.key);
    return s2 = i2 < 0 ? s2.copy(null, null, null, s2.left.insert(t2, e2, n2), null) : 0 === i2 ? s2.copy(null, e2, null, null, null) : s2.copy(null, null, null, null, s2.right.insert(t2, e2, n2)), s2.fixUp();
  }
  removeMin() {
    if (this.left.isEmpty())
      return Gt.EMPTY;
    let t2 = this;
    return t2.left.isRed() || t2.left.left.isRed() || (t2 = t2.moveRedLeft()), t2 = t2.copy(null, null, null, t2.left.removeMin(), null), t2.fixUp();
  }
  remove(t2, e2) {
    let n2, s2 = this;
    if (e2(t2, s2.key) < 0)
      s2.left.isEmpty() || s2.left.isRed() || s2.left.left.isRed() || (s2 = s2.moveRedLeft()), s2 = s2.copy(null, null, null, s2.left.remove(t2, e2), null);
    else {
      if (s2.left.isRed() && (s2 = s2.rotateRight()), s2.right.isEmpty() || s2.right.isRed() || s2.right.left.isRed() || (s2 = s2.moveRedRight()), 0 === e2(t2, s2.key)) {
        if (s2.right.isEmpty())
          return Gt.EMPTY;
        n2 = s2.right.min(), s2 = s2.copy(n2.key, n2.value, null, null, s2.right.removeMin());
      }
      s2 = s2.copy(null, null, null, null, s2.right.remove(t2, e2));
    }
    return s2.fixUp();
  }
  isRed() {
    return this.color;
  }
  fixUp() {
    let t2 = this;
    return t2.right.isRed() && !t2.left.isRed() && (t2 = t2.rotateLeft()), t2.left.isRed() && t2.left.left.isRed() && (t2 = t2.rotateRight()), t2.left.isRed() && t2.right.isRed() && (t2 = t2.colorFlip()), t2;
  }
  moveRedLeft() {
    let t2 = this.colorFlip();
    return t2.right.left.isRed() && (t2 = t2.copy(null, null, null, null, t2.right.rotateRight()), t2 = t2.rotateLeft(), t2 = t2.colorFlip()), t2;
  }
  moveRedRight() {
    let t2 = this.colorFlip();
    return t2.left.left.isRed() && (t2 = t2.rotateRight(), t2 = t2.colorFlip()), t2;
  }
  rotateLeft() {
    const t2 = this.copy(null, null, Gt.RED, null, this.right.left);
    return this.right.copy(null, null, this.color, t2, null);
  }
  rotateRight() {
    const t2 = this.copy(null, null, Gt.RED, this.left.right, null);
    return this.left.copy(null, null, this.color, null, t2);
  }
  colorFlip() {
    const t2 = this.left.copy(null, null, !this.left.color, null, null), e2 = this.right.copy(null, null, !this.right.color, null, null);
    return this.copy(null, null, !this.color, t2, e2);
  }
  checkMaxDepth() {
    const t2 = this.check();
    return Math.pow(2, t2) <= this.size + 1;
  }
  check() {
    if (this.isRed() && this.left.isRed())
      throw L();
    if (this.right.isRed())
      throw L();
    const t2 = this.left.check();
    if (t2 !== this.right.check())
      throw L();
    return t2 + (this.isRed() ? 0 : 1);
  }
}
Gt.EMPTY = null, Gt.RED = true, Gt.BLACK = false;
Gt.EMPTY = new class {
  constructor() {
    this.size = 0;
  }
  get key() {
    throw L();
  }
  get value() {
    throw L();
  }
  get color() {
    throw L();
  }
  get left() {
    throw L();
  }
  get right() {
    throw L();
  }
  copy(t2, e2, n2, s2, i2) {
    return this;
  }
  insert(t2, e2, n2) {
    return new Gt(t2, e2);
  }
  remove(t2, e2) {
    return this;
  }
  isEmpty() {
    return true;
  }
  inorderTraversal(t2) {
    return false;
  }
  reverseTraversal(t2) {
    return false;
  }
  minKey() {
    return null;
  }
  maxKey() {
    return null;
  }
  isRed() {
    return false;
  }
  checkMaxDepth() {
    return true;
  }
  check() {
    return 0;
  }
}();
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Qt {
  constructor(t2) {
    this.comparator = t2, this.data = new qt(this.comparator);
  }
  has(t2) {
    return null !== this.data.get(t2);
  }
  first() {
    return this.data.minKey();
  }
  last() {
    return this.data.maxKey();
  }
  get size() {
    return this.data.size;
  }
  indexOf(t2) {
    return this.data.indexOf(t2);
  }
  forEach(t2) {
    this.data.inorderTraversal((e2, n2) => (t2(e2), false));
  }
  forEachInRange(t2, e2) {
    const n2 = this.data.getIteratorFrom(t2[0]);
    for (; n2.hasNext(); ) {
      const s2 = n2.getNext();
      if (this.comparator(s2.key, t2[1]) >= 0)
        return;
      e2(s2.key);
    }
  }
  forEachWhile(t2, e2) {
    let n2;
    for (n2 = void 0 !== e2 ? this.data.getIteratorFrom(e2) : this.data.getIterator(); n2.hasNext(); ) {
      if (!t2(n2.getNext().key))
        return;
    }
  }
  firstAfterOrEqual(t2) {
    const e2 = this.data.getIteratorFrom(t2);
    return e2.hasNext() ? e2.getNext().key : null;
  }
  getIterator() {
    return new jt(this.data.getIterator());
  }
  getIteratorFrom(t2) {
    return new jt(this.data.getIteratorFrom(t2));
  }
  add(t2) {
    return this.copy(this.data.remove(t2).insert(t2, true));
  }
  delete(t2) {
    return this.has(t2) ? this.copy(this.data.remove(t2)) : this;
  }
  isEmpty() {
    return this.data.isEmpty();
  }
  unionWith(t2) {
    let e2 = this;
    return e2.size < t2.size && (e2 = t2, t2 = this), t2.forEach((t3) => {
      e2 = e2.add(t3);
    }), e2;
  }
  isEqual(t2) {
    if (!(t2 instanceof Qt))
      return false;
    if (this.size !== t2.size)
      return false;
    const e2 = this.data.getIterator(), n2 = t2.data.getIterator();
    for (; e2.hasNext(); ) {
      const t3 = e2.getNext().key, s2 = n2.getNext().key;
      if (0 !== this.comparator(t3, s2))
        return false;
    }
    return true;
  }
  toArray() {
    const t2 = [];
    return this.forEach((e2) => {
      t2.push(e2);
    }), t2;
  }
  toString() {
    const t2 = [];
    return this.forEach((e2) => t2.push(e2)), "SortedSet(" + t2.toString() + ")";
  }
  copy(t2) {
    const e2 = new Qt(this.comparator);
    return e2.data = t2, e2;
  }
}
class jt {
  constructor(t2) {
    this.iter = t2;
  }
  getNext() {
    return this.iter.getNext().key;
  }
  hasNext() {
    return this.iter.hasNext();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class zt {
  constructor(t2) {
    this.fields = t2, t2.sort(ft.comparator);
  }
  static empty() {
    return new zt([]);
  }
  unionWith(t2) {
    let e2 = new Qt(ft.comparator);
    for (const t3 of this.fields)
      e2 = e2.add(t3);
    for (const n2 of t2)
      e2 = e2.add(n2);
    return new zt(e2.toArray());
  }
  covers(t2) {
    for (const e2 of this.fields)
      if (e2.isPrefixOf(t2))
        return true;
    return false;
  }
  isEqual(t2) {
    return rt(this.fields, t2.fields, (t3, e2) => t3.isEqual(e2));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Jt {
  constructor(t2) {
    this.binaryString = t2;
  }
  static fromBase64String(t2) {
    const e2 = atob(t2);
    return new Jt(e2);
  }
  static fromUint8Array(t2) {
    const e2 = function(t3) {
      let e3 = "";
      for (let n2 = 0; n2 < t3.length; ++n2)
        e3 += String.fromCharCode(t3[n2]);
      return e3;
    }(t2);
    return new Jt(e2);
  }
  [Symbol.iterator]() {
    let t2 = 0;
    return {
      next: () => t2 < this.binaryString.length ? {
        value: this.binaryString.charCodeAt(t2++),
        done: false
      } : {
        value: void 0,
        done: true
      }
    };
  }
  toBase64() {
    return t2 = this.binaryString, btoa(t2);
    var t2;
  }
  toUint8Array() {
    return function(t2) {
      const e2 = new Uint8Array(t2.length);
      for (let n2 = 0; n2 < t2.length; n2++)
        e2[n2] = t2.charCodeAt(n2);
      return e2;
    }(this.binaryString);
  }
  approximateByteSize() {
    return 2 * this.binaryString.length;
  }
  compareTo(t2) {
    return it(this.binaryString, t2.binaryString);
  }
  isEqual(t2) {
    return this.binaryString === t2.binaryString;
  }
}
Jt.EMPTY_BYTE_STRING = new Jt("");
const Yt = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function Xt(t2) {
  if (U(!!t2), "string" == typeof t2) {
    let e2 = 0;
    const n2 = Yt.exec(t2);
    if (U(!!n2), n2[1]) {
      let t3 = n2[1];
      t3 = (t3 + "000000000").substr(0, 9), e2 = Number(t3);
    }
    const s2 = new Date(t2);
    return {
      seconds: Math.floor(s2.getTime() / 1e3),
      nanos: e2
    };
  }
  return {
    seconds: Zt(t2.seconds),
    nanos: Zt(t2.nanos)
  };
}
function Zt(t2) {
  return "number" == typeof t2 ? t2 : "string" == typeof t2 ? Number(t2) : 0;
}
function te(t2) {
  return "string" == typeof t2 ? Jt.fromBase64String(t2) : Jt.fromUint8Array(t2);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ee(t2) {
  var e2, n2;
  return "server_timestamp" === (null === (n2 = ((null === (e2 = null == t2 ? void 0 : t2.mapValue) || void 0 === e2 ? void 0 : e2.fields) || {}).__type__) || void 0 === n2 ? void 0 : n2.stringValue);
}
function ne(t2) {
  const e2 = t2.mapValue.fields.__previous_value__;
  return ee(e2) ? ne(e2) : e2;
}
function se(t2) {
  const e2 = Xt(t2.mapValue.fields.__local_write_time__.timestampValue);
  return new ut(e2.seconds, e2.nanos);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ie {
  constructor(t2, e2, n2, s2, i2, r2, o2, u2) {
    this.databaseId = t2, this.appId = e2, this.persistenceKey = n2, this.host = s2, this.ssl = i2, this.forceLongPolling = r2, this.autoDetectLongPolling = o2, this.useFetchStreams = u2;
  }
}
class re {
  constructor(t2, e2) {
    this.projectId = t2, this.database = e2 || "(default)";
  }
  static empty() {
    return new re("", "");
  }
  get isDefaultDatabase() {
    return "(default)" === this.database;
  }
  isEqual(t2) {
    return t2 instanceof re && t2.projectId === this.projectId && t2.database === this.database;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function oe(t2) {
  return null == t2;
}
function ue(t2) {
  return 0 === t2 && 1 / t2 == -1 / 0;
}
function ce(t2) {
  return "number" == typeof t2 && Number.isInteger(t2) && !ue(t2) && t2 <= Number.MAX_SAFE_INTEGER && t2 >= Number.MIN_SAFE_INTEGER;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ae = {
  mapValue: {
    fields: {
      __type__: {
        stringValue: "__max__"
      }
    }
  }
};
function le(t2) {
  return "nullValue" in t2 ? 0 : "booleanValue" in t2 ? 1 : "integerValue" in t2 || "doubleValue" in t2 ? 2 : "timestampValue" in t2 ? 3 : "stringValue" in t2 ? 5 : "bytesValue" in t2 ? 6 : "referenceValue" in t2 ? 7 : "geoPointValue" in t2 ? 8 : "arrayValue" in t2 ? 9 : "mapValue" in t2 ? ee(t2) ? 4 : be(t2) ? 9007199254740991 : 10 : L();
}
function fe(t2, e2) {
  if (t2 === e2)
    return true;
  const n2 = le(t2);
  if (n2 !== le(e2))
    return false;
  switch (n2) {
    case 0:
    case 9007199254740991:
      return true;
    case 1:
      return t2.booleanValue === e2.booleanValue;
    case 4:
      return se(t2).isEqual(se(e2));
    case 3:
      return function(t3, e3) {
        if ("string" == typeof t3.timestampValue && "string" == typeof e3.timestampValue && t3.timestampValue.length === e3.timestampValue.length)
          return t3.timestampValue === e3.timestampValue;
        const n3 = Xt(t3.timestampValue), s2 = Xt(e3.timestampValue);
        return n3.seconds === s2.seconds && n3.nanos === s2.nanos;
      }(t2, e2);
    case 5:
      return t2.stringValue === e2.stringValue;
    case 6:
      return function(t3, e3) {
        return te(t3.bytesValue).isEqual(te(e3.bytesValue));
      }(t2, e2);
    case 7:
      return t2.referenceValue === e2.referenceValue;
    case 8:
      return function(t3, e3) {
        return Zt(t3.geoPointValue.latitude) === Zt(e3.geoPointValue.latitude) && Zt(t3.geoPointValue.longitude) === Zt(e3.geoPointValue.longitude);
      }(t2, e2);
    case 2:
      return function(t3, e3) {
        if ("integerValue" in t3 && "integerValue" in e3)
          return Zt(t3.integerValue) === Zt(e3.integerValue);
        if ("doubleValue" in t3 && "doubleValue" in e3) {
          const n3 = Zt(t3.doubleValue), s2 = Zt(e3.doubleValue);
          return n3 === s2 ? ue(n3) === ue(s2) : isNaN(n3) && isNaN(s2);
        }
        return false;
      }(t2, e2);
    case 9:
      return rt(t2.arrayValue.values || [], e2.arrayValue.values || [], fe);
    case 10:
      return function(t3, e3) {
        const n3 = t3.mapValue.fields || {}, s2 = e3.mapValue.fields || {};
        if (Bt(n3) !== Bt(s2))
          return false;
        for (const t4 in n3)
          if (n3.hasOwnProperty(t4) && (void 0 === s2[t4] || !fe(n3[t4], s2[t4])))
            return false;
        return true;
      }(t2, e2);
    default:
      return L();
  }
}
function de(t2, e2) {
  return void 0 !== (t2.values || []).find((t3) => fe(t3, e2));
}
function _e(t2, e2) {
  if (t2 === e2)
    return 0;
  const n2 = le(t2), s2 = le(e2);
  if (n2 !== s2)
    return it(n2, s2);
  switch (n2) {
    case 0:
    case 9007199254740991:
      return 0;
    case 1:
      return it(t2.booleanValue, e2.booleanValue);
    case 2:
      return function(t3, e3) {
        const n3 = Zt(t3.integerValue || t3.doubleValue), s3 = Zt(e3.integerValue || e3.doubleValue);
        return n3 < s3 ? -1 : n3 > s3 ? 1 : n3 === s3 ? 0 : isNaN(n3) ? isNaN(s3) ? 0 : -1 : 1;
      }(t2, e2);
    case 3:
      return we(t2.timestampValue, e2.timestampValue);
    case 4:
      return we(se(t2), se(e2));
    case 5:
      return it(t2.stringValue, e2.stringValue);
    case 6:
      return function(t3, e3) {
        const n3 = te(t3), s3 = te(e3);
        return n3.compareTo(s3);
      }(t2.bytesValue, e2.bytesValue);
    case 7:
      return function(t3, e3) {
        const n3 = t3.split("/"), s3 = e3.split("/");
        for (let t4 = 0; t4 < n3.length && t4 < s3.length; t4++) {
          const e4 = it(n3[t4], s3[t4]);
          if (0 !== e4)
            return e4;
        }
        return it(n3.length, s3.length);
      }(t2.referenceValue, e2.referenceValue);
    case 8:
      return function(t3, e3) {
        const n3 = it(Zt(t3.latitude), Zt(e3.latitude));
        if (0 !== n3)
          return n3;
        return it(Zt(t3.longitude), Zt(e3.longitude));
      }(t2.geoPointValue, e2.geoPointValue);
    case 9:
      return function(t3, e3) {
        const n3 = t3.values || [], s3 = e3.values || [];
        for (let t4 = 0; t4 < n3.length && t4 < s3.length; ++t4) {
          const e4 = _e(n3[t4], s3[t4]);
          if (e4)
            return e4;
        }
        return it(n3.length, s3.length);
      }(t2.arrayValue, e2.arrayValue);
    case 10:
      return function(t3, e3) {
        if (t3 === ae.mapValue && e3 === ae.mapValue)
          return 0;
        if (t3 === ae.mapValue)
          return 1;
        if (e3 === ae.mapValue)
          return -1;
        const n3 = t3.fields || {}, s3 = Object.keys(n3), i2 = e3.fields || {}, r2 = Object.keys(i2);
        s3.sort(), r2.sort();
        for (let t4 = 0; t4 < s3.length && t4 < r2.length; ++t4) {
          const e4 = it(s3[t4], r2[t4]);
          if (0 !== e4)
            return e4;
          const o2 = _e(n3[s3[t4]], i2[r2[t4]]);
          if (0 !== o2)
            return o2;
        }
        return it(s3.length, r2.length);
      }(t2.mapValue, e2.mapValue);
    default:
      throw L();
  }
}
function we(t2, e2) {
  if ("string" == typeof t2 && "string" == typeof e2 && t2.length === e2.length)
    return it(t2, e2);
  const n2 = Xt(t2), s2 = Xt(e2), i2 = it(n2.seconds, s2.seconds);
  return 0 !== i2 ? i2 : it(n2.nanos, s2.nanos);
}
function me(t2) {
  return ge(t2);
}
function ge(t2) {
  return "nullValue" in t2 ? "null" : "booleanValue" in t2 ? "" + t2.booleanValue : "integerValue" in t2 ? "" + t2.integerValue : "doubleValue" in t2 ? "" + t2.doubleValue : "timestampValue" in t2 ? function(t3) {
    const e3 = Xt(t3);
    return `time(${e3.seconds},${e3.nanos})`;
  }(t2.timestampValue) : "stringValue" in t2 ? t2.stringValue : "bytesValue" in t2 ? te(t2.bytesValue).toBase64() : "referenceValue" in t2 ? (n2 = t2.referenceValue, dt.fromName(n2).toString()) : "geoPointValue" in t2 ? `geo(${(e2 = t2.geoPointValue).latitude},${e2.longitude})` : "arrayValue" in t2 ? function(t3) {
    let e3 = "[", n3 = true;
    for (const s2 of t3.values || [])
      n3 ? n3 = false : e3 += ",", e3 += ge(s2);
    return e3 + "]";
  }(t2.arrayValue) : "mapValue" in t2 ? function(t3) {
    const e3 = Object.keys(t3.fields || {}).sort();
    let n3 = "{", s2 = true;
    for (const i2 of e3)
      s2 ? s2 = false : n3 += ",", n3 += `${i2}:${ge(t3.fields[i2])}`;
    return n3 + "}";
  }(t2.mapValue) : L();
  var e2, n2;
}
function ye(t2, e2) {
  return {
    referenceValue: `projects/${t2.projectId}/databases/${t2.database}/documents/${e2.path.canonicalString()}`
  };
}
function pe(t2) {
  return !!t2 && "integerValue" in t2;
}
function Ie(t2) {
  return !!t2 && "arrayValue" in t2;
}
function Te(t2) {
  return !!t2 && "nullValue" in t2;
}
function Ee(t2) {
  return !!t2 && "doubleValue" in t2 && isNaN(Number(t2.doubleValue));
}
function Ae(t2) {
  return !!t2 && "mapValue" in t2;
}
function Re(t2) {
  if (t2.geoPointValue)
    return {
      geoPointValue: Object.assign({}, t2.geoPointValue)
    };
  if (t2.timestampValue && "object" == typeof t2.timestampValue)
    return {
      timestampValue: Object.assign({}, t2.timestampValue)
    };
  if (t2.mapValue) {
    const e2 = {
      mapValue: {
        fields: {}
      }
    };
    return Lt(t2.mapValue.fields, (t3, n2) => e2.mapValue.fields[t3] = Re(n2)), e2;
  }
  if (t2.arrayValue) {
    const e2 = {
      arrayValue: {
        values: []
      }
    };
    for (let n2 = 0; n2 < (t2.arrayValue.values || []).length; ++n2)
      e2.arrayValue.values[n2] = Re(t2.arrayValue.values[n2]);
    return e2;
  }
  return Object.assign({}, t2);
}
function be(t2) {
  return "__max__" === (((t2.mapValue || {}).fields || {}).__type__ || {}).stringValue;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class De {
  constructor(t2) {
    this.value = t2;
  }
  static empty() {
    return new De({
      mapValue: {}
    });
  }
  field(t2) {
    if (t2.isEmpty())
      return this.value;
    {
      let e2 = this.value;
      for (let n2 = 0; n2 < t2.length - 1; ++n2)
        if (e2 = (e2.mapValue.fields || {})[t2.get(n2)], !Ae(e2))
          return null;
      return e2 = (e2.mapValue.fields || {})[t2.lastSegment()], e2 || null;
    }
  }
  set(t2, e2) {
    this.getFieldsMap(t2.popLast())[t2.lastSegment()] = Re(e2);
  }
  setAll(t2) {
    let e2 = ft.emptyPath(), n2 = {}, s2 = [];
    t2.forEach((t3, i3) => {
      if (!e2.isImmediateParentOf(i3)) {
        const t4 = this.getFieldsMap(e2);
        this.applyChanges(t4, n2, s2), n2 = {}, s2 = [], e2 = i3.popLast();
      }
      t3 ? n2[i3.lastSegment()] = Re(t3) : s2.push(i3.lastSegment());
    });
    const i2 = this.getFieldsMap(e2);
    this.applyChanges(i2, n2, s2);
  }
  delete(t2) {
    const e2 = this.field(t2.popLast());
    Ae(e2) && e2.mapValue.fields && delete e2.mapValue.fields[t2.lastSegment()];
  }
  isEqual(t2) {
    return fe(this.value, t2.value);
  }
  getFieldsMap(t2) {
    let e2 = this.value;
    e2.mapValue.fields || (e2.mapValue = {
      fields: {}
    });
    for (let n2 = 0; n2 < t2.length; ++n2) {
      let s2 = e2.mapValue.fields[t2.get(n2)];
      Ae(s2) && s2.mapValue.fields || (s2 = {
        mapValue: {
          fields: {}
        }
      }, e2.mapValue.fields[t2.get(n2)] = s2), e2 = s2;
    }
    return e2.mapValue.fields;
  }
  applyChanges(t2, e2, n2) {
    Lt(e2, (e3, n3) => t2[e3] = n3);
    for (const e3 of n2)
      delete t2[e3];
  }
  clone() {
    return new De(Re(this.value));
  }
}
function Ce(t2) {
  const e2 = [];
  return Lt(t2.fields, (t3, n2) => {
    const s2 = new ft([t3]);
    if (Ae(n2)) {
      const t4 = Ce(n2.mapValue).fields;
      if (0 === t4.length)
        e2.push(s2);
      else
        for (const n3 of t4)
          e2.push(s2.child(n3));
    } else
      e2.push(s2);
  }), new zt(e2);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class xe {
  constructor(t2, e2, n2, s2, i2, r2) {
    this.key = t2, this.documentType = e2, this.version = n2, this.readTime = s2, this.data = i2, this.documentState = r2;
  }
  static newInvalidDocument(t2) {
    return new xe(t2, 0, ct.min(), ct.min(), De.empty(), 0);
  }
  static newFoundDocument(t2, e2, n2) {
    return new xe(t2, 1, e2, ct.min(), n2, 0);
  }
  static newNoDocument(t2, e2) {
    return new xe(t2, 2, e2, ct.min(), De.empty(), 0);
  }
  static newUnknownDocument(t2, e2) {
    return new xe(t2, 3, e2, ct.min(), De.empty(), 2);
  }
  convertToFoundDocument(t2, e2) {
    return this.version = t2, this.documentType = 1, this.data = e2, this.documentState = 0, this;
  }
  convertToNoDocument(t2) {
    return this.version = t2, this.documentType = 2, this.data = De.empty(), this.documentState = 0, this;
  }
  convertToUnknownDocument(t2) {
    return this.version = t2, this.documentType = 3, this.data = De.empty(), this.documentState = 2, this;
  }
  setHasCommittedMutations() {
    return this.documentState = 2, this;
  }
  setHasLocalMutations() {
    return this.documentState = 1, this.version = ct.min(), this;
  }
  setReadTime(t2) {
    return this.readTime = t2, this;
  }
  get hasLocalMutations() {
    return 1 === this.documentState;
  }
  get hasCommittedMutations() {
    return 2 === this.documentState;
  }
  get hasPendingWrites() {
    return this.hasLocalMutations || this.hasCommittedMutations;
  }
  isValidDocument() {
    return 0 !== this.documentType;
  }
  isFoundDocument() {
    return 1 === this.documentType;
  }
  isNoDocument() {
    return 2 === this.documentType;
  }
  isUnknownDocument() {
    return 3 === this.documentType;
  }
  isEqual(t2) {
    return t2 instanceof xe && this.key.isEqual(t2.key) && this.version.isEqual(t2.version) && this.documentType === t2.documentType && this.documentState === t2.documentState && this.data.isEqual(t2.data);
  }
  mutableCopy() {
    return new xe(this.key, this.documentType, this.version, this.readTime, this.data.clone(), this.documentState);
  }
  toString() {
    return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ne {
  constructor(t2, e2 = null, n2 = [], s2 = [], i2 = null, r2 = null, o2 = null) {
    this.path = t2, this.collectionGroup = e2, this.orderBy = n2, this.filters = s2, this.limit = i2, this.startAt = r2, this.endAt = o2, this.ut = null;
  }
}
function ke(t2, e2 = null, n2 = [], s2 = [], i2 = null, r2 = null, o2 = null) {
  return new Ne(t2, e2, n2, s2, i2, r2, o2);
}
function Oe(t2) {
  const e2 = K(t2);
  if (null === e2.ut) {
    let t3 = e2.path.canonicalString();
    null !== e2.collectionGroup && (t3 += "|cg:" + e2.collectionGroup), t3 += "|f:", t3 += e2.filters.map((t4) => {
      return (e3 = t4).field.canonicalString() + e3.op.toString() + me(e3.value);
      var e3;
    }).join(","), t3 += "|ob:", t3 += e2.orderBy.map((t4) => function(t5) {
      return t5.field.canonicalString() + t5.dir;
    }(t4)).join(","), oe(e2.limit) || (t3 += "|l:", t3 += e2.limit), e2.startAt && (t3 += "|lb:", t3 += e2.startAt.inclusive ? "b:" : "a:", t3 += e2.startAt.position.map((t4) => me(t4)).join(",")), e2.endAt && (t3 += "|ub:", t3 += e2.endAt.inclusive ? "a:" : "b:", t3 += e2.endAt.position.map((t4) => me(t4)).join(",")), e2.ut = t3;
  }
  return e2.ut;
}
function Me(t2) {
  let e2 = t2.path.canonicalString();
  return null !== t2.collectionGroup && (e2 += " collectionGroup=" + t2.collectionGroup), t2.filters.length > 0 && (e2 += `, filters: [${t2.filters.map((t3) => {
    return `${(e3 = t3).field.canonicalString()} ${e3.op} ${me(e3.value)}`;
    var e3;
  }).join(", ")}]`), oe(t2.limit) || (e2 += ", limit: " + t2.limit), t2.orderBy.length > 0 && (e2 += `, orderBy: [${t2.orderBy.map((t3) => function(t4) {
    return `${t4.field.canonicalString()} (${t4.dir})`;
  }(t3)).join(", ")}]`), t2.startAt && (e2 += ", startAt: ", e2 += t2.startAt.inclusive ? "b:" : "a:", e2 += t2.startAt.position.map((t3) => me(t3)).join(",")), t2.endAt && (e2 += ", endAt: ", e2 += t2.endAt.inclusive ? "a:" : "b:", e2 += t2.endAt.position.map((t3) => me(t3)).join(",")), `Target(${e2})`;
}
function Fe(t2, e2) {
  if (t2.limit !== e2.limit)
    return false;
  if (t2.orderBy.length !== e2.orderBy.length)
    return false;
  for (let n3 = 0; n3 < t2.orderBy.length; n3++)
    if (!Ze(t2.orderBy[n3], e2.orderBy[n3]))
      return false;
  if (t2.filters.length !== e2.filters.length)
    return false;
  for (let i2 = 0; i2 < t2.filters.length; i2++)
    if (n2 = t2.filters[i2], s2 = e2.filters[i2], n2.op !== s2.op || !n2.field.isEqual(s2.field) || !fe(n2.value, s2.value))
      return false;
  var n2, s2;
  return t2.collectionGroup === e2.collectionGroup && (!!t2.path.isEqual(e2.path) && (!!en(t2.startAt, e2.startAt) && en(t2.endAt, e2.endAt)));
}
function $e(t2) {
  return dt.isDocumentKey(t2.path) && null === t2.collectionGroup && 0 === t2.filters.length;
}
class qe extends class {
} {
  constructor(t2, e2, n2) {
    super(), this.field = t2, this.op = e2, this.value = n2;
  }
  static create(t2, e2, n2) {
    return t2.isKeyField() ? "in" === e2 || "not-in" === e2 ? this.ct(t2, e2, n2) : new Ke(t2, e2, n2) : "array-contains" === e2 ? new We(t2, n2) : "in" === e2 ? new ze(t2, n2) : "not-in" === e2 ? new He(t2, n2) : "array-contains-any" === e2 ? new Je(t2, n2) : new qe(t2, e2, n2);
  }
  static ct(t2, e2, n2) {
    return "in" === e2 ? new Ge(t2, n2) : new Qe(t2, n2);
  }
  matches(t2) {
    const e2 = t2.data.field(this.field);
    return "!=" === this.op ? null !== e2 && this.at(_e(e2, this.value)) : null !== e2 && le(this.value) === le(e2) && this.at(_e(e2, this.value));
  }
  at(t2) {
    switch (this.op) {
      case "<":
        return t2 < 0;
      case "<=":
        return t2 <= 0;
      case "==":
        return 0 === t2;
      case "!=":
        return 0 !== t2;
      case ">":
        return t2 > 0;
      case ">=":
        return t2 >= 0;
      default:
        return L();
    }
  }
  ht() {
    return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0;
  }
}
class Ke extends qe {
  constructor(t2, e2, n2) {
    super(t2, e2, n2), this.key = dt.fromName(n2.referenceValue);
  }
  matches(t2) {
    const e2 = dt.comparator(t2.key, this.key);
    return this.at(e2);
  }
}
class Ge extends qe {
  constructor(t2, e2) {
    super(t2, "in", e2), this.keys = je("in", e2);
  }
  matches(t2) {
    return this.keys.some((e2) => e2.isEqual(t2.key));
  }
}
class Qe extends qe {
  constructor(t2, e2) {
    super(t2, "not-in", e2), this.keys = je("not-in", e2);
  }
  matches(t2) {
    return !this.keys.some((e2) => e2.isEqual(t2.key));
  }
}
function je(t2, e2) {
  var n2;
  return ((null === (n2 = e2.arrayValue) || void 0 === n2 ? void 0 : n2.values) || []).map((t3) => dt.fromName(t3.referenceValue));
}
class We extends qe {
  constructor(t2, e2) {
    super(t2, "array-contains", e2);
  }
  matches(t2) {
    const e2 = t2.data.field(this.field);
    return Ie(e2) && de(e2.arrayValue, this.value);
  }
}
class ze extends qe {
  constructor(t2, e2) {
    super(t2, "in", e2);
  }
  matches(t2) {
    const e2 = t2.data.field(this.field);
    return null !== e2 && de(this.value.arrayValue, e2);
  }
}
class He extends qe {
  constructor(t2, e2) {
    super(t2, "not-in", e2);
  }
  matches(t2) {
    if (de(this.value.arrayValue, {
      nullValue: "NULL_VALUE"
    }))
      return false;
    const e2 = t2.data.field(this.field);
    return null !== e2 && !de(this.value.arrayValue, e2);
  }
}
class Je extends qe {
  constructor(t2, e2) {
    super(t2, "array-contains-any", e2);
  }
  matches(t2) {
    const e2 = t2.data.field(this.field);
    return !(!Ie(e2) || !e2.arrayValue.values) && e2.arrayValue.values.some((t3) => de(this.value.arrayValue, t3));
  }
}
class Ye {
  constructor(t2, e2) {
    this.position = t2, this.inclusive = e2;
  }
}
class Xe {
  constructor(t2, e2 = "asc") {
    this.field = t2, this.dir = e2;
  }
}
function Ze(t2, e2) {
  return t2.dir === e2.dir && t2.field.isEqual(e2.field);
}
function tn(t2, e2, n2) {
  let s2 = 0;
  for (let i2 = 0; i2 < t2.position.length; i2++) {
    const r2 = e2[i2], o2 = t2.position[i2];
    if (r2.field.isKeyField())
      s2 = dt.comparator(dt.fromName(o2.referenceValue), n2.key);
    else {
      s2 = _e(o2, n2.data.field(r2.field));
    }
    if ("desc" === r2.dir && (s2 *= -1), 0 !== s2)
      break;
  }
  return s2;
}
function en(t2, e2) {
  if (null === t2)
    return null === e2;
  if (null === e2)
    return false;
  if (t2.inclusive !== e2.inclusive || t2.position.length !== e2.position.length)
    return false;
  for (let n2 = 0; n2 < t2.position.length; n2++) {
    if (!fe(t2.position[n2], e2.position[n2]))
      return false;
  }
  return true;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class nn {
  constructor(t2, e2 = null, n2 = [], s2 = [], i2 = null, r2 = "F", o2 = null, u2 = null) {
    this.path = t2, this.collectionGroup = e2, this.explicitOrderBy = n2, this.filters = s2, this.limit = i2, this.limitType = r2, this.startAt = o2, this.endAt = u2, this.lt = null, this.ft = null, this.startAt, this.endAt;
  }
}
function sn(t2, e2, n2, s2, i2, r2, o2, u2) {
  return new nn(t2, e2, n2, s2, i2, r2, o2, u2);
}
function rn(t2) {
  return new nn(t2);
}
function on(t2) {
  return 0 === t2.filters.length && null === t2.limit && null == t2.startAt && null == t2.endAt && (0 === t2.explicitOrderBy.length || 1 === t2.explicitOrderBy.length && t2.explicitOrderBy[0].field.isKeyField());
}
function un(t2) {
  return t2.explicitOrderBy.length > 0 ? t2.explicitOrderBy[0].field : null;
}
function cn(t2) {
  for (const e2 of t2.filters)
    if (e2.ht())
      return e2.field;
  return null;
}
function an(t2) {
  return null !== t2.collectionGroup;
}
function hn(t2) {
  const e2 = K(t2);
  if (null === e2.lt) {
    e2.lt = [];
    const t3 = cn(e2), n2 = un(e2);
    if (null !== t3 && null === n2)
      t3.isKeyField() || e2.lt.push(new Xe(t3)), e2.lt.push(new Xe(ft.keyField(), "asc"));
    else {
      let t4 = false;
      for (const n3 of e2.explicitOrderBy)
        e2.lt.push(n3), n3.field.isKeyField() && (t4 = true);
      if (!t4) {
        const t5 = e2.explicitOrderBy.length > 0 ? e2.explicitOrderBy[e2.explicitOrderBy.length - 1].dir : "asc";
        e2.lt.push(new Xe(ft.keyField(), t5));
      }
    }
  }
  return e2.lt;
}
function ln(t2) {
  const e2 = K(t2);
  if (!e2.ft)
    if ("F" === e2.limitType)
      e2.ft = ke(e2.path, e2.collectionGroup, hn(e2), e2.filters, e2.limit, e2.startAt, e2.endAt);
    else {
      const t3 = [];
      for (const n3 of hn(e2)) {
        const e3 = "desc" === n3.dir ? "asc" : "desc";
        t3.push(new Xe(n3.field, e3));
      }
      const n2 = e2.endAt ? new Ye(e2.endAt.position, e2.endAt.inclusive) : null, s2 = e2.startAt ? new Ye(e2.startAt.position, e2.startAt.inclusive) : null;
      e2.ft = ke(e2.path, e2.collectionGroup, t3, e2.filters, e2.limit, n2, s2);
    }
  return e2.ft;
}
function fn(t2, e2, n2) {
  return new nn(t2.path, t2.collectionGroup, t2.explicitOrderBy.slice(), t2.filters.slice(), e2, n2, t2.startAt, t2.endAt);
}
function dn(t2, e2) {
  return Fe(ln(t2), ln(e2)) && t2.limitType === e2.limitType;
}
function _n(t2) {
  return `${Oe(ln(t2))}|lt:${t2.limitType}`;
}
function wn(t2) {
  return `Query(target=${Me(ln(t2))}; limitType=${t2.limitType})`;
}
function mn(t2, e2) {
  return e2.isFoundDocument() && function(t3, e3) {
    const n2 = e3.key.path;
    return null !== t3.collectionGroup ? e3.key.hasCollectionId(t3.collectionGroup) && t3.path.isPrefixOf(n2) : dt.isDocumentKey(t3.path) ? t3.path.isEqual(n2) : t3.path.isImmediateParentOf(n2);
  }(t2, e2) && function(t3, e3) {
    for (const n2 of t3.explicitOrderBy)
      if (!n2.field.isKeyField() && null === e3.data.field(n2.field))
        return false;
    return true;
  }(t2, e2) && function(t3, e3) {
    for (const n2 of t3.filters)
      if (!n2.matches(e3))
        return false;
    return true;
  }(t2, e2) && function(t3, e3) {
    if (t3.startAt && !function(t4, e4, n2) {
      const s2 = tn(t4, e4, n2);
      return t4.inclusive ? s2 <= 0 : s2 < 0;
    }(t3.startAt, hn(t3), e3))
      return false;
    if (t3.endAt && !function(t4, e4, n2) {
      const s2 = tn(t4, e4, n2);
      return t4.inclusive ? s2 >= 0 : s2 > 0;
    }(t3.endAt, hn(t3), e3))
      return false;
    return true;
  }(t2, e2);
}
function gn(t2) {
  return t2.collectionGroup || (t2.path.length % 2 == 1 ? t2.path.lastSegment() : t2.path.get(t2.path.length - 2));
}
function yn(t2) {
  return (e2, n2) => {
    let s2 = false;
    for (const i2 of hn(t2)) {
      const t3 = pn(i2, e2, n2);
      if (0 !== t3)
        return t3;
      s2 = s2 || i2.field.isKeyField();
    }
    return 0;
  };
}
function pn(t2, e2, n2) {
  const s2 = t2.field.isKeyField() ? dt.comparator(e2.key, n2.key) : function(t3, e3, n3) {
    const s3 = e3.data.field(t3), i2 = n3.data.field(t3);
    return null !== s3 && null !== i2 ? _e(s3, i2) : L();
  }(t2.field, e2, n2);
  switch (t2.dir) {
    case "asc":
      return s2;
    case "desc":
      return -1 * s2;
    default:
      return L();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function In(t2, e2) {
  if (t2.dt) {
    if (isNaN(e2))
      return {
        doubleValue: "NaN"
      };
    if (e2 === 1 / 0)
      return {
        doubleValue: "Infinity"
      };
    if (e2 === -1 / 0)
      return {
        doubleValue: "-Infinity"
      };
  }
  return {
    doubleValue: ue(e2) ? "-0" : e2
  };
}
function Tn(t2) {
  return {
    integerValue: "" + t2
  };
}
function En(t2, e2) {
  return ce(e2) ? Tn(e2) : In(t2, e2);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class An {
  constructor() {
    this._ = void 0;
  }
}
function Rn(t2, e2, n2) {
  return t2 instanceof vn ? function(t3, e3) {
    const n3 = {
      fields: {
        __type__: {
          stringValue: "server_timestamp"
        },
        __local_write_time__: {
          timestampValue: {
            seconds: t3.seconds,
            nanos: t3.nanoseconds
          }
        }
      }
    };
    return e3 && (n3.fields.__previous_value__ = e3), {
      mapValue: n3
    };
  }(n2, e2) : t2 instanceof Vn ? Sn(t2, e2) : t2 instanceof Dn ? Cn(t2, e2) : function(t3, e3) {
    const n3 = Pn(t3, e3), s2 = Nn(n3) + Nn(t3._t);
    return pe(n3) && pe(t3._t) ? Tn(s2) : In(t3.wt, s2);
  }(t2, e2);
}
function bn(t2, e2, n2) {
  return t2 instanceof Vn ? Sn(t2, e2) : t2 instanceof Dn ? Cn(t2, e2) : n2;
}
function Pn(t2, e2) {
  return t2 instanceof xn ? pe(n2 = e2) || function(t3) {
    return !!t3 && "doubleValue" in t3;
  }(n2) ? e2 : {
    integerValue: 0
  } : null;
  var n2;
}
class vn extends An {
}
class Vn extends An {
  constructor(t2) {
    super(), this.elements = t2;
  }
}
function Sn(t2, e2) {
  const n2 = kn(e2);
  for (const e3 of t2.elements)
    n2.some((t3) => fe(t3, e3)) || n2.push(e3);
  return {
    arrayValue: {
      values: n2
    }
  };
}
class Dn extends An {
  constructor(t2) {
    super(), this.elements = t2;
  }
}
function Cn(t2, e2) {
  let n2 = kn(e2);
  for (const e3 of t2.elements)
    n2 = n2.filter((t3) => !fe(t3, e3));
  return {
    arrayValue: {
      values: n2
    }
  };
}
class xn extends An {
  constructor(t2, e2) {
    super(), this.wt = t2, this._t = e2;
  }
}
function Nn(t2) {
  return Zt(t2.integerValue || t2.doubleValue);
}
function kn(t2) {
  return Ie(t2) && t2.arrayValue.values ? t2.arrayValue.values.slice() : [];
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class On {
  constructor(t2, e2) {
    this.field = t2, this.transform = e2;
  }
}
function Mn(t2, e2) {
  return t2.field.isEqual(e2.field) && function(t3, e3) {
    return t3 instanceof Vn && e3 instanceof Vn || t3 instanceof Dn && e3 instanceof Dn ? rt(t3.elements, e3.elements, fe) : t3 instanceof xn && e3 instanceof xn ? fe(t3._t, e3._t) : t3 instanceof vn && e3 instanceof vn;
  }(t2.transform, e2.transform);
}
class Fn {
  constructor(t2, e2) {
    this.version = t2, this.transformResults = e2;
  }
}
class $n {
  constructor(t2, e2) {
    this.updateTime = t2, this.exists = e2;
  }
  static none() {
    return new $n();
  }
  static exists(t2) {
    return new $n(void 0, t2);
  }
  static updateTime(t2) {
    return new $n(t2);
  }
  get isNone() {
    return void 0 === this.updateTime && void 0 === this.exists;
  }
  isEqual(t2) {
    return this.exists === t2.exists && (this.updateTime ? !!t2.updateTime && this.updateTime.isEqual(t2.updateTime) : !t2.updateTime);
  }
}
function Bn(t2, e2) {
  return void 0 !== t2.updateTime ? e2.isFoundDocument() && e2.version.isEqual(t2.updateTime) : void 0 === t2.exists || t2.exists === e2.isFoundDocument();
}
class Ln {
}
function Un(t2, e2) {
  if (!t2.hasLocalMutations || e2 && 0 === e2.fields.length)
    return null;
  if (null === e2)
    return t2.isNoDocument() ? new Yn(t2.key, $n.none()) : new jn(t2.key, t2.data, $n.none());
  {
    const n2 = t2.data, s2 = De.empty();
    let i2 = new Qt(ft.comparator);
    for (let t3 of e2.fields)
      if (!i2.has(t3)) {
        let e3 = n2.field(t3);
        null === e3 && t3.length > 1 && (t3 = t3.popLast(), e3 = n2.field(t3)), null === e3 ? s2.delete(t3) : s2.set(t3, e3), i2 = i2.add(t3);
      }
    return new Wn(t2.key, s2, new zt(i2.toArray()), $n.none());
  }
}
function qn(t2, e2, n2) {
  t2 instanceof jn ? function(t3, e3, n3) {
    const s2 = t3.value.clone(), i2 = Hn(t3.fieldTransforms, e3, n3.transformResults);
    s2.setAll(i2), e3.convertToFoundDocument(n3.version, s2).setHasCommittedMutations();
  }(t2, e2, n2) : t2 instanceof Wn ? function(t3, e3, n3) {
    if (!Bn(t3.precondition, e3))
      return void e3.convertToUnknownDocument(n3.version);
    const s2 = Hn(t3.fieldTransforms, e3, n3.transformResults), i2 = e3.data;
    i2.setAll(zn(t3)), i2.setAll(s2), e3.convertToFoundDocument(n3.version, i2).setHasCommittedMutations();
  }(t2, e2, n2) : function(t3, e3, n3) {
    e3.convertToNoDocument(n3.version).setHasCommittedMutations();
  }(0, e2, n2);
}
function Kn(t2, e2, n2, s2) {
  return t2 instanceof jn ? function(t3, e3, n3, s3) {
    if (!Bn(t3.precondition, e3))
      return n3;
    const i2 = t3.value.clone(), r2 = Jn(t3.fieldTransforms, s3, e3);
    return i2.setAll(r2), e3.convertToFoundDocument(e3.version, i2).setHasLocalMutations(), null;
  }(t2, e2, n2, s2) : t2 instanceof Wn ? function(t3, e3, n3, s3) {
    if (!Bn(t3.precondition, e3))
      return n3;
    const i2 = Jn(t3.fieldTransforms, s3, e3), r2 = e3.data;
    if (r2.setAll(zn(t3)), r2.setAll(i2), e3.convertToFoundDocument(e3.version, r2).setHasLocalMutations(), null === n3)
      return null;
    return n3.unionWith(t3.fieldMask.fields).unionWith(t3.fieldTransforms.map((t4) => t4.field));
  }(t2, e2, n2, s2) : function(t3, e3, n3) {
    if (Bn(t3.precondition, e3))
      return e3.convertToNoDocument(e3.version).setHasLocalMutations(), null;
    return n3;
  }(t2, e2, n2);
}
function Gn(t2, e2) {
  let n2 = null;
  for (const s2 of t2.fieldTransforms) {
    const t3 = e2.data.field(s2.field), i2 = Pn(s2.transform, t3 || null);
    null != i2 && (null === n2 && (n2 = De.empty()), n2.set(s2.field, i2));
  }
  return n2 || null;
}
function Qn(t2, e2) {
  return t2.type === e2.type && (!!t2.key.isEqual(e2.key) && (!!t2.precondition.isEqual(e2.precondition) && (!!function(t3, e3) {
    return void 0 === t3 && void 0 === e3 || !(!t3 || !e3) && rt(t3, e3, (t4, e4) => Mn(t4, e4));
  }(t2.fieldTransforms, e2.fieldTransforms) && (0 === t2.type ? t2.value.isEqual(e2.value) : 1 !== t2.type || t2.data.isEqual(e2.data) && t2.fieldMask.isEqual(e2.fieldMask)))));
}
class jn extends Ln {
  constructor(t2, e2, n2, s2 = []) {
    super(), this.key = t2, this.value = e2, this.precondition = n2, this.fieldTransforms = s2, this.type = 0;
  }
  getFieldMask() {
    return null;
  }
}
class Wn extends Ln {
  constructor(t2, e2, n2, s2, i2 = []) {
    super(), this.key = t2, this.data = e2, this.fieldMask = n2, this.precondition = s2, this.fieldTransforms = i2, this.type = 1;
  }
  getFieldMask() {
    return this.fieldMask;
  }
}
function zn(t2) {
  const e2 = /* @__PURE__ */ new Map();
  return t2.fieldMask.fields.forEach((n2) => {
    if (!n2.isEmpty()) {
      const s2 = t2.data.field(n2);
      e2.set(n2, s2);
    }
  }), e2;
}
function Hn(t2, e2, n2) {
  const s2 = /* @__PURE__ */ new Map();
  U(t2.length === n2.length);
  for (let i2 = 0; i2 < n2.length; i2++) {
    const r2 = t2[i2], o2 = r2.transform, u2 = e2.data.field(r2.field);
    s2.set(r2.field, bn(o2, u2, n2[i2]));
  }
  return s2;
}
function Jn(t2, e2, n2) {
  const s2 = /* @__PURE__ */ new Map();
  for (const i2 of t2) {
    const t3 = i2.transform, r2 = n2.data.field(i2.field);
    s2.set(i2.field, Rn(t3, r2, e2));
  }
  return s2;
}
class Yn extends Ln {
  constructor(t2, e2) {
    super(), this.key = t2, this.precondition = e2, this.type = 2, this.fieldTransforms = [];
  }
  getFieldMask() {
    return null;
  }
}
class Xn extends Ln {
  constructor(t2, e2) {
    super(), this.key = t2, this.precondition = e2, this.type = 3, this.fieldTransforms = [];
  }
  getFieldMask() {
    return null;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Zn {
  constructor(t2) {
    this.count = t2;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ts, es;
function ns(t2) {
  switch (t2) {
    default:
      return L();
    case G.CANCELLED:
    case G.UNKNOWN:
    case G.DEADLINE_EXCEEDED:
    case G.RESOURCE_EXHAUSTED:
    case G.INTERNAL:
    case G.UNAVAILABLE:
    case G.UNAUTHENTICATED:
      return false;
    case G.INVALID_ARGUMENT:
    case G.NOT_FOUND:
    case G.ALREADY_EXISTS:
    case G.PERMISSION_DENIED:
    case G.FAILED_PRECONDITION:
    case G.ABORTED:
    case G.OUT_OF_RANGE:
    case G.UNIMPLEMENTED:
    case G.DATA_LOSS:
      return true;
  }
}
function ss(t2) {
  if (void 0 === t2)
    return F("GRPC error has no .code"), G.UNKNOWN;
  switch (t2) {
    case ts.OK:
      return G.OK;
    case ts.CANCELLED:
      return G.CANCELLED;
    case ts.UNKNOWN:
      return G.UNKNOWN;
    case ts.DEADLINE_EXCEEDED:
      return G.DEADLINE_EXCEEDED;
    case ts.RESOURCE_EXHAUSTED:
      return G.RESOURCE_EXHAUSTED;
    case ts.INTERNAL:
      return G.INTERNAL;
    case ts.UNAVAILABLE:
      return G.UNAVAILABLE;
    case ts.UNAUTHENTICATED:
      return G.UNAUTHENTICATED;
    case ts.INVALID_ARGUMENT:
      return G.INVALID_ARGUMENT;
    case ts.NOT_FOUND:
      return G.NOT_FOUND;
    case ts.ALREADY_EXISTS:
      return G.ALREADY_EXISTS;
    case ts.PERMISSION_DENIED:
      return G.PERMISSION_DENIED;
    case ts.FAILED_PRECONDITION:
      return G.FAILED_PRECONDITION;
    case ts.ABORTED:
      return G.ABORTED;
    case ts.OUT_OF_RANGE:
      return G.OUT_OF_RANGE;
    case ts.UNIMPLEMENTED:
      return G.UNIMPLEMENTED;
    case ts.DATA_LOSS:
      return G.DATA_LOSS;
    default:
      return L();
  }
}
(es = ts || (ts = {}))[es.OK = 0] = "OK", es[es.CANCELLED = 1] = "CANCELLED", es[es.UNKNOWN = 2] = "UNKNOWN", es[es.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", es[es.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", es[es.NOT_FOUND = 5] = "NOT_FOUND", es[es.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", es[es.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", es[es.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", es[es.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", es[es.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", es[es.ABORTED = 10] = "ABORTED", es[es.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", es[es.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", es[es.INTERNAL = 13] = "INTERNAL", es[es.UNAVAILABLE = 14] = "UNAVAILABLE", es[es.DATA_LOSS = 15] = "DATA_LOSS";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class is {
  constructor(t2, e2) {
    this.mapKeyFn = t2, this.equalsFn = e2, this.inner = {}, this.innerSize = 0;
  }
  get(t2) {
    const e2 = this.mapKeyFn(t2), n2 = this.inner[e2];
    if (void 0 !== n2) {
      for (const [e3, s2] of n2)
        if (this.equalsFn(e3, t2))
          return s2;
    }
  }
  has(t2) {
    return void 0 !== this.get(t2);
  }
  set(t2, e2) {
    const n2 = this.mapKeyFn(t2), s2 = this.inner[n2];
    if (void 0 === s2)
      return this.inner[n2] = [[t2, e2]], void this.innerSize++;
    for (let n3 = 0; n3 < s2.length; n3++)
      if (this.equalsFn(s2[n3][0], t2))
        return void (s2[n3] = [t2, e2]);
    s2.push([t2, e2]), this.innerSize++;
  }
  delete(t2) {
    const e2 = this.mapKeyFn(t2), n2 = this.inner[e2];
    if (void 0 === n2)
      return false;
    for (let s2 = 0; s2 < n2.length; s2++)
      if (this.equalsFn(n2[s2][0], t2))
        return 1 === n2.length ? delete this.inner[e2] : n2.splice(s2, 1), this.innerSize--, true;
    return false;
  }
  forEach(t2) {
    Lt(this.inner, (e2, n2) => {
      for (const [e3, s2] of n2)
        t2(e3, s2);
    });
  }
  isEmpty() {
    return Ut(this.inner);
  }
  size() {
    return this.innerSize;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const rs = new qt(dt.comparator);
function os() {
  return rs;
}
const us = new qt(dt.comparator);
function cs(...t2) {
  let e2 = us;
  for (const n2 of t2)
    e2 = e2.insert(n2.key, n2);
  return e2;
}
function as(t2) {
  let e2 = us;
  return t2.forEach((t3, n2) => e2 = e2.insert(t3, n2.overlayedDocument)), e2;
}
function hs() {
  return fs();
}
function ls() {
  return fs();
}
function fs() {
  return new is((t2) => t2.toString(), (t2, e2) => t2.isEqual(e2));
}
const ds = new qt(dt.comparator);
const _s = new Qt(dt.comparator);
function ws(...t2) {
  let e2 = _s;
  for (const n2 of t2)
    e2 = e2.add(n2);
  return e2;
}
const ms = new Qt(it);
function gs() {
  return ms;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ys {
  constructor(t2, e2, n2, s2, i2) {
    this.snapshotVersion = t2, this.targetChanges = e2, this.targetMismatches = n2, this.documentUpdates = s2, this.resolvedLimboDocuments = i2;
  }
  static createSynthesizedRemoteEventForCurrentChange(t2, e2) {
    const n2 = /* @__PURE__ */ new Map();
    return n2.set(t2, ps.createSynthesizedTargetChangeForCurrentChange(t2, e2)), new ys(ct.min(), n2, gs(), os(), ws());
  }
}
class ps {
  constructor(t2, e2, n2, s2, i2) {
    this.resumeToken = t2, this.current = e2, this.addedDocuments = n2, this.modifiedDocuments = s2, this.removedDocuments = i2;
  }
  static createSynthesizedTargetChangeForCurrentChange(t2, e2) {
    return new ps(Jt.EMPTY_BYTE_STRING, e2, ws(), ws(), ws());
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Is {
  constructor(t2, e2, n2, s2) {
    this.gt = t2, this.removedTargetIds = e2, this.key = n2, this.yt = s2;
  }
}
class Ts {
  constructor(t2, e2) {
    this.targetId = t2, this.It = e2;
  }
}
class Es {
  constructor(t2, e2, n2 = Jt.EMPTY_BYTE_STRING, s2 = null) {
    this.state = t2, this.targetIds = e2, this.resumeToken = n2, this.cause = s2;
  }
}
class As {
  constructor() {
    this.Tt = 0, this.Et = Ps(), this.At = Jt.EMPTY_BYTE_STRING, this.Rt = false, this.bt = true;
  }
  get current() {
    return this.Rt;
  }
  get resumeToken() {
    return this.At;
  }
  get Pt() {
    return 0 !== this.Tt;
  }
  get vt() {
    return this.bt;
  }
  Vt(t2) {
    t2.approximateByteSize() > 0 && (this.bt = true, this.At = t2);
  }
  St() {
    let t2 = ws(), e2 = ws(), n2 = ws();
    return this.Et.forEach((s2, i2) => {
      switch (i2) {
        case 0:
          t2 = t2.add(s2);
          break;
        case 2:
          e2 = e2.add(s2);
          break;
        case 1:
          n2 = n2.add(s2);
          break;
        default:
          L();
      }
    }), new ps(this.At, this.Rt, t2, e2, n2);
  }
  Dt() {
    this.bt = false, this.Et = Ps();
  }
  Ct(t2, e2) {
    this.bt = true, this.Et = this.Et.insert(t2, e2);
  }
  xt(t2) {
    this.bt = true, this.Et = this.Et.remove(t2);
  }
  Nt() {
    this.Tt += 1;
  }
  kt() {
    this.Tt -= 1;
  }
  Ot() {
    this.bt = true, this.Rt = true;
  }
}
class Rs {
  constructor(t2) {
    this.Mt = t2, this.Ft = /* @__PURE__ */ new Map(), this.$t = os(), this.Bt = bs(), this.Lt = new Qt(it);
  }
  Ut(t2) {
    for (const e2 of t2.gt)
      t2.yt && t2.yt.isFoundDocument() ? this.qt(e2, t2.yt) : this.Kt(e2, t2.key, t2.yt);
    for (const e2 of t2.removedTargetIds)
      this.Kt(e2, t2.key, t2.yt);
  }
  Gt(t2) {
    this.forEachTarget(t2, (e2) => {
      const n2 = this.Qt(e2);
      switch (t2.state) {
        case 0:
          this.jt(e2) && n2.Vt(t2.resumeToken);
          break;
        case 1:
          n2.kt(), n2.Pt || n2.Dt(), n2.Vt(t2.resumeToken);
          break;
        case 2:
          n2.kt(), n2.Pt || this.removeTarget(e2);
          break;
        case 3:
          this.jt(e2) && (n2.Ot(), n2.Vt(t2.resumeToken));
          break;
        case 4:
          this.jt(e2) && (this.Wt(e2), n2.Vt(t2.resumeToken));
          break;
        default:
          L();
      }
    });
  }
  forEachTarget(t2, e2) {
    t2.targetIds.length > 0 ? t2.targetIds.forEach(e2) : this.Ft.forEach((t3, n2) => {
      this.jt(n2) && e2(n2);
    });
  }
  zt(t2) {
    const e2 = t2.targetId, n2 = t2.It.count, s2 = this.Ht(e2);
    if (s2) {
      const t3 = s2.target;
      if ($e(t3))
        if (0 === n2) {
          const n3 = new dt(t3.path);
          this.Kt(e2, n3, xe.newNoDocument(n3, ct.min()));
        } else
          U(1 === n2);
      else {
        this.Jt(e2) !== n2 && (this.Wt(e2), this.Lt = this.Lt.add(e2));
      }
    }
  }
  Yt(t2) {
    const e2 = /* @__PURE__ */ new Map();
    this.Ft.forEach((n3, s3) => {
      const i2 = this.Ht(s3);
      if (i2) {
        if (n3.current && $e(i2.target)) {
          const e3 = new dt(i2.target.path);
          null !== this.$t.get(e3) || this.Xt(s3, e3) || this.Kt(s3, e3, xe.newNoDocument(e3, t2));
        }
        n3.vt && (e2.set(s3, n3.St()), n3.Dt());
      }
    });
    let n2 = ws();
    this.Bt.forEach((t3, e3) => {
      let s3 = true;
      e3.forEachWhile((t4) => {
        const e4 = this.Ht(t4);
        return !e4 || 2 === e4.purpose || (s3 = false, false);
      }), s3 && (n2 = n2.add(t3));
    }), this.$t.forEach((e3, n3) => n3.setReadTime(t2));
    const s2 = new ys(t2, e2, this.Lt, this.$t, n2);
    return this.$t = os(), this.Bt = bs(), this.Lt = new Qt(it), s2;
  }
  qt(t2, e2) {
    if (!this.jt(t2))
      return;
    const n2 = this.Xt(t2, e2.key) ? 2 : 0;
    this.Qt(t2).Ct(e2.key, n2), this.$t = this.$t.insert(e2.key, e2), this.Bt = this.Bt.insert(e2.key, this.Zt(e2.key).add(t2));
  }
  Kt(t2, e2, n2) {
    if (!this.jt(t2))
      return;
    const s2 = this.Qt(t2);
    this.Xt(t2, e2) ? s2.Ct(e2, 1) : s2.xt(e2), this.Bt = this.Bt.insert(e2, this.Zt(e2).delete(t2)), n2 && (this.$t = this.$t.insert(e2, n2));
  }
  removeTarget(t2) {
    this.Ft.delete(t2);
  }
  Jt(t2) {
    const e2 = this.Qt(t2).St();
    return this.Mt.getRemoteKeysForTarget(t2).size + e2.addedDocuments.size - e2.removedDocuments.size;
  }
  Nt(t2) {
    this.Qt(t2).Nt();
  }
  Qt(t2) {
    let e2 = this.Ft.get(t2);
    return e2 || (e2 = new As(), this.Ft.set(t2, e2)), e2;
  }
  Zt(t2) {
    let e2 = this.Bt.get(t2);
    return e2 || (e2 = new Qt(it), this.Bt = this.Bt.insert(t2, e2)), e2;
  }
  jt(t2) {
    const e2 = null !== this.Ht(t2);
    return e2 || M("WatchChangeAggregator", "Detected inactive target", t2), e2;
  }
  Ht(t2) {
    const e2 = this.Ft.get(t2);
    return e2 && e2.Pt ? null : this.Mt.te(t2);
  }
  Wt(t2) {
    this.Ft.set(t2, new As());
    this.Mt.getRemoteKeysForTarget(t2).forEach((e2) => {
      this.Kt(t2, e2, null);
    });
  }
  Xt(t2, e2) {
    return this.Mt.getRemoteKeysForTarget(t2).has(e2);
  }
}
function bs() {
  return new qt(dt.comparator);
}
function Ps() {
  return new qt(dt.comparator);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const vs = (() => {
  const t2 = {
    asc: "ASCENDING",
    desc: "DESCENDING"
  };
  return t2;
})(), Vs = (() => {
  const t2 = {
    "<": "LESS_THAN",
    "<=": "LESS_THAN_OR_EQUAL",
    ">": "GREATER_THAN",
    ">=": "GREATER_THAN_OR_EQUAL",
    "==": "EQUAL",
    "!=": "NOT_EQUAL",
    "array-contains": "ARRAY_CONTAINS",
    in: "IN",
    "not-in": "NOT_IN",
    "array-contains-any": "ARRAY_CONTAINS_ANY"
  };
  return t2;
})();
class Ss {
  constructor(t2, e2) {
    this.databaseId = t2, this.dt = e2;
  }
}
function Ds(t2, e2) {
  if (t2.dt) {
    return `${new Date(1e3 * e2.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + e2.nanoseconds).slice(-9)}Z`;
  }
  return {
    seconds: "" + e2.seconds,
    nanos: e2.nanoseconds
  };
}
function Cs(t2, e2) {
  return t2.dt ? e2.toBase64() : e2.toUint8Array();
}
function xs(t2, e2) {
  return Ds(t2, e2.toTimestamp());
}
function Ns(t2) {
  return U(!!t2), ct.fromTimestamp(function(t3) {
    const e2 = Xt(t3);
    return new ut(e2.seconds, e2.nanos);
  }(t2));
}
function ks(t2, e2) {
  return function(t3) {
    return new ht(["projects", t3.projectId, "databases", t3.database]);
  }(t2).child("documents").child(e2).canonicalString();
}
function Os(t2) {
  const e2 = ht.fromString(t2);
  return U(ui(e2)), e2;
}
function Ms(t2, e2) {
  return ks(t2.databaseId, e2.path);
}
function Fs(t2, e2) {
  const n2 = Os(e2);
  if (n2.get(1) !== t2.databaseId.projectId)
    throw new Q(G.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + n2.get(1) + " vs " + t2.databaseId.projectId);
  if (n2.get(3) !== t2.databaseId.database)
    throw new Q(G.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + n2.get(3) + " vs " + t2.databaseId.database);
  return new dt(Us(n2));
}
function $s(t2, e2) {
  return ks(t2.databaseId, e2);
}
function Bs(t2) {
  const e2 = Os(t2);
  return 4 === e2.length ? ht.emptyPath() : Us(e2);
}
function Ls(t2) {
  return new ht(["projects", t2.databaseId.projectId, "databases", t2.databaseId.database]).canonicalString();
}
function Us(t2) {
  return U(t2.length > 4 && "documents" === t2.get(4)), t2.popFirst(5);
}
function qs(t2, e2, n2) {
  return {
    name: Ms(t2, e2),
    fields: n2.value.mapValue.fields
  };
}
function Qs(t2, e2) {
  let n2;
  if ("targetChange" in e2) {
    e2.targetChange;
    const s2 = function(t3) {
      return "NO_CHANGE" === t3 ? 0 : "ADD" === t3 ? 1 : "REMOVE" === t3 ? 2 : "CURRENT" === t3 ? 3 : "RESET" === t3 ? 4 : L();
    }(e2.targetChange.targetChangeType || "NO_CHANGE"), i2 = e2.targetChange.targetIds || [], r2 = function(t3, e3) {
      return t3.dt ? (U(void 0 === e3 || "string" == typeof e3), Jt.fromBase64String(e3 || "")) : (U(void 0 === e3 || e3 instanceof Uint8Array), Jt.fromUint8Array(e3 || new Uint8Array()));
    }(t2, e2.targetChange.resumeToken), o2 = e2.targetChange.cause, u2 = o2 && function(t3) {
      const e3 = void 0 === t3.code ? G.UNKNOWN : ss(t3.code);
      return new Q(e3, t3.message || "");
    }(o2);
    n2 = new Es(s2, i2, r2, u2 || null);
  } else if ("documentChange" in e2) {
    e2.documentChange;
    const s2 = e2.documentChange;
    s2.document, s2.document.name, s2.document.updateTime;
    const i2 = Fs(t2, s2.document.name), r2 = Ns(s2.document.updateTime), o2 = new De({
      mapValue: {
        fields: s2.document.fields
      }
    }), u2 = xe.newFoundDocument(i2, r2, o2), c2 = s2.targetIds || [], a2 = s2.removedTargetIds || [];
    n2 = new Is(c2, a2, u2.key, u2);
  } else if ("documentDelete" in e2) {
    e2.documentDelete;
    const s2 = e2.documentDelete;
    s2.document;
    const i2 = Fs(t2, s2.document), r2 = s2.readTime ? Ns(s2.readTime) : ct.min(), o2 = xe.newNoDocument(i2, r2), u2 = s2.removedTargetIds || [];
    n2 = new Is([], u2, o2.key, o2);
  } else if ("documentRemove" in e2) {
    e2.documentRemove;
    const s2 = e2.documentRemove;
    s2.document;
    const i2 = Fs(t2, s2.document), r2 = s2.removedTargetIds || [];
    n2 = new Is([], r2, i2, null);
  } else {
    if (!("filter" in e2))
      return L();
    {
      e2.filter;
      const t3 = e2.filter;
      t3.targetId;
      const s2 = t3.count || 0, i2 = new Zn(s2), r2 = t3.targetId;
      n2 = new Ts(r2, i2);
    }
  }
  return n2;
}
function js(t2, e2) {
  let n2;
  if (e2 instanceof jn)
    n2 = {
      update: qs(t2, e2.key, e2.value)
    };
  else if (e2 instanceof Yn)
    n2 = {
      delete: Ms(t2, e2.key)
    };
  else if (e2 instanceof Wn)
    n2 = {
      update: qs(t2, e2.key, e2.data),
      updateMask: oi(e2.fieldMask)
    };
  else {
    if (!(e2 instanceof Xn))
      return L();
    n2 = {
      verify: Ms(t2, e2.key)
    };
  }
  return e2.fieldTransforms.length > 0 && (n2.updateTransforms = e2.fieldTransforms.map((t3) => function(t4, e3) {
    const n3 = e3.transform;
    if (n3 instanceof vn)
      return {
        fieldPath: e3.field.canonicalString(),
        setToServerValue: "REQUEST_TIME"
      };
    if (n3 instanceof Vn)
      return {
        fieldPath: e3.field.canonicalString(),
        appendMissingElements: {
          values: n3.elements
        }
      };
    if (n3 instanceof Dn)
      return {
        fieldPath: e3.field.canonicalString(),
        removeAllFromArray: {
          values: n3.elements
        }
      };
    if (n3 instanceof xn)
      return {
        fieldPath: e3.field.canonicalString(),
        increment: n3._t
      };
    throw L();
  }(0, t3))), e2.precondition.isNone || (n2.currentDocument = function(t3, e3) {
    return void 0 !== e3.updateTime ? {
      updateTime: xs(t3, e3.updateTime)
    } : void 0 !== e3.exists ? {
      exists: e3.exists
    } : L();
  }(t2, e2.precondition)), n2;
}
function zs(t2, e2) {
  return t2 && t2.length > 0 ? (U(void 0 !== e2), t2.map((t3) => function(t4, e3) {
    let n2 = t4.updateTime ? Ns(t4.updateTime) : Ns(e3);
    return n2.isEqual(ct.min()) && (n2 = Ns(e3)), new Fn(n2, t4.transformResults || []);
  }(t3, e2))) : [];
}
function Hs(t2, e2) {
  return {
    documents: [$s(t2, e2.path)]
  };
}
function Js(t2, e2) {
  const n2 = {
    structuredQuery: {}
  }, s2 = e2.path;
  null !== e2.collectionGroup ? (n2.parent = $s(t2, s2), n2.structuredQuery.from = [{
    collectionId: e2.collectionGroup,
    allDescendants: true
  }]) : (n2.parent = $s(t2, s2.popLast()), n2.structuredQuery.from = [{
    collectionId: s2.lastSegment()
  }]);
  const i2 = function(t3) {
    if (0 === t3.length)
      return;
    const e3 = t3.map((t4) => function(t5) {
      if ("==" === t5.op) {
        if (Ee(t5.value))
          return {
            unaryFilter: {
              field: ni(t5.field),
              op: "IS_NAN"
            }
          };
        if (Te(t5.value))
          return {
            unaryFilter: {
              field: ni(t5.field),
              op: "IS_NULL"
            }
          };
      } else if ("!=" === t5.op) {
        if (Ee(t5.value))
          return {
            unaryFilter: {
              field: ni(t5.field),
              op: "IS_NOT_NAN"
            }
          };
        if (Te(t5.value))
          return {
            unaryFilter: {
              field: ni(t5.field),
              op: "IS_NOT_NULL"
            }
          };
      }
      return {
        fieldFilter: {
          field: ni(t5.field),
          op: ei(t5.op),
          value: t5.value
        }
      };
    }(t4));
    if (1 === e3.length)
      return e3[0];
    return {
      compositeFilter: {
        op: "AND",
        filters: e3
      }
    };
  }(e2.filters);
  i2 && (n2.structuredQuery.where = i2);
  const r2 = function(t3) {
    if (0 === t3.length)
      return;
    return t3.map((t4) => function(t5) {
      return {
        field: ni(t5.field),
        direction: ti(t5.dir)
      };
    }(t4));
  }(e2.orderBy);
  r2 && (n2.structuredQuery.orderBy = r2);
  const o2 = function(t3, e3) {
    return t3.dt || oe(e3) ? e3 : {
      value: e3
    };
  }(t2, e2.limit);
  var u2;
  return null !== o2 && (n2.structuredQuery.limit = o2), e2.startAt && (n2.structuredQuery.startAt = {
    before: (u2 = e2.startAt).inclusive,
    values: u2.position
  }), e2.endAt && (n2.structuredQuery.endAt = function(t3) {
    return {
      before: !t3.inclusive,
      values: t3.position
    };
  }(e2.endAt)), n2;
}
function Ys(t2) {
  let e2 = Bs(t2.parent);
  const n2 = t2.structuredQuery, s2 = n2.from ? n2.from.length : 0;
  let i2 = null;
  if (s2 > 0) {
    U(1 === s2);
    const t3 = n2.from[0];
    t3.allDescendants ? i2 = t3.collectionId : e2 = e2.child(t3.collectionId);
  }
  let r2 = [];
  n2.where && (r2 = Zs(n2.where));
  let o2 = [];
  n2.orderBy && (o2 = n2.orderBy.map((t3) => function(t4) {
    return new Xe(
      si(t4.field),
      function(t5) {
        switch (t5) {
          case "ASCENDING":
            return "asc";
          case "DESCENDING":
            return "desc";
          default:
            return;
        }
      }(t4.direction)
    );
  }(t3)));
  let u2 = null;
  n2.limit && (u2 = function(t3) {
    let e3;
    return e3 = "object" == typeof t3 ? t3.value : t3, oe(e3) ? null : e3;
  }(n2.limit));
  let c2 = null;
  n2.startAt && (c2 = function(t3) {
    const e3 = !!t3.before, n3 = t3.values || [];
    return new Ye(n3, e3);
  }(n2.startAt));
  let a2 = null;
  return n2.endAt && (a2 = function(t3) {
    const e3 = !t3.before, n3 = t3.values || [];
    return new Ye(n3, e3);
  }(n2.endAt)), sn(e2, i2, o2, r2, u2, "F", c2, a2);
}
function Xs(t2, e2) {
  const n2 = function(t3, e3) {
    switch (e3) {
      case 0:
        return null;
      case 1:
        return "existence-filter-mismatch";
      case 2:
        return "limbo-document";
      default:
        return L();
    }
  }(0, e2.purpose);
  return null == n2 ? null : {
    "goog-listen-tags": n2
  };
}
function Zs(t2) {
  return t2 ? void 0 !== t2.unaryFilter ? [ri(t2)] : void 0 !== t2.fieldFilter ? [ii(t2)] : void 0 !== t2.compositeFilter ? t2.compositeFilter.filters.map((t3) => Zs(t3)).reduce((t3, e2) => t3.concat(e2)) : L() : [];
}
function ti(t2) {
  return vs[t2];
}
function ei(t2) {
  return Vs[t2];
}
function ni(t2) {
  return {
    fieldPath: t2.canonicalString()
  };
}
function si(t2) {
  return ft.fromServerFormat(t2.fieldPath);
}
function ii(t2) {
  return qe.create(si(t2.fieldFilter.field), function(t3) {
    switch (t3) {
      case "EQUAL":
        return "==";
      case "NOT_EQUAL":
        return "!=";
      case "GREATER_THAN":
        return ">";
      case "GREATER_THAN_OR_EQUAL":
        return ">=";
      case "LESS_THAN":
        return "<";
      case "LESS_THAN_OR_EQUAL":
        return "<=";
      case "ARRAY_CONTAINS":
        return "array-contains";
      case "IN":
        return "in";
      case "NOT_IN":
        return "not-in";
      case "ARRAY_CONTAINS_ANY":
        return "array-contains-any";
      default:
        return L();
    }
  }(t2.fieldFilter.op), t2.fieldFilter.value);
}
function ri(t2) {
  switch (t2.unaryFilter.op) {
    case "IS_NAN":
      const e2 = si(t2.unaryFilter.field);
      return qe.create(e2, "==", {
        doubleValue: NaN
      });
    case "IS_NULL":
      const n2 = si(t2.unaryFilter.field);
      return qe.create(n2, "==", {
        nullValue: "NULL_VALUE"
      });
    case "IS_NOT_NAN":
      const s2 = si(t2.unaryFilter.field);
      return qe.create(s2, "!=", {
        doubleValue: NaN
      });
    case "IS_NOT_NULL":
      const i2 = si(t2.unaryFilter.field);
      return qe.create(i2, "!=", {
        nullValue: "NULL_VALUE"
      });
    default:
      return L();
  }
}
function oi(t2) {
  const e2 = [];
  return t2.fields.forEach((t3) => e2.push(t3.canonicalString())), {
    fieldPaths: e2
  };
}
function ui(t2) {
  return t2.length >= 4 && "projects" === t2.get(0) && "databases" === t2.get(2);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Fi {
  constructor(t2, e2, n2, s2) {
    this.batchId = t2, this.localWriteTime = e2, this.baseMutations = n2, this.mutations = s2;
  }
  applyToRemoteDocument(t2, e2) {
    const n2 = e2.mutationResults;
    for (let e3 = 0; e3 < this.mutations.length; e3++) {
      const s2 = this.mutations[e3];
      if (s2.key.isEqual(t2.key)) {
        qn(s2, t2, n2[e3]);
      }
    }
  }
  applyToLocalView(t2, e2) {
    for (const n2 of this.baseMutations)
      n2.key.isEqual(t2.key) && (e2 = Kn(n2, t2, e2, this.localWriteTime));
    for (const n2 of this.mutations)
      n2.key.isEqual(t2.key) && (e2 = Kn(n2, t2, e2, this.localWriteTime));
    return e2;
  }
  applyToLocalDocumentSet(t2, e2) {
    const n2 = ls();
    return this.mutations.forEach((s2) => {
      const i2 = t2.get(s2.key), r2 = i2.overlayedDocument;
      let o2 = this.applyToLocalView(r2, i2.mutatedFields);
      o2 = e2.has(s2.key) ? null : o2;
      const u2 = Un(r2, o2);
      null !== u2 && n2.set(s2.key, u2), r2.isValidDocument() || r2.convertToNoDocument(ct.min());
    }), n2;
  }
  keys() {
    return this.mutations.reduce((t2, e2) => t2.add(e2.key), ws());
  }
  isEqual(t2) {
    return this.batchId === t2.batchId && rt(this.mutations, t2.mutations, (t3, e2) => Qn(t3, e2)) && rt(this.baseMutations, t2.baseMutations, (t3, e2) => Qn(t3, e2));
  }
}
class $i {
  constructor(t2, e2, n2, s2) {
    this.batch = t2, this.commitVersion = e2, this.mutationResults = n2, this.docVersions = s2;
  }
  static from(t2, e2, n2) {
    U(t2.mutations.length === n2.length);
    let s2 = ds;
    const i2 = t2.mutations;
    for (let t3 = 0; t3 < i2.length; t3++)
      s2 = s2.insert(i2[t3].key, n2[t3].version);
    return new $i(t2, e2, n2, s2);
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Bi {
  constructor(t2, e2) {
    this.largestBatchId = t2, this.mutation = e2;
  }
  getKey() {
    return this.mutation.key;
  }
  isEqual(t2) {
    return null !== t2 && this.mutation === t2.mutation;
  }
  toString() {
    return `Overlay{
      largestBatchId: ${this.largestBatchId},
      mutation: ${this.mutation.toString()}
    }`;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Li {
  constructor(t2, e2, n2, s2, i2 = ct.min(), r2 = ct.min(), o2 = Jt.EMPTY_BYTE_STRING) {
    this.target = t2, this.targetId = e2, this.purpose = n2, this.sequenceNumber = s2, this.snapshotVersion = i2, this.lastLimboFreeSnapshotVersion = r2, this.resumeToken = o2;
  }
  withSequenceNumber(t2) {
    return new Li(this.target, this.targetId, this.purpose, t2, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken);
  }
  withResumeToken(t2, e2) {
    return new Li(this.target, this.targetId, this.purpose, this.sequenceNumber, e2, this.lastLimboFreeSnapshotVersion, t2);
  }
  withLastLimboFreeSnapshotVersion(t2) {
    return new Li(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, t2, this.resumeToken);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ui {
  constructor(t2) {
    this.ne = t2;
  }
}
function Ji(t2) {
  const e2 = Ys({
    parent: t2.parent,
    structuredQuery: t2.structuredQuery
  });
  return "LAST" === t2.limitType ? fn(e2, e2.limit, "L") : e2;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class mr {
  constructor() {
    this.ze = new gr();
  }
  addToCollectionParentIndex(t2, e2) {
    return this.ze.add(e2), Pt.resolve();
  }
  getCollectionParents(t2, e2) {
    return Pt.resolve(this.ze.getEntries(e2));
  }
  addFieldIndex(t2, e2) {
    return Pt.resolve();
  }
  deleteFieldIndex(t2, e2) {
    return Pt.resolve();
  }
  getDocumentsMatchingTarget(t2, e2) {
    return Pt.resolve(null);
  }
  getIndexType(t2, e2) {
    return Pt.resolve(0);
  }
  getFieldIndexes(t2, e2) {
    return Pt.resolve([]);
  }
  getNextCollectionGroupToUpdate(t2) {
    return Pt.resolve(null);
  }
  getMinOffset(t2, e2) {
    return Pt.resolve(Tt.min());
  }
  getMinOffsetFromCollectionGroup(t2, e2) {
    return Pt.resolve(Tt.min());
  }
  updateCollectionGroup(t2, e2, n2) {
    return Pt.resolve();
  }
  updateIndexEntries(t2, e2) {
    return Pt.resolve();
  }
}
class gr {
  constructor() {
    this.index = {};
  }
  add(t2) {
    const e2 = t2.lastSegment(), n2 = t2.popLast(), s2 = this.index[e2] || new Qt(ht.comparator), i2 = !s2.has(n2);
    return this.index[e2] = s2.add(n2), i2;
  }
  has(t2) {
    const e2 = t2.lastSegment(), n2 = t2.popLast(), s2 = this.index[e2];
    return s2 && s2.has(n2);
  }
  getEntries(t2) {
    return (this.index[t2] || new Qt(ht.comparator)).toArray();
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class kr {
  constructor(t2) {
    this.En = t2;
  }
  next() {
    return this.En += 2, this.En;
  }
  static An() {
    return new kr(0);
  }
  static Rn() {
    return new kr(-1);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Qr {
  constructor() {
    this.changes = new is((t2) => t2.toString(), (t2, e2) => t2.isEqual(e2)), this.changesApplied = false;
  }
  addEntry(t2) {
    this.assertNotApplied(), this.changes.set(t2.key, t2);
  }
  removeEntry(t2, e2) {
    this.assertNotApplied(), this.changes.set(t2, xe.newInvalidDocument(t2).setReadTime(e2));
  }
  getEntry(t2, e2) {
    this.assertNotApplied();
    const n2 = this.changes.get(e2);
    return void 0 !== n2 ? Pt.resolve(n2) : this.getFromCache(t2, e2);
  }
  getEntries(t2, e2) {
    return this.getAllFromCache(t2, e2);
  }
  apply(t2) {
    return this.assertNotApplied(), this.changesApplied = true, this.applyChanges(t2);
  }
  assertNotApplied() {
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class to {
  constructor(t2, e2) {
    this.overlayedDocument = t2, this.mutatedFields = e2;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class eo {
  constructor(t2, e2, n2, s2) {
    this.remoteDocumentCache = t2, this.mutationQueue = e2, this.documentOverlayCache = n2, this.indexManager = s2;
  }
  getDocument(t2, e2) {
    let n2 = null;
    return this.documentOverlayCache.getOverlay(t2, e2).next((s2) => (n2 = s2, this.getBaseDocument(t2, e2, n2))).next((t3) => (null !== n2 && Kn(n2.mutation, t3, zt.empty(), ut.now()), t3));
  }
  getDocuments(t2, e2) {
    return this.remoteDocumentCache.getEntries(t2, e2).next((e3) => this.getLocalViewOfDocuments(t2, e3, ws()).next(() => e3));
  }
  getLocalViewOfDocuments(t2, e2, n2 = ws()) {
    const s2 = hs();
    return this.populateOverlays(t2, s2, e2).next(() => this.computeViews(t2, e2, s2, n2).next((t3) => {
      let e3 = cs();
      return t3.forEach((t4, n3) => {
        e3 = e3.insert(t4, n3.overlayedDocument);
      }), e3;
    }));
  }
  getOverlayedDocuments(t2, e2) {
    const n2 = hs();
    return this.populateOverlays(t2, n2, e2).next(() => this.computeViews(t2, e2, n2, ws()));
  }
  populateOverlays(t2, e2, n2) {
    const s2 = [];
    return n2.forEach((t3) => {
      e2.has(t3) || s2.push(t3);
    }), this.documentOverlayCache.getOverlays(t2, s2).next((t3) => {
      t3.forEach((t4, n3) => {
        e2.set(t4, n3);
      });
    });
  }
  computeViews(t2, e2, n2, s2) {
    let i2 = os();
    const r2 = fs(), o2 = fs();
    return e2.forEach((t3, e3) => {
      const o3 = n2.get(e3.key);
      s2.has(e3.key) && (void 0 === o3 || o3.mutation instanceof Wn) ? i2 = i2.insert(e3.key, e3) : void 0 !== o3 && (r2.set(e3.key, o3.mutation.getFieldMask()), Kn(o3.mutation, e3, o3.mutation.getFieldMask(), ut.now()));
    }), this.recalculateAndSaveOverlays(t2, i2).next((t3) => (t3.forEach((t4, e3) => r2.set(t4, e3)), e2.forEach((t4, e3) => {
      var n3;
      return o2.set(t4, new to(e3, null !== (n3 = r2.get(t4)) && void 0 !== n3 ? n3 : null));
    }), o2));
  }
  recalculateAndSaveOverlays(t2, e2) {
    const n2 = fs();
    let s2 = new qt((t3, e3) => t3 - e3), i2 = ws();
    return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(t2, e2).next((t3) => {
      for (const i3 of t3)
        i3.keys().forEach((t4) => {
          const r2 = e2.get(t4);
          if (null === r2)
            return;
          let o2 = n2.get(t4) || zt.empty();
          o2 = i3.applyToLocalView(r2, o2), n2.set(t4, o2);
          const u2 = (s2.get(i3.batchId) || ws()).add(t4);
          s2 = s2.insert(i3.batchId, u2);
        });
    }).next(() => {
      const r2 = [], o2 = s2.getReverseIterator();
      for (; o2.hasNext(); ) {
        const s3 = o2.getNext(), u2 = s3.key, c2 = s3.value, a2 = ls();
        c2.forEach((t3) => {
          if (!i2.has(t3)) {
            const s4 = Un(e2.get(t3), n2.get(t3));
            null !== s4 && a2.set(t3, s4), i2 = i2.add(t3);
          }
        }), r2.push(this.documentOverlayCache.saveOverlays(t2, u2, a2));
      }
      return Pt.waitFor(r2);
    }).next(() => n2);
  }
  recalculateAndSaveOverlaysForDocumentKeys(t2, e2) {
    return this.remoteDocumentCache.getEntries(t2, e2).next((e3) => this.recalculateAndSaveOverlays(t2, e3));
  }
  getDocumentsMatchingQuery(t2, e2, n2) {
    return function(t3) {
      return dt.isDocumentKey(t3.path) && null === t3.collectionGroup && 0 === t3.filters.length;
    }(e2) ? this.getDocumentsMatchingDocumentQuery(t2, e2.path) : an(e2) ? this.getDocumentsMatchingCollectionGroupQuery(t2, e2, n2) : this.getDocumentsMatchingCollectionQuery(t2, e2, n2);
  }
  getNextDocuments(t2, e2, n2, s2) {
    return this.remoteDocumentCache.getAllFromCollectionGroup(t2, e2, n2, s2).next((i2) => {
      const r2 = s2 - i2.size > 0 ? this.documentOverlayCache.getOverlaysForCollectionGroup(t2, e2, n2.largestBatchId, s2 - i2.size) : Pt.resolve(hs());
      let o2 = -1, u2 = i2;
      return r2.next((e3) => Pt.forEach(e3, (e4, n3) => (o2 < n3.largestBatchId && (o2 = n3.largestBatchId), i2.get(e4) ? Pt.resolve() : this.getBaseDocument(t2, e4, n3).next((t3) => {
        u2 = u2.insert(e4, t3);
      }))).next(() => this.populateOverlays(t2, e3, i2)).next(() => this.computeViews(t2, u2, e3, ws())).next((t3) => ({
        batchId: o2,
        changes: as(t3)
      })));
    });
  }
  getDocumentsMatchingDocumentQuery(t2, e2) {
    return this.getDocument(t2, new dt(e2)).next((t3) => {
      let e3 = cs();
      return t3.isFoundDocument() && (e3 = e3.insert(t3.key, t3)), e3;
    });
  }
  getDocumentsMatchingCollectionGroupQuery(t2, e2, n2) {
    const s2 = e2.collectionGroup;
    let i2 = cs();
    return this.indexManager.getCollectionParents(t2, s2).next((r2) => Pt.forEach(r2, (r3) => {
      const o2 = function(t3, e3) {
        return new nn(
          e3,
          null,
          t3.explicitOrderBy.slice(),
          t3.filters.slice(),
          t3.limit,
          t3.limitType,
          t3.startAt,
          t3.endAt
        );
      }(e2, r3.child(s2));
      return this.getDocumentsMatchingCollectionQuery(t2, o2, n2).next((t3) => {
        t3.forEach((t4, e3) => {
          i2 = i2.insert(t4, e3);
        });
      });
    }).next(() => i2));
  }
  getDocumentsMatchingCollectionQuery(t2, e2, n2) {
    let s2;
    return this.remoteDocumentCache.getAllFromCollection(t2, e2.path, n2).next((i2) => (s2 = i2, this.documentOverlayCache.getOverlaysForCollection(t2, e2.path, n2.largestBatchId))).next((t3) => {
      t3.forEach((t4, e3) => {
        const n4 = e3.getKey();
        null === s2.get(n4) && (s2 = s2.insert(n4, xe.newInvalidDocument(n4)));
      });
      let n3 = cs();
      return s2.forEach((s3, i2) => {
        const r2 = t3.get(s3);
        void 0 !== r2 && Kn(r2.mutation, i2, zt.empty(), ut.now()), mn(e2, i2) && (n3 = n3.insert(s3, i2));
      }), n3;
    });
  }
  getBaseDocument(t2, e2, n2) {
    return null === n2 || 1 === n2.mutation.type ? this.remoteDocumentCache.getEntry(t2, e2) : Pt.resolve(xe.newInvalidDocument(e2));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class no {
  constructor(t2) {
    this.wt = t2, this.Jn = /* @__PURE__ */ new Map(), this.Yn = /* @__PURE__ */ new Map();
  }
  getBundleMetadata(t2, e2) {
    return Pt.resolve(this.Jn.get(e2));
  }
  saveBundleMetadata(t2, e2) {
    var n2;
    return this.Jn.set(e2.id, {
      id: (n2 = e2).id,
      version: n2.version,
      createTime: Ns(n2.createTime)
    }), Pt.resolve();
  }
  getNamedQuery(t2, e2) {
    return Pt.resolve(this.Yn.get(e2));
  }
  saveNamedQuery(t2, e2) {
    return this.Yn.set(e2.name, function(t3) {
      return {
        name: t3.name,
        query: Ji(t3.bundledQuery),
        readTime: Ns(t3.readTime)
      };
    }(e2)), Pt.resolve();
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class so {
  constructor() {
    this.overlays = new qt(dt.comparator), this.Xn = /* @__PURE__ */ new Map();
  }
  getOverlay(t2, e2) {
    return Pt.resolve(this.overlays.get(e2));
  }
  getOverlays(t2, e2) {
    const n2 = hs();
    return Pt.forEach(e2, (e3) => this.getOverlay(t2, e3).next((t3) => {
      null !== t3 && n2.set(e3, t3);
    })).next(() => n2);
  }
  saveOverlays(t2, e2, n2) {
    return n2.forEach((n3, s2) => {
      this.ie(t2, e2, s2);
    }), Pt.resolve();
  }
  removeOverlaysForBatchId(t2, e2, n2) {
    const s2 = this.Xn.get(n2);
    return void 0 !== s2 && (s2.forEach((t3) => this.overlays = this.overlays.remove(t3)), this.Xn.delete(n2)), Pt.resolve();
  }
  getOverlaysForCollection(t2, e2, n2) {
    const s2 = hs(), i2 = e2.length + 1, r2 = new dt(e2.child("")), o2 = this.overlays.getIteratorFrom(r2);
    for (; o2.hasNext(); ) {
      const t3 = o2.getNext().value, r3 = t3.getKey();
      if (!e2.isPrefixOf(r3.path))
        break;
      r3.path.length === i2 && (t3.largestBatchId > n2 && s2.set(t3.getKey(), t3));
    }
    return Pt.resolve(s2);
  }
  getOverlaysForCollectionGroup(t2, e2, n2, s2) {
    let i2 = new qt((t3, e3) => t3 - e3);
    const r2 = this.overlays.getIterator();
    for (; r2.hasNext(); ) {
      const t3 = r2.getNext().value;
      if (t3.getKey().getCollectionGroup() === e2 && t3.largestBatchId > n2) {
        let e3 = i2.get(t3.largestBatchId);
        null === e3 && (e3 = hs(), i2 = i2.insert(t3.largestBatchId, e3)), e3.set(t3.getKey(), t3);
      }
    }
    const o2 = hs(), u2 = i2.getIterator();
    for (; u2.hasNext(); ) {
      if (u2.getNext().value.forEach((t3, e3) => o2.set(t3, e3)), o2.size() >= s2)
        break;
    }
    return Pt.resolve(o2);
  }
  ie(t2, e2, n2) {
    const s2 = this.overlays.get(n2.key);
    if (null !== s2) {
      const t3 = this.Xn.get(s2.largestBatchId).delete(n2.key);
      this.Xn.set(s2.largestBatchId, t3);
    }
    this.overlays = this.overlays.insert(n2.key, new Bi(e2, n2));
    let i2 = this.Xn.get(e2);
    void 0 === i2 && (i2 = ws(), this.Xn.set(e2, i2)), this.Xn.set(e2, i2.add(n2.key));
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class io {
  constructor() {
    this.Zn = new Qt(ro.ts), this.es = new Qt(ro.ns);
  }
  isEmpty() {
    return this.Zn.isEmpty();
  }
  addReference(t2, e2) {
    const n2 = new ro(t2, e2);
    this.Zn = this.Zn.add(n2), this.es = this.es.add(n2);
  }
  ss(t2, e2) {
    t2.forEach((t3) => this.addReference(t3, e2));
  }
  removeReference(t2, e2) {
    this.rs(new ro(t2, e2));
  }
  os(t2, e2) {
    t2.forEach((t3) => this.removeReference(t3, e2));
  }
  us(t2) {
    const e2 = new dt(new ht([])), n2 = new ro(e2, t2), s2 = new ro(e2, t2 + 1), i2 = [];
    return this.es.forEachInRange([n2, s2], (t3) => {
      this.rs(t3), i2.push(t3.key);
    }), i2;
  }
  cs() {
    this.Zn.forEach((t2) => this.rs(t2));
  }
  rs(t2) {
    this.Zn = this.Zn.delete(t2), this.es = this.es.delete(t2);
  }
  hs(t2) {
    const e2 = new dt(new ht([])), n2 = new ro(e2, t2), s2 = new ro(e2, t2 + 1);
    let i2 = ws();
    return this.es.forEachInRange([n2, s2], (t3) => {
      i2 = i2.add(t3.key);
    }), i2;
  }
  containsKey(t2) {
    const e2 = new ro(t2, 0), n2 = this.Zn.firstAfterOrEqual(e2);
    return null !== n2 && t2.isEqual(n2.key);
  }
}
class ro {
  constructor(t2, e2) {
    this.key = t2, this.ls = e2;
  }
  static ts(t2, e2) {
    return dt.comparator(t2.key, e2.key) || it(t2.ls, e2.ls);
  }
  static ns(t2, e2) {
    return it(t2.ls, e2.ls) || dt.comparator(t2.key, e2.key);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class oo {
  constructor(t2, e2) {
    this.indexManager = t2, this.referenceDelegate = e2, this.mutationQueue = [], this.fs = 1, this.ds = new Qt(ro.ts);
  }
  checkEmpty(t2) {
    return Pt.resolve(0 === this.mutationQueue.length);
  }
  addMutationBatch(t2, e2, n2, s2) {
    const i2 = this.fs;
    this.fs++, this.mutationQueue.length > 0 && this.mutationQueue[this.mutationQueue.length - 1];
    const r2 = new Fi(i2, e2, n2, s2);
    this.mutationQueue.push(r2);
    for (const e3 of s2)
      this.ds = this.ds.add(new ro(e3.key, i2)), this.indexManager.addToCollectionParentIndex(t2, e3.key.path.popLast());
    return Pt.resolve(r2);
  }
  lookupMutationBatch(t2, e2) {
    return Pt.resolve(this._s(e2));
  }
  getNextMutationBatchAfterBatchId(t2, e2) {
    const n2 = e2 + 1, s2 = this.ws(n2), i2 = s2 < 0 ? 0 : s2;
    return Pt.resolve(this.mutationQueue.length > i2 ? this.mutationQueue[i2] : null);
  }
  getHighestUnacknowledgedBatchId() {
    return Pt.resolve(0 === this.mutationQueue.length ? -1 : this.fs - 1);
  }
  getAllMutationBatches(t2) {
    return Pt.resolve(this.mutationQueue.slice());
  }
  getAllMutationBatchesAffectingDocumentKey(t2, e2) {
    const n2 = new ro(e2, 0), s2 = new ro(e2, Number.POSITIVE_INFINITY), i2 = [];
    return this.ds.forEachInRange([n2, s2], (t3) => {
      const e3 = this._s(t3.ls);
      i2.push(e3);
    }), Pt.resolve(i2);
  }
  getAllMutationBatchesAffectingDocumentKeys(t2, e2) {
    let n2 = new Qt(it);
    return e2.forEach((t3) => {
      const e3 = new ro(t3, 0), s2 = new ro(t3, Number.POSITIVE_INFINITY);
      this.ds.forEachInRange([e3, s2], (t4) => {
        n2 = n2.add(t4.ls);
      });
    }), Pt.resolve(this.gs(n2));
  }
  getAllMutationBatchesAffectingQuery(t2, e2) {
    const n2 = e2.path, s2 = n2.length + 1;
    let i2 = n2;
    dt.isDocumentKey(i2) || (i2 = i2.child(""));
    const r2 = new ro(new dt(i2), 0);
    let o2 = new Qt(it);
    return this.ds.forEachWhile((t3) => {
      const e3 = t3.key.path;
      return !!n2.isPrefixOf(e3) && (e3.length === s2 && (o2 = o2.add(t3.ls)), true);
    }, r2), Pt.resolve(this.gs(o2));
  }
  gs(t2) {
    const e2 = [];
    return t2.forEach((t3) => {
      const n2 = this._s(t3);
      null !== n2 && e2.push(n2);
    }), e2;
  }
  removeMutationBatch(t2, e2) {
    U(0 === this.ys(e2.batchId, "removed")), this.mutationQueue.shift();
    let n2 = this.ds;
    return Pt.forEach(e2.mutations, (s2) => {
      const i2 = new ro(s2.key, e2.batchId);
      return n2 = n2.delete(i2), this.referenceDelegate.markPotentiallyOrphaned(t2, s2.key);
    }).next(() => {
      this.ds = n2;
    });
  }
  In(t2) {
  }
  containsKey(t2, e2) {
    const n2 = new ro(e2, 0), s2 = this.ds.firstAfterOrEqual(n2);
    return Pt.resolve(e2.isEqual(s2 && s2.key));
  }
  performConsistencyCheck(t2) {
    return this.mutationQueue.length, Pt.resolve();
  }
  ys(t2, e2) {
    return this.ws(t2);
  }
  ws(t2) {
    if (0 === this.mutationQueue.length)
      return 0;
    return t2 - this.mutationQueue[0].batchId;
  }
  _s(t2) {
    const e2 = this.ws(t2);
    if (e2 < 0 || e2 >= this.mutationQueue.length)
      return null;
    return this.mutationQueue[e2];
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class uo {
  constructor(t2) {
    this.ps = t2, this.docs = new qt(dt.comparator), this.size = 0;
  }
  setIndexManager(t2) {
    this.indexManager = t2;
  }
  addEntry(t2, e2) {
    const n2 = e2.key, s2 = this.docs.get(n2), i2 = s2 ? s2.size : 0, r2 = this.ps(e2);
    return this.docs = this.docs.insert(n2, {
      document: e2.mutableCopy(),
      size: r2
    }), this.size += r2 - i2, this.indexManager.addToCollectionParentIndex(t2, n2.path.popLast());
  }
  removeEntry(t2) {
    const e2 = this.docs.get(t2);
    e2 && (this.docs = this.docs.remove(t2), this.size -= e2.size);
  }
  getEntry(t2, e2) {
    const n2 = this.docs.get(e2);
    return Pt.resolve(n2 ? n2.document.mutableCopy() : xe.newInvalidDocument(e2));
  }
  getEntries(t2, e2) {
    let n2 = os();
    return e2.forEach((t3) => {
      const e3 = this.docs.get(t3);
      n2 = n2.insert(t3, e3 ? e3.document.mutableCopy() : xe.newInvalidDocument(t3));
    }), Pt.resolve(n2);
  }
  getAllFromCollection(t2, e2, n2) {
    let s2 = os();
    const i2 = new dt(e2.child("")), r2 = this.docs.getIteratorFrom(i2);
    for (; r2.hasNext(); ) {
      const { key: t3, value: { document: i3 } } = r2.getNext();
      if (!e2.isPrefixOf(t3.path))
        break;
      t3.path.length > e2.length + 1 || (Et(It(i3), n2) <= 0 || (s2 = s2.insert(i3.key, i3.mutableCopy())));
    }
    return Pt.resolve(s2);
  }
  getAllFromCollectionGroup(t2, e2, n2, s2) {
    L();
  }
  Is(t2, e2) {
    return Pt.forEach(this.docs, (t3) => e2(t3));
  }
  newChangeBuffer(t2) {
    return new co(this);
  }
  getSize(t2) {
    return Pt.resolve(this.size);
  }
}
class co extends Qr {
  constructor(t2) {
    super(), this.zn = t2;
  }
  applyChanges(t2) {
    const e2 = [];
    return this.changes.forEach((n2, s2) => {
      s2.isValidDocument() ? e2.push(this.zn.addEntry(t2, s2)) : this.zn.removeEntry(n2);
    }), Pt.waitFor(e2);
  }
  getFromCache(t2, e2) {
    return this.zn.getEntry(t2, e2);
  }
  getAllFromCache(t2, e2) {
    return this.zn.getEntries(t2, e2);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ao {
  constructor(t2) {
    this.persistence = t2, this.Ts = new is((t3) => Oe(t3), Fe), this.lastRemoteSnapshotVersion = ct.min(), this.highestTargetId = 0, this.Es = 0, this.As = new io(), this.targetCount = 0, this.Rs = kr.An();
  }
  forEachTarget(t2, e2) {
    return this.Ts.forEach((t3, n2) => e2(n2)), Pt.resolve();
  }
  getLastRemoteSnapshotVersion(t2) {
    return Pt.resolve(this.lastRemoteSnapshotVersion);
  }
  getHighestSequenceNumber(t2) {
    return Pt.resolve(this.Es);
  }
  allocateTargetId(t2) {
    return this.highestTargetId = this.Rs.next(), Pt.resolve(this.highestTargetId);
  }
  setTargetsMetadata(t2, e2, n2) {
    return n2 && (this.lastRemoteSnapshotVersion = n2), e2 > this.Es && (this.Es = e2), Pt.resolve();
  }
  vn(t2) {
    this.Ts.set(t2.target, t2);
    const e2 = t2.targetId;
    e2 > this.highestTargetId && (this.Rs = new kr(e2), this.highestTargetId = e2), t2.sequenceNumber > this.Es && (this.Es = t2.sequenceNumber);
  }
  addTargetData(t2, e2) {
    return this.vn(e2), this.targetCount += 1, Pt.resolve();
  }
  updateTargetData(t2, e2) {
    return this.vn(e2), Pt.resolve();
  }
  removeTargetData(t2, e2) {
    return this.Ts.delete(e2.target), this.As.us(e2.targetId), this.targetCount -= 1, Pt.resolve();
  }
  removeTargets(t2, e2, n2) {
    let s2 = 0;
    const i2 = [];
    return this.Ts.forEach((r2, o2) => {
      o2.sequenceNumber <= e2 && null === n2.get(o2.targetId) && (this.Ts.delete(r2), i2.push(this.removeMatchingKeysForTargetId(t2, o2.targetId)), s2++);
    }), Pt.waitFor(i2).next(() => s2);
  }
  getTargetCount(t2) {
    return Pt.resolve(this.targetCount);
  }
  getTargetData(t2, e2) {
    const n2 = this.Ts.get(e2) || null;
    return Pt.resolve(n2);
  }
  addMatchingKeys(t2, e2, n2) {
    return this.As.ss(e2, n2), Pt.resolve();
  }
  removeMatchingKeys(t2, e2, n2) {
    this.As.os(e2, n2);
    const s2 = this.persistence.referenceDelegate, i2 = [];
    return s2 && e2.forEach((e3) => {
      i2.push(s2.markPotentiallyOrphaned(t2, e3));
    }), Pt.waitFor(i2);
  }
  removeMatchingKeysForTargetId(t2, e2) {
    return this.As.us(e2), Pt.resolve();
  }
  getMatchingKeysForTargetId(t2, e2) {
    const n2 = this.As.hs(e2);
    return Pt.resolve(n2);
  }
  containsKey(t2, e2) {
    return Pt.resolve(this.As.containsKey(e2));
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ho {
  constructor(t2, e2) {
    this.bs = {}, this.overlays = {}, this.Ps = new $t(0), this.vs = false, this.vs = true, this.referenceDelegate = t2(this), this.Vs = new ao(this);
    this.indexManager = new mr(), this.remoteDocumentCache = function(t3) {
      return new uo(t3);
    }((t3) => this.referenceDelegate.Ss(t3)), this.wt = new Ui(e2), this.Ds = new no(this.wt);
  }
  start() {
    return Promise.resolve();
  }
  shutdown() {
    return this.vs = false, Promise.resolve();
  }
  get started() {
    return this.vs;
  }
  setDatabaseDeletedListener() {
  }
  setNetworkEnabled() {
  }
  getIndexManager(t2) {
    return this.indexManager;
  }
  getDocumentOverlayCache(t2) {
    let e2 = this.overlays[t2.toKey()];
    return e2 || (e2 = new so(), this.overlays[t2.toKey()] = e2), e2;
  }
  getMutationQueue(t2, e2) {
    let n2 = this.bs[t2.toKey()];
    return n2 || (n2 = new oo(e2, this.referenceDelegate), this.bs[t2.toKey()] = n2), n2;
  }
  getTargetCache() {
    return this.Vs;
  }
  getRemoteDocumentCache() {
    return this.remoteDocumentCache;
  }
  getBundleCache() {
    return this.Ds;
  }
  runTransaction(t2, e2, n2) {
    M("MemoryPersistence", "Starting transaction:", t2);
    const s2 = new lo(this.Ps.next());
    return this.referenceDelegate.Cs(), n2(s2).next((t3) => this.referenceDelegate.xs(s2).next(() => t3)).toPromise().then((t3) => (s2.raiseOnCommittedEvent(), t3));
  }
  Ns(t2, e2) {
    return Pt.or(Object.values(this.bs).map((n2) => () => n2.containsKey(t2, e2)));
  }
}
class lo extends Rt {
  constructor(t2) {
    super(), this.currentSequenceNumber = t2;
  }
}
class fo {
  constructor(t2) {
    this.persistence = t2, this.ks = new io(), this.Os = null;
  }
  static Ms(t2) {
    return new fo(t2);
  }
  get Fs() {
    if (this.Os)
      return this.Os;
    throw L();
  }
  addReference(t2, e2, n2) {
    return this.ks.addReference(n2, e2), this.Fs.delete(n2.toString()), Pt.resolve();
  }
  removeReference(t2, e2, n2) {
    return this.ks.removeReference(n2, e2), this.Fs.add(n2.toString()), Pt.resolve();
  }
  markPotentiallyOrphaned(t2, e2) {
    return this.Fs.add(e2.toString()), Pt.resolve();
  }
  removeTarget(t2, e2) {
    this.ks.us(e2.targetId).forEach((t3) => this.Fs.add(t3.toString()));
    const n2 = this.persistence.getTargetCache();
    return n2.getMatchingKeysForTargetId(t2, e2.targetId).next((t3) => {
      t3.forEach((t4) => this.Fs.add(t4.toString()));
    }).next(() => n2.removeTargetData(t2, e2));
  }
  Cs() {
    this.Os = /* @__PURE__ */ new Set();
  }
  xs(t2) {
    const e2 = this.persistence.getRemoteDocumentCache().newChangeBuffer();
    return Pt.forEach(this.Fs, (n2) => {
      const s2 = dt.fromPath(n2);
      return this.$s(t2, s2).next((t3) => {
        t3 || e2.removeEntry(s2, ct.min());
      });
    }).next(() => (this.Os = null, e2.apply(t2)));
  }
  updateLimboDocument(t2, e2) {
    return this.$s(t2, e2).next((t3) => {
      t3 ? this.Fs.delete(e2.toString()) : this.Fs.add(e2.toString());
    });
  }
  Ss(t2) {
    return 0;
  }
  $s(t2, e2) {
    return Pt.or([() => Pt.resolve(this.ks.containsKey(e2)), () => this.persistence.getTargetCache().containsKey(t2, e2), () => this.persistence.Ns(t2, e2)]);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class To {
  constructor(t2, e2, n2, s2) {
    this.targetId = t2, this.fromCache = e2, this.Pi = n2, this.vi = s2;
  }
  static Vi(t2, e2) {
    let n2 = ws(), s2 = ws();
    for (const t3 of e2.docChanges)
      switch (t3.type) {
        case 0:
          n2 = n2.add(t3.doc.key);
          break;
        case 1:
          s2 = s2.add(t3.doc.key);
      }
    return new To(t2, e2.fromCache, n2, s2);
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Eo {
  constructor() {
    this.Si = false;
  }
  initialize(t2, e2) {
    this.Di = t2, this.indexManager = e2, this.Si = true;
  }
  getDocumentsMatchingQuery(t2, e2, n2, s2) {
    return this.Ci(t2, e2).next((i2) => i2 || this.xi(t2, e2, s2, n2)).next((n3) => n3 || this.Ni(t2, e2));
  }
  Ci(t2, e2) {
    return Pt.resolve(null);
  }
  xi(t2, e2, n2, s2) {
    return on(e2) || s2.isEqual(ct.min()) ? this.Ni(t2, e2) : this.Di.getDocuments(t2, n2).next((i2) => {
      const r2 = this.ki(e2, i2);
      return this.Oi(e2, r2, n2, s2) ? this.Ni(t2, e2) : (k() <= LogLevel.DEBUG && M("QueryEngine", "Re-using previous result from %s to execute query: %s", s2.toString(), wn(e2)), this.Mi(t2, r2, e2, pt(s2, -1)));
    });
  }
  ki(t2, e2) {
    let n2 = new Qt(yn(t2));
    return e2.forEach((e3, s2) => {
      mn(t2, s2) && (n2 = n2.add(s2));
    }), n2;
  }
  Oi(t2, e2, n2, s2) {
    if (null === t2.limit)
      return false;
    if (n2.size !== e2.size)
      return true;
    const i2 = "F" === t2.limitType ? e2.last() : e2.first();
    return !!i2 && (i2.hasPendingWrites || i2.version.compareTo(s2) > 0);
  }
  Ni(t2, e2) {
    return k() <= LogLevel.DEBUG && M("QueryEngine", "Using full collection scan to execute query:", wn(e2)), this.Di.getDocumentsMatchingQuery(t2, e2, Tt.min());
  }
  Mi(t2, e2, n2, s2) {
    return this.Di.getDocumentsMatchingQuery(t2, n2, s2).next((t3) => (e2.forEach((e3) => {
      t3 = t3.insert(e3.key, e3);
    }), t3));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ao {
  constructor(t2, e2, n2, s2) {
    this.persistence = t2, this.Fi = e2, this.wt = s2, this.$i = new qt(it), this.Bi = new is((t3) => Oe(t3), Fe), this.Li = /* @__PURE__ */ new Map(), this.Ui = t2.getRemoteDocumentCache(), this.Vs = t2.getTargetCache(), this.Ds = t2.getBundleCache(), this.qi(n2);
  }
  qi(t2) {
    this.documentOverlayCache = this.persistence.getDocumentOverlayCache(t2), this.indexManager = this.persistence.getIndexManager(t2), this.mutationQueue = this.persistence.getMutationQueue(t2, this.indexManager), this.localDocuments = new eo(this.Ui, this.mutationQueue, this.documentOverlayCache, this.indexManager), this.Ui.setIndexManager(this.indexManager), this.Fi.initialize(this.localDocuments, this.indexManager);
  }
  collectGarbage(t2) {
    return this.persistence.runTransaction("Collect garbage", "readwrite-primary", (e2) => t2.collect(e2, this.$i));
  }
}
function Ro(t2, e2, n2, s2) {
  return new Ao(t2, e2, n2, s2);
}
async function bo(t2, e2) {
  const n2 = K(t2);
  return await n2.persistence.runTransaction("Handle user change", "readonly", (t3) => {
    let s2;
    return n2.mutationQueue.getAllMutationBatches(t3).next((i2) => (s2 = i2, n2.qi(e2), n2.mutationQueue.getAllMutationBatches(t3))).next((e3) => {
      const i2 = [], r2 = [];
      let o2 = ws();
      for (const t4 of s2) {
        i2.push(t4.batchId);
        for (const e4 of t4.mutations)
          o2 = o2.add(e4.key);
      }
      for (const t4 of e3) {
        r2.push(t4.batchId);
        for (const e4 of t4.mutations)
          o2 = o2.add(e4.key);
      }
      return n2.localDocuments.getDocuments(t3, o2).next((t4) => ({
        Ki: t4,
        removedBatchIds: i2,
        addedBatchIds: r2
      }));
    });
  });
}
function Po(t2, e2) {
  const n2 = K(t2);
  return n2.persistence.runTransaction("Acknowledge batch", "readwrite-primary", (t3) => {
    const s2 = e2.batch.keys(), i2 = n2.Ui.newChangeBuffer({
      trackRemovals: true
    });
    return function(t4, e3, n3, s3) {
      const i3 = n3.batch, r2 = i3.keys();
      let o2 = Pt.resolve();
      return r2.forEach((t5) => {
        o2 = o2.next(() => s3.getEntry(e3, t5)).next((e4) => {
          const r3 = n3.docVersions.get(t5);
          U(null !== r3), e4.version.compareTo(r3) < 0 && (i3.applyToRemoteDocument(e4, n3), e4.isValidDocument() && (e4.setReadTime(n3.commitVersion), s3.addEntry(e4)));
        });
      }), o2.next(() => t4.mutationQueue.removeMutationBatch(e3, i3));
    }(n2, t3, e2, i2).next(() => i2.apply(t3)).next(() => n2.mutationQueue.performConsistencyCheck(t3)).next(() => n2.documentOverlayCache.removeOverlaysForBatchId(t3, s2, e2.batch.batchId)).next(() => n2.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(t3, function(t4) {
      let e3 = ws();
      for (let n3 = 0; n3 < t4.mutationResults.length; ++n3) {
        t4.mutationResults[n3].transformResults.length > 0 && (e3 = e3.add(t4.batch.mutations[n3].key));
      }
      return e3;
    }(e2))).next(() => n2.localDocuments.getDocuments(t3, s2));
  });
}
function vo(t2) {
  const e2 = K(t2);
  return e2.persistence.runTransaction("Get last remote snapshot version", "readonly", (t3) => e2.Vs.getLastRemoteSnapshotVersion(t3));
}
function Vo(t2, e2) {
  const n2 = K(t2), s2 = e2.snapshotVersion;
  let i2 = n2.$i;
  return n2.persistence.runTransaction("Apply remote event", "readwrite-primary", (t3) => {
    const r2 = n2.Ui.newChangeBuffer({
      trackRemovals: true
    });
    i2 = n2.$i;
    const o2 = [];
    e2.targetChanges.forEach((r3, u3) => {
      const c3 = i2.get(u3);
      if (!c3)
        return;
      o2.push(n2.Vs.removeMatchingKeys(t3, r3.removedDocuments, u3).next(() => n2.Vs.addMatchingKeys(t3, r3.addedDocuments, u3)));
      let a2 = c3.withSequenceNumber(t3.currentSequenceNumber);
      e2.targetMismatches.has(u3) ? a2 = a2.withResumeToken(Jt.EMPTY_BYTE_STRING, ct.min()).withLastLimboFreeSnapshotVersion(ct.min()) : r3.resumeToken.approximateByteSize() > 0 && (a2 = a2.withResumeToken(r3.resumeToken, s2)), i2 = i2.insert(u3, a2), function(t4, e3, n3) {
        if (0 === t4.resumeToken.approximateByteSize())
          return true;
        if (e3.snapshotVersion.toMicroseconds() - t4.snapshotVersion.toMicroseconds() >= 3e8)
          return true;
        return n3.addedDocuments.size + n3.modifiedDocuments.size + n3.removedDocuments.size > 0;
      }(c3, a2, r3) && o2.push(n2.Vs.updateTargetData(t3, a2));
    });
    let u2 = os(), c2 = ws();
    if (e2.documentUpdates.forEach((s3) => {
      e2.resolvedLimboDocuments.has(s3) && o2.push(n2.persistence.referenceDelegate.updateLimboDocument(t3, s3));
    }), o2.push(So(t3, r2, e2.documentUpdates).next((t4) => {
      u2 = t4.Gi, c2 = t4.Qi;
    })), !s2.isEqual(ct.min())) {
      const e3 = n2.Vs.getLastRemoteSnapshotVersion(t3).next((e4) => n2.Vs.setTargetsMetadata(t3, t3.currentSequenceNumber, s2));
      o2.push(e3);
    }
    return Pt.waitFor(o2).next(() => r2.apply(t3)).next(() => n2.localDocuments.getLocalViewOfDocuments(t3, u2, c2)).next(() => u2);
  }).then((t3) => (n2.$i = i2, t3));
}
function So(t2, e2, n2) {
  let s2 = ws(), i2 = ws();
  return n2.forEach((t3) => s2 = s2.add(t3)), e2.getEntries(t2, s2).next((t3) => {
    let s3 = os();
    return n2.forEach((n3, r2) => {
      const o2 = t3.get(n3);
      r2.isFoundDocument() !== o2.isFoundDocument() && (i2 = i2.add(n3)), r2.isNoDocument() && r2.version.isEqual(ct.min()) ? (e2.removeEntry(n3, r2.readTime), s3 = s3.insert(n3, r2)) : !o2.isValidDocument() || r2.version.compareTo(o2.version) > 0 || 0 === r2.version.compareTo(o2.version) && o2.hasPendingWrites ? (e2.addEntry(r2), s3 = s3.insert(n3, r2)) : M("LocalStore", "Ignoring outdated watch update for ", n3, ". Current version:", o2.version, " Watch version:", r2.version);
    }), {
      Gi: s3,
      Qi: i2
    };
  });
}
function Do(t2, e2) {
  const n2 = K(t2);
  return n2.persistence.runTransaction("Get next mutation batch", "readonly", (t3) => (void 0 === e2 && (e2 = -1), n2.mutationQueue.getNextMutationBatchAfterBatchId(t3, e2)));
}
function Co(t2, e2) {
  const n2 = K(t2);
  return n2.persistence.runTransaction("Allocate target", "readwrite", (t3) => {
    let s2;
    return n2.Vs.getTargetData(t3, e2).next((i2) => i2 ? (s2 = i2, Pt.resolve(s2)) : n2.Vs.allocateTargetId(t3).next((i3) => (s2 = new Li(e2, i3, 0, t3.currentSequenceNumber), n2.Vs.addTargetData(t3, s2).next(() => s2))));
  }).then((t3) => {
    const s2 = n2.$i.get(t3.targetId);
    return (null === s2 || t3.snapshotVersion.compareTo(s2.snapshotVersion) > 0) && (n2.$i = n2.$i.insert(t3.targetId, t3), n2.Bi.set(e2, t3.targetId)), t3;
  });
}
async function xo(t2, e2, n2) {
  const s2 = K(t2), i2 = s2.$i.get(e2), r2 = n2 ? "readwrite" : "readwrite-primary";
  try {
    n2 || await s2.persistence.runTransaction("Release target", r2, (t3) => s2.persistence.referenceDelegate.removeTarget(t3, i2));
  } catch (t3) {
    if (!Ct(t3))
      throw t3;
    M("LocalStore", `Failed to update sequence numbers for target ${e2}: ${t3}`);
  }
  s2.$i = s2.$i.remove(e2), s2.Bi.delete(i2.target);
}
function No(t2, e2, n2) {
  const s2 = K(t2);
  let i2 = ct.min(), r2 = ws();
  return s2.persistence.runTransaction("Execute query", "readonly", (t3) => function(t4, e3, n3) {
    const s3 = K(t4), i3 = s3.Bi.get(n3);
    return void 0 !== i3 ? Pt.resolve(s3.$i.get(i3)) : s3.Vs.getTargetData(e3, n3);
  }(s2, t3, ln(e2)).next((e3) => {
    if (e3)
      return i2 = e3.lastLimboFreeSnapshotVersion, s2.Vs.getMatchingKeysForTargetId(t3, e3.targetId).next((t4) => {
        r2 = t4;
      });
  }).next(() => s2.Fi.getDocumentsMatchingQuery(t3, e2, n2 ? i2 : ct.min(), n2 ? r2 : ws())).next((t4) => (Mo(s2, gn(e2), t4), {
    documents: t4,
    ji: r2
  })));
}
function Mo(t2, e2, n2) {
  let s2 = ct.min();
  n2.forEach((t3, e3) => {
    e3.readTime.compareTo(s2) > 0 && (s2 = e3.readTime);
  }), t2.Li.set(e2, s2);
}
class jo {
  constructor() {
    this.activeTargetIds = gs();
  }
  Xi(t2) {
    this.activeTargetIds = this.activeTargetIds.add(t2);
  }
  Zi(t2) {
    this.activeTargetIds = this.activeTargetIds.delete(t2);
  }
  Yi() {
    const t2 = {
      activeTargetIds: this.activeTargetIds.toArray(),
      updateTimeMs: Date.now()
    };
    return JSON.stringify(t2);
  }
}
class zo {
  constructor() {
    this.Fr = new jo(), this.$r = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null;
  }
  addPendingMutation(t2) {
  }
  updateMutationState(t2, e2, n2) {
  }
  addLocalQueryTarget(t2) {
    return this.Fr.Xi(t2), this.$r[t2] || "not-current";
  }
  updateQueryState(t2, e2, n2) {
    this.$r[t2] = e2;
  }
  removeLocalQueryTarget(t2) {
    this.Fr.Zi(t2);
  }
  isLocalQueryTarget(t2) {
    return this.Fr.activeTargetIds.has(t2);
  }
  clearQueryState(t2) {
    delete this.$r[t2];
  }
  getAllActiveQueryTargets() {
    return this.Fr.activeTargetIds;
  }
  isActiveQueryTarget(t2) {
    return this.Fr.activeTargetIds.has(t2);
  }
  start() {
    return this.Fr = new jo(), Promise.resolve();
  }
  handleUserChange(t2, e2, n2) {
  }
  setOnlineState(t2) {
  }
  shutdown() {
  }
  writeSequenceNumber(t2) {
  }
  notifyBundleLoaded(t2) {
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ho {
  Br(t2) {
  }
  shutdown() {
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Jo {
  constructor() {
    this.Lr = () => this.Ur(), this.qr = () => this.Kr(), this.Gr = [], this.Qr();
  }
  Br(t2) {
    this.Gr.push(t2);
  }
  shutdown() {
    window.removeEventListener("online", this.Lr), window.removeEventListener("offline", this.qr);
  }
  Qr() {
    window.addEventListener("online", this.Lr), window.addEventListener("offline", this.qr);
  }
  Ur() {
    M("ConnectivityMonitor", "Network connectivity changed: AVAILABLE");
    for (const t2 of this.Gr)
      t2(0);
  }
  Kr() {
    M("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE");
    for (const t2 of this.Gr)
      t2(1);
  }
  static V() {
    return "undefined" != typeof window && void 0 !== window.addEventListener && void 0 !== window.removeEventListener;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Yo = {
  BatchGetDocuments: "batchGet",
  Commit: "commit",
  RunQuery: "runQuery"
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Xo {
  constructor(t2) {
    this.jr = t2.jr, this.Wr = t2.Wr;
  }
  zr(t2) {
    this.Hr = t2;
  }
  Jr(t2) {
    this.Yr = t2;
  }
  onMessage(t2) {
    this.Xr = t2;
  }
  close() {
    this.Wr();
  }
  send(t2) {
    this.jr(t2);
  }
  Zr() {
    this.Hr();
  }
  eo(t2) {
    this.Yr(t2);
  }
  no(t2) {
    this.Xr(t2);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Zo extends class {
  constructor(t2) {
    this.databaseInfo = t2, this.databaseId = t2.databaseId;
    const e2 = t2.ssl ? "https" : "http";
    this.so = e2 + "://" + t2.host, this.io = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents";
  }
  ro(t2, e2, n2, s2, i2) {
    const r2 = this.oo(t2, e2);
    M("RestConnection", "Sending: ", r2, n2);
    const o2 = {};
    return this.uo(o2, s2, i2), this.co(t2, r2, o2, n2).then((t3) => (M("RestConnection", "Received: ", t3), t3), (e3) => {
      throw $("RestConnection", `${t2} failed with error: `, e3, "url: ", r2, "request:", n2), e3;
    });
  }
  ao(t2, e2, n2, s2, i2, r2) {
    return this.ro(t2, e2, n2, s2, i2);
  }
  uo(t2, e2, n2) {
    t2["X-Goog-Api-Client"] = "gl-js/ fire/" + x, t2["Content-Type"] = "text/plain", this.databaseInfo.appId && (t2["X-Firebase-GMPID"] = this.databaseInfo.appId), e2 && e2.headers.forEach((e3, n3) => t2[n3] = e3), n2 && n2.headers.forEach((e3, n3) => t2[n3] = e3);
  }
  oo(t2, e2) {
    const n2 = Yo[t2];
    return `${this.so}/v1/${e2}:${n2}`;
  }
} {
  constructor(t2) {
    super(t2), this.forceLongPolling = t2.forceLongPolling, this.autoDetectLongPolling = t2.autoDetectLongPolling, this.useFetchStreams = t2.useFetchStreams;
  }
  co(t2, e2, n2, s2) {
    return new Promise((i2, r2) => {
      const o2 = new XhrIo();
      o2.listenOnce(EventType.COMPLETE, () => {
        try {
          switch (o2.getLastErrorCode()) {
            case ErrorCode$1.NO_ERROR:
              const e3 = o2.getResponseJson();
              M("Connection", "XHR received:", JSON.stringify(e3)), i2(e3);
              break;
            case ErrorCode$1.TIMEOUT:
              M("Connection", 'RPC "' + t2 + '" timed out'), r2(new Q(G.DEADLINE_EXCEEDED, "Request time out"));
              break;
            case ErrorCode$1.HTTP_ERROR:
              const n3 = o2.getStatus();
              if (M("Connection", 'RPC "' + t2 + '" failed with status:', n3, "response text:", o2.getResponseText()), n3 > 0) {
                const t3 = o2.getResponseJson().error;
                if (t3 && t3.status && t3.message) {
                  const e4 = function(t4) {
                    const e5 = t4.toLowerCase().replace(/_/g, "-");
                    return Object.values(G).indexOf(e5) >= 0 ? e5 : G.UNKNOWN;
                  }(t3.status);
                  r2(new Q(e4, t3.message));
                } else
                  r2(new Q(G.UNKNOWN, "Server responded with status " + o2.getStatus()));
              } else
                r2(new Q(G.UNAVAILABLE, "Connection failed."));
              break;
            default:
              L();
          }
        } finally {
          M("Connection", 'RPC "' + t2 + '" completed.');
        }
      });
      const u2 = JSON.stringify(s2);
      o2.send(e2, "POST", u2, n2, 15);
    });
  }
  ho(t2, e2, n2) {
    const s2 = [this.so, "/", "google.firestore.v1.Firestore", "/", t2, "/channel"], i2 = createWebChannelTransport(), r2 = getStatEventTarget(), o2 = {
      httpSessionIdParam: "gsessionid",
      initMessageHeaders: {},
      messageUrlParams: {
        database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`
      },
      sendRawJson: true,
      supportsCrossDomainXhr: true,
      internalChannelParams: {
        forwardChannelRequestTimeoutMs: 6e5
      },
      forceLongPolling: this.forceLongPolling,
      detectBufferingProxy: this.autoDetectLongPolling
    };
    this.useFetchStreams && (o2.xmlHttpFactory = new FetchXmlHttpFactory({})), this.uo(o2.initMessageHeaders, e2, n2), isMobileCordova() || isReactNative() || isElectron() || isIE() || isUWP() || isBrowserExtension() || (o2.httpHeadersOverwriteParam = "$httpHeaders");
    const u2 = s2.join("");
    M("Connection", "Creating WebChannel: " + u2, o2);
    const c2 = i2.createWebChannel(u2, o2);
    let a2 = false, h2 = false;
    const l2 = new Xo({
      jr: (t3) => {
        h2 ? M("Connection", "Not sending because WebChannel is closed:", t3) : (a2 || (M("Connection", "Opening WebChannel transport."), c2.open(), a2 = true), M("Connection", "WebChannel sending:", t3), c2.send(t3));
      },
      Wr: () => c2.close()
    }), y2 = (t3, e3, n3) => {
      t3.listen(e3, (t4) => {
        try {
          n3(t4);
        } catch (t5) {
          setTimeout(() => {
            throw t5;
          }, 0);
        }
      });
    };
    return y2(c2, WebChannel.EventType.OPEN, () => {
      h2 || M("Connection", "WebChannel transport opened.");
    }), y2(c2, WebChannel.EventType.CLOSE, () => {
      h2 || (h2 = true, M("Connection", "WebChannel transport closed"), l2.eo());
    }), y2(c2, WebChannel.EventType.ERROR, (t3) => {
      h2 || (h2 = true, $("Connection", "WebChannel transport errored:", t3), l2.eo(new Q(G.UNAVAILABLE, "The operation could not be completed")));
    }), y2(c2, WebChannel.EventType.MESSAGE, (t3) => {
      var e3;
      if (!h2) {
        const n3 = t3.data[0];
        U(!!n3);
        const s3 = n3, i3 = s3.error || (null === (e3 = s3[0]) || void 0 === e3 ? void 0 : e3.error);
        if (i3) {
          M("Connection", "WebChannel received error:", i3);
          const t4 = i3.status;
          let e4 = function(t5) {
            const e5 = ts[t5];
            if (void 0 !== e5)
              return ss(e5);
          }(t4), n4 = i3.message;
          void 0 === e4 && (e4 = G.INTERNAL, n4 = "Unknown error status: " + t4 + " with message " + i3.message), h2 = true, l2.eo(new Q(e4, n4)), c2.close();
        } else
          M("Connection", "WebChannel received:", n3), l2.no(n3);
      }
    }), y2(r2, Event$1.STAT_EVENT, (t3) => {
      t3.stat === Stat.PROXY ? M("Connection", "Detected buffering proxy") : t3.stat === Stat.NOPROXY && M("Connection", "Detected no buffering proxy");
    }), setTimeout(() => {
      l2.Zr();
    }, 0), l2;
  }
}
function eu() {
  return "undefined" != typeof document ? document : null;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function nu(t2) {
  return new Ss(t2, true);
}
class su {
  constructor(t2, e2, n2 = 1e3, s2 = 1.5, i2 = 6e4) {
    this.js = t2, this.timerId = e2, this.lo = n2, this.fo = s2, this._o = i2, this.wo = 0, this.mo = null, this.yo = Date.now(), this.reset();
  }
  reset() {
    this.wo = 0;
  }
  po() {
    this.wo = this._o;
  }
  Io(t2) {
    this.cancel();
    const e2 = Math.floor(this.wo + this.To()), n2 = Math.max(0, Date.now() - this.yo), s2 = Math.max(0, e2 - n2);
    s2 > 0 && M("ExponentialBackoff", `Backing off for ${s2} ms (base delay: ${this.wo} ms, delay with jitter: ${e2} ms, last attempt: ${n2} ms ago)`), this.mo = this.js.enqueueAfterDelay(this.timerId, s2, () => (this.yo = Date.now(), t2())), this.wo *= this.fo, this.wo < this.lo && (this.wo = this.lo), this.wo > this._o && (this.wo = this._o);
  }
  Eo() {
    null !== this.mo && (this.mo.skipDelay(), this.mo = null);
  }
  cancel() {
    null !== this.mo && (this.mo.cancel(), this.mo = null);
  }
  To() {
    return (Math.random() - 0.5) * this.wo;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class iu {
  constructor(t2, e2, n2, s2, i2, r2, o2, u2) {
    this.js = t2, this.Ao = n2, this.Ro = s2, this.bo = i2, this.authCredentialsProvider = r2, this.appCheckCredentialsProvider = o2, this.listener = u2, this.state = 0, this.Po = 0, this.vo = null, this.Vo = null, this.stream = null, this.So = new su(t2, e2);
  }
  Do() {
    return 1 === this.state || 5 === this.state || this.Co();
  }
  Co() {
    return 2 === this.state || 3 === this.state;
  }
  start() {
    4 !== this.state ? this.auth() : this.xo();
  }
  async stop() {
    this.Do() && await this.close(0);
  }
  No() {
    this.state = 0, this.So.reset();
  }
  ko() {
    this.Co() && null === this.vo && (this.vo = this.js.enqueueAfterDelay(this.Ao, 6e4, () => this.Oo()));
  }
  Mo(t2) {
    this.Fo(), this.stream.send(t2);
  }
  async Oo() {
    if (this.Co())
      return this.close(0);
  }
  Fo() {
    this.vo && (this.vo.cancel(), this.vo = null);
  }
  $o() {
    this.Vo && (this.Vo.cancel(), this.Vo = null);
  }
  async close(t2, e2) {
    this.Fo(), this.$o(), this.So.cancel(), this.Po++, 4 !== t2 ? this.So.reset() : e2 && e2.code === G.RESOURCE_EXHAUSTED ? (F(e2.toString()), F("Using maximum backoff delay to prevent overloading the backend."), this.So.po()) : e2 && e2.code === G.UNAUTHENTICATED && 3 !== this.state && (this.authCredentialsProvider.invalidateToken(), this.appCheckCredentialsProvider.invalidateToken()), null !== this.stream && (this.Bo(), this.stream.close(), this.stream = null), this.state = t2, await this.listener.Jr(e2);
  }
  Bo() {
  }
  auth() {
    this.state = 1;
    const t2 = this.Lo(this.Po), e2 = this.Po;
    Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then(([t3, n2]) => {
      this.Po === e2 && this.Uo(t3, n2);
    }, (e3) => {
      t2(() => {
        const t3 = new Q(G.UNKNOWN, "Fetching auth token failed: " + e3.message);
        return this.qo(t3);
      });
    });
  }
  Uo(t2, e2) {
    const n2 = this.Lo(this.Po);
    this.stream = this.Ko(t2, e2), this.stream.zr(() => {
      n2(() => (this.state = 2, this.Vo = this.js.enqueueAfterDelay(this.Ro, 1e4, () => (this.Co() && (this.state = 3), Promise.resolve())), this.listener.zr()));
    }), this.stream.Jr((t3) => {
      n2(() => this.qo(t3));
    }), this.stream.onMessage((t3) => {
      n2(() => this.onMessage(t3));
    });
  }
  xo() {
    this.state = 5, this.So.Io(async () => {
      this.state = 0, this.start();
    });
  }
  qo(t2) {
    return M("PersistentStream", `close with error: ${t2}`), this.stream = null, this.close(4, t2);
  }
  Lo(t2) {
    return (e2) => {
      this.js.enqueueAndForget(() => this.Po === t2 ? e2() : (M("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve()));
    };
  }
}
class ru extends iu {
  constructor(t2, e2, n2, s2, i2, r2) {
    super(t2, "listen_stream_connection_backoff", "listen_stream_idle", "health_check_timeout", e2, n2, s2, r2), this.wt = i2;
  }
  Ko(t2, e2) {
    return this.bo.ho("Listen", t2, e2);
  }
  onMessage(t2) {
    this.So.reset();
    const e2 = Qs(this.wt, t2), n2 = function(t3) {
      if (!("targetChange" in t3))
        return ct.min();
      const e3 = t3.targetChange;
      return e3.targetIds && e3.targetIds.length ? ct.min() : e3.readTime ? Ns(e3.readTime) : ct.min();
    }(t2);
    return this.listener.Go(e2, n2);
  }
  Qo(t2) {
    const e2 = {};
    e2.database = Ls(this.wt), e2.addTarget = function(t3, e3) {
      let n3;
      const s2 = e3.target;
      return n3 = $e(s2) ? {
        documents: Hs(t3, s2)
      } : {
        query: Js(t3, s2)
      }, n3.targetId = e3.targetId, e3.resumeToken.approximateByteSize() > 0 ? n3.resumeToken = Cs(t3, e3.resumeToken) : e3.snapshotVersion.compareTo(ct.min()) > 0 && (n3.readTime = Ds(t3, e3.snapshotVersion.toTimestamp())), n3;
    }(this.wt, t2);
    const n2 = Xs(this.wt, t2);
    n2 && (e2.labels = n2), this.Mo(e2);
  }
  jo(t2) {
    const e2 = {};
    e2.database = Ls(this.wt), e2.removeTarget = t2, this.Mo(e2);
  }
}
class ou extends iu {
  constructor(t2, e2, n2, s2, i2, r2) {
    super(t2, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", e2, n2, s2, r2), this.wt = i2, this.Wo = false;
  }
  get zo() {
    return this.Wo;
  }
  start() {
    this.Wo = false, this.lastStreamToken = void 0, super.start();
  }
  Bo() {
    this.Wo && this.Ho([]);
  }
  Ko(t2, e2) {
    return this.bo.ho("Write", t2, e2);
  }
  onMessage(t2) {
    if (U(!!t2.streamToken), this.lastStreamToken = t2.streamToken, this.Wo) {
      this.So.reset();
      const e2 = zs(t2.writeResults, t2.commitTime), n2 = Ns(t2.commitTime);
      return this.listener.Jo(n2, e2);
    }
    return U(!t2.writeResults || 0 === t2.writeResults.length), this.Wo = true, this.listener.Yo();
  }
  Xo() {
    const t2 = {};
    t2.database = Ls(this.wt), this.Mo(t2);
  }
  Ho(t2) {
    const e2 = {
      streamToken: this.lastStreamToken,
      writes: t2.map((t3) => js(this.wt, t3))
    };
    this.Mo(e2);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class uu extends class {
} {
  constructor(t2, e2, n2, s2) {
    super(), this.authCredentials = t2, this.appCheckCredentials = e2, this.bo = n2, this.wt = s2, this.Zo = false;
  }
  tu() {
    if (this.Zo)
      throw new Q(G.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  ro(t2, e2, n2) {
    return this.tu(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s2, i2]) => this.bo.ro(t2, e2, n2, s2, i2)).catch((t3) => {
      throw "FirebaseError" === t3.name ? (t3.code === G.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), t3) : new Q(G.UNKNOWN, t3.toString());
    });
  }
  ao(t2, e2, n2, s2) {
    return this.tu(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([i2, r2]) => this.bo.ao(t2, e2, n2, i2, r2, s2)).catch((t3) => {
      throw "FirebaseError" === t3.name ? (t3.code === G.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), t3) : new Q(G.UNKNOWN, t3.toString());
    });
  }
  terminate() {
    this.Zo = true;
  }
}
class cu {
  constructor(t2, e2) {
    this.asyncQueue = t2, this.onlineStateHandler = e2, this.state = "Unknown", this.eu = 0, this.nu = null, this.su = true;
  }
  iu() {
    0 === this.eu && (this.ru("Unknown"), this.nu = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.nu = null, this.ou("Backend didn't respond within 10 seconds."), this.ru("Offline"), Promise.resolve())));
  }
  uu(t2) {
    "Online" === this.state ? this.ru("Unknown") : (this.eu++, this.eu >= 1 && (this.cu(), this.ou(`Connection failed 1 times. Most recent error: ${t2.toString()}`), this.ru("Offline")));
  }
  set(t2) {
    this.cu(), this.eu = 0, "Online" === t2 && (this.su = false), this.ru(t2);
  }
  ru(t2) {
    t2 !== this.state && (this.state = t2, this.onlineStateHandler(t2));
  }
  ou(t2) {
    const e2 = `Could not reach Cloud Firestore backend. ${t2}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
    this.su ? (F(e2), this.su = false) : M("OnlineStateTracker", e2);
  }
  cu() {
    null !== this.nu && (this.nu.cancel(), this.nu = null);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class au {
  constructor(t2, e2, n2, s2, i2) {
    this.localStore = t2, this.datastore = e2, this.asyncQueue = n2, this.remoteSyncer = {}, this.au = [], this.hu = /* @__PURE__ */ new Map(), this.lu = /* @__PURE__ */ new Set(), this.fu = [], this.du = i2, this.du.Br((t3) => {
      n2.enqueueAndForget(async () => {
        yu(this) && (M("RemoteStore", "Restarting streams for network reachability change."), await async function(t4) {
          const e3 = K(t4);
          e3.lu.add(4), await lu(e3), e3._u.set("Unknown"), e3.lu.delete(4), await hu(e3);
        }(this));
      });
    }), this._u = new cu(n2, s2);
  }
}
async function hu(t2) {
  if (yu(t2))
    for (const e2 of t2.fu)
      await e2(true);
}
async function lu(t2) {
  for (const e2 of t2.fu)
    await e2(false);
}
function fu(t2, e2) {
  const n2 = K(t2);
  n2.hu.has(e2.targetId) || (n2.hu.set(e2.targetId, e2), gu(n2) ? mu(n2) : Mu(n2).Co() && _u(n2, e2));
}
function du(t2, e2) {
  const n2 = K(t2), s2 = Mu(n2);
  n2.hu.delete(e2), s2.Co() && wu(n2, e2), 0 === n2.hu.size && (s2.Co() ? s2.ko() : yu(n2) && n2._u.set("Unknown"));
}
function _u(t2, e2) {
  t2.wu.Nt(e2.targetId), Mu(t2).Qo(e2);
}
function wu(t2, e2) {
  t2.wu.Nt(e2), Mu(t2).jo(e2);
}
function mu(t2) {
  t2.wu = new Rs({
    getRemoteKeysForTarget: (e2) => t2.remoteSyncer.getRemoteKeysForTarget(e2),
    te: (e2) => t2.hu.get(e2) || null
  }), Mu(t2).start(), t2._u.iu();
}
function gu(t2) {
  return yu(t2) && !Mu(t2).Do() && t2.hu.size > 0;
}
function yu(t2) {
  return 0 === K(t2).lu.size;
}
function pu(t2) {
  t2.wu = void 0;
}
async function Iu(t2) {
  t2.hu.forEach((e2, n2) => {
    _u(t2, e2);
  });
}
async function Tu(t2, e2) {
  pu(t2), gu(t2) ? (t2._u.uu(e2), mu(t2)) : t2._u.set("Unknown");
}
async function Eu(t2, e2, n2) {
  if (t2._u.set("Online"), e2 instanceof Es && 2 === e2.state && e2.cause)
    try {
      await async function(t3, e3) {
        const n3 = e3.cause;
        for (const s2 of e3.targetIds)
          t3.hu.has(s2) && (await t3.remoteSyncer.rejectListen(s2, n3), t3.hu.delete(s2), t3.wu.removeTarget(s2));
      }(t2, e2);
    } catch (n3) {
      M("RemoteStore", "Failed to remove targets %s: %s ", e2.targetIds.join(","), n3), await Au(t2, n3);
    }
  else if (e2 instanceof Is ? t2.wu.Ut(e2) : e2 instanceof Ts ? t2.wu.zt(e2) : t2.wu.Gt(e2), !n2.isEqual(ct.min()))
    try {
      const e3 = await vo(t2.localStore);
      n2.compareTo(e3) >= 0 && await function(t3, e4) {
        const n3 = t3.wu.Yt(e4);
        return n3.targetChanges.forEach((n4, s2) => {
          if (n4.resumeToken.approximateByteSize() > 0) {
            const i2 = t3.hu.get(s2);
            i2 && t3.hu.set(s2, i2.withResumeToken(n4.resumeToken, e4));
          }
        }), n3.targetMismatches.forEach((e5) => {
          const n4 = t3.hu.get(e5);
          if (!n4)
            return;
          t3.hu.set(e5, n4.withResumeToken(Jt.EMPTY_BYTE_STRING, n4.snapshotVersion)), wu(t3, e5);
          const s2 = new Li(n4.target, e5, 1, n4.sequenceNumber);
          _u(t3, s2);
        }), t3.remoteSyncer.applyRemoteEvent(n3);
      }(t2, n2);
    } catch (e3) {
      M("RemoteStore", "Failed to raise snapshot:", e3), await Au(t2, e3);
    }
}
async function Au(t2, e2, n2) {
  if (!Ct(e2))
    throw e2;
  t2.lu.add(1), await lu(t2), t2._u.set("Offline"), n2 || (n2 = () => vo(t2.localStore)), t2.asyncQueue.enqueueRetryable(async () => {
    M("RemoteStore", "Retrying IndexedDB access"), await n2(), t2.lu.delete(1), await hu(t2);
  });
}
function Ru(t2, e2) {
  return e2().catch((n2) => Au(t2, n2, e2));
}
async function bu(t2) {
  const e2 = K(t2), n2 = Fu(e2);
  let s2 = e2.au.length > 0 ? e2.au[e2.au.length - 1].batchId : -1;
  for (; Pu(e2); )
    try {
      const t3 = await Do(e2.localStore, s2);
      if (null === t3) {
        0 === e2.au.length && n2.ko();
        break;
      }
      s2 = t3.batchId, vu(e2, t3);
    } catch (t3) {
      await Au(e2, t3);
    }
  Vu(e2) && Su(e2);
}
function Pu(t2) {
  return yu(t2) && t2.au.length < 10;
}
function vu(t2, e2) {
  t2.au.push(e2);
  const n2 = Fu(t2);
  n2.Co() && n2.zo && n2.Ho(e2.mutations);
}
function Vu(t2) {
  return yu(t2) && !Fu(t2).Do() && t2.au.length > 0;
}
function Su(t2) {
  Fu(t2).start();
}
async function Du(t2) {
  Fu(t2).Xo();
}
async function Cu(t2) {
  const e2 = Fu(t2);
  for (const n2 of t2.au)
    e2.Ho(n2.mutations);
}
async function xu(t2, e2, n2) {
  const s2 = t2.au.shift(), i2 = $i.from(s2, e2, n2);
  await Ru(t2, () => t2.remoteSyncer.applySuccessfulWrite(i2)), await bu(t2);
}
async function Nu(t2, e2) {
  e2 && Fu(t2).zo && await async function(t3, e3) {
    if (n2 = e3.code, ns(n2) && n2 !== G.ABORTED) {
      const n3 = t3.au.shift();
      Fu(t3).No(), await Ru(t3, () => t3.remoteSyncer.rejectFailedWrite(n3.batchId, e3)), await bu(t3);
    }
    var n2;
  }(t2, e2), Vu(t2) && Su(t2);
}
async function ku(t2, e2) {
  const n2 = K(t2);
  n2.asyncQueue.verifyOperationInProgress(), M("RemoteStore", "RemoteStore received new credentials");
  const s2 = yu(n2);
  n2.lu.add(3), await lu(n2), s2 && n2._u.set("Unknown"), await n2.remoteSyncer.handleCredentialChange(e2), n2.lu.delete(3), await hu(n2);
}
async function Ou(t2, e2) {
  const n2 = K(t2);
  e2 ? (n2.lu.delete(2), await hu(n2)) : e2 || (n2.lu.add(2), await lu(n2), n2._u.set("Unknown"));
}
function Mu(t2) {
  return t2.mu || (t2.mu = function(t3, e2, n2) {
    const s2 = K(t3);
    return s2.tu(), new ru(e2, s2.bo, s2.authCredentials, s2.appCheckCredentials, s2.wt, n2);
  }(t2.datastore, t2.asyncQueue, {
    zr: Iu.bind(null, t2),
    Jr: Tu.bind(null, t2),
    Go: Eu.bind(null, t2)
  }), t2.fu.push(async (e2) => {
    e2 ? (t2.mu.No(), gu(t2) ? mu(t2) : t2._u.set("Unknown")) : (await t2.mu.stop(), pu(t2));
  })), t2.mu;
}
function Fu(t2) {
  return t2.gu || (t2.gu = function(t3, e2, n2) {
    const s2 = K(t3);
    return s2.tu(), new ou(e2, s2.bo, s2.authCredentials, s2.appCheckCredentials, s2.wt, n2);
  }(t2.datastore, t2.asyncQueue, {
    zr: Du.bind(null, t2),
    Jr: Nu.bind(null, t2),
    Yo: Cu.bind(null, t2),
    Jo: xu.bind(null, t2)
  }), t2.fu.push(async (e2) => {
    e2 ? (t2.gu.No(), await bu(t2)) : (await t2.gu.stop(), t2.au.length > 0 && (M("RemoteStore", `Stopping write stream with ${t2.au.length} pending writes`), t2.au = []));
  })), t2.gu;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class $u {
  constructor(t2, e2, n2, s2, i2) {
    this.asyncQueue = t2, this.timerId = e2, this.targetTimeMs = n2, this.op = s2, this.removalCallback = i2, this.deferred = new j(), this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch((t3) => {
    });
  }
  static createAndSchedule(t2, e2, n2, s2, i2) {
    const r2 = Date.now() + n2, o2 = new $u(t2, e2, r2, s2, i2);
    return o2.start(n2), o2;
  }
  start(t2) {
    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), t2);
  }
  skipDelay() {
    return this.handleDelayElapsed();
  }
  cancel(t2) {
    null !== this.timerHandle && (this.clearTimeout(), this.deferred.reject(new Q(G.CANCELLED, "Operation cancelled" + (t2 ? ": " + t2 : ""))));
  }
  handleDelayElapsed() {
    this.asyncQueue.enqueueAndForget(() => null !== this.timerHandle ? (this.clearTimeout(), this.op().then((t2) => this.deferred.resolve(t2))) : Promise.resolve());
  }
  clearTimeout() {
    null !== this.timerHandle && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);
  }
}
function Bu(t2, e2) {
  if (F("AsyncQueue", `${e2}: ${t2}`), Ct(t2))
    return new Q(G.UNAVAILABLE, `${e2}: ${t2}`);
  throw t2;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Lu {
  constructor(t2) {
    this.comparator = t2 ? (e2, n2) => t2(e2, n2) || dt.comparator(e2.key, n2.key) : (t3, e2) => dt.comparator(t3.key, e2.key), this.keyedMap = cs(), this.sortedSet = new qt(this.comparator);
  }
  static emptySet(t2) {
    return new Lu(t2.comparator);
  }
  has(t2) {
    return null != this.keyedMap.get(t2);
  }
  get(t2) {
    return this.keyedMap.get(t2);
  }
  first() {
    return this.sortedSet.minKey();
  }
  last() {
    return this.sortedSet.maxKey();
  }
  isEmpty() {
    return this.sortedSet.isEmpty();
  }
  indexOf(t2) {
    const e2 = this.keyedMap.get(t2);
    return e2 ? this.sortedSet.indexOf(e2) : -1;
  }
  get size() {
    return this.sortedSet.size;
  }
  forEach(t2) {
    this.sortedSet.inorderTraversal((e2, n2) => (t2(e2), false));
  }
  add(t2) {
    const e2 = this.delete(t2.key);
    return e2.copy(e2.keyedMap.insert(t2.key, t2), e2.sortedSet.insert(t2, null));
  }
  delete(t2) {
    const e2 = this.get(t2);
    return e2 ? this.copy(this.keyedMap.remove(t2), this.sortedSet.remove(e2)) : this;
  }
  isEqual(t2) {
    if (!(t2 instanceof Lu))
      return false;
    if (this.size !== t2.size)
      return false;
    const e2 = this.sortedSet.getIterator(), n2 = t2.sortedSet.getIterator();
    for (; e2.hasNext(); ) {
      const t3 = e2.getNext().key, s2 = n2.getNext().key;
      if (!t3.isEqual(s2))
        return false;
    }
    return true;
  }
  toString() {
    const t2 = [];
    return this.forEach((e2) => {
      t2.push(e2.toString());
    }), 0 === t2.length ? "DocumentSet ()" : "DocumentSet (\n  " + t2.join("  \n") + "\n)";
  }
  copy(t2, e2) {
    const n2 = new Lu();
    return n2.comparator = this.comparator, n2.keyedMap = t2, n2.sortedSet = e2, n2;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Uu {
  constructor() {
    this.yu = new qt(dt.comparator);
  }
  track(t2) {
    const e2 = t2.doc.key, n2 = this.yu.get(e2);
    n2 ? 0 !== t2.type && 3 === n2.type ? this.yu = this.yu.insert(e2, t2) : 3 === t2.type && 1 !== n2.type ? this.yu = this.yu.insert(e2, {
      type: n2.type,
      doc: t2.doc
    }) : 2 === t2.type && 2 === n2.type ? this.yu = this.yu.insert(e2, {
      type: 2,
      doc: t2.doc
    }) : 2 === t2.type && 0 === n2.type ? this.yu = this.yu.insert(e2, {
      type: 0,
      doc: t2.doc
    }) : 1 === t2.type && 0 === n2.type ? this.yu = this.yu.remove(e2) : 1 === t2.type && 2 === n2.type ? this.yu = this.yu.insert(e2, {
      type: 1,
      doc: n2.doc
    }) : 0 === t2.type && 1 === n2.type ? this.yu = this.yu.insert(e2, {
      type: 2,
      doc: t2.doc
    }) : L() : this.yu = this.yu.insert(e2, t2);
  }
  pu() {
    const t2 = [];
    return this.yu.inorderTraversal((e2, n2) => {
      t2.push(n2);
    }), t2;
  }
}
class qu {
  constructor(t2, e2, n2, s2, i2, r2, o2, u2) {
    this.query = t2, this.docs = e2, this.oldDocs = n2, this.docChanges = s2, this.mutatedKeys = i2, this.fromCache = r2, this.syncStateChanged = o2, this.excludesMetadataChanges = u2;
  }
  static fromInitialDocuments(t2, e2, n2, s2) {
    const i2 = [];
    return e2.forEach((t3) => {
      i2.push({
        type: 0,
        doc: t3
      });
    }), new qu(
      t2,
      e2,
      Lu.emptySet(e2),
      i2,
      n2,
      s2,
      true,
      false
    );
  }
  get hasPendingWrites() {
    return !this.mutatedKeys.isEmpty();
  }
  isEqual(t2) {
    if (!(this.fromCache === t2.fromCache && this.syncStateChanged === t2.syncStateChanged && this.mutatedKeys.isEqual(t2.mutatedKeys) && dn(this.query, t2.query) && this.docs.isEqual(t2.docs) && this.oldDocs.isEqual(t2.oldDocs)))
      return false;
    const e2 = this.docChanges, n2 = t2.docChanges;
    if (e2.length !== n2.length)
      return false;
    for (let t3 = 0; t3 < e2.length; t3++)
      if (e2[t3].type !== n2[t3].type || !e2[t3].doc.isEqual(n2[t3].doc))
        return false;
    return true;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ku {
  constructor() {
    this.Iu = void 0, this.listeners = [];
  }
}
class Gu {
  constructor() {
    this.queries = new is((t2) => _n(t2), dn), this.onlineState = "Unknown", this.Tu = /* @__PURE__ */ new Set();
  }
}
async function Qu(t2, e2) {
  const n2 = K(t2), s2 = e2.query;
  let i2 = false, r2 = n2.queries.get(s2);
  if (r2 || (i2 = true, r2 = new Ku()), i2)
    try {
      r2.Iu = await n2.onListen(s2);
    } catch (t3) {
      const n3 = Bu(t3, `Initialization of query '${wn(e2.query)}' failed`);
      return void e2.onError(n3);
    }
  if (n2.queries.set(s2, r2), r2.listeners.push(e2), e2.Eu(n2.onlineState), r2.Iu) {
    e2.Au(r2.Iu) && Hu(n2);
  }
}
async function ju(t2, e2) {
  const n2 = K(t2), s2 = e2.query;
  let i2 = false;
  const r2 = n2.queries.get(s2);
  if (r2) {
    const t3 = r2.listeners.indexOf(e2);
    t3 >= 0 && (r2.listeners.splice(t3, 1), i2 = 0 === r2.listeners.length);
  }
  if (i2)
    return n2.queries.delete(s2), n2.onUnlisten(s2);
}
function Wu(t2, e2) {
  const n2 = K(t2);
  let s2 = false;
  for (const t3 of e2) {
    const e3 = t3.query, i2 = n2.queries.get(e3);
    if (i2) {
      for (const e4 of i2.listeners)
        e4.Au(t3) && (s2 = true);
      i2.Iu = t3;
    }
  }
  s2 && Hu(n2);
}
function zu(t2, e2, n2) {
  const s2 = K(t2), i2 = s2.queries.get(e2);
  if (i2)
    for (const t3 of i2.listeners)
      t3.onError(n2);
  s2.queries.delete(e2);
}
function Hu(t2) {
  t2.Tu.forEach((t3) => {
    t3.next();
  });
}
class Ju {
  constructor(t2, e2, n2) {
    this.query = t2, this.Ru = e2, this.bu = false, this.Pu = null, this.onlineState = "Unknown", this.options = n2 || {};
  }
  Au(t2) {
    if (!this.options.includeMetadataChanges) {
      const e3 = [];
      for (const n2 of t2.docChanges)
        3 !== n2.type && e3.push(n2);
      t2 = new qu(
        t2.query,
        t2.docs,
        t2.oldDocs,
        e3,
        t2.mutatedKeys,
        t2.fromCache,
        t2.syncStateChanged,
        true
      );
    }
    let e2 = false;
    return this.bu ? this.vu(t2) && (this.Ru.next(t2), e2 = true) : this.Vu(t2, this.onlineState) && (this.Su(t2), e2 = true), this.Pu = t2, e2;
  }
  onError(t2) {
    this.Ru.error(t2);
  }
  Eu(t2) {
    this.onlineState = t2;
    let e2 = false;
    return this.Pu && !this.bu && this.Vu(this.Pu, t2) && (this.Su(this.Pu), e2 = true), e2;
  }
  Vu(t2, e2) {
    if (!t2.fromCache)
      return true;
    const n2 = "Offline" !== e2;
    return (!this.options.Du || !n2) && (!t2.docs.isEmpty() || "Offline" === e2);
  }
  vu(t2) {
    if (t2.docChanges.length > 0)
      return true;
    const e2 = this.Pu && this.Pu.hasPendingWrites !== t2.hasPendingWrites;
    return !(!t2.syncStateChanged && !e2) && true === this.options.includeMetadataChanges;
  }
  Su(t2) {
    t2 = qu.fromInitialDocuments(t2.query, t2.docs, t2.mutatedKeys, t2.fromCache), this.bu = true, this.Ru.next(t2);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ec {
  constructor(t2) {
    this.key = t2;
  }
}
class nc {
  constructor(t2) {
    this.key = t2;
  }
}
class sc {
  constructor(t2, e2) {
    this.query = t2, this.Fu = e2, this.$u = null, this.current = false, this.Bu = ws(), this.mutatedKeys = ws(), this.Lu = yn(t2), this.Uu = new Lu(this.Lu);
  }
  get qu() {
    return this.Fu;
  }
  Ku(t2, e2) {
    const n2 = e2 ? e2.Gu : new Uu(), s2 = e2 ? e2.Uu : this.Uu;
    let i2 = e2 ? e2.mutatedKeys : this.mutatedKeys, r2 = s2, o2 = false;
    const u2 = "F" === this.query.limitType && s2.size === this.query.limit ? s2.last() : null, c2 = "L" === this.query.limitType && s2.size === this.query.limit ? s2.first() : null;
    if (t2.inorderTraversal((t3, e3) => {
      const a2 = s2.get(t3), h2 = mn(this.query, e3) ? e3 : null, l2 = !!a2 && this.mutatedKeys.has(a2.key), f2 = !!h2 && (h2.hasLocalMutations || this.mutatedKeys.has(h2.key) && h2.hasCommittedMutations);
      let d2 = false;
      if (a2 && h2) {
        a2.data.isEqual(h2.data) ? l2 !== f2 && (n2.track({
          type: 3,
          doc: h2
        }), d2 = true) : this.Qu(a2, h2) || (n2.track({
          type: 2,
          doc: h2
        }), d2 = true, (u2 && this.Lu(h2, u2) > 0 || c2 && this.Lu(h2, c2) < 0) && (o2 = true));
      } else
        !a2 && h2 ? (n2.track({
          type: 0,
          doc: h2
        }), d2 = true) : a2 && !h2 && (n2.track({
          type: 1,
          doc: a2
        }), d2 = true, (u2 || c2) && (o2 = true));
      d2 && (h2 ? (r2 = r2.add(h2), i2 = f2 ? i2.add(t3) : i2.delete(t3)) : (r2 = r2.delete(t3), i2 = i2.delete(t3)));
    }), null !== this.query.limit)
      for (; r2.size > this.query.limit; ) {
        const t3 = "F" === this.query.limitType ? r2.last() : r2.first();
        r2 = r2.delete(t3.key), i2 = i2.delete(t3.key), n2.track({
          type: 1,
          doc: t3
        });
      }
    return {
      Uu: r2,
      Gu: n2,
      Oi: o2,
      mutatedKeys: i2
    };
  }
  Qu(t2, e2) {
    return t2.hasLocalMutations && e2.hasCommittedMutations && !e2.hasLocalMutations;
  }
  applyChanges(t2, e2, n2) {
    const s2 = this.Uu;
    this.Uu = t2.Uu, this.mutatedKeys = t2.mutatedKeys;
    const i2 = t2.Gu.pu();
    i2.sort((t3, e3) => function(t4, e4) {
      const n3 = (t5) => {
        switch (t5) {
          case 0:
            return 1;
          case 2:
          case 3:
            return 2;
          case 1:
            return 0;
          default:
            return L();
        }
      };
      return n3(t4) - n3(e4);
    }(t3.type, e3.type) || this.Lu(t3.doc, e3.doc)), this.ju(n2);
    const r2 = e2 ? this.Wu() : [], o2 = 0 === this.Bu.size && this.current ? 1 : 0, u2 = o2 !== this.$u;
    if (this.$u = o2, 0 !== i2.length || u2) {
      return {
        snapshot: new qu(
          this.query,
          t2.Uu,
          s2,
          i2,
          t2.mutatedKeys,
          0 === o2,
          u2,
          false
        ),
        zu: r2
      };
    }
    return {
      zu: r2
    };
  }
  Eu(t2) {
    return this.current && "Offline" === t2 ? (this.current = false, this.applyChanges(
      {
        Uu: this.Uu,
        Gu: new Uu(),
        mutatedKeys: this.mutatedKeys,
        Oi: false
      },
      false
    )) : {
      zu: []
    };
  }
  Hu(t2) {
    return !this.Fu.has(t2) && (!!this.Uu.has(t2) && !this.Uu.get(t2).hasLocalMutations);
  }
  ju(t2) {
    t2 && (t2.addedDocuments.forEach((t3) => this.Fu = this.Fu.add(t3)), t2.modifiedDocuments.forEach((t3) => {
    }), t2.removedDocuments.forEach((t3) => this.Fu = this.Fu.delete(t3)), this.current = t2.current);
  }
  Wu() {
    if (!this.current)
      return [];
    const t2 = this.Bu;
    this.Bu = ws(), this.Uu.forEach((t3) => {
      this.Hu(t3.key) && (this.Bu = this.Bu.add(t3.key));
    });
    const e2 = [];
    return t2.forEach((t3) => {
      this.Bu.has(t3) || e2.push(new nc(t3));
    }), this.Bu.forEach((n2) => {
      t2.has(n2) || e2.push(new ec(n2));
    }), e2;
  }
  Ju(t2) {
    this.Fu = t2.ji, this.Bu = ws();
    const e2 = this.Ku(t2.documents);
    return this.applyChanges(e2, true);
  }
  Yu() {
    return qu.fromInitialDocuments(this.query, this.Uu, this.mutatedKeys, 0 === this.$u);
  }
}
class ic {
  constructor(t2, e2, n2) {
    this.query = t2, this.targetId = e2, this.view = n2;
  }
}
class rc {
  constructor(t2) {
    this.key = t2, this.Xu = false;
  }
}
class oc {
  constructor(t2, e2, n2, s2, i2, r2) {
    this.localStore = t2, this.remoteStore = e2, this.eventManager = n2, this.sharedClientState = s2, this.currentUser = i2, this.maxConcurrentLimboResolutions = r2, this.Zu = {}, this.tc = new is((t3) => _n(t3), dn), this.ec = /* @__PURE__ */ new Map(), this.nc = /* @__PURE__ */ new Set(), this.sc = new qt(dt.comparator), this.ic = /* @__PURE__ */ new Map(), this.rc = new io(), this.oc = {}, this.uc = /* @__PURE__ */ new Map(), this.cc = kr.Rn(), this.onlineState = "Unknown", this.ac = void 0;
  }
  get isPrimaryClient() {
    return true === this.ac;
  }
}
async function uc(t2, e2) {
  const n2 = Mc(t2);
  let s2, i2;
  const r2 = n2.tc.get(e2);
  if (r2)
    s2 = r2.targetId, n2.sharedClientState.addLocalQueryTarget(s2), i2 = r2.view.Yu();
  else {
    const t3 = await Co(n2.localStore, ln(e2));
    n2.isPrimaryClient && fu(n2.remoteStore, t3);
    const r3 = n2.sharedClientState.addLocalQueryTarget(t3.targetId);
    s2 = t3.targetId, i2 = await cc(n2, e2, s2, "current" === r3);
  }
  return i2;
}
async function cc(t2, e2, n2, s2) {
  t2.hc = (e3, n3, s3) => async function(t3, e4, n4, s4) {
    let i3 = e4.view.Ku(n4);
    i3.Oi && (i3 = await No(
      t3.localStore,
      e4.query,
      false
    ).then(({ documents: t4 }) => e4.view.Ku(t4, i3)));
    const r3 = s4 && s4.targetChanges.get(e4.targetId), o3 = e4.view.applyChanges(
      i3,
      t3.isPrimaryClient,
      r3
    );
    return Tc(t3, e4.targetId, o3.zu), o3.snapshot;
  }(t2, e3, n3, s3);
  const i2 = await No(
    t2.localStore,
    e2,
    true
  ), r2 = new sc(e2, i2.ji), o2 = r2.Ku(i2.documents), u2 = ps.createSynthesizedTargetChangeForCurrentChange(n2, s2 && "Offline" !== t2.onlineState), c2 = r2.applyChanges(
    o2,
    t2.isPrimaryClient,
    u2
  );
  Tc(t2, n2, c2.zu);
  const a2 = new ic(e2, n2, r2);
  return t2.tc.set(e2, a2), t2.ec.has(n2) ? t2.ec.get(n2).push(e2) : t2.ec.set(n2, [e2]), c2.snapshot;
}
async function ac(t2, e2) {
  const n2 = K(t2), s2 = n2.tc.get(e2), i2 = n2.ec.get(s2.targetId);
  if (i2.length > 1)
    return n2.ec.set(s2.targetId, i2.filter((t3) => !dn(t3, e2))), void n2.tc.delete(e2);
  if (n2.isPrimaryClient) {
    n2.sharedClientState.removeLocalQueryTarget(s2.targetId);
    n2.sharedClientState.isActiveQueryTarget(s2.targetId) || await xo(
      n2.localStore,
      s2.targetId,
      false
    ).then(() => {
      n2.sharedClientState.clearQueryState(s2.targetId), du(n2.remoteStore, s2.targetId), pc(n2, s2.targetId);
    }).catch(bt);
  } else
    pc(n2, s2.targetId), await xo(
      n2.localStore,
      s2.targetId,
      true
    );
}
async function hc(t2, e2, n2) {
  const s2 = Fc(t2);
  try {
    const t3 = await function(t4, e3) {
      const n3 = K(t4), s3 = ut.now(), i2 = e3.reduce((t5, e4) => t5.add(e4.key), ws());
      let r2, o2;
      return n3.persistence.runTransaction("Locally write mutations", "readwrite", (t5) => {
        let u2 = os(), c2 = ws();
        return n3.Ui.getEntries(t5, i2).next((t6) => {
          u2 = t6, u2.forEach((t7, e4) => {
            e4.isValidDocument() || (c2 = c2.add(t7));
          });
        }).next(() => n3.localDocuments.getOverlayedDocuments(t5, u2)).next((i3) => {
          r2 = i3;
          const o3 = [];
          for (const t6 of e3) {
            const e4 = Gn(t6, r2.get(t6.key).overlayedDocument);
            null != e4 && o3.push(new Wn(t6.key, e4, Ce(e4.value.mapValue), $n.exists(true)));
          }
          return n3.mutationQueue.addMutationBatch(t5, s3, o3, e3);
        }).next((e4) => {
          o2 = e4;
          const s4 = e4.applyToLocalDocumentSet(r2, c2);
          return n3.documentOverlayCache.saveOverlays(t5, e4.batchId, s4);
        });
      }).then(() => ({
        batchId: o2.batchId,
        changes: as(r2)
      }));
    }(s2.localStore, e2);
    s2.sharedClientState.addPendingMutation(t3.batchId), function(t4, e3, n3) {
      let s3 = t4.oc[t4.currentUser.toKey()];
      s3 || (s3 = new qt(it));
      s3 = s3.insert(e3, n3), t4.oc[t4.currentUser.toKey()] = s3;
    }(s2, t3.batchId, n2), await Rc(s2, t3.changes), await bu(s2.remoteStore);
  } catch (t3) {
    const e3 = Bu(t3, "Failed to persist write");
    n2.reject(e3);
  }
}
async function lc(t2, e2) {
  const n2 = K(t2);
  try {
    const t3 = await Vo(n2.localStore, e2);
    e2.targetChanges.forEach((t4, e3) => {
      const s2 = n2.ic.get(e3);
      s2 && (U(t4.addedDocuments.size + t4.modifiedDocuments.size + t4.removedDocuments.size <= 1), t4.addedDocuments.size > 0 ? s2.Xu = true : t4.modifiedDocuments.size > 0 ? U(s2.Xu) : t4.removedDocuments.size > 0 && (U(s2.Xu), s2.Xu = false));
    }), await Rc(n2, t3, e2);
  } catch (t3) {
    await bt(t3);
  }
}
function fc(t2, e2, n2) {
  const s2 = K(t2);
  if (s2.isPrimaryClient && 0 === n2 || !s2.isPrimaryClient && 1 === n2) {
    const t3 = [];
    s2.tc.forEach((n3, s3) => {
      const i2 = s3.view.Eu(e2);
      i2.snapshot && t3.push(i2.snapshot);
    }), function(t4, e3) {
      const n3 = K(t4);
      n3.onlineState = e3;
      let s3 = false;
      n3.queries.forEach((t5, n4) => {
        for (const t6 of n4.listeners)
          t6.Eu(e3) && (s3 = true);
      }), s3 && Hu(n3);
    }(s2.eventManager, e2), t3.length && s2.Zu.Go(t3), s2.onlineState = e2, s2.isPrimaryClient && s2.sharedClientState.setOnlineState(e2);
  }
}
async function dc(t2, e2, n2) {
  const s2 = K(t2);
  s2.sharedClientState.updateQueryState(e2, "rejected", n2);
  const i2 = s2.ic.get(e2), r2 = i2 && i2.key;
  if (r2) {
    let t3 = new qt(dt.comparator);
    t3 = t3.insert(r2, xe.newNoDocument(r2, ct.min()));
    const n3 = ws().add(r2), i3 = new ys(
      ct.min(),
      /* @__PURE__ */ new Map(),
      new Qt(it),
      t3,
      n3
    );
    await lc(s2, i3), s2.sc = s2.sc.remove(r2), s2.ic.delete(e2), Ac(s2);
  } else
    await xo(
      s2.localStore,
      e2,
      false
    ).then(() => pc(s2, e2, n2)).catch(bt);
}
async function _c(t2, e2) {
  const n2 = K(t2), s2 = e2.batch.batchId;
  try {
    const t3 = await Po(n2.localStore, e2);
    yc(n2, s2, null), gc(n2, s2), n2.sharedClientState.updateMutationState(s2, "acknowledged"), await Rc(n2, t3);
  } catch (t3) {
    await bt(t3);
  }
}
async function wc(t2, e2, n2) {
  const s2 = K(t2);
  try {
    const t3 = await function(t4, e3) {
      const n3 = K(t4);
      return n3.persistence.runTransaction("Reject batch", "readwrite-primary", (t5) => {
        let s3;
        return n3.mutationQueue.lookupMutationBatch(t5, e3).next((e4) => (U(null !== e4), s3 = e4.keys(), n3.mutationQueue.removeMutationBatch(t5, e4))).next(() => n3.mutationQueue.performConsistencyCheck(t5)).next(() => n3.documentOverlayCache.removeOverlaysForBatchId(t5, s3, e3)).next(() => n3.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(t5, s3)).next(() => n3.localDocuments.getDocuments(t5, s3));
      });
    }(s2.localStore, e2);
    yc(s2, e2, n2), gc(s2, e2), s2.sharedClientState.updateMutationState(e2, "rejected", n2), await Rc(s2, t3);
  } catch (n3) {
    await bt(n3);
  }
}
function gc(t2, e2) {
  (t2.uc.get(e2) || []).forEach((t3) => {
    t3.resolve();
  }), t2.uc.delete(e2);
}
function yc(t2, e2, n2) {
  const s2 = K(t2);
  let i2 = s2.oc[s2.currentUser.toKey()];
  if (i2) {
    const t3 = i2.get(e2);
    t3 && (n2 ? t3.reject(n2) : t3.resolve(), i2 = i2.remove(e2)), s2.oc[s2.currentUser.toKey()] = i2;
  }
}
function pc(t2, e2, n2 = null) {
  t2.sharedClientState.removeLocalQueryTarget(e2);
  for (const s2 of t2.ec.get(e2))
    t2.tc.delete(s2), n2 && t2.Zu.lc(s2, n2);
  if (t2.ec.delete(e2), t2.isPrimaryClient) {
    t2.rc.us(e2).forEach((e3) => {
      t2.rc.containsKey(e3) || Ic(t2, e3);
    });
  }
}
function Ic(t2, e2) {
  t2.nc.delete(e2.path.canonicalString());
  const n2 = t2.sc.get(e2);
  null !== n2 && (du(t2.remoteStore, n2), t2.sc = t2.sc.remove(e2), t2.ic.delete(n2), Ac(t2));
}
function Tc(t2, e2, n2) {
  for (const s2 of n2)
    if (s2 instanceof ec)
      t2.rc.addReference(s2.key, e2), Ec(t2, s2);
    else if (s2 instanceof nc) {
      M("SyncEngine", "Document no longer in limbo: " + s2.key), t2.rc.removeReference(s2.key, e2);
      t2.rc.containsKey(s2.key) || Ic(t2, s2.key);
    } else
      L();
}
function Ec(t2, e2) {
  const n2 = e2.key, s2 = n2.path.canonicalString();
  t2.sc.get(n2) || t2.nc.has(s2) || (M("SyncEngine", "New document in limbo: " + n2), t2.nc.add(s2), Ac(t2));
}
function Ac(t2) {
  for (; t2.nc.size > 0 && t2.sc.size < t2.maxConcurrentLimboResolutions; ) {
    const e2 = t2.nc.values().next().value;
    t2.nc.delete(e2);
    const n2 = new dt(ht.fromString(e2)), s2 = t2.cc.next();
    t2.ic.set(s2, new rc(n2)), t2.sc = t2.sc.insert(n2, s2), fu(t2.remoteStore, new Li(ln(rn(n2.path)), s2, 2, $t.ot));
  }
}
async function Rc(t2, e2, n2) {
  const s2 = K(t2), i2 = [], r2 = [], o2 = [];
  s2.tc.isEmpty() || (s2.tc.forEach((t3, u2) => {
    o2.push(s2.hc(u2, e2, n2).then((t4) => {
      if (t4) {
        s2.isPrimaryClient && s2.sharedClientState.updateQueryState(u2.targetId, t4.fromCache ? "not-current" : "current"), i2.push(t4);
        const e3 = To.Vi(u2.targetId, t4);
        r2.push(e3);
      }
    }));
  }), await Promise.all(o2), s2.Zu.Go(i2), await async function(t3, e3) {
    const n3 = K(t3);
    try {
      await n3.persistence.runTransaction("notifyLocalViewChanges", "readwrite", (t4) => Pt.forEach(e3, (e4) => Pt.forEach(e4.Pi, (s3) => n3.persistence.referenceDelegate.addReference(t4, e4.targetId, s3)).next(() => Pt.forEach(e4.vi, (s3) => n3.persistence.referenceDelegate.removeReference(t4, e4.targetId, s3)))));
    } catch (t4) {
      if (!Ct(t4))
        throw t4;
      M("LocalStore", "Failed to update sequence numbers: " + t4);
    }
    for (const t4 of e3) {
      const e4 = t4.targetId;
      if (!t4.fromCache) {
        const t5 = n3.$i.get(e4), s3 = t5.snapshotVersion, i3 = t5.withLastLimboFreeSnapshotVersion(s3);
        n3.$i = n3.$i.insert(e4, i3);
      }
    }
  }(s2.localStore, r2));
}
async function bc(t2, e2) {
  const n2 = K(t2);
  if (!n2.currentUser.isEqual(e2)) {
    M("SyncEngine", "User change. New user:", e2.toKey());
    const t3 = await bo(n2.localStore, e2);
    n2.currentUser = e2, function(t4, e3) {
      t4.uc.forEach((t5) => {
        t5.forEach((t6) => {
          t6.reject(new Q(G.CANCELLED, e3));
        });
      }), t4.uc.clear();
    }(n2, "'waitForPendingWrites' promise is rejected due to a user change."), n2.sharedClientState.handleUserChange(e2, t3.removedBatchIds, t3.addedBatchIds), await Rc(n2, t3.Ki);
  }
}
function Pc(t2, e2) {
  const n2 = K(t2), s2 = n2.ic.get(e2);
  if (s2 && s2.Xu)
    return ws().add(s2.key);
  {
    let t3 = ws();
    const s3 = n2.ec.get(e2);
    if (!s3)
      return t3;
    for (const e3 of s3) {
      const s4 = n2.tc.get(e3);
      t3 = t3.unionWith(s4.view.qu);
    }
    return t3;
  }
}
function Mc(t2) {
  const e2 = K(t2);
  return e2.remoteStore.remoteSyncer.applyRemoteEvent = lc.bind(null, e2), e2.remoteStore.remoteSyncer.getRemoteKeysForTarget = Pc.bind(null, e2), e2.remoteStore.remoteSyncer.rejectListen = dc.bind(null, e2), e2.Zu.Go = Wu.bind(null, e2.eventManager), e2.Zu.lc = zu.bind(null, e2.eventManager), e2;
}
function Fc(t2) {
  const e2 = K(t2);
  return e2.remoteStore.remoteSyncer.applySuccessfulWrite = _c.bind(null, e2), e2.remoteStore.remoteSyncer.rejectFailedWrite = wc.bind(null, e2), e2;
}
class Bc {
  constructor() {
    this.synchronizeTabs = false;
  }
  async initialize(t2) {
    this.wt = nu(t2.databaseInfo.databaseId), this.sharedClientState = this.dc(t2), this.persistence = this._c(t2), await this.persistence.start(), this.localStore = this.wc(t2), this.gcScheduler = this.mc(t2, this.localStore), this.indexBackfillerScheduler = this.gc(t2, this.localStore);
  }
  mc(t2, e2) {
    return null;
  }
  gc(t2, e2) {
    return null;
  }
  wc(t2) {
    return Ro(this.persistence, new Eo(), t2.initialUser, this.wt);
  }
  _c(t2) {
    return new ho(fo.Ms, this.wt);
  }
  dc(t2) {
    return new zo();
  }
  async terminate() {
    this.gcScheduler && this.gcScheduler.stop(), await this.sharedClientState.shutdown(), await this.persistence.shutdown();
  }
}
class qc {
  async initialize(t2, e2) {
    this.localStore || (this.localStore = t2.localStore, this.sharedClientState = t2.sharedClientState, this.datastore = this.createDatastore(e2), this.remoteStore = this.createRemoteStore(e2), this.eventManager = this.createEventManager(e2), this.syncEngine = this.createSyncEngine(
      e2,
      !t2.synchronizeTabs
    ), this.sharedClientState.onlineStateHandler = (t3) => fc(this.syncEngine, t3, 1), this.remoteStore.remoteSyncer.handleCredentialChange = bc.bind(null, this.syncEngine), await Ou(this.remoteStore, this.syncEngine.isPrimaryClient));
  }
  createEventManager(t2) {
    return new Gu();
  }
  createDatastore(t2) {
    const e2 = nu(t2.databaseInfo.databaseId), n2 = (s2 = t2.databaseInfo, new Zo(s2));
    var s2;
    return function(t3, e3, n3, s3) {
      return new uu(t3, e3, n3, s3);
    }(t2.authCredentials, t2.appCheckCredentials, n2, e2);
  }
  createRemoteStore(t2) {
    return e2 = this.localStore, n2 = this.datastore, s2 = t2.asyncQueue, i2 = (t3) => fc(this.syncEngine, t3, 0), r2 = Jo.V() ? new Jo() : new Ho(), new au(e2, n2, s2, i2, r2);
    var e2, n2, s2, i2, r2;
  }
  createSyncEngine(t2, e2) {
    return function(t3, e3, n2, s2, i2, r2, o2) {
      const u2 = new oc(t3, e3, n2, s2, i2, r2);
      return o2 && (u2.ac = true), u2;
    }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, t2.initialUser, t2.maxConcurrentLimboResolutions, e2);
  }
  terminate() {
    return async function(t2) {
      const e2 = K(t2);
      M("RemoteStore", "RemoteStore shutting down."), e2.lu.add(5), await lu(e2), e2.du.shutdown(), e2._u.set("Unknown");
    }(this.remoteStore);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Gc {
  constructor(t2) {
    this.observer = t2, this.muted = false;
  }
  next(t2) {
    this.observer.next && this.Ic(this.observer.next, t2);
  }
  error(t2) {
    this.observer.error ? this.Ic(this.observer.error, t2) : console.error("Uncaught Error in snapshot listener:", t2);
  }
  Tc() {
    this.muted = true;
  }
  Ic(t2, e2) {
    this.muted || setTimeout(() => {
      this.muted || t2(e2);
    }, 0);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class zc {
  constructor(t2, e2, n2, s2) {
    this.authCredentials = t2, this.appCheckCredentials = e2, this.asyncQueue = n2, this.databaseInfo = s2, this.user = C.UNAUTHENTICATED, this.clientId = st.I(), this.authCredentialListener = () => Promise.resolve(), this.appCheckCredentialListener = () => Promise.resolve(), this.authCredentials.start(n2, async (t3) => {
      M("FirestoreClient", "Received user=", t3.uid), await this.authCredentialListener(t3), this.user = t3;
    }), this.appCheckCredentials.start(n2, (t3) => (M("FirestoreClient", "Received new app check token=", t3), this.appCheckCredentialListener(t3, this.user)));
  }
  async getConfiguration() {
    return {
      asyncQueue: this.asyncQueue,
      databaseInfo: this.databaseInfo,
      clientId: this.clientId,
      authCredentials: this.authCredentials,
      appCheckCredentials: this.appCheckCredentials,
      initialUser: this.user,
      maxConcurrentLimboResolutions: 100
    };
  }
  setCredentialChangeListener(t2) {
    this.authCredentialListener = t2;
  }
  setAppCheckTokenChangeListener(t2) {
    this.appCheckCredentialListener = t2;
  }
  verifyNotTerminated() {
    if (this.asyncQueue.isShuttingDown)
      throw new Q(G.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  terminate() {
    this.asyncQueue.enterRestrictedMode();
    const t2 = new j();
    return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
      try {
        this.onlineComponents && await this.onlineComponents.terminate(), this.offlineComponents && await this.offlineComponents.terminate(), this.authCredentials.shutdown(), this.appCheckCredentials.shutdown(), t2.resolve();
      } catch (e2) {
        const n2 = Bu(e2, "Failed to shutdown persistence");
        t2.reject(n2);
      }
    }), t2.promise;
  }
}
async function Hc(t2, e2) {
  t2.asyncQueue.verifyOperationInProgress(), M("FirestoreClient", "Initializing OfflineComponentProvider");
  const n2 = await t2.getConfiguration();
  await e2.initialize(n2);
  let s2 = n2.initialUser;
  t2.setCredentialChangeListener(async (t3) => {
    s2.isEqual(t3) || (await bo(e2.localStore, t3), s2 = t3);
  }), e2.persistence.setDatabaseDeletedListener(() => t2.terminate()), t2.offlineComponents = e2;
}
async function Jc(t2, e2) {
  t2.asyncQueue.verifyOperationInProgress();
  const n2 = await Yc(t2);
  M("FirestoreClient", "Initializing OnlineComponentProvider");
  const s2 = await t2.getConfiguration();
  await e2.initialize(n2, s2), t2.setCredentialChangeListener((t3) => ku(e2.remoteStore, t3)), t2.setAppCheckTokenChangeListener((t3, n3) => ku(e2.remoteStore, n3)), t2.onlineComponents = e2;
}
async function Yc(t2) {
  return t2.offlineComponents || (M("FirestoreClient", "Using default OfflineComponentProvider"), await Hc(t2, new Bc())), t2.offlineComponents;
}
async function Xc(t2) {
  return t2.onlineComponents || (M("FirestoreClient", "Using default OnlineComponentProvider"), await Jc(t2, new qc())), t2.onlineComponents;
}
function na(t2) {
  return Xc(t2).then((t3) => t3.syncEngine);
}
async function sa(t2) {
  const e2 = await Xc(t2), n2 = e2.eventManager;
  return n2.onListen = uc.bind(null, e2.syncEngine), n2.onUnlisten = ac.bind(null, e2.syncEngine), n2;
}
function aa(t2, e2, n2 = {}) {
  const s2 = new j();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e3, n3, s3, i2) {
    const r2 = new Gc({
      next: (n4) => {
        e3.enqueueAndForget(() => ju(t3, o2)), n4.fromCache && "server" === s3.source ? i2.reject(new Q(G.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : i2.resolve(n4);
      },
      error: (t4) => i2.reject(t4)
    }), o2 = new Ju(n3, r2, {
      includeMetadataChanges: true,
      Du: true
    });
    return Qu(t3, o2);
  }(await sa(t2), t2.asyncQueue, e2, n2, s2)), s2.promise;
}
const _a = /* @__PURE__ */ new Map();
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function wa(t2, e2, n2) {
  if (!n2)
    throw new Q(G.INVALID_ARGUMENT, `Function ${t2}() cannot be called with an empty ${e2}.`);
}
function ma(t2, e2, n2, s2) {
  if (true === e2 && true === s2)
    throw new Q(G.INVALID_ARGUMENT, `${t2} and ${n2} cannot be used together.`);
}
function ga(t2) {
  if (!dt.isDocumentKey(t2))
    throw new Q(G.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${t2} has ${t2.length}.`);
}
function ya(t2) {
  if (dt.isDocumentKey(t2))
    throw new Q(G.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${t2} has ${t2.length}.`);
}
function pa(t2) {
  if (void 0 === t2)
    return "undefined";
  if (null === t2)
    return "null";
  if ("string" == typeof t2)
    return t2.length > 20 && (t2 = `${t2.substring(0, 20)}...`), JSON.stringify(t2);
  if ("number" == typeof t2 || "boolean" == typeof t2)
    return "" + t2;
  if ("object" == typeof t2) {
    if (t2 instanceof Array)
      return "an array";
    {
      const e2 = function(t3) {
        if (t3.constructor)
          return t3.constructor.name;
        return null;
      }(t2);
      return e2 ? `a custom ${e2} object` : "an object";
    }
  }
  return "function" == typeof t2 ? "a function" : L();
}
function Ia(t2, e2) {
  if ("_delegate" in t2 && (t2 = t2._delegate), !(t2 instanceof e2)) {
    if (e2.name === t2.constructor.name)
      throw new Q(G.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
    {
      const n2 = pa(t2);
      throw new Q(G.INVALID_ARGUMENT, `Expected type '${e2.name}', but it was: ${n2}`);
    }
  }
  return t2;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ea {
  constructor(t2) {
    var e2;
    if (void 0 === t2.host) {
      if (void 0 !== t2.ssl)
        throw new Q(G.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
      this.host = "firestore.googleapis.com", this.ssl = true;
    } else
      this.host = t2.host, this.ssl = null === (e2 = t2.ssl) || void 0 === e2 || e2;
    if (this.credentials = t2.credentials, this.ignoreUndefinedProperties = !!t2.ignoreUndefinedProperties, void 0 === t2.cacheSizeBytes)
      this.cacheSizeBytes = 41943040;
    else {
      if (-1 !== t2.cacheSizeBytes && t2.cacheSizeBytes < 1048576)
        throw new Q(G.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
      this.cacheSizeBytes = t2.cacheSizeBytes;
    }
    this.experimentalForceLongPolling = !!t2.experimentalForceLongPolling, this.experimentalAutoDetectLongPolling = !!t2.experimentalAutoDetectLongPolling, this.useFetchStreams = !!t2.useFetchStreams, ma("experimentalForceLongPolling", t2.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", t2.experimentalAutoDetectLongPolling);
  }
  isEqual(t2) {
    return this.host === t2.host && this.ssl === t2.ssl && this.credentials === t2.credentials && this.cacheSizeBytes === t2.cacheSizeBytes && this.experimentalForceLongPolling === t2.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === t2.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === t2.ignoreUndefinedProperties && this.useFetchStreams === t2.useFetchStreams;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Aa {
  constructor(t2, e2, n2) {
    this._authCredentials = e2, this._appCheckCredentials = n2, this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new Ea({}), this._settingsFrozen = false, t2 instanceof re ? this._databaseId = t2 : (this._app = t2, this._databaseId = function(t3) {
      if (!Object.prototype.hasOwnProperty.apply(t3.options, ["projectId"]))
        throw new Q(G.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
      return new re(t3.options.projectId);
    }(t2));
  }
  get app() {
    if (!this._app)
      throw new Q(G.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    return this._app;
  }
  get _initialized() {
    return this._settingsFrozen;
  }
  get _terminated() {
    return void 0 !== this._terminateTask;
  }
  _setSettings(t2) {
    if (this._settingsFrozen)
      throw new Q(G.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
    this._settings = new Ea(t2), void 0 !== t2.credentials && (this._authCredentials = function(t3) {
      if (!t3)
        return new z();
      switch (t3.type) {
        case "gapi":
          const e2 = t3.client;
          return U(!("object" != typeof e2 || null === e2 || !e2.auth || !e2.auth.getAuthHeaderValueForFirstParty)), new X(e2, t3.sessionIndex || "0", t3.iamToken || null);
        case "provider":
          return t3.client;
        default:
          throw new Q(G.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type");
      }
    }(t2.credentials));
  }
  _getSettings() {
    return this._settings;
  }
  _freezeSettings() {
    return this._settingsFrozen = true, this._settings;
  }
  _delete() {
    return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;
  }
  toJSON() {
    return {
      app: this._app,
      databaseId: this._databaseId,
      settings: this._settings
    };
  }
  _terminate() {
    return function(t2) {
      const e2 = _a.get(t2);
      e2 && (M("ComponentProvider", "Removing Datastore"), _a.delete(t2), e2.terminate());
    }(this), Promise.resolve();
  }
}
function Ra(t2, e2, n2, s2 = {}) {
  var i2;
  const r2 = (t2 = Ia(t2, Aa))._getSettings();
  if ("firestore.googleapis.com" !== r2.host && r2.host !== e2 && $("Host has been set in both settings() and useEmulator(), emulator host will be used"), t2._setSettings(Object.assign(Object.assign({}, r2), {
    host: `${e2}:${n2}`,
    ssl: false
  })), s2.mockUserToken) {
    let e3, n3;
    if ("string" == typeof s2.mockUserToken)
      e3 = s2.mockUserToken, n3 = C.MOCK_USER;
    else {
      e3 = createMockUserToken(s2.mockUserToken, null === (i2 = t2._app) || void 0 === i2 ? void 0 : i2.options.projectId);
      const r3 = s2.mockUserToken.sub || s2.mockUserToken.user_id;
      if (!r3)
        throw new Q(G.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
      n3 = new C(r3);
    }
    t2._authCredentials = new H(new W(e3, n3));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ba {
  constructor(t2, e2, n2) {
    this.converter = e2, this._key = n2, this.type = "document", this.firestore = t2;
  }
  get _path() {
    return this._key.path;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get path() {
    return this._key.path.canonicalString();
  }
  get parent() {
    return new va(this.firestore, this.converter, this._key.path.popLast());
  }
  withConverter(t2) {
    return new ba(this.firestore, t2, this._key);
  }
}
class Pa {
  constructor(t2, e2, n2) {
    this.converter = e2, this._query = n2, this.type = "query", this.firestore = t2;
  }
  withConverter(t2) {
    return new Pa(this.firestore, t2, this._query);
  }
}
class va extends Pa {
  constructor(t2, e2, n2) {
    super(t2, e2, rn(n2)), this._path = n2, this.type = "collection";
  }
  get id() {
    return this._query.path.lastSegment();
  }
  get path() {
    return this._query.path.canonicalString();
  }
  get parent() {
    const t2 = this._path.popLast();
    return t2.isEmpty() ? null : new ba(
      this.firestore,
      null,
      new dt(t2)
    );
  }
  withConverter(t2) {
    return new va(this.firestore, t2, this._path);
  }
}
function Va(t2, e2, ...n2) {
  if (t2 = getModularInstance(t2), wa("collection", "path", e2), t2 instanceof Aa) {
    const s2 = ht.fromString(e2, ...n2);
    return ya(s2), new va(t2, null, s2);
  }
  {
    if (!(t2 instanceof ba || t2 instanceof va))
      throw new Q(G.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s2 = t2._path.child(ht.fromString(e2, ...n2));
    return ya(s2), new va(
      t2.firestore,
      null,
      s2
    );
  }
}
function Da(t2, e2, ...n2) {
  if (t2 = getModularInstance(t2), 1 === arguments.length && (e2 = st.I()), wa("doc", "path", e2), t2 instanceof Aa) {
    const s2 = ht.fromString(e2, ...n2);
    return ga(s2), new ba(
      t2,
      null,
      new dt(s2)
    );
  }
  {
    if (!(t2 instanceof ba || t2 instanceof va))
      throw new Q(G.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s2 = t2._path.child(ht.fromString(e2, ...n2));
    return ga(s2), new ba(t2.firestore, t2 instanceof va ? t2.converter : null, new dt(s2));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Na {
  constructor() {
    this.Oc = Promise.resolve(), this.Mc = [], this.Fc = false, this.$c = [], this.Bc = null, this.Lc = false, this.Uc = false, this.qc = [], this.So = new su(this, "async_queue_retry"), this.Kc = () => {
      const t3 = eu();
      t3 && M("AsyncQueue", "Visibility state changed to " + t3.visibilityState), this.So.Eo();
    };
    const t2 = eu();
    t2 && "function" == typeof t2.addEventListener && t2.addEventListener("visibilitychange", this.Kc);
  }
  get isShuttingDown() {
    return this.Fc;
  }
  enqueueAndForget(t2) {
    this.enqueue(t2);
  }
  enqueueAndForgetEvenWhileRestricted(t2) {
    this.Gc(), this.Qc(t2);
  }
  enterRestrictedMode(t2) {
    if (!this.Fc) {
      this.Fc = true, this.Uc = t2 || false;
      const e2 = eu();
      e2 && "function" == typeof e2.removeEventListener && e2.removeEventListener("visibilitychange", this.Kc);
    }
  }
  enqueue(t2) {
    if (this.Gc(), this.Fc)
      return new Promise(() => {
      });
    const e2 = new j();
    return this.Qc(() => this.Fc && this.Uc ? Promise.resolve() : (t2().then(e2.resolve, e2.reject), e2.promise)).then(() => e2.promise);
  }
  enqueueRetryable(t2) {
    this.enqueueAndForget(() => (this.Mc.push(t2), this.jc()));
  }
  async jc() {
    if (0 !== this.Mc.length) {
      try {
        await this.Mc[0](), this.Mc.shift(), this.So.reset();
      } catch (t2) {
        if (!Ct(t2))
          throw t2;
        M("AsyncQueue", "Operation failed with retryable error: " + t2);
      }
      this.Mc.length > 0 && this.So.Io(() => this.jc());
    }
  }
  Qc(t2) {
    const e2 = this.Oc.then(() => (this.Lc = true, t2().catch((t3) => {
      this.Bc = t3, this.Lc = false;
      const e3 = function(t4) {
        let e4 = t4.message || "";
        t4.stack && (e4 = t4.stack.includes(t4.message) ? t4.stack : t4.message + "\n" + t4.stack);
        return e4;
      }(t3);
      throw F("INTERNAL UNHANDLED ERROR: ", e3), t3;
    }).then((t3) => (this.Lc = false, t3))));
    return this.Oc = e2, e2;
  }
  enqueueAfterDelay(t2, e2, n2) {
    this.Gc(), this.qc.indexOf(t2) > -1 && (e2 = 0);
    const s2 = $u.createAndSchedule(this, t2, e2, n2, (t3) => this.Wc(t3));
    return this.$c.push(s2), s2;
  }
  Gc() {
    this.Bc && L();
  }
  verifyOperationInProgress() {
  }
  async zc() {
    let t2;
    do {
      t2 = this.Oc, await t2;
    } while (t2 !== this.Oc);
  }
  Hc(t2) {
    for (const e2 of this.$c)
      if (e2.timerId === t2)
        return true;
    return false;
  }
  Jc(t2) {
    return this.zc().then(() => {
      this.$c.sort((t3, e2) => t3.targetTimeMs - e2.targetTimeMs);
      for (const e2 of this.$c)
        if (e2.skipDelay(), "all" !== t2 && e2.timerId === t2)
          break;
      return this.zc();
    });
  }
  Yc(t2) {
    this.qc.push(t2);
  }
  Wc(t2) {
    const e2 = this.$c.indexOf(t2);
    this.$c.splice(e2, 1);
  }
}
function ka(t2) {
  return function(t3, e2) {
    if ("object" != typeof t3 || null === t3)
      return false;
    const n2 = t3;
    for (const t4 of e2)
      if (t4 in n2 && "function" == typeof n2[t4])
        return true;
    return false;
  }(t2, ["next", "error", "complete"]);
}
class Fa extends Aa {
  constructor(t2, e2, n2) {
    super(t2, e2, n2), this.type = "firestore", this._queue = new Na(), this._persistenceKey = "name" in t2 ? t2.name : "[DEFAULT]";
  }
  _terminate() {
    return this._firestoreClient || Ua(this), this._firestoreClient.terminate();
  }
}
function $a(t2, e2) {
  const n2 = _getProvider(t2, "firestore");
  if (n2.isInitialized()) {
    const t3 = n2.getImmediate(), s2 = n2.getOptions();
    if (deepEqual(s2, e2))
      return t3;
    throw new Q(G.FAILED_PRECONDITION, "initializeFirestore() has already been called with different options. To avoid this error, call initializeFirestore() with the same options as when it was originally called, or call getFirestore() to return the already initialized instance.");
  }
  if (void 0 !== e2.cacheSizeBytes && -1 !== e2.cacheSizeBytes && e2.cacheSizeBytes < 1048576)
    throw new Q(G.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
  return n2.initialize({
    options: e2
  });
}
function Ba(e2 = getApp()) {
  return _getProvider(e2, "firestore").getImmediate();
}
function La(t2) {
  return t2._firestoreClient || Ua(t2), t2._firestoreClient.verifyNotTerminated(), t2._firestoreClient;
}
function Ua(t2) {
  var e2;
  const n2 = t2._freezeSettings(), s2 = function(t3, e3, n3, s3) {
    return new ie(t3, e3, n3, s3.host, s3.ssl, s3.experimentalForceLongPolling, s3.experimentalAutoDetectLongPolling, s3.useFetchStreams);
  }(t2._databaseId, (null === (e2 = t2._app) || void 0 === e2 ? void 0 : e2.options.appId) || "", t2._persistenceKey, n2);
  t2._firestoreClient = new zc(t2._authCredentials, t2._appCheckCredentials, t2._queue, s2);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Za {
  constructor(...t2) {
    for (let e2 = 0; e2 < t2.length; ++e2)
      if (0 === t2[e2].length)
        throw new Q(G.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
    this._internalPath = new ft(t2);
  }
  isEqual(t2) {
    return this._internalPath.isEqual(t2._internalPath);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class eh {
  constructor(t2) {
    this._byteString = t2;
  }
  static fromBase64String(t2) {
    try {
      return new eh(Jt.fromBase64String(t2));
    } catch (t3) {
      throw new Q(G.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + t3);
    }
  }
  static fromUint8Array(t2) {
    return new eh(Jt.fromUint8Array(t2));
  }
  toBase64() {
    return this._byteString.toBase64();
  }
  toUint8Array() {
    return this._byteString.toUint8Array();
  }
  toString() {
    return "Bytes(base64: " + this.toBase64() + ")";
  }
  isEqual(t2) {
    return this._byteString.isEqual(t2._byteString);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class nh {
  constructor(t2) {
    this._methodName = t2;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class sh {
  constructor(t2, e2) {
    if (!isFinite(t2) || t2 < -90 || t2 > 90)
      throw new Q(G.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + t2);
    if (!isFinite(e2) || e2 < -180 || e2 > 180)
      throw new Q(G.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + e2);
    this._lat = t2, this._long = e2;
  }
  get latitude() {
    return this._lat;
  }
  get longitude() {
    return this._long;
  }
  isEqual(t2) {
    return this._lat === t2._lat && this._long === t2._long;
  }
  toJSON() {
    return {
      latitude: this._lat,
      longitude: this._long
    };
  }
  _compareTo(t2) {
    return it(this._lat, t2._lat) || it(this._long, t2._long);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ih = /^__.*__$/;
class rh {
  constructor(t2, e2, n2) {
    this.data = t2, this.fieldMask = e2, this.fieldTransforms = n2;
  }
  toMutation(t2, e2) {
    return null !== this.fieldMask ? new Wn(t2, this.data, this.fieldMask, e2, this.fieldTransforms) : new jn(t2, this.data, e2, this.fieldTransforms);
  }
}
class oh {
  constructor(t2, e2, n2) {
    this.data = t2, this.fieldMask = e2, this.fieldTransforms = n2;
  }
  toMutation(t2, e2) {
    return new Wn(t2, this.data, this.fieldMask, e2, this.fieldTransforms);
  }
}
function uh(t2) {
  switch (t2) {
    case 0:
    case 2:
    case 1:
      return true;
    case 3:
    case 4:
      return false;
    default:
      throw L();
  }
}
class ch {
  constructor(t2, e2, n2, s2, i2, r2) {
    this.settings = t2, this.databaseId = e2, this.wt = n2, this.ignoreUndefinedProperties = s2, void 0 === i2 && this.Xc(), this.fieldTransforms = i2 || [], this.fieldMask = r2 || [];
  }
  get path() {
    return this.settings.path;
  }
  get Zc() {
    return this.settings.Zc;
  }
  ta(t2) {
    return new ch(Object.assign(Object.assign({}, this.settings), t2), this.databaseId, this.wt, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
  }
  ea(t2) {
    var e2;
    const n2 = null === (e2 = this.path) || void 0 === e2 ? void 0 : e2.child(t2), s2 = this.ta({
      path: n2,
      na: false
    });
    return s2.sa(t2), s2;
  }
  ia(t2) {
    var e2;
    const n2 = null === (e2 = this.path) || void 0 === e2 ? void 0 : e2.child(t2), s2 = this.ta({
      path: n2,
      na: false
    });
    return s2.Xc(), s2;
  }
  ra(t2) {
    return this.ta({
      path: void 0,
      na: true
    });
  }
  oa(t2) {
    return Vh(t2, this.settings.methodName, this.settings.ua || false, this.path, this.settings.ca);
  }
  contains(t2) {
    return void 0 !== this.fieldMask.find((e2) => t2.isPrefixOf(e2)) || void 0 !== this.fieldTransforms.find((e2) => t2.isPrefixOf(e2.field));
  }
  Xc() {
    if (this.path)
      for (let t2 = 0; t2 < this.path.length; t2++)
        this.sa(this.path.get(t2));
  }
  sa(t2) {
    if (0 === t2.length)
      throw this.oa("Document fields must not be empty");
    if (uh(this.Zc) && ih.test(t2))
      throw this.oa('Document fields cannot begin and end with "__"');
  }
}
class ah {
  constructor(t2, e2, n2) {
    this.databaseId = t2, this.ignoreUndefinedProperties = e2, this.wt = n2 || nu(t2);
  }
  aa(t2, e2, n2, s2 = false) {
    return new ch({
      Zc: t2,
      methodName: e2,
      ca: n2,
      path: ft.emptyPath(),
      na: false,
      ua: s2
    }, this.databaseId, this.wt, this.ignoreUndefinedProperties);
  }
}
function hh(t2) {
  const e2 = t2._freezeSettings(), n2 = nu(t2._databaseId);
  return new ah(t2._databaseId, !!e2.ignoreUndefinedProperties, n2);
}
function lh(t2, e2, n2, s2, i2, r2 = {}) {
  const o2 = t2.aa(r2.merge || r2.mergeFields ? 2 : 0, e2, n2, i2);
  Rh("Data must be an object, but it was:", o2, s2);
  const u2 = Eh(s2, o2);
  let c2, a2;
  if (r2.merge)
    c2 = new zt(o2.fieldMask), a2 = o2.fieldTransforms;
  else if (r2.mergeFields) {
    const t3 = [];
    for (const s3 of r2.mergeFields) {
      const i3 = bh(e2, s3, n2);
      if (!o2.contains(i3))
        throw new Q(G.INVALID_ARGUMENT, `Field '${i3}' is specified in your field mask but missing from your input data.`);
      Sh(t3, i3) || t3.push(i3);
    }
    c2 = new zt(t3), a2 = o2.fieldTransforms.filter((t4) => c2.covers(t4.field));
  } else
    c2 = null, a2 = o2.fieldTransforms;
  return new rh(new De(u2), c2, a2);
}
class fh extends nh {
  _toFieldTransform(t2) {
    if (2 !== t2.Zc)
      throw 1 === t2.Zc ? t2.oa(`${this._methodName}() can only appear at the top level of your update data`) : t2.oa(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
    return t2.fieldMask.push(t2.path), null;
  }
  isEqual(t2) {
    return t2 instanceof fh;
  }
}
class _h extends nh {
  _toFieldTransform(t2) {
    return new On(t2.path, new vn());
  }
  isEqual(t2) {
    return t2 instanceof _h;
  }
}
function yh(t2, e2, n2, s2) {
  const i2 = t2.aa(1, e2, n2);
  Rh("Data must be an object, but it was:", i2, s2);
  const r2 = [], o2 = De.empty();
  Lt(s2, (t3, s3) => {
    const u3 = vh(e2, t3, n2);
    s3 = getModularInstance(s3);
    const c2 = i2.ia(u3);
    if (s3 instanceof fh)
      r2.push(u3);
    else {
      const t4 = Th(s3, c2);
      null != t4 && (r2.push(u3), o2.set(u3, t4));
    }
  });
  const u2 = new zt(r2);
  return new oh(o2, u2, i2.fieldTransforms);
}
function ph(t2, e2, n2, s2, i2, r2) {
  const o2 = t2.aa(1, e2, n2), u2 = [bh(e2, s2, n2)], c2 = [i2];
  if (r2.length % 2 != 0)
    throw new Q(G.INVALID_ARGUMENT, `Function ${e2}() needs to be called with an even number of arguments that alternate between field names and values.`);
  for (let t3 = 0; t3 < r2.length; t3 += 2)
    u2.push(bh(e2, r2[t3])), c2.push(r2[t3 + 1]);
  const a2 = [], h2 = De.empty();
  for (let t3 = u2.length - 1; t3 >= 0; --t3)
    if (!Sh(a2, u2[t3])) {
      const e3 = u2[t3];
      let n3 = c2[t3];
      n3 = getModularInstance(n3);
      const s3 = o2.ia(e3);
      if (n3 instanceof fh)
        a2.push(e3);
      else {
        const t4 = Th(n3, s3);
        null != t4 && (a2.push(e3), h2.set(e3, t4));
      }
    }
  const l2 = new zt(a2);
  return new oh(h2, l2, o2.fieldTransforms);
}
function Ih(t2, e2, n2, s2 = false) {
  return Th(n2, t2.aa(s2 ? 4 : 3, e2));
}
function Th(t2, e2) {
  if (Ah(
    t2 = getModularInstance(t2)
  ))
    return Rh("Unsupported field value:", e2, t2), Eh(t2, e2);
  if (t2 instanceof nh)
    return function(t3, e3) {
      if (!uh(e3.Zc))
        throw e3.oa(`${t3._methodName}() can only be used with update() and set()`);
      if (!e3.path)
        throw e3.oa(`${t3._methodName}() is not currently supported inside arrays`);
      const n2 = t3._toFieldTransform(e3);
      n2 && e3.fieldTransforms.push(n2);
    }(t2, e2), null;
  if (void 0 === t2 && e2.ignoreUndefinedProperties)
    return null;
  if (e2.path && e2.fieldMask.push(e2.path), t2 instanceof Array) {
    if (e2.settings.na && 4 !== e2.Zc)
      throw e2.oa("Nested arrays are not supported");
    return function(t3, e3) {
      const n2 = [];
      let s2 = 0;
      for (const i2 of t3) {
        let t4 = Th(i2, e3.ra(s2));
        null == t4 && (t4 = {
          nullValue: "NULL_VALUE"
        }), n2.push(t4), s2++;
      }
      return {
        arrayValue: {
          values: n2
        }
      };
    }(t2, e2);
  }
  return function(t3, e3) {
    if (null === (t3 = getModularInstance(t3)))
      return {
        nullValue: "NULL_VALUE"
      };
    if ("number" == typeof t3)
      return En(e3.wt, t3);
    if ("boolean" == typeof t3)
      return {
        booleanValue: t3
      };
    if ("string" == typeof t3)
      return {
        stringValue: t3
      };
    if (t3 instanceof Date) {
      const n2 = ut.fromDate(t3);
      return {
        timestampValue: Ds(e3.wt, n2)
      };
    }
    if (t3 instanceof ut) {
      const n2 = new ut(t3.seconds, 1e3 * Math.floor(t3.nanoseconds / 1e3));
      return {
        timestampValue: Ds(e3.wt, n2)
      };
    }
    if (t3 instanceof sh)
      return {
        geoPointValue: {
          latitude: t3.latitude,
          longitude: t3.longitude
        }
      };
    if (t3 instanceof eh)
      return {
        bytesValue: Cs(e3.wt, t3._byteString)
      };
    if (t3 instanceof ba) {
      const n2 = e3.databaseId, s2 = t3.firestore._databaseId;
      if (!s2.isEqual(n2))
        throw e3.oa(`Document reference is for database ${s2.projectId}/${s2.database} but should be for database ${n2.projectId}/${n2.database}`);
      return {
        referenceValue: ks(t3.firestore._databaseId || e3.databaseId, t3._key.path)
      };
    }
    throw e3.oa(`Unsupported field value: ${pa(t3)}`);
  }(t2, e2);
}
function Eh(t2, e2) {
  const n2 = {};
  return Ut(t2) ? e2.path && e2.path.length > 0 && e2.fieldMask.push(e2.path) : Lt(t2, (t3, s2) => {
    const i2 = Th(s2, e2.ea(t3));
    null != i2 && (n2[t3] = i2);
  }), {
    mapValue: {
      fields: n2
    }
  };
}
function Ah(t2) {
  return !("object" != typeof t2 || null === t2 || t2 instanceof Array || t2 instanceof Date || t2 instanceof ut || t2 instanceof sh || t2 instanceof eh || t2 instanceof ba || t2 instanceof nh);
}
function Rh(t2, e2, n2) {
  if (!Ah(n2) || !function(t3) {
    return "object" == typeof t3 && null !== t3 && (Object.getPrototypeOf(t3) === Object.prototype || null === Object.getPrototypeOf(t3));
  }(n2)) {
    const s2 = pa(n2);
    throw "an object" === s2 ? e2.oa(t2 + " a custom object") : e2.oa(t2 + " " + s2);
  }
}
function bh(t2, e2, n2) {
  if ((e2 = getModularInstance(e2)) instanceof Za)
    return e2._internalPath;
  if ("string" == typeof e2)
    return vh(t2, e2);
  throw Vh(
    "Field path arguments must be of type string or ",
    t2,
    false,
    void 0,
    n2
  );
}
const Ph = new RegExp("[~\\*/\\[\\]]");
function vh(t2, e2, n2) {
  if (e2.search(Ph) >= 0)
    throw Vh(
      `Invalid field path (${e2}). Paths must not contain '~', '*', '/', '[', or ']'`,
      t2,
      false,
      void 0,
      n2
    );
  try {
    return new Za(...e2.split("."))._internalPath;
  } catch (s2) {
    throw Vh(
      `Invalid field path (${e2}). Paths must not be empty, begin with '.', end with '.', or contain '..'`,
      t2,
      false,
      void 0,
      n2
    );
  }
}
function Vh(t2, e2, n2, s2, i2) {
  const r2 = s2 && !s2.isEmpty(), o2 = void 0 !== i2;
  let u2 = `Function ${e2}() called with invalid data`;
  n2 && (u2 += " (via `toFirestore()`)"), u2 += ". ";
  let c2 = "";
  return (r2 || o2) && (c2 += " (found", r2 && (c2 += ` in field ${s2}`), o2 && (c2 += ` in document ${i2}`), c2 += ")"), new Q(G.INVALID_ARGUMENT, u2 + t2 + c2);
}
function Sh(t2, e2) {
  return t2.some((t3) => t3.isEqual(e2));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Dh {
  constructor(t2, e2, n2, s2, i2) {
    this._firestore = t2, this._userDataWriter = e2, this._key = n2, this._document = s2, this._converter = i2;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get ref() {
    return new ba(this._firestore, this._converter, this._key);
  }
  exists() {
    return null !== this._document;
  }
  data() {
    if (this._document) {
      if (this._converter) {
        const t2 = new Ch(
          this._firestore,
          this._userDataWriter,
          this._key,
          this._document,
          null
        );
        return this._converter.fromFirestore(t2);
      }
      return this._userDataWriter.convertValue(this._document.data.value);
    }
  }
  get(t2) {
    if (this._document) {
      const e2 = this._document.data.field(xh("DocumentSnapshot.get", t2));
      if (null !== e2)
        return this._userDataWriter.convertValue(e2);
    }
  }
}
class Ch extends Dh {
  data() {
    return super.data();
  }
}
function xh(t2, e2) {
  return "string" == typeof e2 ? vh(t2, e2) : e2 instanceof Za ? e2._internalPath : e2._delegate._internalPath;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Nh {
  constructor(t2, e2) {
    this.hasPendingWrites = t2, this.fromCache = e2;
  }
  isEqual(t2) {
    return this.hasPendingWrites === t2.hasPendingWrites && this.fromCache === t2.fromCache;
  }
}
class kh extends Dh {
  constructor(t2, e2, n2, s2, i2, r2) {
    super(t2, e2, n2, s2, r2), this._firestore = t2, this._firestoreImpl = t2, this.metadata = i2;
  }
  exists() {
    return super.exists();
  }
  data(t2 = {}) {
    if (this._document) {
      if (this._converter) {
        const e2 = new Oh(
          this._firestore,
          this._userDataWriter,
          this._key,
          this._document,
          this.metadata,
          null
        );
        return this._converter.fromFirestore(e2, t2);
      }
      return this._userDataWriter.convertValue(this._document.data.value, t2.serverTimestamps);
    }
  }
  get(t2, e2 = {}) {
    if (this._document) {
      const n2 = this._document.data.field(xh("DocumentSnapshot.get", t2));
      if (null !== n2)
        return this._userDataWriter.convertValue(n2, e2.serverTimestamps);
    }
  }
}
class Oh extends kh {
  data(t2 = {}) {
    return super.data(t2);
  }
}
class Mh {
  constructor(t2, e2, n2, s2) {
    this._firestore = t2, this._userDataWriter = e2, this._snapshot = s2, this.metadata = new Nh(s2.hasPendingWrites, s2.fromCache), this.query = n2;
  }
  get docs() {
    const t2 = [];
    return this.forEach((e2) => t2.push(e2)), t2;
  }
  get size() {
    return this._snapshot.docs.size;
  }
  get empty() {
    return 0 === this.size;
  }
  forEach(t2, e2) {
    this._snapshot.docs.forEach((n2) => {
      t2.call(e2, new Oh(this._firestore, this._userDataWriter, n2.key, n2, new Nh(this._snapshot.mutatedKeys.has(n2.key), this._snapshot.fromCache), this.query.converter));
    });
  }
  docChanges(t2 = {}) {
    const e2 = !!t2.includeMetadataChanges;
    if (e2 && this._snapshot.excludesMetadataChanges)
      throw new Q(G.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
    return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === e2 || (this._cachedChanges = function(t3, e3) {
      if (t3._snapshot.oldDocs.isEmpty()) {
        let e4 = 0;
        return t3._snapshot.docChanges.map((n2) => ({
          type: "added",
          doc: new Oh(t3._firestore, t3._userDataWriter, n2.doc.key, n2.doc, new Nh(t3._snapshot.mutatedKeys.has(n2.doc.key), t3._snapshot.fromCache), t3.query.converter),
          oldIndex: -1,
          newIndex: e4++
        }));
      }
      {
        let n2 = t3._snapshot.oldDocs;
        return t3._snapshot.docChanges.filter((t4) => e3 || 3 !== t4.type).map((e4) => {
          const s2 = new Oh(t3._firestore, t3._userDataWriter, e4.doc.key, e4.doc, new Nh(t3._snapshot.mutatedKeys.has(e4.doc.key), t3._snapshot.fromCache), t3.query.converter);
          let i2 = -1, r2 = -1;
          return 0 !== e4.type && (i2 = n2.indexOf(e4.doc.key), n2 = n2.delete(e4.doc.key)), 1 !== e4.type && (n2 = n2.add(e4.doc), r2 = n2.indexOf(e4.doc.key)), {
            type: Fh(e4.type),
            doc: s2,
            oldIndex: i2,
            newIndex: r2
          };
        });
      }
    }(this, e2), this._cachedChangesIncludeMetadataChanges = e2), this._cachedChanges;
  }
}
function Fh(t2) {
  switch (t2) {
    case 0:
      return "added";
    case 2:
    case 3:
      return "modified";
    case 1:
      return "removed";
    default:
      return L();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Bh(t2) {
  if ("L" === t2.limitType && 0 === t2.explicitOrderBy.length)
    throw new Q(G.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause");
}
class Lh {
}
function Uh(t2, ...e2) {
  for (const n2 of e2)
    t2 = n2._apply(t2);
  return t2;
}
class qh extends Lh {
  constructor(t2, e2, n2) {
    super(), this.fa = t2, this.da = e2, this._a = n2, this.type = "where";
  }
  _apply(t2) {
    const e2 = hh(t2.firestore), n2 = function(t3, e3, n3, s2, i2, r2, o2) {
      let u2;
      if (i2.isKeyField()) {
        if ("array-contains" === r2 || "array-contains-any" === r2)
          throw new Q(G.INVALID_ARGUMENT, `Invalid Query. You can't perform '${r2}' queries on documentId().`);
        if ("in" === r2 || "not-in" === r2) {
          sl(o2, r2);
          const e4 = [];
          for (const n4 of o2)
            e4.push(nl(s2, t3, n4));
          u2 = {
            arrayValue: {
              values: e4
            }
          };
        } else
          u2 = nl(s2, t3, o2);
      } else
        "in" !== r2 && "not-in" !== r2 && "array-contains-any" !== r2 || sl(o2, r2), u2 = Ih(
          n3,
          e3,
          o2,
          "in" === r2 || "not-in" === r2
        );
      const c2 = qe.create(i2, r2, u2);
      return function(t4, e4) {
        if (e4.ht()) {
          const n5 = cn(t4);
          if (null !== n5 && !n5.isEqual(e4.field))
            throw new Q(G.INVALID_ARGUMENT, `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${n5.toString()}' and '${e4.field.toString()}'`);
          const s3 = un(t4);
          null !== s3 && il(t4, e4.field, s3);
        }
        const n4 = function(t5, e5) {
          for (const n5 of t5.filters)
            if (e5.indexOf(n5.op) >= 0)
              return n5.op;
          return null;
        }(
          t4,
          function(t5) {
            switch (t5) {
              case "!=":
                return ["!=", "not-in"];
              case "array-contains":
                return ["array-contains", "array-contains-any", "not-in"];
              case "in":
                return ["array-contains-any", "in", "not-in"];
              case "array-contains-any":
                return ["array-contains", "array-contains-any", "in", "not-in"];
              case "not-in":
                return ["array-contains", "array-contains-any", "in", "not-in", "!="];
              default:
                return [];
            }
          }(e4.op)
        );
        if (null !== n4)
          throw n4 === e4.op ? new Q(G.INVALID_ARGUMENT, `Invalid query. You cannot use more than one '${e4.op.toString()}' filter.`) : new Q(G.INVALID_ARGUMENT, `Invalid query. You cannot use '${e4.op.toString()}' filters with '${n4.toString()}' filters.`);
      }(t3, c2), c2;
    }(t2._query, "where", e2, t2.firestore._databaseId, this.fa, this.da, this._a);
    return new Pa(t2.firestore, t2.converter, function(t3, e3) {
      const n3 = t3.filters.concat([e3]);
      return new nn(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), n3, t3.limit, t3.limitType, t3.startAt, t3.endAt);
    }(t2._query, n2));
  }
}
function Kh(t2, e2, n2) {
  const s2 = e2, i2 = xh("where", t2);
  return new qh(i2, s2, n2);
}
function nl(t2, e2, n2) {
  if ("string" == typeof (n2 = getModularInstance(n2))) {
    if ("" === n2)
      throw new Q(G.INVALID_ARGUMENT, "Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.");
    if (!an(e2) && -1 !== n2.indexOf("/"))
      throw new Q(G.INVALID_ARGUMENT, `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${n2}' contains a '/' character.`);
    const s2 = e2.path.child(ht.fromString(n2));
    if (!dt.isDocumentKey(s2))
      throw new Q(G.INVALID_ARGUMENT, `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${s2}' is not because it has an odd number of segments (${s2.length}).`);
    return ye(t2, new dt(s2));
  }
  if (n2 instanceof ba)
    return ye(t2, n2._key);
  throw new Q(G.INVALID_ARGUMENT, `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${pa(n2)}.`);
}
function sl(t2, e2) {
  if (!Array.isArray(t2) || 0 === t2.length)
    throw new Q(G.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${e2.toString()}' filters.`);
  if (t2.length > 10)
    throw new Q(G.INVALID_ARGUMENT, `Invalid Query. '${e2.toString()}' filters support a maximum of 10 elements in the value array.`);
}
function il(t2, e2, n2) {
  if (!n2.isEqual(e2))
    throw new Q(G.INVALID_ARGUMENT, `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${e2.toString()}' and so you must also use '${e2.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${n2.toString()}' instead.`);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ol {
  convertValue(t2, e2 = "none") {
    switch (le(t2)) {
      case 0:
        return null;
      case 1:
        return t2.booleanValue;
      case 2:
        return Zt(t2.integerValue || t2.doubleValue);
      case 3:
        return this.convertTimestamp(t2.timestampValue);
      case 4:
        return this.convertServerTimestamp(t2, e2);
      case 5:
        return t2.stringValue;
      case 6:
        return this.convertBytes(te(t2.bytesValue));
      case 7:
        return this.convertReference(t2.referenceValue);
      case 8:
        return this.convertGeoPoint(t2.geoPointValue);
      case 9:
        return this.convertArray(t2.arrayValue, e2);
      case 10:
        return this.convertObject(t2.mapValue, e2);
      default:
        throw L();
    }
  }
  convertObject(t2, e2) {
    const n2 = {};
    return Lt(t2.fields, (t3, s2) => {
      n2[t3] = this.convertValue(s2, e2);
    }), n2;
  }
  convertGeoPoint(t2) {
    return new sh(Zt(t2.latitude), Zt(t2.longitude));
  }
  convertArray(t2, e2) {
    return (t2.values || []).map((t3) => this.convertValue(t3, e2));
  }
  convertServerTimestamp(t2, e2) {
    switch (e2) {
      case "previous":
        const n2 = ne(t2);
        return null == n2 ? null : this.convertValue(n2, e2);
      case "estimate":
        return this.convertTimestamp(se(t2));
      default:
        return null;
    }
  }
  convertTimestamp(t2) {
    const e2 = Xt(t2);
    return new ut(e2.seconds, e2.nanos);
  }
  convertDocumentKey(t2, e2) {
    const n2 = ht.fromString(t2);
    U(ui(n2));
    const s2 = new re(n2.get(1), n2.get(3)), i2 = new dt(n2.popFirst(5));
    return s2.isEqual(e2) || F(`Document ${i2} contains a document reference within a different database (${s2.projectId}/${s2.database}) which is not supported. It will be treated as a reference in the current database (${e2.projectId}/${e2.database}) instead.`), i2;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ul(t2, e2, n2) {
  let s2;
  return s2 = t2 ? n2 && (n2.merge || n2.mergeFields) ? t2.toFirestore(e2, n2) : t2.toFirestore(e2) : e2, s2;
}
class fl extends ol {
  constructor(t2) {
    super(), this.firestore = t2;
  }
  convertBytes(t2) {
    return new eh(t2);
  }
  convertReference(t2) {
    const e2 = this.convertDocumentKey(t2, this.firestore._databaseId);
    return new ba(this.firestore, null, e2);
  }
}
function wl(t2) {
  t2 = Ia(t2, Pa);
  const e2 = Ia(t2.firestore, Fa), n2 = La(e2), s2 = new fl(e2);
  return Bh(t2._query), aa(n2, t2._query).then((n3) => new Mh(e2, s2, t2, n3));
}
function pl(t2, e2, n2, ...s2) {
  t2 = Ia(t2, ba);
  const i2 = Ia(t2.firestore, Fa), r2 = hh(i2);
  let o2;
  o2 = "string" == typeof (e2 = getModularInstance(e2)) || e2 instanceof Za ? ph(r2, "updateDoc", t2._key, e2, n2, s2) : yh(r2, "updateDoc", t2._key, e2);
  return Rl(i2, [o2.toMutation(t2._key, $n.exists(true))]);
}
function Tl(t2, e2) {
  const n2 = Ia(t2.firestore, Fa), s2 = Da(t2), i2 = ul(t2.converter, e2);
  return Rl(n2, [lh(hh(t2.firestore), "addDoc", s2._key, i2, null !== t2.converter, {}).toMutation(s2._key, $n.exists(false))]).then(() => s2);
}
function El(t2, ...e2) {
  var n2, s2, i2;
  t2 = getModularInstance(t2);
  let r2 = {
    includeMetadataChanges: false
  }, o2 = 0;
  "object" != typeof e2[o2] || ka(e2[o2]) || (r2 = e2[o2], o2++);
  const u2 = {
    includeMetadataChanges: r2.includeMetadataChanges
  };
  if (ka(e2[o2])) {
    const t3 = e2[o2];
    e2[o2] = null === (n2 = t3.next) || void 0 === n2 ? void 0 : n2.bind(t3), e2[o2 + 1] = null === (s2 = t3.error) || void 0 === s2 ? void 0 : s2.bind(t3), e2[o2 + 2] = null === (i2 = t3.complete) || void 0 === i2 ? void 0 : i2.bind(t3);
  }
  let c2, a2, h2;
  if (t2 instanceof ba)
    a2 = Ia(t2.firestore, Fa), h2 = rn(t2._key.path), c2 = {
      next: (n3) => {
        e2[o2] && e2[o2](bl(a2, t2, n3));
      },
      error: e2[o2 + 1],
      complete: e2[o2 + 2]
    };
  else {
    const n3 = Ia(t2, Pa);
    a2 = Ia(n3.firestore, Fa), h2 = n3._query;
    const s3 = new fl(a2);
    c2 = {
      next: (t3) => {
        e2[o2] && e2[o2](new Mh(a2, s3, n3, t3));
      },
      error: e2[o2 + 1],
      complete: e2[o2 + 2]
    }, Bh(t2._query);
  }
  return function(t3, e3, n3, s3) {
    const i3 = new Gc(s3), r3 = new Ju(e3, i3, n3);
    return t3.asyncQueue.enqueueAndForget(async () => Qu(await sa(t3), r3)), () => {
      i3.Tc(), t3.asyncQueue.enqueueAndForget(async () => ju(await sa(t3), r3));
    };
  }(La(a2), h2, u2, c2);
}
function Rl(t2, e2) {
  return function(t3, e3) {
    const n2 = new j();
    return t3.asyncQueue.enqueueAndForget(async () => hc(await na(t3), e3, n2)), n2.promise;
  }(La(t2), e2);
}
function bl(t2, e2, n2) {
  const s2 = n2.docs.get(e2._key), i2 = new fl(t2);
  return new kh(t2, i2, e2._key, s2, new Nh(n2.hasPendingWrites, n2.fromCache), e2.converter);
}
function Sl() {
  return new _h("serverTimestamp");
}
!function(t2, e2 = true) {
  !function(t3) {
    x = t3;
  }(SDK_VERSION), _registerComponent(new Component("firestore", (t3, { options: n2 }) => {
    const s2 = t3.getProvider("app").getImmediate(), i2 = new Fa(s2, new J(t3.getProvider("auth-internal")), new tt(t3.getProvider("app-check-internal")));
    return n2 = Object.assign({
      useFetchStreams: e2
    }, n2), i2._setSettings(n2), i2;
  }, "PUBLIC")), registerVersion(D, "3.4.12", t2), registerVersion(D, "3.4.12", "esm2017");
}();
const addCheckout = async ({ userId }) => {
  const addRef2 = await Tl(
    Va(
      Da(
        Va(
          Ba(),
          "customers"
        ),
        userId
      ),
      "checkout_sessions"
    ),
    {
      cancel_url: window.location.href,
      price: "price_1JXGjVFSSDySG1smmI1f8krR",
      success_url: window.location.href
    }
  );
  return await new Promise((resolve2, reject) => {
    El(addRef2, (snapshot) => {
      var _a2;
      if ((_a2 = snapshot.data()) == null ? void 0 : _a2.url) {
        resolve2(snapshot);
      }
    }, (error) => {
      reject(error);
    });
  });
};
const addDoc = async ({ doc: doc2, ownerId }) => {
  const addRef2 = await Tl(
    Va(
      Ba(),
      "documents"
    ),
    {
      ...doc2,
      ownerId,
      syncedAt: Sl()
    }
  );
  return new Promise((resolve2, reject) => {
    El(addRef2, (fullRef) => {
      resolve2(fullRef);
    }, (error) => {
      reject(error);
    });
  });
};
const fetchDocs = async ({ ownerId, syncedAfter }) => {
  const querySnapshot = await wl(
    Uh(
      Va(Ba(), "documents"),
      Kh("ownerId", "==", ownerId),
      Kh("syncedAt", ">", syncedAfter)
    )
  );
  return querySnapshot.docs;
};
const fetchSharedDoc = async ({ docId }) => {
  const querySnapshot = await wl(
    Uh(
      Va(
        Ba(),
        "documents"
      ),
      Kh("public", "==", true),
      Kh("id", "==", docId)
    )
  );
  return querySnapshot.docs[0];
};
const updateDoc = async ({ doc: doc2, docId }) => {
  return pl(
    Da(
      Va(
        Ba(),
        "documents"
      ),
      docId
    ),
    {
      ...doc2,
      syncedAt: Sl()
    }
  );
};
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  const links = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep) => {
    dep = assetsURL(dep);
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    const isBaseRelative = !!importerUrl;
    if (isBaseRelative) {
      for (let i2 = links.length - 1; i2 >= 0; i2--) {
        const link2 = links[i2];
        if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
          return;
        }
      }
    } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule());
};
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "AsyncChangeLog",
  setup(__props) {
    const AsyncChangeLog = defineAsyncComponent(() => {
      return __vitePreload(() => import("./ChangeLog.dcee2b99.js"), true ? ["assets/ChangeLog.dcee2b99.js","assets/account.8a10d9d6.js","assets/Modal.1c333d29.js"] : void 0);
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(AsyncChangeLog));
    };
  }
});
const App_vue_vue_type_style_index_0_lang = "";
const _sfc_main = {
  components: {
    AsyncChangeLog: _sfc_main$1
  },
  inject: ["mq"],
  computed: {
    flow() {
      return this.$route.query.flow;
    },
    home() {
      return this.$route.name === "home";
    },
    ligatures() {
      return this.$store.state.settings.editor.ligatures;
    },
    publicDoc() {
      return this.$route.name === "public-doc";
    },
    sizes() {
      if (this.mq.current === "xs")
        return ["xs xs-plus"];
      if (this.mq.current === "sm")
        return ["sm xs-plus sm-plus"];
      if (this.mq.current === "md")
        return ["md xs-plus sm-plus md-plus"];
      if (this.mq.current === "lg")
        return ["lg xs-plus sm-plus md-plus lg-plus"];
      if (this.mq.current === "xl")
        return ["xl xs-plus sm-plus md-plus lg-plus xl-plus"];
      return [];
    }
  },
  methods: {
    closeChangelog() {
      this.showChangelog = false;
    }
  }
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AsyncChangeLog = resolveComponent("AsyncChangeLog");
  const _component_router_view = resolveComponent("router-view");
  return openBlock(), createElementBlock("div", {
    id: "app",
    class: normalizeClass(["h-full", $options.sizes.concat([!$options.ligatures && "ligatures-none"])])
  }, [
    !$options.home && !$options.publicDoc && !$options.flow ? (openBlock(), createBlock(_component_AsyncChangeLog, { key: 0 })) : createCommentVNode("", true),
    createVNode(_component_router_view, {
      inheritAttrs: true,
      class: "flex-grow flex-shrink min-h-0"
    })
  ], 2);
}
const App = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
var name$1 = "firebase";
var version$1 = "9.9.0";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
registerVersion(name$1, version$1, "app");
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_HOST = "firebasestorage.googleapis.com";
const CONFIG_STORAGE_BUCKET_KEY = "storageBucket";
const DEFAULT_MAX_OPERATION_RETRY_TIME = 2 * 60 * 1e3;
const DEFAULT_MAX_UPLOAD_RETRY_TIME = 10 * 60 * 1e3;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class StorageError extends FirebaseError {
  constructor(code, message) {
    super(prependCode(code), `Firebase Storage: ${message} (${prependCode(code)})`);
    this.customData = { serverResponse: null };
    this._baseMessage = this.message;
    Object.setPrototypeOf(this, StorageError.prototype);
  }
  _codeEquals(code) {
    return prependCode(code) === this.code;
  }
  get serverResponse() {
    return this.customData.serverResponse;
  }
  set serverResponse(serverResponse) {
    this.customData.serverResponse = serverResponse;
    if (this.customData.serverResponse) {
      this.message = `${this._baseMessage}
${this.customData.serverResponse}`;
    } else {
      this.message = this._baseMessage;
    }
  }
}
function prependCode(code) {
  return "storage/" + code;
}
function unknown() {
  const message = "An unknown error occurred, please check the error payload for server response.";
  return new StorageError("unknown", message);
}
function quotaExceeded(bucket) {
  return new StorageError("quota-exceeded", "Quota for bucket '" + bucket + "' exceeded, please view quota on https://firebase.google.com/pricing/.");
}
function unauthenticated() {
  const message = "User is not authenticated, please authenticate using Firebase Authentication and try again.";
  return new StorageError("unauthenticated", message);
}
function unauthorizedApp() {
  return new StorageError("unauthorized-app", "This app does not have permission to access Firebase Storage on this project.");
}
function unauthorized(path) {
  return new StorageError("unauthorized", "User does not have permission to access '" + path + "'.");
}
function retryLimitExceeded() {
  return new StorageError("retry-limit-exceeded", "Max retry time for operation exceeded, please try again.");
}
function canceled() {
  return new StorageError("canceled", "User canceled the upload/download.");
}
function invalidUrl(url) {
  return new StorageError("invalid-url", "Invalid URL '" + url + "'.");
}
function invalidDefaultBucket(bucket) {
  return new StorageError("invalid-default-bucket", "Invalid default bucket '" + bucket + "'.");
}
function noDefaultBucket() {
  return new StorageError("no-default-bucket", "No default bucket found. Did you set the '" + CONFIG_STORAGE_BUCKET_KEY + "' property when initializing the app?");
}
function cannotSliceBlob() {
  return new StorageError("cannot-slice-blob", "Cannot slice blob for upload. Please retry the upload.");
}
function invalidArgument(message) {
  return new StorageError("invalid-argument", message);
}
function appDeleted() {
  return new StorageError("app-deleted", "The Firebase app was deleted.");
}
function invalidRootOperation(name2) {
  return new StorageError("invalid-root-operation", "The operation '" + name2 + "' cannot be performed on a root reference, create a non-root reference using child, such as .child('file.png').");
}
function invalidFormat(format, message) {
  return new StorageError("invalid-format", "String does not match format '" + format + "': " + message);
}
function internalError(message) {
  throw new StorageError("internal-error", "Internal error: " + message);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Location {
  constructor(bucket, path) {
    this.bucket = bucket;
    this.path_ = path;
  }
  get path() {
    return this.path_;
  }
  get isRoot() {
    return this.path.length === 0;
  }
  fullServerUrl() {
    const encode2 = encodeURIComponent;
    return "/b/" + encode2(this.bucket) + "/o/" + encode2(this.path);
  }
  bucketOnlyServerUrl() {
    const encode2 = encodeURIComponent;
    return "/b/" + encode2(this.bucket) + "/o";
  }
  static makeFromBucketSpec(bucketString, host) {
    let bucketLocation;
    try {
      bucketLocation = Location.makeFromUrl(bucketString, host);
    } catch (e2) {
      return new Location(bucketString, "");
    }
    if (bucketLocation.path === "") {
      return bucketLocation;
    } else {
      throw invalidDefaultBucket(bucketString);
    }
  }
  static makeFromUrl(url, host) {
    let location2 = null;
    const bucketDomain = "([A-Za-z0-9.\\-_]+)";
    function gsModify(loc) {
      if (loc.path.charAt(loc.path.length - 1) === "/") {
        loc.path_ = loc.path_.slice(0, -1);
      }
    }
    const gsPath = "(/(.*))?$";
    const gsRegex = new RegExp("^gs://" + bucketDomain + gsPath, "i");
    const gsIndices = { bucket: 1, path: 3 };
    function httpModify(loc) {
      loc.path_ = decodeURIComponent(loc.path);
    }
    const version2 = "v[A-Za-z0-9_]+";
    const firebaseStorageHost = host.replace(/[.]/g, "\\.");
    const firebaseStoragePath = "(/([^?#]*).*)?$";
    const firebaseStorageRegExp = new RegExp(`^https?://${firebaseStorageHost}/${version2}/b/${bucketDomain}/o${firebaseStoragePath}`, "i");
    const firebaseStorageIndices = { bucket: 1, path: 3 };
    const cloudStorageHost = host === DEFAULT_HOST ? "(?:storage.googleapis.com|storage.cloud.google.com)" : host;
    const cloudStoragePath = "([^?#]*)";
    const cloudStorageRegExp = new RegExp(`^https?://${cloudStorageHost}/${bucketDomain}/${cloudStoragePath}`, "i");
    const cloudStorageIndices = { bucket: 1, path: 2 };
    const groups = [
      { regex: gsRegex, indices: gsIndices, postModify: gsModify },
      {
        regex: firebaseStorageRegExp,
        indices: firebaseStorageIndices,
        postModify: httpModify
      },
      {
        regex: cloudStorageRegExp,
        indices: cloudStorageIndices,
        postModify: httpModify
      }
    ];
    for (let i2 = 0; i2 < groups.length; i2++) {
      const group = groups[i2];
      const captures = group.regex.exec(url);
      if (captures) {
        const bucketValue = captures[group.indices.bucket];
        let pathValue = captures[group.indices.path];
        if (!pathValue) {
          pathValue = "";
        }
        location2 = new Location(bucketValue, pathValue);
        group.postModify(location2);
        break;
      }
    }
    if (location2 == null) {
      throw invalidUrl(url);
    }
    return location2;
  }
}
class FailRequest {
  constructor(error) {
    this.promise_ = Promise.reject(error);
  }
  getPromise() {
    return this.promise_;
  }
  cancel(_appDelete = false) {
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function start(f2, callback, timeout) {
  let waitSeconds = 1;
  let retryTimeoutId = null;
  let globalTimeoutId = null;
  let hitTimeout = false;
  let cancelState = 0;
  function canceled2() {
    return cancelState === 2;
  }
  let triggeredCallback = false;
  function triggerCallback(...args) {
    if (!triggeredCallback) {
      triggeredCallback = true;
      callback.apply(null, args);
    }
  }
  function callWithDelay(millis) {
    retryTimeoutId = setTimeout(() => {
      retryTimeoutId = null;
      f2(handler, canceled2());
    }, millis);
  }
  function clearGlobalTimeout() {
    if (globalTimeoutId) {
      clearTimeout(globalTimeoutId);
    }
  }
  function handler(success, ...args) {
    if (triggeredCallback) {
      clearGlobalTimeout();
      return;
    }
    if (success) {
      clearGlobalTimeout();
      triggerCallback.call(null, success, ...args);
      return;
    }
    const mustStop = canceled2() || hitTimeout;
    if (mustStop) {
      clearGlobalTimeout();
      triggerCallback.call(null, success, ...args);
      return;
    }
    if (waitSeconds < 64) {
      waitSeconds *= 2;
    }
    let waitMillis;
    if (cancelState === 1) {
      cancelState = 2;
      waitMillis = 0;
    } else {
      waitMillis = (waitSeconds + Math.random()) * 1e3;
    }
    callWithDelay(waitMillis);
  }
  let stopped = false;
  function stop2(wasTimeout) {
    if (stopped) {
      return;
    }
    stopped = true;
    clearGlobalTimeout();
    if (triggeredCallback) {
      return;
    }
    if (retryTimeoutId !== null) {
      if (!wasTimeout) {
        cancelState = 2;
      }
      clearTimeout(retryTimeoutId);
      callWithDelay(0);
    } else {
      if (!wasTimeout) {
        cancelState = 1;
      }
    }
  }
  callWithDelay(0);
  globalTimeoutId = setTimeout(() => {
    hitTimeout = true;
    stop2(true);
  }, timeout);
  return stop2;
}
function stop(id2) {
  id2(false);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function isJustDef(p2) {
  return p2 !== void 0;
}
function isNonArrayObject(p2) {
  return typeof p2 === "object" && !Array.isArray(p2);
}
function isString(p2) {
  return typeof p2 === "string" || p2 instanceof String;
}
function isNativeBlob(p2) {
  return isNativeBlobDefined() && p2 instanceof Blob;
}
function isNativeBlobDefined() {
  return typeof Blob !== "undefined";
}
function validateNumber(argument, minValue, maxValue, value) {
  if (value < minValue) {
    throw invalidArgument(`Invalid value for '${argument}'. Expected ${minValue} or greater.`);
  }
  if (value > maxValue) {
    throw invalidArgument(`Invalid value for '${argument}'. Expected ${maxValue} or less.`);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function makeUrl(urlPart, host, protocol) {
  let origin = host;
  if (protocol == null) {
    origin = `https://${host}`;
  }
  return `${protocol}://${origin}/v0${urlPart}`;
}
function makeQueryString(params) {
  const encode2 = encodeURIComponent;
  let queryPart = "?";
  for (const key in params) {
    if (params.hasOwnProperty(key)) {
      const nextPart = encode2(key) + "=" + encode2(params[key]);
      queryPart = queryPart + nextPart + "&";
    }
  }
  queryPart = queryPart.slice(0, -1);
  return queryPart;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2[ErrorCode2["NO_ERROR"] = 0] = "NO_ERROR";
  ErrorCode2[ErrorCode2["NETWORK_ERROR"] = 1] = "NETWORK_ERROR";
  ErrorCode2[ErrorCode2["ABORT"] = 2] = "ABORT";
})(ErrorCode || (ErrorCode = {}));
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NetworkRequest {
  constructor(url_, method_, headers_, body_, successCodes_, additionalRetryCodes_, callback_, errorCallback_, timeout_, progressCallback_, connectionFactory_) {
    this.url_ = url_;
    this.method_ = method_;
    this.headers_ = headers_;
    this.body_ = body_;
    this.successCodes_ = successCodes_;
    this.additionalRetryCodes_ = additionalRetryCodes_;
    this.callback_ = callback_;
    this.errorCallback_ = errorCallback_;
    this.timeout_ = timeout_;
    this.progressCallback_ = progressCallback_;
    this.connectionFactory_ = connectionFactory_;
    this.pendingConnection_ = null;
    this.backoffId_ = null;
    this.canceled_ = false;
    this.appDelete_ = false;
    this.promise_ = new Promise((resolve2, reject) => {
      this.resolve_ = resolve2;
      this.reject_ = reject;
      this.start_();
    });
  }
  start_() {
    const doTheRequest = (backoffCallback, canceled2) => {
      if (canceled2) {
        backoffCallback(false, new RequestEndStatus(false, null, true));
        return;
      }
      const connection = this.connectionFactory_();
      this.pendingConnection_ = connection;
      const progressListener = (progressEvent) => {
        const loaded = progressEvent.loaded;
        const total = progressEvent.lengthComputable ? progressEvent.total : -1;
        if (this.progressCallback_ !== null) {
          this.progressCallback_(loaded, total);
        }
      };
      if (this.progressCallback_ !== null) {
        connection.addUploadProgressListener(progressListener);
      }
      connection.send(this.url_, this.method_, this.body_, this.headers_).then(() => {
        if (this.progressCallback_ !== null) {
          connection.removeUploadProgressListener(progressListener);
        }
        this.pendingConnection_ = null;
        const hitServer = connection.getErrorCode() === ErrorCode.NO_ERROR;
        const status = connection.getStatus();
        if (!hitServer || this.isRetryStatusCode_(status)) {
          const wasCanceled = connection.getErrorCode() === ErrorCode.ABORT;
          backoffCallback(false, new RequestEndStatus(false, null, wasCanceled));
          return;
        }
        const successCode = this.successCodes_.indexOf(status) !== -1;
        backoffCallback(true, new RequestEndStatus(successCode, connection));
      });
    };
    const backoffDone = (requestWentThrough, status) => {
      const resolve2 = this.resolve_;
      const reject = this.reject_;
      const connection = status.connection;
      if (status.wasSuccessCode) {
        try {
          const result = this.callback_(connection, connection.getResponse());
          if (isJustDef(result)) {
            resolve2(result);
          } else {
            resolve2();
          }
        } catch (e2) {
          reject(e2);
        }
      } else {
        if (connection !== null) {
          const err = unknown();
          err.serverResponse = connection.getErrorText();
          if (this.errorCallback_) {
            reject(this.errorCallback_(connection, err));
          } else {
            reject(err);
          }
        } else {
          if (status.canceled) {
            const err = this.appDelete_ ? appDeleted() : canceled();
            reject(err);
          } else {
            const err = retryLimitExceeded();
            reject(err);
          }
        }
      }
    };
    if (this.canceled_) {
      backoffDone(false, new RequestEndStatus(false, null, true));
    } else {
      this.backoffId_ = start(doTheRequest, backoffDone, this.timeout_);
    }
  }
  getPromise() {
    return this.promise_;
  }
  cancel(appDelete) {
    this.canceled_ = true;
    this.appDelete_ = appDelete || false;
    if (this.backoffId_ !== null) {
      stop(this.backoffId_);
    }
    if (this.pendingConnection_ !== null) {
      this.pendingConnection_.abort();
    }
  }
  isRetryStatusCode_(status) {
    const isFiveHundredCode = status >= 500 && status < 600;
    const extraRetryCodes = [
      408,
      429
    ];
    const isExtraRetryCode = extraRetryCodes.indexOf(status) !== -1;
    const isRequestSpecificRetryCode = this.additionalRetryCodes_.indexOf(status) !== -1;
    return isFiveHundredCode || isExtraRetryCode || isRequestSpecificRetryCode;
  }
}
class RequestEndStatus {
  constructor(wasSuccessCode, connection, canceled2) {
    this.wasSuccessCode = wasSuccessCode;
    this.connection = connection;
    this.canceled = !!canceled2;
  }
}
function addAuthHeader_(headers, authToken) {
  if (authToken !== null && authToken.length > 0) {
    headers["Authorization"] = "Firebase " + authToken;
  }
}
function addVersionHeader_(headers, firebaseVersion) {
  headers["X-Firebase-Storage-Version"] = "webjs/" + (firebaseVersion !== null && firebaseVersion !== void 0 ? firebaseVersion : "AppManager");
}
function addGmpidHeader_(headers, appId) {
  if (appId) {
    headers["X-Firebase-GMPID"] = appId;
  }
}
function addAppCheckHeader_(headers, appCheckToken) {
  if (appCheckToken !== null) {
    headers["X-Firebase-AppCheck"] = appCheckToken;
  }
}
function makeRequest(requestInfo, appId, authToken, appCheckToken, requestFactory, firebaseVersion) {
  const queryPart = makeQueryString(requestInfo.urlParams);
  const url = requestInfo.url + queryPart;
  const headers = Object.assign({}, requestInfo.headers);
  addGmpidHeader_(headers, appId);
  addAuthHeader_(headers, authToken);
  addVersionHeader_(headers, firebaseVersion);
  addAppCheckHeader_(headers, appCheckToken);
  return new NetworkRequest(url, requestInfo.method, headers, requestInfo.body, requestInfo.successCodes, requestInfo.additionalRetryCodes, requestInfo.handler, requestInfo.errorHandler, requestInfo.timeout, requestInfo.progressCallback, requestFactory);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getBlobBuilder() {
  if (typeof BlobBuilder !== "undefined") {
    return BlobBuilder;
  } else if (typeof WebKitBlobBuilder !== "undefined") {
    return WebKitBlobBuilder;
  } else {
    return void 0;
  }
}
function getBlob$1(...args) {
  const BlobBuilder2 = getBlobBuilder();
  if (BlobBuilder2 !== void 0) {
    const bb2 = new BlobBuilder2();
    for (let i2 = 0; i2 < args.length; i2++) {
      bb2.append(args[i2]);
    }
    return bb2.getBlob();
  } else {
    if (isNativeBlobDefined()) {
      return new Blob(args);
    } else {
      throw new StorageError("unsupported-environment", "This browser doesn't seem to support creating Blobs");
    }
  }
}
function sliceBlob(blob, start2, end) {
  if (blob.webkitSlice) {
    return blob.webkitSlice(start2, end);
  } else if (blob.mozSlice) {
    return blob.mozSlice(start2, end);
  } else if (blob.slice) {
    return blob.slice(start2, end);
  }
  return null;
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function decodeBase64(encoded) {
  return atob(encoded);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const StringFormat = {
  RAW: "raw",
  BASE64: "base64",
  BASE64URL: "base64url",
  DATA_URL: "data_url"
};
class StringData {
  constructor(data, contentType) {
    this.data = data;
    this.contentType = contentType || null;
  }
}
function dataFromString(format, stringData) {
  switch (format) {
    case StringFormat.RAW:
      return new StringData(utf8Bytes_(stringData));
    case StringFormat.BASE64:
    case StringFormat.BASE64URL:
      return new StringData(base64Bytes_(format, stringData));
    case StringFormat.DATA_URL:
      return new StringData(dataURLBytes_(stringData), dataURLContentType_(stringData));
  }
  throw unknown();
}
function utf8Bytes_(value) {
  const b2 = [];
  for (let i2 = 0; i2 < value.length; i2++) {
    let c2 = value.charCodeAt(i2);
    if (c2 <= 127) {
      b2.push(c2);
    } else {
      if (c2 <= 2047) {
        b2.push(192 | c2 >> 6, 128 | c2 & 63);
      } else {
        if ((c2 & 64512) === 55296) {
          const valid = i2 < value.length - 1 && (value.charCodeAt(i2 + 1) & 64512) === 56320;
          if (!valid) {
            b2.push(239, 191, 189);
          } else {
            const hi = c2;
            const lo2 = value.charCodeAt(++i2);
            c2 = 65536 | (hi & 1023) << 10 | lo2 & 1023;
            b2.push(240 | c2 >> 18, 128 | c2 >> 12 & 63, 128 | c2 >> 6 & 63, 128 | c2 & 63);
          }
        } else {
          if ((c2 & 64512) === 56320) {
            b2.push(239, 191, 189);
          } else {
            b2.push(224 | c2 >> 12, 128 | c2 >> 6 & 63, 128 | c2 & 63);
          }
        }
      }
    }
  }
  return new Uint8Array(b2);
}
function percentEncodedBytes_(value) {
  let decoded;
  try {
    decoded = decodeURIComponent(value);
  } catch (e2) {
    throw invalidFormat(StringFormat.DATA_URL, "Malformed data URL.");
  }
  return utf8Bytes_(decoded);
}
function base64Bytes_(format, value) {
  switch (format) {
    case StringFormat.BASE64: {
      const hasMinus = value.indexOf("-") !== -1;
      const hasUnder = value.indexOf("_") !== -1;
      if (hasMinus || hasUnder) {
        const invalidChar = hasMinus ? "-" : "_";
        throw invalidFormat(format, "Invalid character '" + invalidChar + "' found: is it base64url encoded?");
      }
      break;
    }
    case StringFormat.BASE64URL: {
      const hasPlus = value.indexOf("+") !== -1;
      const hasSlash = value.indexOf("/") !== -1;
      if (hasPlus || hasSlash) {
        const invalidChar = hasPlus ? "+" : "/";
        throw invalidFormat(format, "Invalid character '" + invalidChar + "' found: is it base64 encoded?");
      }
      value = value.replace(/-/g, "+").replace(/_/g, "/");
      break;
    }
  }
  let bytes;
  try {
    bytes = decodeBase64(value);
  } catch (e2) {
    throw invalidFormat(format, "Invalid character found");
  }
  const array = new Uint8Array(bytes.length);
  for (let i2 = 0; i2 < bytes.length; i2++) {
    array[i2] = bytes.charCodeAt(i2);
  }
  return array;
}
class DataURLParts {
  constructor(dataURL) {
    this.base64 = false;
    this.contentType = null;
    const matches = dataURL.match(/^data:([^,]+)?,/);
    if (matches === null) {
      throw invalidFormat(StringFormat.DATA_URL, "Must be formatted 'data:[<mediatype>][;base64],<data>");
    }
    const middle = matches[1] || null;
    if (middle != null) {
      this.base64 = endsWith(middle, ";base64");
      this.contentType = this.base64 ? middle.substring(0, middle.length - ";base64".length) : middle;
    }
    this.rest = dataURL.substring(dataURL.indexOf(",") + 1);
  }
}
function dataURLBytes_(dataUrl) {
  const parts = new DataURLParts(dataUrl);
  if (parts.base64) {
    return base64Bytes_(StringFormat.BASE64, parts.rest);
  } else {
    return percentEncodedBytes_(parts.rest);
  }
}
function dataURLContentType_(dataUrl) {
  const parts = new DataURLParts(dataUrl);
  return parts.contentType;
}
function endsWith(s2, end) {
  const longEnough = s2.length >= end.length;
  if (!longEnough) {
    return false;
  }
  return s2.substring(s2.length - end.length) === end;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FbsBlob {
  constructor(data, elideCopy) {
    let size2 = 0;
    let blobType = "";
    if (isNativeBlob(data)) {
      this.data_ = data;
      size2 = data.size;
      blobType = data.type;
    } else if (data instanceof ArrayBuffer) {
      if (elideCopy) {
        this.data_ = new Uint8Array(data);
      } else {
        this.data_ = new Uint8Array(data.byteLength);
        this.data_.set(new Uint8Array(data));
      }
      size2 = this.data_.length;
    } else if (data instanceof Uint8Array) {
      if (elideCopy) {
        this.data_ = data;
      } else {
        this.data_ = new Uint8Array(data.length);
        this.data_.set(data);
      }
      size2 = data.length;
    }
    this.size_ = size2;
    this.type_ = blobType;
  }
  size() {
    return this.size_;
  }
  type() {
    return this.type_;
  }
  slice(startByte, endByte) {
    if (isNativeBlob(this.data_)) {
      const realBlob = this.data_;
      const sliced = sliceBlob(realBlob, startByte, endByte);
      if (sliced === null) {
        return null;
      }
      return new FbsBlob(sliced);
    } else {
      const slice = new Uint8Array(this.data_.buffer, startByte, endByte - startByte);
      return new FbsBlob(slice, true);
    }
  }
  static getBlob(...args) {
    if (isNativeBlobDefined()) {
      const blobby = args.map((val) => {
        if (val instanceof FbsBlob) {
          return val.data_;
        } else {
          return val;
        }
      });
      return new FbsBlob(getBlob$1.apply(null, blobby));
    } else {
      const uint8Arrays = args.map((val) => {
        if (isString(val)) {
          return dataFromString(StringFormat.RAW, val).data;
        } else {
          return val.data_;
        }
      });
      let finalLength = 0;
      uint8Arrays.forEach((array) => {
        finalLength += array.byteLength;
      });
      const merged = new Uint8Array(finalLength);
      let index = 0;
      uint8Arrays.forEach((array) => {
        for (let i2 = 0; i2 < array.length; i2++) {
          merged[index++] = array[i2];
        }
      });
      return new FbsBlob(merged, true);
    }
  }
  uploadData() {
    return this.data_;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function jsonObjectOrNull(s2) {
  let obj;
  try {
    obj = JSON.parse(s2);
  } catch (e2) {
    return null;
  }
  if (isNonArrayObject(obj)) {
    return obj;
  } else {
    return null;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function parent(path) {
  if (path.length === 0) {
    return null;
  }
  const index = path.lastIndexOf("/");
  if (index === -1) {
    return "";
  }
  const newPath = path.slice(0, index);
  return newPath;
}
function child(path, childPath) {
  const canonicalChildPath = childPath.split("/").filter((component) => component.length > 0).join("/");
  if (path.length === 0) {
    return canonicalChildPath;
  } else {
    return path + "/" + canonicalChildPath;
  }
}
function lastComponent(path) {
  const index = path.lastIndexOf("/", path.length - 2);
  if (index === -1) {
    return path;
  } else {
    return path.slice(index + 1);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function noXform_(metadata, value) {
  return value;
}
class Mapping {
  constructor(server, local, writable, xform) {
    this.server = server;
    this.local = local || server;
    this.writable = !!writable;
    this.xform = xform || noXform_;
  }
}
let mappings_ = null;
function xformPath(fullPath) {
  if (!isString(fullPath) || fullPath.length < 2) {
    return fullPath;
  } else {
    return lastComponent(fullPath);
  }
}
function getMappings() {
  if (mappings_) {
    return mappings_;
  }
  const mappings = [];
  mappings.push(new Mapping("bucket"));
  mappings.push(new Mapping("generation"));
  mappings.push(new Mapping("metageneration"));
  mappings.push(new Mapping("name", "fullPath", true));
  function mappingsXformPath(_metadata, fullPath) {
    return xformPath(fullPath);
  }
  const nameMapping = new Mapping("name");
  nameMapping.xform = mappingsXformPath;
  mappings.push(nameMapping);
  function xformSize(_metadata, size2) {
    if (size2 !== void 0) {
      return Number(size2);
    } else {
      return size2;
    }
  }
  const sizeMapping = new Mapping("size");
  sizeMapping.xform = xformSize;
  mappings.push(sizeMapping);
  mappings.push(new Mapping("timeCreated"));
  mappings.push(new Mapping("updated"));
  mappings.push(new Mapping("md5Hash", null, true));
  mappings.push(new Mapping("cacheControl", null, true));
  mappings.push(new Mapping("contentDisposition", null, true));
  mappings.push(new Mapping("contentEncoding", null, true));
  mappings.push(new Mapping("contentLanguage", null, true));
  mappings.push(new Mapping("contentType", null, true));
  mappings.push(new Mapping("metadata", "customMetadata", true));
  mappings_ = mappings;
  return mappings_;
}
function addRef(metadata, service) {
  function generateRef() {
    const bucket = metadata["bucket"];
    const path = metadata["fullPath"];
    const loc = new Location(bucket, path);
    return service._makeStorageReference(loc);
  }
  Object.defineProperty(metadata, "ref", { get: generateRef });
}
function fromResource(service, resource, mappings) {
  const metadata = {};
  metadata["type"] = "file";
  const len = mappings.length;
  for (let i2 = 0; i2 < len; i2++) {
    const mapping = mappings[i2];
    metadata[mapping.local] = mapping.xform(metadata, resource[mapping.server]);
  }
  addRef(metadata, service);
  return metadata;
}
function fromResourceString(service, resourceString, mappings) {
  const obj = jsonObjectOrNull(resourceString);
  if (obj === null) {
    return null;
  }
  const resource = obj;
  return fromResource(service, resource, mappings);
}
function toResourceString(metadata, mappings) {
  const resource = {};
  const len = mappings.length;
  for (let i2 = 0; i2 < len; i2++) {
    const mapping = mappings[i2];
    if (mapping.writable) {
      resource[mapping.server] = metadata[mapping.local];
    }
  }
  return JSON.stringify(resource);
}
class RequestInfo {
  constructor(url, method, handler, timeout) {
    this.url = url;
    this.method = method;
    this.handler = handler;
    this.timeout = timeout;
    this.urlParams = {};
    this.headers = {};
    this.body = null;
    this.errorHandler = null;
    this.progressCallback = null;
    this.successCodes = [200];
    this.additionalRetryCodes = [];
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function handlerCheck(cndn) {
  if (!cndn) {
    throw unknown();
  }
}
function metadataHandler(service, mappings) {
  function handler(xhr, text) {
    const metadata = fromResourceString(service, text, mappings);
    handlerCheck(metadata !== null);
    return metadata;
  }
  return handler;
}
function sharedErrorHandler(location2) {
  function errorHandler(xhr, err) {
    let newErr;
    if (xhr.getStatus() === 401) {
      if (xhr.getErrorText().includes("Firebase App Check token is invalid")) {
        newErr = unauthorizedApp();
      } else {
        newErr = unauthenticated();
      }
    } else {
      if (xhr.getStatus() === 402) {
        newErr = quotaExceeded(location2.bucket);
      } else {
        if (xhr.getStatus() === 403) {
          newErr = unauthorized(location2.path);
        } else {
          newErr = err;
        }
      }
    }
    newErr.serverResponse = err.serverResponse;
    return newErr;
  }
  return errorHandler;
}
function determineContentType_(metadata, blob) {
  return metadata && metadata["contentType"] || blob && blob.type() || "application/octet-stream";
}
function metadataForUpload_(location2, blob, metadata) {
  const metadataClone = Object.assign({}, metadata);
  metadataClone["fullPath"] = location2.path;
  metadataClone["size"] = blob.size();
  if (!metadataClone["contentType"]) {
    metadataClone["contentType"] = determineContentType_(null, blob);
  }
  return metadataClone;
}
function multipartUpload(service, location2, mappings, blob, metadata) {
  const urlPart = location2.bucketOnlyServerUrl();
  const headers = {
    "X-Goog-Upload-Protocol": "multipart"
  };
  function genBoundary() {
    let str = "";
    for (let i2 = 0; i2 < 2; i2++) {
      str = str + Math.random().toString().slice(2);
    }
    return str;
  }
  const boundary = genBoundary();
  headers["Content-Type"] = "multipart/related; boundary=" + boundary;
  const metadata_ = metadataForUpload_(location2, blob, metadata);
  const metadataString = toResourceString(metadata_, mappings);
  const preBlobPart = "--" + boundary + "\r\nContent-Type: application/json; charset=utf-8\r\n\r\n" + metadataString + "\r\n--" + boundary + "\r\nContent-Type: " + metadata_["contentType"] + "\r\n\r\n";
  const postBlobPart = "\r\n--" + boundary + "--";
  const body = FbsBlob.getBlob(preBlobPart, blob, postBlobPart);
  if (body === null) {
    throw cannotSliceBlob();
  }
  const urlParams = { name: metadata_["fullPath"] };
  const url = makeUrl(urlPart, service.host, service._protocol);
  const method = "POST";
  const timeout = service.maxUploadRetryTime;
  const requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);
  requestInfo.urlParams = urlParams;
  requestInfo.headers = headers;
  requestInfo.body = body.uploadData();
  requestInfo.errorHandler = sharedErrorHandler(location2);
  return requestInfo;
}
class XhrConnection {
  constructor() {
    this.sent_ = false;
    this.xhr_ = new XMLHttpRequest();
    this.initXhr();
    this.errorCode_ = ErrorCode.NO_ERROR;
    this.sendPromise_ = new Promise((resolve2) => {
      this.xhr_.addEventListener("abort", () => {
        this.errorCode_ = ErrorCode.ABORT;
        resolve2();
      });
      this.xhr_.addEventListener("error", () => {
        this.errorCode_ = ErrorCode.NETWORK_ERROR;
        resolve2();
      });
      this.xhr_.addEventListener("load", () => {
        resolve2();
      });
    });
  }
  send(url, method, body, headers) {
    if (this.sent_) {
      throw internalError("cannot .send() more than once");
    }
    this.sent_ = true;
    this.xhr_.open(method, url, true);
    if (headers !== void 0) {
      for (const key in headers) {
        if (headers.hasOwnProperty(key)) {
          this.xhr_.setRequestHeader(key, headers[key].toString());
        }
      }
    }
    if (body !== void 0) {
      this.xhr_.send(body);
    } else {
      this.xhr_.send();
    }
    return this.sendPromise_;
  }
  getErrorCode() {
    if (!this.sent_) {
      throw internalError("cannot .getErrorCode() before sending");
    }
    return this.errorCode_;
  }
  getStatus() {
    if (!this.sent_) {
      throw internalError("cannot .getStatus() before sending");
    }
    try {
      return this.xhr_.status;
    } catch (e2) {
      return -1;
    }
  }
  getResponse() {
    if (!this.sent_) {
      throw internalError("cannot .getResponse() before sending");
    }
    return this.xhr_.response;
  }
  getErrorText() {
    if (!this.sent_) {
      throw internalError("cannot .getErrorText() before sending");
    }
    return this.xhr_.statusText;
  }
  abort() {
    this.xhr_.abort();
  }
  getResponseHeader(header) {
    return this.xhr_.getResponseHeader(header);
  }
  addUploadProgressListener(listener) {
    if (this.xhr_.upload != null) {
      this.xhr_.upload.addEventListener("progress", listener);
    }
  }
  removeUploadProgressListener(listener) {
    if (this.xhr_.upload != null) {
      this.xhr_.upload.removeEventListener("progress", listener);
    }
  }
}
class XhrTextConnection extends XhrConnection {
  initXhr() {
    this.xhr_.responseType = "text";
  }
}
function newTextConnection() {
  return new XhrTextConnection();
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Reference {
  constructor(_service, location2) {
    this._service = _service;
    if (location2 instanceof Location) {
      this._location = location2;
    } else {
      this._location = Location.makeFromUrl(location2, _service.host);
    }
  }
  toString() {
    return "gs://" + this._location.bucket + "/" + this._location.path;
  }
  _newRef(service, location2) {
    return new Reference(service, location2);
  }
  get root() {
    const location2 = new Location(this._location.bucket, "");
    return this._newRef(this._service, location2);
  }
  get bucket() {
    return this._location.bucket;
  }
  get fullPath() {
    return this._location.path;
  }
  get name() {
    return lastComponent(this._location.path);
  }
  get storage() {
    return this._service;
  }
  get parent() {
    const newPath = parent(this._location.path);
    if (newPath === null) {
      return null;
    }
    const location2 = new Location(this._location.bucket, newPath);
    return new Reference(this._service, location2);
  }
  _throwIfRoot(name2) {
    if (this._location.path === "") {
      throw invalidRootOperation(name2);
    }
  }
}
function uploadBytes$1(ref2, data, metadata) {
  ref2._throwIfRoot("uploadBytes");
  const requestInfo = multipartUpload(ref2.storage, ref2._location, getMappings(), new FbsBlob(data, true), metadata);
  return ref2.storage.makeRequestWithTokens(requestInfo, newTextConnection).then((finalMetadata) => {
    return {
      metadata: finalMetadata,
      ref: ref2
    };
  });
}
function _getChild$1(ref2, childPath) {
  const newPath = child(ref2._location.path, childPath);
  const location2 = new Location(ref2._location.bucket, newPath);
  return new Reference(ref2.storage, location2);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function isUrl(path) {
  return /^[A-Za-z]+:\/\//.test(path);
}
function refFromURL(service, url) {
  return new Reference(service, url);
}
function refFromPath(ref2, path) {
  if (ref2 instanceof FirebaseStorageImpl) {
    const service = ref2;
    if (service._bucket == null) {
      throw noDefaultBucket();
    }
    const reference = new Reference(service, service._bucket);
    if (path != null) {
      return refFromPath(reference, path);
    } else {
      return reference;
    }
  } else {
    if (path !== void 0) {
      return _getChild$1(ref2, path);
    } else {
      return ref2;
    }
  }
}
function ref$1(serviceOrRef, pathOrUrl) {
  if (pathOrUrl && isUrl(pathOrUrl)) {
    if (serviceOrRef instanceof FirebaseStorageImpl) {
      return refFromURL(serviceOrRef, pathOrUrl);
    } else {
      throw invalidArgument("To use ref(service, url), the first argument must be a Storage instance.");
    }
  } else {
    return refFromPath(serviceOrRef, pathOrUrl);
  }
}
function extractBucket(host, config2) {
  const bucketString = config2 === null || config2 === void 0 ? void 0 : config2[CONFIG_STORAGE_BUCKET_KEY];
  if (bucketString == null) {
    return null;
  }
  return Location.makeFromBucketSpec(bucketString, host);
}
function connectStorageEmulator$1(storage, host, port, options = {}) {
  storage.host = `${host}:${port}`;
  storage._protocol = "http";
  const { mockUserToken } = options;
  if (mockUserToken) {
    storage._overrideAuthToken = typeof mockUserToken === "string" ? mockUserToken : createMockUserToken(mockUserToken, storage.app.options.projectId);
  }
}
class FirebaseStorageImpl {
  constructor(app2, _authProvider, _appCheckProvider, _url, _firebaseVersion) {
    this.app = app2;
    this._authProvider = _authProvider;
    this._appCheckProvider = _appCheckProvider;
    this._url = _url;
    this._firebaseVersion = _firebaseVersion;
    this._bucket = null;
    this._host = DEFAULT_HOST;
    this._protocol = "https";
    this._appId = null;
    this._deleted = false;
    this._maxOperationRetryTime = DEFAULT_MAX_OPERATION_RETRY_TIME;
    this._maxUploadRetryTime = DEFAULT_MAX_UPLOAD_RETRY_TIME;
    this._requests = /* @__PURE__ */ new Set();
    if (_url != null) {
      this._bucket = Location.makeFromBucketSpec(_url, this._host);
    } else {
      this._bucket = extractBucket(this._host, this.app.options);
    }
  }
  get host() {
    return this._host;
  }
  set host(host) {
    this._host = host;
    if (this._url != null) {
      this._bucket = Location.makeFromBucketSpec(this._url, host);
    } else {
      this._bucket = extractBucket(host, this.app.options);
    }
  }
  get maxUploadRetryTime() {
    return this._maxUploadRetryTime;
  }
  set maxUploadRetryTime(time) {
    validateNumber(
      "time",
      0,
      Number.POSITIVE_INFINITY,
      time
    );
    this._maxUploadRetryTime = time;
  }
  get maxOperationRetryTime() {
    return this._maxOperationRetryTime;
  }
  set maxOperationRetryTime(time) {
    validateNumber(
      "time",
      0,
      Number.POSITIVE_INFINITY,
      time
    );
    this._maxOperationRetryTime = time;
  }
  async _getAuthToken() {
    if (this._overrideAuthToken) {
      return this._overrideAuthToken;
    }
    const auth = this._authProvider.getImmediate({ optional: true });
    if (auth) {
      const tokenData = await auth.getToken();
      if (tokenData !== null) {
        return tokenData.accessToken;
      }
    }
    return null;
  }
  async _getAppCheckToken() {
    const appCheck = this._appCheckProvider.getImmediate({ optional: true });
    if (appCheck) {
      const result = await appCheck.getToken();
      return result.token;
    }
    return null;
  }
  _delete() {
    if (!this._deleted) {
      this._deleted = true;
      this._requests.forEach((request) => request.cancel());
      this._requests.clear();
    }
    return Promise.resolve();
  }
  _makeStorageReference(loc) {
    return new Reference(this, loc);
  }
  _makeRequest(requestInfo, requestFactory, authToken, appCheckToken) {
    if (!this._deleted) {
      const request = makeRequest(requestInfo, this._appId, authToken, appCheckToken, requestFactory, this._firebaseVersion);
      this._requests.add(request);
      request.getPromise().then(() => this._requests.delete(request), () => this._requests.delete(request));
      return request;
    } else {
      return new FailRequest(appDeleted());
    }
  }
  async makeRequestWithTokens(requestInfo, requestFactory) {
    const [authToken, appCheckToken] = await Promise.all([
      this._getAuthToken(),
      this._getAppCheckToken()
    ]);
    return this._makeRequest(requestInfo, requestFactory, authToken, appCheckToken).getPromise();
  }
}
const name = "@firebase/storage";
const version = "0.9.9";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const STORAGE_TYPE = "storage";
function uploadBytes(ref2, data, metadata) {
  ref2 = getModularInstance(ref2);
  return uploadBytes$1(ref2, data, metadata);
}
function ref(serviceOrRef, pathOrUrl) {
  serviceOrRef = getModularInstance(serviceOrRef);
  return ref$1(serviceOrRef, pathOrUrl);
}
function getStorage(app2 = getApp(), bucketUrl) {
  app2 = getModularInstance(app2);
  const storageProvider = _getProvider(app2, STORAGE_TYPE);
  const storageInstance = storageProvider.getImmediate({
    identifier: bucketUrl
  });
  return storageInstance;
}
function connectStorageEmulator(storage, host, port, options = {}) {
  connectStorageEmulator$1(storage, host, port, options);
}
function factory(container, { instanceIdentifier: url }) {
  const app2 = container.getProvider("app").getImmediate();
  const authProvider = container.getProvider("auth-internal");
  const appCheckProvider = container.getProvider("app-check-internal");
  return new FirebaseStorageImpl(app2, authProvider, appCheckProvider, url, SDK_VERSION);
}
function registerStorage() {
  _registerComponent(new Component(STORAGE_TYPE, factory, "PUBLIC").setMultipleInstances(true));
  registerVersion(name, version, "");
  registerVersion(name, version, "esm2017");
}
registerStorage();
const globalConfig = {
  supportsFirebase: false
};
const updateGlobalConfig = (updates) => {
  Object.assign(globalConfig, updates);
};
const config = {
  apiKey: "AIzaSyCqk-k-XiYFYgPQo28ITj3qkxoqDGDrVk0",
  appId: "1:1011232276130:web:1ae2ea1437c349a4c2e1fb",
  authDomain: "api.octo.app",
  databaseURL: "https://octo-64838.firebaseio.com",
  messagingSenderId: "1011232276130",
  projectId: "octo-64838",
  storageBucket: "octo-64838.appspot.com"
};
const verifyConfig = () => {
  const missingKeys = Object.keys(config).filter((key) => !config[key]);
  if (missingKeys.length > 0) {
    console.warn(
      `Skipping Firebase initialization. Missing keys: [${missingKeys.join(", ")}]`
    );
    return false;
  }
  return true;
};
const init = () => {
  if (!verifyConfig()) {
    return;
  }
  const app2 = initializeApp(config);
  $a(app2, {
    experimentalAutoDetectLongPolling: true
  });
  O("error");
  if (location.hostname === "localhost" && !{ "VITE_APP_CDN_URL": "https://cdn.octo.app", "VITE_FATHOM_EVENT_CTA_MODAL_UPGRADE": "I4IWFGNK", "VITE_FATHOM_GOAL_ACCOUNT_REGISTRATION": "SQC05HQB", "VITE_FIREBASE_DATABASE_URL": "https://octo-64838.firebaseio.com", "VITE_FATHOM_EVENT_CTA_SIGN_UP_NOW": "TOVMVZSW", "VITE_FIREBASE_MESSAGING_SENDER_ID": "1011232276130", "VITE_FATHOM_SITE_URL": "https://twelve-intellectual.octo.app", "VITE_STRIPE_MONTHLY_PRICE": "price_1JXGjVFSSDySG1smmI1f8krR", "VITE_FIREBASE_STORAGE_BUCKET": "octo-64838.appspot.com", "VITE_FATHOM_EVENT_CTA_UPGRADE_TO_PRO": "WGUAVK63", "VITE_FIREBASE_AUTH_DOMAIN": "api.octo.app", "VITE_DISCORD_INVITE_LINK": "https://link.octo.app/discord", "VITE_FATHOM_SITE_ID": "NPCCHOAZ", "VITE_FATHOM_GOAL_CTA_SYNC_DOCS": "LO3GIHSZ", "VITE_FIREBASE_PROJECT_ID": "octo-64838", "VITE_FATHOM_EVENT_CTA_TRY_IT_OUT": "O6H36OQU", "VITE_FATHOM_EVENT_CTA_SETTINGS_UPGRADE": "92SS7KST", "VITE_FIREBASE_APP_ID": "1:1011232276130:web:1ae2ea1437c349a4c2e1fb", "VITE_FATHOM_EVENT_CTA_CONTINUE_WITH_PRO": "YKH3CBR1", "VITE_FIREBASE_LOG_LEVEL": "error", "VITE_FIREBASE_API_KEY": "AIzaSyCqk-k-XiYFYgPQo28ITj3qkxoqDGDrVk0", "VITE_FATHOM_EVENT_CTA_OPEN_APP": "VGYOUBMF", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true }.VITE_FIREBASE_EMULATOR_BYPASS) {
    connectAuthEmulator(
      getAuth(),
      { "VITE_APP_CDN_URL": "https://cdn.octo.app", "VITE_FATHOM_EVENT_CTA_MODAL_UPGRADE": "I4IWFGNK", "VITE_FATHOM_GOAL_ACCOUNT_REGISTRATION": "SQC05HQB", "VITE_FIREBASE_DATABASE_URL": "https://octo-64838.firebaseio.com", "VITE_FATHOM_EVENT_CTA_SIGN_UP_NOW": "TOVMVZSW", "VITE_FIREBASE_MESSAGING_SENDER_ID": "1011232276130", "VITE_FATHOM_SITE_URL": "https://twelve-intellectual.octo.app", "VITE_STRIPE_MONTHLY_PRICE": "price_1JXGjVFSSDySG1smmI1f8krR", "VITE_FIREBASE_STORAGE_BUCKET": "octo-64838.appspot.com", "VITE_FATHOM_EVENT_CTA_UPGRADE_TO_PRO": "WGUAVK63", "VITE_FIREBASE_AUTH_DOMAIN": "api.octo.app", "VITE_DISCORD_INVITE_LINK": "https://link.octo.app/discord", "VITE_FATHOM_SITE_ID": "NPCCHOAZ", "VITE_FATHOM_GOAL_CTA_SYNC_DOCS": "LO3GIHSZ", "VITE_FIREBASE_PROJECT_ID": "octo-64838", "VITE_FATHOM_EVENT_CTA_TRY_IT_OUT": "O6H36OQU", "VITE_FATHOM_EVENT_CTA_SETTINGS_UPGRADE": "92SS7KST", "VITE_FIREBASE_APP_ID": "1:1011232276130:web:1ae2ea1437c349a4c2e1fb", "VITE_FATHOM_EVENT_CTA_CONTINUE_WITH_PRO": "YKH3CBR1", "VITE_FIREBASE_LOG_LEVEL": "error", "VITE_FIREBASE_API_KEY": "AIzaSyCqk-k-XiYFYgPQo28ITj3qkxoqDGDrVk0", "VITE_FATHOM_EVENT_CTA_OPEN_APP": "VGYOUBMF", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true }.VITE_FIREBASE_EMULATOR_AUTH,
      {
        disableWarnings: true
      }
    );
    Ra(
      Ba(),
      { "VITE_APP_CDN_URL": "https://cdn.octo.app", "VITE_FATHOM_EVENT_CTA_MODAL_UPGRADE": "I4IWFGNK", "VITE_FATHOM_GOAL_ACCOUNT_REGISTRATION": "SQC05HQB", "VITE_FIREBASE_DATABASE_URL": "https://octo-64838.firebaseio.com", "VITE_FATHOM_EVENT_CTA_SIGN_UP_NOW": "TOVMVZSW", "VITE_FIREBASE_MESSAGING_SENDER_ID": "1011232276130", "VITE_FATHOM_SITE_URL": "https://twelve-intellectual.octo.app", "VITE_STRIPE_MONTHLY_PRICE": "price_1JXGjVFSSDySG1smmI1f8krR", "VITE_FIREBASE_STORAGE_BUCKET": "octo-64838.appspot.com", "VITE_FATHOM_EVENT_CTA_UPGRADE_TO_PRO": "WGUAVK63", "VITE_FIREBASE_AUTH_DOMAIN": "api.octo.app", "VITE_DISCORD_INVITE_LINK": "https://link.octo.app/discord", "VITE_FATHOM_SITE_ID": "NPCCHOAZ", "VITE_FATHOM_GOAL_CTA_SYNC_DOCS": "LO3GIHSZ", "VITE_FIREBASE_PROJECT_ID": "octo-64838", "VITE_FATHOM_EVENT_CTA_TRY_IT_OUT": "O6H36OQU", "VITE_FATHOM_EVENT_CTA_SETTINGS_UPGRADE": "92SS7KST", "VITE_FIREBASE_APP_ID": "1:1011232276130:web:1ae2ea1437c349a4c2e1fb", "VITE_FATHOM_EVENT_CTA_CONTINUE_WITH_PRO": "YKH3CBR1", "VITE_FIREBASE_LOG_LEVEL": "error", "VITE_FIREBASE_API_KEY": "AIzaSyCqk-k-XiYFYgPQo28ITj3qkxoqDGDrVk0", "VITE_FATHOM_EVENT_CTA_OPEN_APP": "VGYOUBMF", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true }.VITE_FIREBASE_EMULATOR_FIRESTORE_HOST,
      { "VITE_APP_CDN_URL": "https://cdn.octo.app", "VITE_FATHOM_EVENT_CTA_MODAL_UPGRADE": "I4IWFGNK", "VITE_FATHOM_GOAL_ACCOUNT_REGISTRATION": "SQC05HQB", "VITE_FIREBASE_DATABASE_URL": "https://octo-64838.firebaseio.com", "VITE_FATHOM_EVENT_CTA_SIGN_UP_NOW": "TOVMVZSW", "VITE_FIREBASE_MESSAGING_SENDER_ID": "1011232276130", "VITE_FATHOM_SITE_URL": "https://twelve-intellectual.octo.app", "VITE_STRIPE_MONTHLY_PRICE": "price_1JXGjVFSSDySG1smmI1f8krR", "VITE_FIREBASE_STORAGE_BUCKET": "octo-64838.appspot.com", "VITE_FATHOM_EVENT_CTA_UPGRADE_TO_PRO": "WGUAVK63", "VITE_FIREBASE_AUTH_DOMAIN": "api.octo.app", "VITE_DISCORD_INVITE_LINK": "https://link.octo.app/discord", "VITE_FATHOM_SITE_ID": "NPCCHOAZ", "VITE_FATHOM_GOAL_CTA_SYNC_DOCS": "LO3GIHSZ", "VITE_FIREBASE_PROJECT_ID": "octo-64838", "VITE_FATHOM_EVENT_CTA_TRY_IT_OUT": "O6H36OQU", "VITE_FATHOM_EVENT_CTA_SETTINGS_UPGRADE": "92SS7KST", "VITE_FIREBASE_APP_ID": "1:1011232276130:web:1ae2ea1437c349a4c2e1fb", "VITE_FATHOM_EVENT_CTA_CONTINUE_WITH_PRO": "YKH3CBR1", "VITE_FIREBASE_LOG_LEVEL": "error", "VITE_FIREBASE_API_KEY": "AIzaSyCqk-k-XiYFYgPQo28ITj3qkxoqDGDrVk0", "VITE_FATHOM_EVENT_CTA_OPEN_APP": "VGYOUBMF", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true }.VITE_FIREBASE_EMULATOR_FIRESTORE_PORT
    );
    connectStorageEmulator(
      getStorage(),
      { "VITE_APP_CDN_URL": "https://cdn.octo.app", "VITE_FATHOM_EVENT_CTA_MODAL_UPGRADE": "I4IWFGNK", "VITE_FATHOM_GOAL_ACCOUNT_REGISTRATION": "SQC05HQB", "VITE_FIREBASE_DATABASE_URL": "https://octo-64838.firebaseio.com", "VITE_FATHOM_EVENT_CTA_SIGN_UP_NOW": "TOVMVZSW", "VITE_FIREBASE_MESSAGING_SENDER_ID": "1011232276130", "VITE_FATHOM_SITE_URL": "https://twelve-intellectual.octo.app", "VITE_STRIPE_MONTHLY_PRICE": "price_1JXGjVFSSDySG1smmI1f8krR", "VITE_FIREBASE_STORAGE_BUCKET": "octo-64838.appspot.com", "VITE_FATHOM_EVENT_CTA_UPGRADE_TO_PRO": "WGUAVK63", "VITE_FIREBASE_AUTH_DOMAIN": "api.octo.app", "VITE_DISCORD_INVITE_LINK": "https://link.octo.app/discord", "VITE_FATHOM_SITE_ID": "NPCCHOAZ", "VITE_FATHOM_GOAL_CTA_SYNC_DOCS": "LO3GIHSZ", "VITE_FIREBASE_PROJECT_ID": "octo-64838", "VITE_FATHOM_EVENT_CTA_TRY_IT_OUT": "O6H36OQU", "VITE_FATHOM_EVENT_CTA_SETTINGS_UPGRADE": "92SS7KST", "VITE_FIREBASE_APP_ID": "1:1011232276130:web:1ae2ea1437c349a4c2e1fb", "VITE_FATHOM_EVENT_CTA_CONTINUE_WITH_PRO": "YKH3CBR1", "VITE_FIREBASE_LOG_LEVEL": "error", "VITE_FIREBASE_API_KEY": "AIzaSyCqk-k-XiYFYgPQo28ITj3qkxoqDGDrVk0", "VITE_FATHOM_EVENT_CTA_OPEN_APP": "VGYOUBMF", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true }.VITE_FIREBASE_EMULATOR_STORAGE_HOST,
      { "VITE_APP_CDN_URL": "https://cdn.octo.app", "VITE_FATHOM_EVENT_CTA_MODAL_UPGRADE": "I4IWFGNK", "VITE_FATHOM_GOAL_ACCOUNT_REGISTRATION": "SQC05HQB", "VITE_FIREBASE_DATABASE_URL": "https://octo-64838.firebaseio.com", "VITE_FATHOM_EVENT_CTA_SIGN_UP_NOW": "TOVMVZSW", "VITE_FIREBASE_MESSAGING_SENDER_ID": "1011232276130", "VITE_FATHOM_SITE_URL": "https://twelve-intellectual.octo.app", "VITE_STRIPE_MONTHLY_PRICE": "price_1JXGjVFSSDySG1smmI1f8krR", "VITE_FIREBASE_STORAGE_BUCKET": "octo-64838.appspot.com", "VITE_FATHOM_EVENT_CTA_UPGRADE_TO_PRO": "WGUAVK63", "VITE_FIREBASE_AUTH_DOMAIN": "api.octo.app", "VITE_DISCORD_INVITE_LINK": "https://link.octo.app/discord", "VITE_FATHOM_SITE_ID": "NPCCHOAZ", "VITE_FATHOM_GOAL_CTA_SYNC_DOCS": "LO3GIHSZ", "VITE_FIREBASE_PROJECT_ID": "octo-64838", "VITE_FATHOM_EVENT_CTA_TRY_IT_OUT": "O6H36OQU", "VITE_FATHOM_EVENT_CTA_SETTINGS_UPGRADE": "92SS7KST", "VITE_FIREBASE_APP_ID": "1:1011232276130:web:1ae2ea1437c349a4c2e1fb", "VITE_FATHOM_EVENT_CTA_CONTINUE_WITH_PRO": "YKH3CBR1", "VITE_FIREBASE_LOG_LEVEL": "error", "VITE_FIREBASE_API_KEY": "AIzaSyCqk-k-XiYFYgPQo28ITj3qkxoqDGDrVk0", "VITE_FATHOM_EVENT_CTA_OPEN_APP": "VGYOUBMF", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true }.VITE_FIREBASE_EMULATOR_STORAGE_PORT
    );
  }
  updateGlobalConfig({ supportsFirebase: true });
};
const ACTIVATE_CONTEXT = "ACTIVATE_CONTEXT";
const ADD_DOCUMENT = "ADD_DOCUMENT";
const BLUR_EDITOR = "BLUR_EDITOR";
const DEACTIVATE_CONTEXT = "DEACTIVATE_CONTEXT";
const DISCARD_DOCUMENT = "DISCARD_DOCUMENT";
const DUPLICATE_DOCUMENT = "DUPLICATE_DOCUMENT";
const DOCUMENTS_LOADED = "DOCUMENTS_LOADED";
const EDIT_DOCUMENT = "EDIT_DOCUMENT";
const FOCUS_EDITOR = "FOCUS_EDITOR";
const LOAD_DOCUMENT = "LOAD_DOCUMENT";
const LOAD_DOCUMENTS = "LOAD_DOCUMENTS";
const MERGE_DOCUMENT = "MERGE_DOCUMENT";
const MERGE_DOCUMENTS = "MERGE_DOCUMENTS";
const RESTORE_DOCUMENT = "RESTORE_DOCUMENT";
const RESTRICT_DOCUMENT = "RESTRICT_DOCUMENT";
const SET_CONTEXT_TAGS = "SET_CONTEXT_TAGS";
const SET_DOCUMENT = "SET_DOCUMENT";
const SET_EDITOR = "SET_EDITOR";
const SET_MOD_KEY = "SET_MOD_KEY";
const SET_OFFLINE = "SET_OFFLINE";
const SET_ONLINE = "SET_ONLINE";
const SET_RIGHT_SIDEBAR_VISIBILITY = "SET_RIGHT_SIDEBAR_VISIBILITY";
const SET_SHOW_WELCOME = "SET_SHOW_WELCOME";
const SHARE_DOCUMENT = "SHARE_DOCUMENT";
const SIGN_OUT = "SIGN_OUT";
const SYNC = "SYNC";
const TOUCH_DOCUMENT = "TOUCH_DOCUMENT";
const SET_SUBSCRIPTION = "SET_SUBSCRIPTION";
const SET_USER = "SET_USER";
const authModule = {
  state: () => ({
    isEvaluated: false,
    subscription: {
      pro: false
    },
    user: null
  }),
  mutations: {
    [SET_SUBSCRIPTION](state, subscription) {
      state.subscription = subscription;
    },
    [SET_USER](state, user) {
      state.user = user;
      state.isEvaluated = true;
    }
  },
  actions: {
    async [SET_USER](context, payload) {
      context.commit(SET_USER, payload);
    },
    async [SIGN_OUT](context, payload) {
      getAuth().signOut();
      return context.dispatch(SET_USER, { user: null });
    }
  }
};
const ADD_CONTEXT = "ADD_CONTEXT";
const LOAD_CONTEXT = "LOAD_CONTEXT";
const LOAD_CONTEXTS = "LOAD_CONTEXTS";
const REMOVE_CONTEXT = "REMOVE_CONTEXT";
const contextsModule = {
  state: () => ({
    all: []
  }),
  getters: {
    sortedContexts(state, _getters) {
      return state.all.sort((a2, b2) => {
        if (a2.name === b2.name)
          return 0;
        return a2.name < b2.name ? -1 : 1;
      });
    }
  },
  mutations: {
    [ADD_CONTEXT](state, context) {
      state.all.push(context);
    },
    [LOAD_CONTEXT](state, context) {
      state.all.push(context);
    },
    [REMOVE_CONTEXT](state, context) {
      state.all = state.all.filter((c2) => c2.id !== context.id);
    }
  },
  actions: {
    [LOAD_CONTEXTS]({ commit: commit2 }, contexts) {
      contexts.forEach((context) => {
        commit2(LOAD_CONTEXT, context);
      });
    }
  }
};
let random = (bytes) => crypto.getRandomValues(new Uint8Array(bytes));
let customRandom = (alphabet, defaultSize, getRandom) => {
  let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
  let step = -~(1.6 * mask * defaultSize / alphabet.length);
  return (size2 = defaultSize) => {
    let id2 = "";
    while (true) {
      let bytes = getRandom(step);
      let j2 = step;
      while (j2--) {
        id2 += alphabet[bytes[j2] & mask] || "";
        if (id2.length === size2)
          return id2;
      }
    }
  };
};
let customAlphabet = (alphabet, size2 = 21) => customRandom(alphabet, size2, random);
let nanoid = (size2 = 21) => crypto.getRandomValues(new Uint8Array(size2)).reduce((id2, byte) => {
  byte &= 63;
  if (byte < 36) {
    id2 += byte.toString(36);
  } else if (byte < 62) {
    id2 += (byte - 26).toString(36).toUpperCase();
  } else if (byte > 62) {
    id2 += "-";
  } else {
    id2 += "_";
  }
  return id2;
}, "");
const decode = (bytestream) => {
  const decoder = new TextDecoder();
  return decoder.decode(bytestream);
};
const encode = (data) => {
  const encoder = new TextEncoder();
  return encoder.encode(data);
};
const generateIv = () => {
  return window.crypto.getRandomValues(new Uint8Array(12));
};
const pack$1 = (buffer) => {
  return window.btoa(
    String.fromCharCode.apply(null, new Uint8Array(buffer))
  );
};
const unpack$1 = (packed) => {
  const string = window.atob(packed);
  const buffer = new ArrayBuffer(string.length);
  const bufferView = new Uint8Array(buffer);
  for (let i2 = 0; i2 < string.length; i2++) {
    bufferView[i2] = string.charCodeAt(i2);
  }
  return buffer;
};
const algorithm$1 = {
  name: "RSA-OAEP"
};
const decrypt$2 = async (cipher, privateKey) => {
  const decrypted = await window.crypto.subtle.decrypt(algorithm$1, privateKey, cipher);
  return decode(decrypted);
};
const exportKeys = async (keys2) => {
  const exported = {};
  if (keys2.privateKey) {
    exported.privateKey = await exportPrivateKey(keys2.privateKey);
  }
  if (keys2.publicKey) {
    exported.publicKey = await exportPublicKey(keys2.publicKey);
  }
  return exported;
};
const exportPrivateKey = async (key) => {
  const base642 = pack$1(await window.crypto.subtle.exportKey("pkcs8", key));
  return `-----BEGIN PRIVATE KEY-----
${base642}
-----END PRIVATE KEY-----`;
};
const exportPublicKey = async (key) => {
  const base642 = pack$1(await window.crypto.subtle.exportKey("spki", key));
  return `-----BEGIN PUBLIC KEY-----
${base642}
-----END PUBLIC KEY-----`;
};
const generateKeys = async () => {
  return window.crypto.subtle.generateKey({
    hash: "SHA-512",
    modulusLength: 4096,
    name: algorithm$1.name,
    publicExponent: new Uint8Array([1, 0, 1])
  }, true, ["encrypt", "decrypt"]);
};
const importKeys = async (exported) => {
  const keys2 = {};
  if (exported.privateKey) {
    keys2.privateKey = await importPrivateKey(exported.privateKey);
  }
  if (exported.publicKey) {
    keys2.publicKey = await importPublicKey(exported.publicKey);
  }
  return keys2;
};
const importPrivateKey = async (pemKey) => {
  const header = "-----BEGIN PRIVATE KEY-----";
  const footer = "-----END PRIVATE KEY-----";
  const base642 = pemKey.substring(header.length, pemKey.length - footer.length);
  const buffer = unpack$1(base642);
  return window.crypto.subtle.importKey("pkcs8", buffer, {
    hash: "SHA-512",
    name: algorithm$1.name
  }, true, ["decrypt", "unwrapKey"]);
};
const importPublicKey = async (pemKey) => {
  const header = "-----BEGIN PUBLIC KEY-----";
  const footer = "-----END PUBLIC KEY-----";
  const base642 = pemKey.substring(header.length, pemKey.length - footer.length);
  const buffer = unpack$1(base642);
  return window.crypto.subtle.importKey("spki", buffer, {
    hash: "SHA-512",
    name: algorithm$1.name
  }, true, ["encrypt", "wrapKey"]);
};
const asym = {
  algorithm: algorithm$1,
  decrypt: decrypt$2,
  exportKeys,
  exportPrivateKey,
  exportPublicKey,
  generateKeys,
  importKeys,
  importPrivateKey,
  importPublicKey
};
const algorithm = {
  name: "AES-GCM"
};
const decrypt$1 = async (cipher, key, iv) => {
  const encoded = await window.crypto.subtle.decrypt({
    name: algorithm.name,
    iv
  }, key, cipher);
  return decode(encoded);
};
const encrypt$1 = async (data, key) => {
  const encoded = encode(data);
  const iv = generateIv();
  const cipher = await window.crypto.subtle.encrypt({
    name: algorithm.name,
    iv
  }, key, encoded);
  return {
    cipher,
    iv
  };
};
const generateKey = async () => {
  return window.crypto.subtle.generateKey({
    name: algorithm.name,
    length: 256
  }, true, ["encrypt", "decrypt"]);
};
const importKey = async (keyBuffer) => {
  return window.crypto.subtle.importKey("raw", keyBuffer, algorithm.name, true, ["decrypt", "encrypt"]);
};
const sym = {
  algorithm,
  decrypt: decrypt$1,
  encrypt: encrypt$1,
  generateKey,
  importKey
};
const unwrapKey = async (wrappedKey, privateKey) => {
  return window.crypto.subtle.unwrapKey("raw", wrappedKey, privateKey, asym.algorithm, sym.algorithm, true, ["encrypt", "decrypt"]);
};
const wrapKey = async (key, publicKey) => {
  return window.crypto.subtle.wrapKey("raw", key, publicKey, asym.algorithm);
};
const decrypt = async (options) => {
  const cipher = unpack$1(options.cipher);
  const cipherKey = unpack$1(options.cipherKey);
  const iv = unpack$1(options.iv);
  const { privateKey } = await asym.importKeys({ privateKey: options.privateKey });
  try {
    var dataKey = await unwrapKey(cipherKey, privateKey);
  } catch (_error) {
    var dataKey = await asym.decrypt(cipherKey, privateKey).then((dec) => sym.importKey(unpack$1(dec)));
  }
  return sym.decrypt(cipher, dataKey, iv);
};
const encrypt = async (options) => {
  const dataKey = await sym.generateKey();
  const { cipher, iv } = await sym.encrypt(options.data, dataKey);
  const { publicKey } = await asym.importKeys({ publicKey: options.publicKey });
  const cipherKey = await wrapKey(dataKey, publicKey);
  return {
    cipher: pack$1(cipher),
    cipherKey: pack$1(cipherKey),
    iv: pack$1(iv)
  };
};
const unicodeLettersAndMarks = /A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D/;
const unicodeNumbers = /0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19/;
const hashtagSpecialChars = /_\u200c\u200d\ua67e\u05be\u05f3\u05f4\uff5e\u301c\u309b\u309c\u30a0\u30fb\u3003\u0f0b\u0f0c\u00b7/;
const hashSigns = /[#＃]/;
const hashtagChars = new RegExp(`[${unicodeLettersAndMarks.source}${unicodeNumbers.source}${hashtagSpecialChars.source}/-]`);
const hashtagBoundary = /(?<boundary>^|\s)/;
const hashtag = new RegExp(`(?<sign>${hashSigns.source})(?!${/\ufe0f|\u20e3/.source})(?<tag>${hashtagChars.source}+)`, "i");
const hashtagWithBoundary = new RegExp(`(?:${hashtagBoundary.source})(?:${hashtag.source})`, "i");
const hashtagStart = new RegExp(`${hashtagBoundary.source}(?<sign>${hashSigns.source})(?!${/\ufe0f|\u20e3/.source})`, "i");
const HASHTAG_CODES = [35, 65283];
const MATCH_HASHTAG_PREFIX = new RegExp(`(${hashtagBoundary.source}${hashSigns.source})$`, "i");
const formatMatch = (match) => {
  var _a2, _b, _c2;
  const boundary = ((_a2 = match.groups) == null ? void 0 : _a2.boundary) || "";
  const sign = ((_b = match.groups) == null ? void 0 : _b.sign) || "";
  const tag = ((_c2 = match.groups) == null ? void 0 : _c2.tag) || "";
  return {
    index: Number(match.index),
    length: boundary.length + sign.length + tag.length,
    boundary,
    sign,
    tag
  };
};
const matchHashtag = (text) => {
  const match = text.match(hashtagWithBoundary);
  if (!match) {
    return null;
  }
  return formatMatch(match);
};
const matchHashtagPrefix = (text) => {
  const match = text.match(MATCH_HASHTAG_PREFIX);
  if (!match) {
    return null;
  }
  return formatMatch(match);
};
const matchStarts = (text) => {
  const matches = text.matchAll(new RegExp(hashtagStart.source, "gi"));
  return [...matches].map((match) => {
    return formatMatch(match);
  });
};
const codeBlockIndicators = ["`````", "````", "```"];
const codeInlineIndicators = ["``", "`"];
const trashMultiline = new RegExp(codeBlockIndicators.map((ind) => `${ind}.*?${ind}`).join("|"));
const trashInline = new RegExp(codeInlineIndicators.map((ind) => `${ind}[^
]*?${ind}`).join("|"));
const trashBin = new RegExp(`${trashMultiline.source}|${trashInline.source}`);
const referencesRegex = new RegExp(`${trashBin.source}|\\[\\[(.*?)\\]\\]`, "gsi");
const tagsRegex = new RegExp(`${trashBin.source}|(${hashtagWithBoundary.source})`, "gsi");
const codeRegex = /```([^\n\s]*)(?:\s([\w-]+\.[\w]+))?\n(.*?)```/gs;
const headersRegex = /````.*?````|```.*?```|``.*?``|`.*?`|\w+:\/?\/?\S*|# ([^\n]+)/gs;
const tasksRegex = /````.*?````|```.*?```|``.*?``|`.*?`|- \[ \] ([^\n]+)/gs;
const parse = (regex, text) => {
  let matches = null;
  const results = [];
  while (matches = regex.exec(text)) {
    results.push(matches);
  }
  return results;
};
const parseCodeblocks = (text) => {
  const matches = parse(codeRegex, text);
  const results = [];
  matches.forEach((match) => {
    if (match) {
      results.push({
        filename: match[2],
        language: match[1],
        code: match[3]
      });
    }
  });
  return results;
};
const parseReferences = (text) => {
  const matches = parse(referencesRegex, text);
  const references = /* @__PURE__ */ new Set();
  matches.forEach((match) => {
    if (match && match[1]) {
      references.add(match[1]);
    }
  });
  return Array.from(references).sort();
};
const parseTags = (text) => {
  const matches = parse(tagsRegex, text);
  const tags = /* @__PURE__ */ new Set();
  matches.forEach((match) => {
    if (match && match[1]) {
      tags.add(match[1].toLowerCase().trim().slice(1));
    }
  });
  return Array.from(tags).sort();
};
const parseHeaders = (text) => {
  const matches = parse(headersRegex, text);
  const headers = [];
  matches.forEach((match) => {
    if (match && match[1]) {
      headers.push(match[1]);
    }
  });
  return headers;
};
const parseTasks = (text) => {
  const matches = parse(tasksRegex, text);
  const results = [];
  matches.forEach((match) => {
    if (match && match[1]) {
      results.push(match[1]);
    }
  });
  return results;
};
class Doc {
  constructor(attributes = {}) {
    this.id = attributes.id || nanoid();
    this.text = attributes.text || "";
    this.textKey = attributes.textKey || null;
    this.daily = attributes.daily || false;
    this.iv = attributes.iv || null;
    this.encrypted = attributes.encrypted || false;
    this.createdAt = attributes.createdAt || new Date();
    this.updatedAt = attributes.updatedAt || new Date();
    this.touchedAt = attributes.touchedAt || new Date();
    this.discardedAt = attributes.discardedAt || null;
    this.headers = this.encrypted ? [] : parseHeaders(this.text);
    this.tags = this.encrypted ? [] : parseTags(this.text);
    this.tasks = this.encrypted ? [] : parseTasks(this.text);
    this.firebaseId = attributes.firebaseId || null;
    this.ownerId = attributes.ownerId || null;
    this.syncedAt = attributes.syncedAt || null;
    this.public = attributes.public || false;
  }
  discard() {
    this.updatedAt = new Date();
    this.touchedAt = new Date();
    this.discardedAt = new Date();
  }
  duplicate() {
    return new Doc({ text: this.text });
  }
  merge(attributes) {
    Object.assign(this, attributes, { id: this.id });
  }
  restore() {
    this.updatedAt = new Date();
    this.touchedAt = new Date();
    this.discardedAt = null;
  }
  restrict() {
    this.public = false;
    this.updatedAt = new Date();
    this.touchedAt = new Date();
  }
  share() {
    this.public = true;
    this.updatedAt = new Date();
    this.touchedAt = new Date();
  }
  touch() {
    this.touchedAt = new Date();
  }
  update({ text }) {
    this.text = text;
    this.headers.splice(0, this.headers.length, ...parseHeaders(text));
    this.tags.splice(0, this.tags.length, ...parseTags(text));
    this.tasks.splice(0, this.tasks.length, ...parseTasks(text));
    this.updatedAt = new Date();
    this.touchedAt = new Date();
  }
}
const pack = async (doc2, { preferEncryption = null, publicKey = null }) => {
  const packed = Object.assign({}, {
    ...doc2,
    headers: [],
    tags: [],
    tasks: []
  });
  if (preferEncryption && publicKey && !doc2.encrypted && !doc2.public) {
    const { cipher, cipherKey, iv } = await encrypt({ data: packed.text, publicKey });
    return Object.assign({}, packed, {
      encrypted: true,
      iv,
      text: cipher,
      textKey: cipherKey
    });
  }
  return Object.assign({}, packed);
};
const unpack = async (packed, { privateKey }) => {
  try {
    if (privateKey && packed.encrypted) {
      const text = await decrypt({ cipher: packed.text, cipherKey: packed.textKey, iv: packed.iv, privateKey });
      return new Doc(
        Object.assign({}, packed, {
          encrypted: false,
          text
        })
      );
    }
  } catch (_error) {
  }
  return new Doc(packed);
};
const findDoc$1 = (state, id2) => {
  return state.all.filter((doc2) => !doc2.encrypted).find((doc2) => doc2.id === id2);
};
const documentsModule = {
  state: () => ({
    all: [],
    currentId: null,
    loaded: false
  }),
  getters: {
    allKept(_state, getters) {
      return getters.sorted.filter((doc2) => doc2.discardedAt === null);
    },
    daily(_state, getters) {
      return getters.sortedByCreated.find((doc2) => doc2.daily);
    },
    currentDoc(state, getters) {
      return getters.decrypted.find((doc2) => doc2.id === state.currentId);
    },
    decrypted(state) {
      return state.all.filter((doc2) => !doc2.encrypted);
    },
    discarded(_state, getters) {
      return getters.sorted.filter((doc2) => doc2.discardedAt !== null);
    },
    filtered(state, getters, globalState) {
      if (globalState.context.active) {
        return getters.sorted.filter((doc2) => {
          return globalState.context.tags.some((t2) => doc2.tags.includes(t2));
        });
      }
      return getters.sorted;
    },
    kept(_state, getters) {
      return getters.filtered.filter((doc2) => doc2.discardedAt === null);
    },
    sorted(_state, getters) {
      return getters.decrypted.sort((a2, b2) => {
        return b2.updatedAt - a2.updatedAt;
      });
    },
    sortedByCreated(_state, getters) {
      return getters.decrypted.sort((a2, b2) => {
        return b2.createdAt - a2.createdAt;
      });
    },
    tasks(_state, getters, _globalState, _globalGetters) {
      return getters.kept.filter((doc2) => doc2.tasks.length > 0);
    },
    untagged(_state, getters) {
      return getters.allKept.filter((doc2) => doc2.tags.length == 0);
    },
    withTag(_state, getters) {
      return (tag) => {
        return getters.kept.filter((doc2) => !!doc2.tags.find((t2) => t2 === tag));
      };
    }
  },
  mutations: {
    [ADD_DOCUMENT](state, doc2) {
      state.all.push(doc2);
    },
    [DISCARD_DOCUMENT](state, { id: id2 }) {
      findDoc$1(state, id2).discard();
    },
    [DOCUMENTS_LOADED](state) {
      state.loaded = true;
    },
    [EDIT_DOCUMENT](state, { id: id2, text }) {
      findDoc$1(state, id2).update({ text });
    },
    [LOAD_DOCUMENT](state, doc2) {
      state.all.push(doc2);
    },
    [MERGE_DOCUMENT](state, doc2) {
      findDoc$1(state, doc2.id).merge(doc2);
    },
    [RESTORE_DOCUMENT](state, { id: id2 }) {
      findDoc$1(state, id2).restore();
    },
    [RESTRICT_DOCUMENT](state, { id: id2 }) {
      findDoc$1(state, id2).restrict();
    },
    [SET_DOCUMENT](state, { id: id2 }) {
      state.currentId = id2;
      if (id2) {
        const recentDocs = useRecentDocs();
        recentDocs.add(id2);
      }
    },
    [SHARE_DOCUMENT](state, { id: id2 }) {
      findDoc$1(state, id2).share();
    },
    [TOUCH_DOCUMENT](state, { id: id2 }) {
      findDoc$1(state, id2).touch();
    }
  },
  actions: {
    async [ADD_DOCUMENT](context, doc2) {
      context.commit(ADD_DOCUMENT, doc2);
    },
    async [DISCARD_DOCUMENT](context, doc2) {
      context.commit(DISCARD_DOCUMENT, doc2);
    },
    async [DOCUMENTS_LOADED](context) {
      context.commit(DOCUMENTS_LOADED);
    },
    async [DUPLICATE_DOCUMENT](context, { id: id2 }) {
      const newDoc = findDoc$1(context.state, id2).duplicate();
      context.commit(ADD_DOCUMENT, newDoc);
      return newDoc.id;
    },
    async [EDIT_DOCUMENT](context, doc2) {
      context.commit(EDIT_DOCUMENT, doc2);
    },
    async [LOAD_DOCUMENT](context, doc2) {
      context.commit(LOAD_DOCUMENT, doc2);
    },
    async [LOAD_DOCUMENTS](context, docs) {
      return Promise.all(
        docs.map((doc2) => context.dispatch(LOAD_DOCUMENT, doc2))
      );
    },
    async [MERGE_DOCUMENT](context, doc2) {
      context.commit(MERGE_DOCUMENT, doc2);
    },
    async [MERGE_DOCUMENTS](context, docs) {
      const originalDocs = docs.map((doc2) => findDoc$1(context.state, doc2.id));
      const newDoc = new Doc({
        text: originalDocs.map((doc2) => doc2.text).join("\n\n")
      });
      context.commit(ADD_DOCUMENT, newDoc);
      return originalDocs.map((doc2) => context.dispatch(DISCARD_DOCUMENT, doc2));
    },
    async [RESTORE_DOCUMENT](context, doc2) {
      context.commit(RESTORE_DOCUMENT, doc2);
    },
    async [RESTRICT_DOCUMENT](context, doc2) {
      context.commit(RESTRICT_DOCUMENT, doc2);
    },
    async [SET_DOCUMENT](context, { id: id2 }) {
      context.commit(SET_DOCUMENT, { id: id2 });
    },
    async [SHARE_DOCUMENT](context, doc2) {
      context.commit(SHARE_DOCUMENT, doc2);
    },
    async [TOUCH_DOCUMENT](context, doc2) {
      context.commit(TOUCH_DOCUMENT, doc2);
    }
  }
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n2) {
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function() {
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else
    a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var mousetrap = { exports: {} };
(function(module) {
  (function(window2, document2, undefined$1) {
    if (!window2) {
      return;
    }
    var _MAP = {
      8: "backspace",
      9: "tab",
      13: "enter",
      16: "shift",
      17: "ctrl",
      18: "alt",
      20: "capslock",
      27: "esc",
      32: "space",
      33: "pageup",
      34: "pagedown",
      35: "end",
      36: "home",
      37: "left",
      38: "up",
      39: "right",
      40: "down",
      45: "ins",
      46: "del",
      91: "meta",
      93: "meta",
      224: "meta"
    };
    var _KEYCODE_MAP = {
      106: "*",
      107: "+",
      109: "-",
      110: ".",
      111: "/",
      186: ";",
      187: "=",
      188: ",",
      189: "-",
      190: ".",
      191: "/",
      192: "`",
      219: "[",
      220: "\\",
      221: "]",
      222: "'"
    };
    var _SHIFT_MAP = {
      "~": "`",
      "!": "1",
      "@": "2",
      "#": "3",
      "$": "4",
      "%": "5",
      "^": "6",
      "&": "7",
      "*": "8",
      "(": "9",
      ")": "0",
      "_": "-",
      "+": "=",
      ":": ";",
      '"': "'",
      "<": ",",
      ">": ".",
      "?": "/",
      "|": "\\"
    };
    var _SPECIAL_ALIASES = {
      "option": "alt",
      "command": "meta",
      "return": "enter",
      "escape": "esc",
      "plus": "+",
      "mod": /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? "meta" : "ctrl"
    };
    var _REVERSE_MAP;
    for (var i2 = 1; i2 < 20; ++i2) {
      _MAP[111 + i2] = "f" + i2;
    }
    for (i2 = 0; i2 <= 9; ++i2) {
      _MAP[i2 + 96] = i2.toString();
    }
    function _addEvent(object, type2, callback) {
      if (object.addEventListener) {
        object.addEventListener(type2, callback, false);
        return;
      }
      object.attachEvent("on" + type2, callback);
    }
    function _characterFromEvent(e2) {
      if (e2.type == "keypress") {
        var character = String.fromCharCode(e2.which);
        if (!e2.shiftKey) {
          character = character.toLowerCase();
        }
        return character;
      }
      if (_MAP[e2.which]) {
        return _MAP[e2.which];
      }
      if (_KEYCODE_MAP[e2.which]) {
        return _KEYCODE_MAP[e2.which];
      }
      return String.fromCharCode(e2.which).toLowerCase();
    }
    function _modifiersMatch(modifiers1, modifiers2) {
      return modifiers1.sort().join(",") === modifiers2.sort().join(",");
    }
    function _eventModifiers(e2) {
      var modifiers = [];
      if (e2.shiftKey) {
        modifiers.push("shift");
      }
      if (e2.altKey) {
        modifiers.push("alt");
      }
      if (e2.ctrlKey) {
        modifiers.push("ctrl");
      }
      if (e2.metaKey) {
        modifiers.push("meta");
      }
      return modifiers;
    }
    function _preventDefault(e2) {
      if (e2.preventDefault) {
        e2.preventDefault();
        return;
      }
      e2.returnValue = false;
    }
    function _stopPropagation(e2) {
      if (e2.stopPropagation) {
        e2.stopPropagation();
        return;
      }
      e2.cancelBubble = true;
    }
    function _isModifier(key) {
      return key == "shift" || key == "ctrl" || key == "alt" || key == "meta";
    }
    function _getReverseMap() {
      if (!_REVERSE_MAP) {
        _REVERSE_MAP = {};
        for (var key in _MAP) {
          if (key > 95 && key < 112) {
            continue;
          }
          if (_MAP.hasOwnProperty(key)) {
            _REVERSE_MAP[_MAP[key]] = key;
          }
        }
      }
      return _REVERSE_MAP;
    }
    function _pickBestAction(key, modifiers, action) {
      if (!action) {
        action = _getReverseMap()[key] ? "keydown" : "keypress";
      }
      if (action == "keypress" && modifiers.length) {
        action = "keydown";
      }
      return action;
    }
    function _keysFromString(combination) {
      if (combination === "+") {
        return ["+"];
      }
      combination = combination.replace(/\+{2}/g, "+plus");
      return combination.split("+");
    }
    function _getKeyInfo(combination, action) {
      var keys2;
      var key;
      var i3;
      var modifiers = [];
      keys2 = _keysFromString(combination);
      for (i3 = 0; i3 < keys2.length; ++i3) {
        key = keys2[i3];
        if (_SPECIAL_ALIASES[key]) {
          key = _SPECIAL_ALIASES[key];
        }
        if (action && action != "keypress" && _SHIFT_MAP[key]) {
          key = _SHIFT_MAP[key];
          modifiers.push("shift");
        }
        if (_isModifier(key)) {
          modifiers.push(key);
        }
      }
      action = _pickBestAction(key, modifiers, action);
      return {
        key,
        modifiers,
        action
      };
    }
    function _belongsTo(element, ancestor) {
      if (element === null || element === document2) {
        return false;
      }
      if (element === ancestor) {
        return true;
      }
      return _belongsTo(element.parentNode, ancestor);
    }
    function Mousetrap2(targetElement) {
      var self2 = this;
      targetElement = targetElement || document2;
      if (!(self2 instanceof Mousetrap2)) {
        return new Mousetrap2(targetElement);
      }
      self2.target = targetElement;
      self2._callbacks = {};
      self2._directMap = {};
      var _sequenceLevels = {};
      var _resetTimer;
      var _ignoreNextKeyup = false;
      var _ignoreNextKeypress = false;
      var _nextExpectedAction = false;
      function _resetSequences(doNotReset) {
        doNotReset = doNotReset || {};
        var activeSequences = false, key;
        for (key in _sequenceLevels) {
          if (doNotReset[key]) {
            activeSequences = true;
            continue;
          }
          _sequenceLevels[key] = 0;
        }
        if (!activeSequences) {
          _nextExpectedAction = false;
        }
      }
      function _getMatches(character, modifiers, e2, sequenceName, combination, level) {
        var i3;
        var callback;
        var matches = [];
        var action = e2.type;
        if (!self2._callbacks[character]) {
          return [];
        }
        if (action == "keyup" && _isModifier(character)) {
          modifiers = [character];
        }
        for (i3 = 0; i3 < self2._callbacks[character].length; ++i3) {
          callback = self2._callbacks[character][i3];
          if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {
            continue;
          }
          if (action != callback.action) {
            continue;
          }
          if (action == "keypress" && !e2.metaKey && !e2.ctrlKey || _modifiersMatch(modifiers, callback.modifiers)) {
            var deleteCombo = !sequenceName && callback.combo == combination;
            var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;
            if (deleteCombo || deleteSequence) {
              self2._callbacks[character].splice(i3, 1);
            }
            matches.push(callback);
          }
        }
        return matches;
      }
      function _fireCallback(callback, e2, combo, sequence) {
        if (self2.stopCallback(e2, e2.target || e2.srcElement, combo, sequence)) {
          return;
        }
        if (callback(e2, combo) === false) {
          _preventDefault(e2);
          _stopPropagation(e2);
        }
      }
      self2._handleKey = function(character, modifiers, e2) {
        var callbacks = _getMatches(character, modifiers, e2);
        var i3;
        var doNotReset = {};
        var maxLevel = 0;
        var processedSequenceCallback = false;
        for (i3 = 0; i3 < callbacks.length; ++i3) {
          if (callbacks[i3].seq) {
            maxLevel = Math.max(maxLevel, callbacks[i3].level);
          }
        }
        for (i3 = 0; i3 < callbacks.length; ++i3) {
          if (callbacks[i3].seq) {
            if (callbacks[i3].level != maxLevel) {
              continue;
            }
            processedSequenceCallback = true;
            doNotReset[callbacks[i3].seq] = 1;
            _fireCallback(callbacks[i3].callback, e2, callbacks[i3].combo, callbacks[i3].seq);
            continue;
          }
          if (!processedSequenceCallback) {
            _fireCallback(callbacks[i3].callback, e2, callbacks[i3].combo);
          }
        }
        var ignoreThisKeypress = e2.type == "keypress" && _ignoreNextKeypress;
        if (e2.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {
          _resetSequences(doNotReset);
        }
        _ignoreNextKeypress = processedSequenceCallback && e2.type == "keydown";
      };
      function _handleKeyEvent(e2) {
        if (typeof e2.which !== "number") {
          e2.which = e2.keyCode;
        }
        var character = _characterFromEvent(e2);
        if (!character) {
          return;
        }
        if (e2.type == "keyup" && _ignoreNextKeyup === character) {
          _ignoreNextKeyup = false;
          return;
        }
        self2.handleKey(character, _eventModifiers(e2), e2);
      }
      function _resetSequenceTimer() {
        clearTimeout(_resetTimer);
        _resetTimer = setTimeout(_resetSequences, 1e3);
      }
      function _bindSequence(combo, keys2, callback, action) {
        _sequenceLevels[combo] = 0;
        function _increaseSequence(nextAction) {
          return function() {
            _nextExpectedAction = nextAction;
            ++_sequenceLevels[combo];
            _resetSequenceTimer();
          };
        }
        function _callbackAndReset(e2) {
          _fireCallback(callback, e2, combo);
          if (action !== "keyup") {
            _ignoreNextKeyup = _characterFromEvent(e2);
          }
          setTimeout(_resetSequences, 10);
        }
        for (var i3 = 0; i3 < keys2.length; ++i3) {
          var isFinal = i3 + 1 === keys2.length;
          var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys2[i3 + 1]).action);
          _bindSingle(keys2[i3], wrappedCallback, action, combo, i3);
        }
      }
      function _bindSingle(combination, callback, action, sequenceName, level) {
        self2._directMap[combination + ":" + action] = callback;
        combination = combination.replace(/\s+/g, " ");
        var sequence = combination.split(" ");
        var info;
        if (sequence.length > 1) {
          _bindSequence(combination, sequence, callback, action);
          return;
        }
        info = _getKeyInfo(combination, action);
        self2._callbacks[info.key] = self2._callbacks[info.key] || [];
        _getMatches(info.key, info.modifiers, { type: info.action }, sequenceName, combination, level);
        self2._callbacks[info.key][sequenceName ? "unshift" : "push"]({
          callback,
          modifiers: info.modifiers,
          action: info.action,
          seq: sequenceName,
          level,
          combo: combination
        });
      }
      self2._bindMultiple = function(combinations, callback, action) {
        for (var i3 = 0; i3 < combinations.length; ++i3) {
          _bindSingle(combinations[i3], callback, action);
        }
      };
      _addEvent(targetElement, "keypress", _handleKeyEvent);
      _addEvent(targetElement, "keydown", _handleKeyEvent);
      _addEvent(targetElement, "keyup", _handleKeyEvent);
    }
    Mousetrap2.prototype.bind = function(keys2, callback, action) {
      var self2 = this;
      keys2 = keys2 instanceof Array ? keys2 : [keys2];
      self2._bindMultiple.call(self2, keys2, callback, action);
      return self2;
    };
    Mousetrap2.prototype.unbind = function(keys2, action) {
      var self2 = this;
      return self2.bind.call(self2, keys2, function() {
      }, action);
    };
    Mousetrap2.prototype.trigger = function(keys2, action) {
      var self2 = this;
      if (self2._directMap[keys2 + ":" + action]) {
        self2._directMap[keys2 + ":" + action]({}, keys2);
      }
      return self2;
    };
    Mousetrap2.prototype.reset = function() {
      var self2 = this;
      self2._callbacks = {};
      self2._directMap = {};
      return self2;
    };
    Mousetrap2.prototype.stopCallback = function(e2, element) {
      var self2 = this;
      if ((" " + element.className + " ").indexOf(" mousetrap ") > -1) {
        return false;
      }
      if (_belongsTo(element, self2.target)) {
        return false;
      }
      if ("composedPath" in e2 && typeof e2.composedPath === "function") {
        var initialEventTarget = e2.composedPath()[0];
        if (initialEventTarget !== e2.target) {
          element = initialEventTarget;
        }
      }
      return element.tagName == "INPUT" || element.tagName == "SELECT" || element.tagName == "TEXTAREA" || element.isContentEditable;
    };
    Mousetrap2.prototype.handleKey = function() {
      var self2 = this;
      return self2._handleKey.apply(self2, arguments);
    };
    Mousetrap2.addKeycodes = function(object) {
      for (var key in object) {
        if (object.hasOwnProperty(key)) {
          _MAP[key] = object[key];
        }
      }
      _REVERSE_MAP = null;
    };
    Mousetrap2.init = function() {
      var documentMousetrap = Mousetrap2(document2);
      for (var method in documentMousetrap) {
        if (method.charAt(0) !== "_") {
          Mousetrap2[method] = function(method2) {
            return function() {
              return documentMousetrap[method2].apply(documentMousetrap, arguments);
            };
          }(method);
        }
      }
    };
    Mousetrap2.init();
    window2.Mousetrap = Mousetrap2;
    if (module.exports) {
      module.exports = Mousetrap2;
    }
    if (typeof undefined$1 === "function" && undefined$1.amd) {
      undefined$1(function() {
        return Mousetrap2;
      });
    }
  })(typeof window !== "undefined" ? window : null, typeof window !== "undefined" ? document : null);
})(mousetrap);
const Mousetrap$1 = mousetrap.exports;
(function(a2) {
  var c2 = {}, d2 = a2.prototype.stopCallback;
  a2.prototype.stopCallback = function(e2, b2, a3, f2) {
    return this.paused ? true : c2[a3] || c2[f2] ? false : d2.call(this, e2, b2, a3);
  };
  a2.prototype.bindGlobal = function(a3, b2, d3) {
    this.bind(a3, b2, d3);
    if (a3 instanceof Array)
      for (b2 = 0; b2 < a3.length; b2++)
        c2[a3[b2]] = true;
    else
      c2[a3] = true;
  };
  a2.init();
})(Mousetrap);
const bind = ({ keybinding, callback }) => {
  Mousetrap$1.bind(keybinding, (e2, _sequence) => {
    e2.preventDefault();
    callback();
  });
};
const bindGlobal = (keybinding, callback) => {
  Mousetrap$1.bindGlobal(keybinding, (e2, _sequence) => {
    e2.preventDefault();
    callback();
  });
};
const unbind = ({ keybinding }) => {
  Mousetrap$1.unbind(keybinding);
};
const DISABLE_LISTENER = "DISABLE_LISTENER";
const DISABLE_LISTENERS = "DISABLE_LISTENERS";
const ENABLE_LISTENER = "ENABLE_LISTENER";
const ENABLE_LISTENERS = "ENABLE_LISTENERS";
const KEYBINDINGS_LOADED = "KEYBINDINGS_LOADED";
const LOAD_KEYBINDINGS = "LOAD_KEYBINDINGS";
const TOGGLE_LISTENERS = "TOGGLE_LISTENERS";
const goTo = (path) => {
  open$1({ path });
};
const makeCallback = (callback, context) => {
  return () => {
    callback();
    context.dispatch(DISABLE_LISTENERS);
  };
};
const makeListener = (keybinding, callback, context) => {
  return { keybinding, callback: makeCallback(callback, context) };
};
const makeListeners = (context) => {
  return [
    makeListener("a", () => goTo("/account"), context),
    makeListener("c", () => goTo("/contexts"), context),
    makeListener("d", () => goTo("/docs/f/discarded"), context),
    makeListener("e", () => goTo("/force-graph"), context),
    makeListener("n", () => goTo("/docs/new"), context),
    makeListener("p", () => goTo("/notepad"), context),
    makeListener("r", () => goTo("/docs"), context),
    makeListener("s", () => goTo("/settings"), context),
    makeListener("t", () => goTo("/docs/f/tasks"), context),
    makeListener("u", () => goTo("/docs/f/untagged"), context)
  ];
};
const keybindingsModule = {
  state: () => ({
    activeElement: null,
    listeners: [],
    listening: false,
    loaded: false
  }),
  getters: {},
  mutations: {
    [DISABLE_LISTENER](state, listener) {
      state.listeners = state.listeners.filter((l2) => l2 !== listener);
    },
    [DISABLE_LISTENERS](state) {
      state.listening = false;
    },
    [ENABLE_LISTENER](state, listener) {
      state.listeners.push(listener);
    },
    [ENABLE_LISTENERS](state) {
      state.listening = true;
    },
    [KEYBINDINGS_LOADED](state) {
      state.loaded = true;
    }
  },
  actions: {
    async [LOAD_KEYBINDINGS](context) {
      bindGlobal("esc", () => context.dispatch(DISABLE_LISTENERS));
      bindGlobal("mod+k", () => context.dispatch(TOGGLE_LISTENERS));
      bindGlobal("mod+s", () => context.dispatch(DISABLE_LISTENERS));
      bindGlobal("mod+shift+f", () => {
        context.dispatch(DISABLE_LISTENERS);
        goTo("/docs");
      });
      window.addEventListener("click", () => context.dispatch(DISABLE_LISTENERS));
      context.commit(KEYBINDINGS_LOADED);
    },
    async [DISABLE_LISTENER](context, listener) {
      unbind(listener);
      context.commit(DISABLE_LISTENER, listener);
    },
    async [DISABLE_LISTENERS](context) {
      await Promise.all(
        context.state.listeners.map((listener) => {
          context.dispatch(DISABLE_LISTENER, listener);
        })
      );
      if (context.state.activeElement) {
        context.state.activeElement.focus();
        context.state.activeElement = null;
      }
      context.commit(DISABLE_LISTENERS);
    },
    async [ENABLE_LISTENER](context, listener) {
      bind(listener);
      context.commit(ENABLE_LISTENER, listener);
    },
    async [ENABLE_LISTENERS](context) {
      context.state.activeElement = document.activeElement;
      context.state.activeElement.blur();
      await Promise.all(
        makeListeners(context).map((listener) => {
          context.dispatch(ENABLE_LISTENER, listener);
        })
      );
      context.commit(ENABLE_LISTENERS);
    },
    async [TOGGLE_LISTENERS](context, settings) {
      if (context.state.listening) {
        return context.dispatch(DISABLE_LISTENERS);
      } else {
        return context.dispatch(ENABLE_LISTENERS);
      }
    }
  }
};
var isMergeableObject = function isMergeableObject2(value) {
  return isNonNullObject(value) && !isSpecial(value);
};
function isNonNullObject(value) {
  return !!value && typeof value === "object";
}
function isSpecial(value) {
  var stringValue = Object.prototype.toString.call(value);
  return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
}
var canUseSymbol = typeof Symbol === "function" && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
function isReactElement(value) {
  return value.$$typeof === REACT_ELEMENT_TYPE;
}
function emptyTarget(val) {
  return Array.isArray(val) ? [] : {};
}
function cloneUnlessOtherwiseSpecified(value, options) {
  return options.clone !== false && options.isMergeableObject(value) ? deepmerge$1(emptyTarget(value), value, options) : value;
}
function defaultArrayMerge(target, source, options) {
  return target.concat(source).map(function(element) {
    return cloneUnlessOtherwiseSpecified(element, options);
  });
}
function getMergeFunction(key, options) {
  if (!options.customMerge) {
    return deepmerge$1;
  }
  var customMerge = options.customMerge(key);
  return typeof customMerge === "function" ? customMerge : deepmerge$1;
}
function getEnumerableOwnPropertySymbols(target) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
    return target.propertyIsEnumerable(symbol);
  }) : [];
}
function getKeys$1(target) {
  return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
}
function propertyIsOnObject(object, property) {
  try {
    return property in object;
  } catch (_2) {
    return false;
  }
}
function propertyIsUnsafe(target, key) {
  return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
}
function mergeObject(target, source, options) {
  var destination = {};
  if (options.isMergeableObject(target)) {
    getKeys$1(target).forEach(function(key) {
      destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
    });
  }
  getKeys$1(source).forEach(function(key) {
    if (propertyIsUnsafe(target, key)) {
      return;
    }
    if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
      destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
    } else {
      destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
    }
  });
  return destination;
}
function deepmerge$1(target, source, options) {
  options = options || {};
  options.arrayMerge = options.arrayMerge || defaultArrayMerge;
  options.isMergeableObject = options.isMergeableObject || isMergeableObject;
  options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
  var sourceIsArray = Array.isArray(source);
  var targetIsArray = Array.isArray(target);
  var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
  if (!sourceAndTargetTypesMatch) {
    return cloneUnlessOtherwiseSpecified(source, options);
  } else if (sourceIsArray) {
    return options.arrayMerge(target, source, options);
  } else {
    return mergeObject(target, source, options);
  }
}
deepmerge$1.all = function deepmergeAll(array, options) {
  if (!Array.isArray(array)) {
    throw new Error("first argument should be an array");
  }
  return array.reduce(function(prev, next) {
    return deepmerge$1(prev, next, options);
  }, {});
};
var deepmerge_1 = deepmerge$1;
var cjs = deepmerge_1;
const LOAD_SETTINGS = "LOAD_SETTINGS";
const SET_CRYPTO_ENABLED = "SET_CRYPTO_ENABLED";
const SET_CRYPTO_KEYS = "SET_CRYPTO_KEYS";
const SET_EDITOR_IMAGES_ENABLED = "SET_EDITOR_IMAGES_ENABLED";
const SET_EDITOR_IMAGES_SHOW_CAPTIONS = "SET_EDITOR_IMAGES_SHOW_CAPTIONS";
const SET_EDITOR_KEY_MAP = "SET_EDITOR_KEY_MAP";
const SET_EDITOR_LIGATURES = "SET_EDITOR_LIGATURES";
const SET_EDITOR_LISTS_ENABLED = "SET_EDITOR_LISTS_ENABLED";
const SET_EDITOR_READABILITY_ENABLED = "SET_EDITOR_READABILITY_ENABLED";
const SET_EDITOR_READABILITY_MAX_WIDTH = "SET_EDITOR_READABILITY_MAX_WIDTH";
const SET_EDITOR_READABILITY_WORDS_PER_MINUTE = "SET_EDITOR_READABILITY_WORDS_PER_MINUTE";
const SET_EDITOR_SPELLCHECK = "SET_EDITOR_SPELLCHECK";
const SET_EDITOR_TAB_SIZE = "SET_EDITOR_TAB_SIZE";
const SET_EDITOR_TOOLBAR = "SET_EDITOR_TOOLBAR";
const SET_EXPERIMENTAL = "SET_EXPERIMENTAL";
const SET_THEME = "SET_THEME";
const SETTINGS_LOADED = "SETTINGS_LOADED";
const settingsModule = {
  state: () => ({
    crypto: {
      enabled: false,
      privateKey: null,
      publicKey: null
    },
    editor: {
      images: {
        enabled: true,
        showCaptions: true
      },
      keyMap: "default",
      ligatures: true,
      lists: {
        enabled: true
      },
      readability: {
        enabled: true,
        maxWidthInChars: 100,
        wordsPerMinute: 225
      },
      spellcheck: true,
      tabSize: 2,
      toolbar: true
    },
    experimental: false,
    loaded: false,
    theme: "auto"
  }),
  getters: {},
  mutations: {
    [LOAD_SETTINGS](state, settings) {
      Object.assign(state, cjs(state, settings));
    },
    [SET_CRYPTO_ENABLED](state, enabled) {
      state.crypto.enabled = enabled;
    },
    [SET_CRYPTO_KEYS](state, keys2) {
      if (keys2.privateKey) {
        state.crypto.privateKey = keys2.privateKey;
      }
      if (keys2.publicKey) {
        state.crypto.publicKey = keys2.publicKey;
      }
    },
    [SET_EDITOR_IMAGES_ENABLED](state, isEnabled) {
      state.editor.images.enabled = isEnabled;
    },
    [SET_EDITOR_IMAGES_SHOW_CAPTIONS](state, showCaptions) {
      state.editor.images.showCaptions = showCaptions;
    },
    [SET_EDITOR_KEY_MAP](state, keyMap) {
      state.editor.keyMap = keyMap;
    },
    [SET_EDITOR_LIGATURES](state, isEnabled) {
      state.editor.ligatures = isEnabled;
    },
    [SET_EDITOR_LISTS_ENABLED](state, isEnabled) {
      state.editor.lists.enabled = isEnabled;
    },
    [SET_EDITOR_READABILITY_ENABLED](state, isEnabled) {
      state.editor.readability.enabled = isEnabled;
    },
    [SET_EDITOR_READABILITY_MAX_WIDTH](state, maxWidthInChars) {
      state.editor.readability.maxWidthInChars = maxWidthInChars;
    },
    [SET_EDITOR_READABILITY_WORDS_PER_MINUTE](state, wordsPerMinute) {
      state.editor.readability.wordsPerMinute = wordsPerMinute;
    },
    [SET_EDITOR_SPELLCHECK](state, spellcheck) {
      state.editor.spellcheck = spellcheck;
    },
    [SET_EDITOR_TAB_SIZE](state, tabSize) {
      state.editor.tabSize = tabSize;
    },
    [SET_EDITOR_TOOLBAR](state, isEnabled) {
      state.editor.toolbar = isEnabled;
    },
    [SET_EXPERIMENTAL](state, isEnabled) {
      state.experimental = isEnabled;
    },
    [SET_THEME](state, theme) {
      state.theme = theme;
    },
    [SETTINGS_LOADED](state) {
      state.loaded = true;
    }
  },
  actions: {
    async [LOAD_SETTINGS](context, settings) {
      context.commit(LOAD_SETTINGS, settings);
    },
    async [SET_CRYPTO_ENABLED](context, enabled) {
      context.commit(SET_CRYPTO_ENABLED, enabled);
    },
    async [SET_CRYPTO_KEYS](context, keys2) {
      context.commit(SET_CRYPTO_KEYS, keys2);
    },
    async [SET_EDITOR_IMAGES_ENABLED](context, isEnabled) {
      context.commit(SET_EDITOR_IMAGES_ENABLED, isEnabled);
    },
    async [SET_EDITOR_IMAGES_SHOW_CAPTIONS](context, showCaptions) {
      context.commit(SET_EDITOR_IMAGES_SHOW_CAPTIONS, showCaptions);
    },
    async [SET_EDITOR_KEY_MAP](context, keyMap) {
      context.commit(SET_EDITOR_KEY_MAP, keyMap);
    },
    async [SET_EDITOR_TAB_SIZE](context, tabSize) {
      context.commit(SET_EDITOR_TAB_SIZE, tabSize);
    },
    async [SET_THEME](context, theme) {
      context.commit(SET_THEME, theme);
    },
    async [SETTINGS_LOADED](context) {
      context.commit(SETTINGS_LOADED);
    }
  }
};
const OBJECT_STRINGS = {
  Array: "[object Array]",
  Boolean: "[object Boolean]",
  Date: "[object Date]",
  Number: "[object Number]",
  Object: "[object Object]",
  String: "[object String]"
};
const compare = (object, string) => {
  return Object.prototype.toString.call(object) === string;
};
const isArray = (object) => {
  return compare(object, OBJECT_STRINGS.Array);
};
const isDate = (object) => {
  return compare(object, OBJECT_STRINGS.Date);
};
const isObject = (object) => {
  return compare(object, OBJECT_STRINGS.Object);
};
const unwrap = (object) => {
  if (isArray(object)) {
    return unwrapArray(object);
  }
  if (isDate(object)) {
    return unwrapDate(object);
  }
  if (isObject(object)) {
    return unwrapObject(object);
  }
  return object;
};
const unwrapArray = (object) => {
  return object.map((item) => {
    return unwrap(item);
  });
};
const unwrapDate = (object) => {
  return new Date(object);
};
const unwrapObject = (object) => {
  return Object.keys(object).reduce((unwrapped, key) => {
    return {
      ...unwrapped,
      [key]: unwrap(object[key])
    };
  }, {});
};
const PULL_DOCUMENT = "PULL_DOCUMENT";
const PULL_DOCUMENTS = "PULL_DOCUMENTS";
const PUSH_DOCUMENT = "PUSH_DOCUMENT";
const PUSH_DOCUMENTS = "PUSH_DOCUMENTS";
const findDoc = (state, id2) => {
  return state.documents.all.find((doc2) => doc2.id === id2);
};
const syncModule = {
  state: () => ({}),
  getters: {
    lastSyncedAt(_state, _getters, globalState) {
      return new Date(Math.max(0, ...globalState.documents.all.map((doc2) => doc2.syncedAt)));
    }
  },
  actions: {
    async [PULL_DOCUMENT](context, doc2) {
      const found = findDoc(context.rootState, doc2.id);
      if (found) {
        if (found.updatedAt < doc2.updatedAt) {
          return context.dispatch(MERGE_DOCUMENT, doc2);
        } else if (found.updatedAt > doc2.updatedAt)
          ;
        else {
          if (!found.syncedAt || found.syncedAt < doc2.syncedAt) {
            return context.dispatch(MERGE_DOCUMENT, doc2);
          }
        }
      } else {
        return context.dispatch(ADD_DOCUMENT, doc2);
      }
    },
    async [PULL_DOCUMENTS](context) {
      const docs = await fetchDocs({
        ownerId: context.rootState.auth.user.uid,
        syncedAfter: context.getters.lastSyncedAt
      });
      return Promise.all(
        docs.map(async (docRef) => {
          const serverDoc = docRef.data();
          const packed = {
            ...serverDoc,
            id: serverDoc.id || serverDoc.clientId,
            firebaseId: docRef.id,
            textKey: serverDoc.textKey || serverDoc.dataKey,
            createdAt: serverDoc.createdAt ? serverDoc.createdAt.toDate() : null,
            discardedAt: serverDoc.discardedAt ? serverDoc.discardedAt.toDate() : null,
            updatedAt: serverDoc.updatedAt ? serverDoc.updatedAt.toDate() : null,
            touchedAt: serverDoc.touchedAt ? serverDoc.touchedAt.toDate() : null,
            syncedAt: serverDoc.syncedAt.toDate()
          };
          const doc2 = await unpack(packed, {
            privateKey: context.rootState.settings.crypto.privateKey
          });
          return context.dispatch(PULL_DOCUMENT, doc2);
        })
      );
    },
    async [PUSH_DOCUMENT](context, doc2) {
      const packed = unwrap(await pack(doc2, {
        preferEncryption: context.rootState.settings.crypto.enabled,
        publicKey: context.rootState.settings.crypto.publicKey
      }));
      if (!packed.syncedAt) {
        return addDoc({
          doc: packed,
          ownerId: context.rootState.auth.user.uid
        });
      } else if (packed.updatedAt > packed.syncedAt || packed.touchedAt > packed.syncedAt) {
        return updateDoc({
          doc: packed,
          docId: packed.firebaseId
        });
      }
    },
    async [PUSH_DOCUMENTS](context) {
      await Promise.all(
        context.rootState.documents.all.map((doc2) => context.dispatch(PUSH_DOCUMENT, doc2))
      );
    },
    async [SYNC](context) {
      await context.dispatch(PULL_DOCUMENTS);
      await context.dispatch(PUSH_DOCUMENTS);
      await context.dispatch(PULL_DOCUMENTS);
    }
  }
};
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var localforage$1 = { exports: {} };
/*!
    localForage -- Offline Storage, Improved
    Version 1.10.0
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
(function(module, exports) {
  (function(f2) {
    {
      module.exports = f2();
    }
  })(function() {
    return function e2(t2, n2, r2) {
      function s2(o3, u2) {
        if (!n2[o3]) {
          if (!t2[o3]) {
            var a2 = typeof commonjsRequire == "function" && commonjsRequire;
            if (!u2 && a2)
              return a2(o3, true);
            if (i2)
              return i2(o3, true);
            var f2 = new Error("Cannot find module '" + o3 + "'");
            throw f2.code = "MODULE_NOT_FOUND", f2;
          }
          var l2 = n2[o3] = { exports: {} };
          t2[o3][0].call(l2.exports, function(e3) {
            var n3 = t2[o3][1][e3];
            return s2(n3 ? n3 : e3);
          }, l2, l2.exports, e2, t2, n2, r2);
        }
        return n2[o3].exports;
      }
      var i2 = typeof commonjsRequire == "function" && commonjsRequire;
      for (var o2 = 0; o2 < r2.length; o2++)
        s2(r2[o2]);
      return s2;
    }({ 1: [function(_dereq_, module2, exports2) {
      (function(global2) {
        var Mutation = global2.MutationObserver || global2.WebKitMutationObserver;
        var scheduleDrain;
        {
          if (Mutation) {
            var called = 0;
            var observer = new Mutation(nextTick2);
            var element = global2.document.createTextNode("");
            observer.observe(element, {
              characterData: true
            });
            scheduleDrain = function() {
              element.data = called = ++called % 2;
            };
          } else if (!global2.setImmediate && typeof global2.MessageChannel !== "undefined") {
            var channel = new global2.MessageChannel();
            channel.port1.onmessage = nextTick2;
            scheduleDrain = function() {
              channel.port2.postMessage(0);
            };
          } else if ("document" in global2 && "onreadystatechange" in global2.document.createElement("script")) {
            scheduleDrain = function() {
              var scriptEl = global2.document.createElement("script");
              scriptEl.onreadystatechange = function() {
                nextTick2();
                scriptEl.onreadystatechange = null;
                scriptEl.parentNode.removeChild(scriptEl);
                scriptEl = null;
              };
              global2.document.documentElement.appendChild(scriptEl);
            };
          } else {
            scheduleDrain = function() {
              setTimeout(nextTick2, 0);
            };
          }
        }
        var draining;
        var queue2 = [];
        function nextTick2() {
          draining = true;
          var i2, oldQueue;
          var len = queue2.length;
          while (len) {
            oldQueue = queue2;
            queue2 = [];
            i2 = -1;
            while (++i2 < len) {
              oldQueue[i2]();
            }
            len = queue2.length;
          }
          draining = false;
        }
        module2.exports = immediate;
        function immediate(task) {
          if (queue2.push(task) === 1 && !draining) {
            scheduleDrain();
          }
        }
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 2: [function(_dereq_, module2, exports2) {
      var immediate = _dereq_(1);
      function INTERNAL() {
      }
      var handlers2 = {};
      var REJECTED = ["REJECTED"];
      var FULFILLED = ["FULFILLED"];
      var PENDING = ["PENDING"];
      module2.exports = Promise2;
      function Promise2(resolver) {
        if (typeof resolver !== "function") {
          throw new TypeError("resolver must be a function");
        }
        this.state = PENDING;
        this.queue = [];
        this.outcome = void 0;
        if (resolver !== INTERNAL) {
          safelyResolveThenable(this, resolver);
        }
      }
      Promise2.prototype["catch"] = function(onRejected) {
        return this.then(null, onRejected);
      };
      Promise2.prototype.then = function(onFulfilled, onRejected) {
        if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
          return this;
        }
        var promise = new this.constructor(INTERNAL);
        if (this.state !== PENDING) {
          var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
          unwrap2(promise, resolver, this.outcome);
        } else {
          this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
        }
        return promise;
      };
      function QueueItem(promise, onFulfilled, onRejected) {
        this.promise = promise;
        if (typeof onFulfilled === "function") {
          this.onFulfilled = onFulfilled;
          this.callFulfilled = this.otherCallFulfilled;
        }
        if (typeof onRejected === "function") {
          this.onRejected = onRejected;
          this.callRejected = this.otherCallRejected;
        }
      }
      QueueItem.prototype.callFulfilled = function(value) {
        handlers2.resolve(this.promise, value);
      };
      QueueItem.prototype.otherCallFulfilled = function(value) {
        unwrap2(this.promise, this.onFulfilled, value);
      };
      QueueItem.prototype.callRejected = function(value) {
        handlers2.reject(this.promise, value);
      };
      QueueItem.prototype.otherCallRejected = function(value) {
        unwrap2(this.promise, this.onRejected, value);
      };
      function unwrap2(promise, func, value) {
        immediate(function() {
          var returnValue;
          try {
            returnValue = func(value);
          } catch (e2) {
            return handlers2.reject(promise, e2);
          }
          if (returnValue === promise) {
            handlers2.reject(promise, new TypeError("Cannot resolve promise with itself"));
          } else {
            handlers2.resolve(promise, returnValue);
          }
        });
      }
      handlers2.resolve = function(self2, value) {
        var result = tryCatch(getThen, value);
        if (result.status === "error") {
          return handlers2.reject(self2, result.value);
        }
        var thenable = result.value;
        if (thenable) {
          safelyResolveThenable(self2, thenable);
        } else {
          self2.state = FULFILLED;
          self2.outcome = value;
          var i2 = -1;
          var len = self2.queue.length;
          while (++i2 < len) {
            self2.queue[i2].callFulfilled(value);
          }
        }
        return self2;
      };
      handlers2.reject = function(self2, error) {
        self2.state = REJECTED;
        self2.outcome = error;
        var i2 = -1;
        var len = self2.queue.length;
        while (++i2 < len) {
          self2.queue[i2].callRejected(error);
        }
        return self2;
      };
      function getThen(obj) {
        var then = obj && obj.then;
        if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
          return function appyThen() {
            then.apply(obj, arguments);
          };
        }
      }
      function safelyResolveThenable(self2, thenable) {
        var called = false;
        function onError(value) {
          if (called) {
            return;
          }
          called = true;
          handlers2.reject(self2, value);
        }
        function onSuccess(value) {
          if (called) {
            return;
          }
          called = true;
          handlers2.resolve(self2, value);
        }
        function tryToUnwrap() {
          thenable(onSuccess, onError);
        }
        var result = tryCatch(tryToUnwrap);
        if (result.status === "error") {
          onError(result.value);
        }
      }
      function tryCatch(func, value) {
        var out = {};
        try {
          out.value = func(value);
          out.status = "success";
        } catch (e2) {
          out.status = "error";
          out.value = e2;
        }
        return out;
      }
      Promise2.resolve = resolve2;
      function resolve2(value) {
        if (value instanceof this) {
          return value;
        }
        return handlers2.resolve(new this(INTERNAL), value);
      }
      Promise2.reject = reject;
      function reject(reason) {
        var promise = new this(INTERNAL);
        return handlers2.reject(promise, reason);
      }
      Promise2.all = all;
      function all(iterable) {
        var self2 = this;
        if (Object.prototype.toString.call(iterable) !== "[object Array]") {
          return this.reject(new TypeError("must be an array"));
        }
        var len = iterable.length;
        var called = false;
        if (!len) {
          return this.resolve([]);
        }
        var values = new Array(len);
        var resolved = 0;
        var i2 = -1;
        var promise = new this(INTERNAL);
        while (++i2 < len) {
          allResolver(iterable[i2], i2);
        }
        return promise;
        function allResolver(value, i3) {
          self2.resolve(value).then(resolveFromAll, function(error) {
            if (!called) {
              called = true;
              handlers2.reject(promise, error);
            }
          });
          function resolveFromAll(outValue) {
            values[i3] = outValue;
            if (++resolved === len && !called) {
              called = true;
              handlers2.resolve(promise, values);
            }
          }
        }
      }
      Promise2.race = race;
      function race(iterable) {
        var self2 = this;
        if (Object.prototype.toString.call(iterable) !== "[object Array]") {
          return this.reject(new TypeError("must be an array"));
        }
        var len = iterable.length;
        var called = false;
        if (!len) {
          return this.resolve([]);
        }
        var i2 = -1;
        var promise = new this(INTERNAL);
        while (++i2 < len) {
          resolver(iterable[i2]);
        }
        return promise;
        function resolver(value) {
          self2.resolve(value).then(function(response) {
            if (!called) {
              called = true;
              handlers2.resolve(promise, response);
            }
          }, function(error) {
            if (!called) {
              called = true;
              handlers2.reject(promise, error);
            }
          });
        }
      }
    }, { "1": 1 }], 3: [function(_dereq_, module2, exports2) {
      (function(global2) {
        if (typeof global2.Promise !== "function") {
          global2.Promise = _dereq_(2);
        }
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "2": 2 }], 4: [function(_dereq_, module2, exports2) {
      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function getIDB() {
        try {
          if (typeof indexedDB !== "undefined") {
            return indexedDB;
          }
          if (typeof webkitIndexedDB !== "undefined") {
            return webkitIndexedDB;
          }
          if (typeof mozIndexedDB !== "undefined") {
            return mozIndexedDB;
          }
          if (typeof OIndexedDB !== "undefined") {
            return OIndexedDB;
          }
          if (typeof msIndexedDB !== "undefined") {
            return msIndexedDB;
          }
        } catch (e2) {
          return;
        }
      }
      var idb = getIDB();
      function isIndexedDBValid() {
        try {
          if (!idb || !idb.open) {
            return false;
          }
          var isSafari = typeof openDatabase !== "undefined" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);
          var hasFetch = typeof fetch === "function" && fetch.toString().indexOf("[native code") !== -1;
          return (!isSafari || hasFetch) && typeof indexedDB !== "undefined" && typeof IDBKeyRange !== "undefined";
        } catch (e2) {
          return false;
        }
      }
      function createBlob(parts, properties) {
        parts = parts || [];
        properties = properties || {};
        try {
          return new Blob(parts, properties);
        } catch (e2) {
          if (e2.name !== "TypeError") {
            throw e2;
          }
          var Builder = typeof BlobBuilder !== "undefined" ? BlobBuilder : typeof MSBlobBuilder !== "undefined" ? MSBlobBuilder : typeof MozBlobBuilder !== "undefined" ? MozBlobBuilder : WebKitBlobBuilder;
          var builder = new Builder();
          for (var i2 = 0; i2 < parts.length; i2 += 1) {
            builder.append(parts[i2]);
          }
          return builder.getBlob(properties.type);
        }
      }
      if (typeof Promise === "undefined") {
        _dereq_(3);
      }
      var Promise$1 = Promise;
      function executeCallback(promise, callback) {
        if (callback) {
          promise.then(function(result) {
            callback(null, result);
          }, function(error) {
            callback(error);
          });
        }
      }
      function executeTwoCallbacks(promise, callback, errorCallback) {
        if (typeof callback === "function") {
          promise.then(callback);
        }
        if (typeof errorCallback === "function") {
          promise["catch"](errorCallback);
        }
      }
      function normalizeKey2(key2) {
        if (typeof key2 !== "string") {
          console.warn(key2 + " used as a key, but it is not a string.");
          key2 = String(key2);
        }
        return key2;
      }
      function getCallback() {
        if (arguments.length && typeof arguments[arguments.length - 1] === "function") {
          return arguments[arguments.length - 1];
        }
      }
      var DETECT_BLOB_SUPPORT_STORE = "local-forage-detect-blob-support";
      var supportsBlobs = void 0;
      var dbContexts = {};
      var toString = Object.prototype.toString;
      var READ_ONLY = "readonly";
      var READ_WRITE = "readwrite";
      function _binStringToArrayBuffer(bin) {
        var length2 = bin.length;
        var buf = new ArrayBuffer(length2);
        var arr = new Uint8Array(buf);
        for (var i2 = 0; i2 < length2; i2++) {
          arr[i2] = bin.charCodeAt(i2);
        }
        return buf;
      }
      function _checkBlobSupportWithoutCaching(idb2) {
        return new Promise$1(function(resolve2) {
          var txn = idb2.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
          var blob = createBlob([""]);
          txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, "key");
          txn.onabort = function(e2) {
            e2.preventDefault();
            e2.stopPropagation();
            resolve2(false);
          };
          txn.oncomplete = function() {
            var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
            var matchedEdge = navigator.userAgent.match(/Edge\//);
            resolve2(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
          };
        })["catch"](function() {
          return false;
        });
      }
      function _checkBlobSupport(idb2) {
        if (typeof supportsBlobs === "boolean") {
          return Promise$1.resolve(supportsBlobs);
        }
        return _checkBlobSupportWithoutCaching(idb2).then(function(value) {
          supportsBlobs = value;
          return supportsBlobs;
        });
      }
      function _deferReadiness(dbInfo) {
        var dbContext = dbContexts[dbInfo.name];
        var deferredOperation = {};
        deferredOperation.promise = new Promise$1(function(resolve2, reject) {
          deferredOperation.resolve = resolve2;
          deferredOperation.reject = reject;
        });
        dbContext.deferredOperations.push(deferredOperation);
        if (!dbContext.dbReady) {
          dbContext.dbReady = deferredOperation.promise;
        } else {
          dbContext.dbReady = dbContext.dbReady.then(function() {
            return deferredOperation.promise;
          });
        }
      }
      function _advanceReadiness(dbInfo) {
        var dbContext = dbContexts[dbInfo.name];
        var deferredOperation = dbContext.deferredOperations.pop();
        if (deferredOperation) {
          deferredOperation.resolve();
          return deferredOperation.promise;
        }
      }
      function _rejectReadiness(dbInfo, err) {
        var dbContext = dbContexts[dbInfo.name];
        var deferredOperation = dbContext.deferredOperations.pop();
        if (deferredOperation) {
          deferredOperation.reject(err);
          return deferredOperation.promise;
        }
      }
      function _getConnection(dbInfo, upgradeNeeded) {
        return new Promise$1(function(resolve2, reject) {
          dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();
          if (dbInfo.db) {
            if (upgradeNeeded) {
              _deferReadiness(dbInfo);
              dbInfo.db.close();
            } else {
              return resolve2(dbInfo.db);
            }
          }
          var dbArgs = [dbInfo.name];
          if (upgradeNeeded) {
            dbArgs.push(dbInfo.version);
          }
          var openreq = idb.open.apply(idb, dbArgs);
          if (upgradeNeeded) {
            openreq.onupgradeneeded = function(e2) {
              var db2 = openreq.result;
              try {
                db2.createObjectStore(dbInfo.storeName);
                if (e2.oldVersion <= 1) {
                  db2.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                }
              } catch (ex) {
                if (ex.name === "ConstraintError") {
                  console.warn('The database "' + dbInfo.name + '" has been upgraded from version ' + e2.oldVersion + " to version " + e2.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                } else {
                  throw ex;
                }
              }
            };
          }
          openreq.onerror = function(e2) {
            e2.preventDefault();
            reject(openreq.error);
          };
          openreq.onsuccess = function() {
            var db2 = openreq.result;
            db2.onversionchange = function(e2) {
              e2.target.close();
            };
            resolve2(db2);
            _advanceReadiness(dbInfo);
          };
        });
      }
      function _getOriginalConnection(dbInfo) {
        return _getConnection(dbInfo, false);
      }
      function _getUpgradedConnection(dbInfo) {
        return _getConnection(dbInfo, true);
      }
      function _isUpgradeNeeded(dbInfo, defaultVersion) {
        if (!dbInfo.db) {
          return true;
        }
        var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
        var isDowngrade = dbInfo.version < dbInfo.db.version;
        var isUpgrade = dbInfo.version > dbInfo.db.version;
        if (isDowngrade) {
          if (dbInfo.version !== defaultVersion) {
            console.warn('The database "' + dbInfo.name + `" can't be downgraded from version ` + dbInfo.db.version + " to version " + dbInfo.version + ".");
          }
          dbInfo.version = dbInfo.db.version;
        }
        if (isUpgrade || isNewStore) {
          if (isNewStore) {
            var incVersion = dbInfo.db.version + 1;
            if (incVersion > dbInfo.version) {
              dbInfo.version = incVersion;
            }
          }
          return true;
        }
        return false;
      }
      function _encodeBlob(blob) {
        return new Promise$1(function(resolve2, reject) {
          var reader = new FileReader();
          reader.onerror = reject;
          reader.onloadend = function(e2) {
            var base642 = btoa(e2.target.result || "");
            resolve2({
              __local_forage_encoded_blob: true,
              data: base642,
              type: blob.type
            });
          };
          reader.readAsBinaryString(blob);
        });
      }
      function _decodeBlob(encodedBlob) {
        var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
        return createBlob([arrayBuff], { type: encodedBlob.type });
      }
      function _isEncodedBlob(value) {
        return value && value.__local_forage_encoded_blob;
      }
      function _fullyReady(callback) {
        var self2 = this;
        var promise = self2._initReady().then(function() {
          var dbContext = dbContexts[self2._dbInfo.name];
          if (dbContext && dbContext.dbReady) {
            return dbContext.dbReady;
          }
        });
        executeTwoCallbacks(promise, callback, callback);
        return promise;
      }
      function _tryReconnect(dbInfo) {
        _deferReadiness(dbInfo);
        var dbContext = dbContexts[dbInfo.name];
        var forages = dbContext.forages;
        for (var i2 = 0; i2 < forages.length; i2++) {
          var forage = forages[i2];
          if (forage._dbInfo.db) {
            forage._dbInfo.db.close();
            forage._dbInfo.db = null;
          }
        }
        dbInfo.db = null;
        return _getOriginalConnection(dbInfo).then(function(db2) {
          dbInfo.db = db2;
          if (_isUpgradeNeeded(dbInfo)) {
            return _getUpgradedConnection(dbInfo);
          }
          return db2;
        }).then(function(db2) {
          dbInfo.db = dbContext.db = db2;
          for (var i3 = 0; i3 < forages.length; i3++) {
            forages[i3]._dbInfo.db = db2;
          }
        })["catch"](function(err) {
          _rejectReadiness(dbInfo, err);
          throw err;
        });
      }
      function createTransaction(dbInfo, mode, callback, retries) {
        if (retries === void 0) {
          retries = 1;
        }
        try {
          var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
          callback(null, tx);
        } catch (err) {
          if (retries > 0 && (!dbInfo.db || err.name === "InvalidStateError" || err.name === "NotFoundError")) {
            return Promise$1.resolve().then(function() {
              if (!dbInfo.db || err.name === "NotFoundError" && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                if (dbInfo.db) {
                  dbInfo.version = dbInfo.db.version + 1;
                }
                return _getUpgradedConnection(dbInfo);
              }
            }).then(function() {
              return _tryReconnect(dbInfo).then(function() {
                createTransaction(dbInfo, mode, callback, retries - 1);
              });
            })["catch"](callback);
          }
          callback(err);
        }
      }
      function createDbContext() {
        return {
          forages: [],
          db: null,
          dbReady: null,
          deferredOperations: []
        };
      }
      function _initStorage(options) {
        var self2 = this;
        var dbInfo = {
          db: null
        };
        if (options) {
          for (var i2 in options) {
            dbInfo[i2] = options[i2];
          }
        }
        var dbContext = dbContexts[dbInfo.name];
        if (!dbContext) {
          dbContext = createDbContext();
          dbContexts[dbInfo.name] = dbContext;
        }
        dbContext.forages.push(self2);
        if (!self2._initReady) {
          self2._initReady = self2.ready;
          self2.ready = _fullyReady;
        }
        var initPromises = [];
        function ignoreErrors() {
          return Promise$1.resolve();
        }
        for (var j2 = 0; j2 < dbContext.forages.length; j2++) {
          var forage = dbContext.forages[j2];
          if (forage !== self2) {
            initPromises.push(forage._initReady()["catch"](ignoreErrors));
          }
        }
        var forages = dbContext.forages.slice(0);
        return Promise$1.all(initPromises).then(function() {
          dbInfo.db = dbContext.db;
          return _getOriginalConnection(dbInfo);
        }).then(function(db2) {
          dbInfo.db = db2;
          if (_isUpgradeNeeded(dbInfo, self2._defaultConfig.version)) {
            return _getUpgradedConnection(dbInfo);
          }
          return db2;
        }).then(function(db2) {
          dbInfo.db = dbContext.db = db2;
          self2._dbInfo = dbInfo;
          for (var k2 = 0; k2 < forages.length; k2++) {
            var forage2 = forages[k2];
            if (forage2 !== self2) {
              forage2._dbInfo.db = dbInfo.db;
              forage2._dbInfo.version = dbInfo.version;
            }
          }
        });
      }
      function getItem(key2, callback) {
        var self2 = this;
        key2 = normalizeKey2(key2);
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store2 = transaction.objectStore(self2._dbInfo.storeName);
                var req = store2.get(key2);
                req.onsuccess = function() {
                  var value = req.result;
                  if (value === void 0) {
                    value = null;
                  }
                  if (_isEncodedBlob(value)) {
                    value = _decodeBlob(value);
                  }
                  resolve2(value);
                };
                req.onerror = function() {
                  reject(req.error);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function iterate(iterator, callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store2 = transaction.objectStore(self2._dbInfo.storeName);
                var req = store2.openCursor();
                var iterationNumber = 1;
                req.onsuccess = function() {
                  var cursor = req.result;
                  if (cursor) {
                    var value = cursor.value;
                    if (_isEncodedBlob(value)) {
                      value = _decodeBlob(value);
                    }
                    var result = iterator(value, cursor.key, iterationNumber++);
                    if (result !== void 0) {
                      resolve2(result);
                    } else {
                      cursor["continue"]();
                    }
                  } else {
                    resolve2();
                  }
                };
                req.onerror = function() {
                  reject(req.error);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function setItem(key2, value, callback) {
        var self2 = this;
        key2 = normalizeKey2(key2);
        var promise = new Promise$1(function(resolve2, reject) {
          var dbInfo;
          self2.ready().then(function() {
            dbInfo = self2._dbInfo;
            if (toString.call(value) === "[object Blob]") {
              return _checkBlobSupport(dbInfo.db).then(function(blobSupport) {
                if (blobSupport) {
                  return value;
                }
                return _encodeBlob(value);
              });
            }
            return value;
          }).then(function(value2) {
            createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store2 = transaction.objectStore(self2._dbInfo.storeName);
                if (value2 === null) {
                  value2 = void 0;
                }
                var req = store2.put(value2, key2);
                transaction.oncomplete = function() {
                  if (value2 === void 0) {
                    value2 = null;
                  }
                  resolve2(value2);
                };
                transaction.onabort = transaction.onerror = function() {
                  var err2 = req.error ? req.error : req.transaction.error;
                  reject(err2);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function removeItem(key2, callback) {
        var self2 = this;
        key2 = normalizeKey2(key2);
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store2 = transaction.objectStore(self2._dbInfo.storeName);
                var req = store2["delete"](key2);
                transaction.oncomplete = function() {
                  resolve2();
                };
                transaction.onerror = function() {
                  reject(req.error);
                };
                transaction.onabort = function() {
                  var err2 = req.error ? req.error : req.transaction.error;
                  reject(err2);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function clear2(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store2 = transaction.objectStore(self2._dbInfo.storeName);
                var req = store2.clear();
                transaction.oncomplete = function() {
                  resolve2();
                };
                transaction.onabort = transaction.onerror = function() {
                  var err2 = req.error ? req.error : req.transaction.error;
                  reject(err2);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function length(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store2 = transaction.objectStore(self2._dbInfo.storeName);
                var req = store2.count();
                req.onsuccess = function() {
                  resolve2(req.result);
                };
                req.onerror = function() {
                  reject(req.error);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function key(n2, callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          if (n2 < 0) {
            resolve2(null);
            return;
          }
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store2 = transaction.objectStore(self2._dbInfo.storeName);
                var advanced = false;
                var req = store2.openKeyCursor();
                req.onsuccess = function() {
                  var cursor = req.result;
                  if (!cursor) {
                    resolve2(null);
                    return;
                  }
                  if (n2 === 0) {
                    resolve2(cursor.key);
                  } else {
                    if (!advanced) {
                      advanced = true;
                      cursor.advance(n2);
                    } else {
                      resolve2(cursor.key);
                    }
                  }
                };
                req.onerror = function() {
                  reject(req.error);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function keys2(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store2 = transaction.objectStore(self2._dbInfo.storeName);
                var req = store2.openKeyCursor();
                var keys3 = [];
                req.onsuccess = function() {
                  var cursor = req.result;
                  if (!cursor) {
                    resolve2(keys3);
                    return;
                  }
                  keys3.push(cursor.key);
                  cursor["continue"]();
                };
                req.onerror = function() {
                  reject(req.error);
                };
              } catch (e2) {
                reject(e2);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function dropInstance(options, callback) {
        callback = getCallback.apply(this, arguments);
        var currentConfig = this.config();
        options = typeof options !== "function" && options || {};
        if (!options.name) {
          options.name = options.name || currentConfig.name;
          options.storeName = options.storeName || currentConfig.storeName;
        }
        var self2 = this;
        var promise;
        if (!options.name) {
          promise = Promise$1.reject("Invalid arguments");
        } else {
          var isCurrentDb = options.name === currentConfig.name && self2._dbInfo.db;
          var dbPromise2 = isCurrentDb ? Promise$1.resolve(self2._dbInfo.db) : _getOriginalConnection(options).then(function(db2) {
            var dbContext = dbContexts[options.name];
            var forages = dbContext.forages;
            dbContext.db = db2;
            for (var i2 = 0; i2 < forages.length; i2++) {
              forages[i2]._dbInfo.db = db2;
            }
            return db2;
          });
          if (!options.storeName) {
            promise = dbPromise2.then(function(db2) {
              _deferReadiness(options);
              var dbContext = dbContexts[options.name];
              var forages = dbContext.forages;
              db2.close();
              for (var i2 = 0; i2 < forages.length; i2++) {
                var forage = forages[i2];
                forage._dbInfo.db = null;
              }
              var dropDBPromise = new Promise$1(function(resolve2, reject) {
                var req = idb.deleteDatabase(options.name);
                req.onerror = function() {
                  var db3 = req.result;
                  if (db3) {
                    db3.close();
                  }
                  reject(req.error);
                };
                req.onblocked = function() {
                  console.warn('dropInstance blocked for database "' + options.name + '" until all open connections are closed');
                };
                req.onsuccess = function() {
                  var db3 = req.result;
                  if (db3) {
                    db3.close();
                  }
                  resolve2(db3);
                };
              });
              return dropDBPromise.then(function(db3) {
                dbContext.db = db3;
                for (var i3 = 0; i3 < forages.length; i3++) {
                  var _forage = forages[i3];
                  _advanceReadiness(_forage._dbInfo);
                }
              })["catch"](function(err) {
                (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                });
                throw err;
              });
            });
          } else {
            promise = dbPromise2.then(function(db2) {
              if (!db2.objectStoreNames.contains(options.storeName)) {
                return;
              }
              var newVersion = db2.version + 1;
              _deferReadiness(options);
              var dbContext = dbContexts[options.name];
              var forages = dbContext.forages;
              db2.close();
              for (var i2 = 0; i2 < forages.length; i2++) {
                var forage = forages[i2];
                forage._dbInfo.db = null;
                forage._dbInfo.version = newVersion;
              }
              var dropObjectPromise = new Promise$1(function(resolve2, reject) {
                var req = idb.open(options.name, newVersion);
                req.onerror = function(err) {
                  var db3 = req.result;
                  db3.close();
                  reject(err);
                };
                req.onupgradeneeded = function() {
                  var db3 = req.result;
                  db3.deleteObjectStore(options.storeName);
                };
                req.onsuccess = function() {
                  var db3 = req.result;
                  db3.close();
                  resolve2(db3);
                };
              });
              return dropObjectPromise.then(function(db3) {
                dbContext.db = db3;
                for (var j2 = 0; j2 < forages.length; j2++) {
                  var _forage2 = forages[j2];
                  _forage2._dbInfo.db = db3;
                  _advanceReadiness(_forage2._dbInfo);
                }
              })["catch"](function(err) {
                (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                });
                throw err;
              });
            });
          }
        }
        executeCallback(promise, callback);
        return promise;
      }
      var asyncStorage = {
        _driver: "asyncStorage",
        _initStorage,
        _support: isIndexedDBValid(),
        iterate,
        getItem,
        setItem,
        removeItem,
        clear: clear2,
        length,
        key,
        keys: keys2,
        dropInstance
      };
      function isWebSQLValid() {
        return typeof openDatabase === "function";
      }
      var BASE_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var BLOB_TYPE_PREFIX = "~~local_forage_type~";
      var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;
      var SERIALIZED_MARKER = "__lfsc__:";
      var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;
      var TYPE_ARRAYBUFFER = "arbf";
      var TYPE_BLOB = "blob";
      var TYPE_INT8ARRAY = "si08";
      var TYPE_UINT8ARRAY = "ui08";
      var TYPE_UINT8CLAMPEDARRAY = "uic8";
      var TYPE_INT16ARRAY = "si16";
      var TYPE_INT32ARRAY = "si32";
      var TYPE_UINT16ARRAY = "ur16";
      var TYPE_UINT32ARRAY = "ui32";
      var TYPE_FLOAT32ARRAY = "fl32";
      var TYPE_FLOAT64ARRAY = "fl64";
      var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
      var toString$1 = Object.prototype.toString;
      function stringToBuffer(serializedString) {
        var bufferLength = serializedString.length * 0.75;
        var len = serializedString.length;
        var i2;
        var p2 = 0;
        var encoded1, encoded2, encoded3, encoded4;
        if (serializedString[serializedString.length - 1] === "=") {
          bufferLength--;
          if (serializedString[serializedString.length - 2] === "=") {
            bufferLength--;
          }
        }
        var buffer = new ArrayBuffer(bufferLength);
        var bytes = new Uint8Array(buffer);
        for (i2 = 0; i2 < len; i2 += 4) {
          encoded1 = BASE_CHARS.indexOf(serializedString[i2]);
          encoded2 = BASE_CHARS.indexOf(serializedString[i2 + 1]);
          encoded3 = BASE_CHARS.indexOf(serializedString[i2 + 2]);
          encoded4 = BASE_CHARS.indexOf(serializedString[i2 + 3]);
          bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
          bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
          bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
        }
        return buffer;
      }
      function bufferToString(buffer) {
        var bytes = new Uint8Array(buffer);
        var base64String = "";
        var i2;
        for (i2 = 0; i2 < bytes.length; i2 += 3) {
          base64String += BASE_CHARS[bytes[i2] >> 2];
          base64String += BASE_CHARS[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];
          base64String += BASE_CHARS[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];
          base64String += BASE_CHARS[bytes[i2 + 2] & 63];
        }
        if (bytes.length % 3 === 2) {
          base64String = base64String.substring(0, base64String.length - 1) + "=";
        } else if (bytes.length % 3 === 1) {
          base64String = base64String.substring(0, base64String.length - 2) + "==";
        }
        return base64String;
      }
      function serialize(value, callback) {
        var valueType = "";
        if (value) {
          valueType = toString$1.call(value);
        }
        if (value && (valueType === "[object ArrayBuffer]" || value.buffer && toString$1.call(value.buffer) === "[object ArrayBuffer]")) {
          var buffer;
          var marker = SERIALIZED_MARKER;
          if (value instanceof ArrayBuffer) {
            buffer = value;
            marker += TYPE_ARRAYBUFFER;
          } else {
            buffer = value.buffer;
            if (valueType === "[object Int8Array]") {
              marker += TYPE_INT8ARRAY;
            } else if (valueType === "[object Uint8Array]") {
              marker += TYPE_UINT8ARRAY;
            } else if (valueType === "[object Uint8ClampedArray]") {
              marker += TYPE_UINT8CLAMPEDARRAY;
            } else if (valueType === "[object Int16Array]") {
              marker += TYPE_INT16ARRAY;
            } else if (valueType === "[object Uint16Array]") {
              marker += TYPE_UINT16ARRAY;
            } else if (valueType === "[object Int32Array]") {
              marker += TYPE_INT32ARRAY;
            } else if (valueType === "[object Uint32Array]") {
              marker += TYPE_UINT32ARRAY;
            } else if (valueType === "[object Float32Array]") {
              marker += TYPE_FLOAT32ARRAY;
            } else if (valueType === "[object Float64Array]") {
              marker += TYPE_FLOAT64ARRAY;
            } else {
              callback(new Error("Failed to get type for BinaryArray"));
            }
          }
          callback(marker + bufferToString(buffer));
        } else if (valueType === "[object Blob]") {
          var fileReader = new FileReader();
          fileReader.onload = function() {
            var str = BLOB_TYPE_PREFIX + value.type + "~" + bufferToString(this.result);
            callback(SERIALIZED_MARKER + TYPE_BLOB + str);
          };
          fileReader.readAsArrayBuffer(value);
        } else {
          try {
            callback(JSON.stringify(value));
          } catch (e2) {
            console.error("Couldn't convert value into a JSON string: ", value);
            callback(null, e2);
          }
        }
      }
      function deserialize(value) {
        if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
          return JSON.parse(value);
        }
        var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
        var type2 = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
        var blobType;
        if (type2 === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
          var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
          blobType = matcher[1];
          serializedString = serializedString.substring(matcher[0].length);
        }
        var buffer = stringToBuffer(serializedString);
        switch (type2) {
          case TYPE_ARRAYBUFFER:
            return buffer;
          case TYPE_BLOB:
            return createBlob([buffer], { type: blobType });
          case TYPE_INT8ARRAY:
            return new Int8Array(buffer);
          case TYPE_UINT8ARRAY:
            return new Uint8Array(buffer);
          case TYPE_UINT8CLAMPEDARRAY:
            return new Uint8ClampedArray(buffer);
          case TYPE_INT16ARRAY:
            return new Int16Array(buffer);
          case TYPE_UINT16ARRAY:
            return new Uint16Array(buffer);
          case TYPE_INT32ARRAY:
            return new Int32Array(buffer);
          case TYPE_UINT32ARRAY:
            return new Uint32Array(buffer);
          case TYPE_FLOAT32ARRAY:
            return new Float32Array(buffer);
          case TYPE_FLOAT64ARRAY:
            return new Float64Array(buffer);
          default:
            throw new Error("Unkown type: " + type2);
        }
      }
      var localforageSerializer = {
        serialize,
        deserialize,
        stringToBuffer,
        bufferToString
      };
      function createDbTable(t2, dbInfo, callback, errorCallback) {
        t2.executeSql("CREATE TABLE IF NOT EXISTS " + dbInfo.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], callback, errorCallback);
      }
      function _initStorage$1(options) {
        var self2 = this;
        var dbInfo = {
          db: null
        };
        if (options) {
          for (var i2 in options) {
            dbInfo[i2] = typeof options[i2] !== "string" ? options[i2].toString() : options[i2];
          }
        }
        var dbInfoPromise = new Promise$1(function(resolve2, reject) {
          try {
            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
          } catch (e2) {
            return reject(e2);
          }
          dbInfo.db.transaction(function(t2) {
            createDbTable(t2, dbInfo, function() {
              self2._dbInfo = dbInfo;
              resolve2();
            }, function(t3, error) {
              reject(error);
            });
          }, reject);
        });
        dbInfo.serializer = localforageSerializer;
        return dbInfoPromise;
      }
      function tryExecuteSql(t2, dbInfo, sqlStatement, args, callback, errorCallback) {
        t2.executeSql(sqlStatement, args, callback, function(t3, error) {
          if (error.code === error.SYNTAX_ERR) {
            t3.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [dbInfo.storeName], function(t4, results) {
              if (!results.rows.length) {
                createDbTable(t4, dbInfo, function() {
                  t4.executeSql(sqlStatement, args, callback, errorCallback);
                }, errorCallback);
              } else {
                errorCallback(t4, error);
              }
            }, errorCallback);
          } else {
            errorCallback(t3, error);
          }
        }, errorCallback);
      }
      function getItem$1(key2, callback) {
        var self2 = this;
        key2 = normalizeKey2(key2);
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t2) {
              tryExecuteSql(t2, dbInfo, "SELECT * FROM " + dbInfo.storeName + " WHERE key = ? LIMIT 1", [key2], function(t3, results) {
                var result = results.rows.length ? results.rows.item(0).value : null;
                if (result) {
                  result = dbInfo.serializer.deserialize(result);
                }
                resolve2(result);
              }, function(t3, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function iterate$1(iterator, callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t2) {
              tryExecuteSql(t2, dbInfo, "SELECT * FROM " + dbInfo.storeName, [], function(t3, results) {
                var rows = results.rows;
                var length2 = rows.length;
                for (var i2 = 0; i2 < length2; i2++) {
                  var item = rows.item(i2);
                  var result = item.value;
                  if (result) {
                    result = dbInfo.serializer.deserialize(result);
                  }
                  result = iterator(result, item.key, i2 + 1);
                  if (result !== void 0) {
                    resolve2(result);
                    return;
                  }
                }
                resolve2();
              }, function(t3, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function _setItem(key2, value, callback, retriesLeft) {
        var self2 = this;
        key2 = normalizeKey2(key2);
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            if (value === void 0) {
              value = null;
            }
            var originalValue = value;
            var dbInfo = self2._dbInfo;
            dbInfo.serializer.serialize(value, function(value2, error) {
              if (error) {
                reject(error);
              } else {
                dbInfo.db.transaction(function(t2) {
                  tryExecuteSql(t2, dbInfo, "INSERT OR REPLACE INTO " + dbInfo.storeName + " (key, value) VALUES (?, ?)", [key2, value2], function() {
                    resolve2(originalValue);
                  }, function(t3, error2) {
                    reject(error2);
                  });
                }, function(sqlError) {
                  if (sqlError.code === sqlError.QUOTA_ERR) {
                    if (retriesLeft > 0) {
                      resolve2(_setItem.apply(self2, [key2, originalValue, callback, retriesLeft - 1]));
                      return;
                    }
                    reject(sqlError);
                  }
                });
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function setItem$1(key2, value, callback) {
        return _setItem.apply(this, [key2, value, callback, 1]);
      }
      function removeItem$1(key2, callback) {
        var self2 = this;
        key2 = normalizeKey2(key2);
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t2) {
              tryExecuteSql(t2, dbInfo, "DELETE FROM " + dbInfo.storeName + " WHERE key = ?", [key2], function() {
                resolve2();
              }, function(t3, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function clear$1(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t2) {
              tryExecuteSql(t2, dbInfo, "DELETE FROM " + dbInfo.storeName, [], function() {
                resolve2();
              }, function(t3, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function length$1(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t2) {
              tryExecuteSql(t2, dbInfo, "SELECT COUNT(key) as c FROM " + dbInfo.storeName, [], function(t3, results) {
                var result = results.rows.item(0).c;
                resolve2(result);
              }, function(t3, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function key$1(n2, callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t2) {
              tryExecuteSql(t2, dbInfo, "SELECT key FROM " + dbInfo.storeName + " WHERE id = ? LIMIT 1", [n2 + 1], function(t3, results) {
                var result = results.rows.length ? results.rows.item(0).key : null;
                resolve2(result);
              }, function(t3, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function keys$1(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t2) {
              tryExecuteSql(t2, dbInfo, "SELECT key FROM " + dbInfo.storeName, [], function(t3, results) {
                var keys3 = [];
                for (var i2 = 0; i2 < results.rows.length; i2++) {
                  keys3.push(results.rows.item(i2).key);
                }
                resolve2(keys3);
              }, function(t3, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function getAllStoreNames(db2) {
        return new Promise$1(function(resolve2, reject) {
          db2.transaction(function(t2) {
            t2.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(t3, results) {
              var storeNames = [];
              for (var i2 = 0; i2 < results.rows.length; i2++) {
                storeNames.push(results.rows.item(i2).name);
              }
              resolve2({
                db: db2,
                storeNames
              });
            }, function(t3, error) {
              reject(error);
            });
          }, function(sqlError) {
            reject(sqlError);
          });
        });
      }
      function dropInstance$1(options, callback) {
        callback = getCallback.apply(this, arguments);
        var currentConfig = this.config();
        options = typeof options !== "function" && options || {};
        if (!options.name) {
          options.name = options.name || currentConfig.name;
          options.storeName = options.storeName || currentConfig.storeName;
        }
        var self2 = this;
        var promise;
        if (!options.name) {
          promise = Promise$1.reject("Invalid arguments");
        } else {
          promise = new Promise$1(function(resolve2) {
            var db2;
            if (options.name === currentConfig.name) {
              db2 = self2._dbInfo.db;
            } else {
              db2 = openDatabase(options.name, "", "", 0);
            }
            if (!options.storeName) {
              resolve2(getAllStoreNames(db2));
            } else {
              resolve2({
                db: db2,
                storeNames: [options.storeName]
              });
            }
          }).then(function(operationInfo) {
            return new Promise$1(function(resolve2, reject) {
              operationInfo.db.transaction(function(t2) {
                function dropTable(storeName) {
                  return new Promise$1(function(resolve3, reject2) {
                    t2.executeSql("DROP TABLE IF EXISTS " + storeName, [], function() {
                      resolve3();
                    }, function(t3, error) {
                      reject2(error);
                    });
                  });
                }
                var operations = [];
                for (var i2 = 0, len = operationInfo.storeNames.length; i2 < len; i2++) {
                  operations.push(dropTable(operationInfo.storeNames[i2]));
                }
                Promise$1.all(operations).then(function() {
                  resolve2();
                })["catch"](function(e2) {
                  reject(e2);
                });
              }, function(sqlError) {
                reject(sqlError);
              });
            });
          });
        }
        executeCallback(promise, callback);
        return promise;
      }
      var webSQLStorage = {
        _driver: "webSQLStorage",
        _initStorage: _initStorage$1,
        _support: isWebSQLValid(),
        iterate: iterate$1,
        getItem: getItem$1,
        setItem: setItem$1,
        removeItem: removeItem$1,
        clear: clear$1,
        length: length$1,
        key: key$1,
        keys: keys$1,
        dropInstance: dropInstance$1
      };
      function isLocalStorageValid() {
        try {
          return typeof localStorage !== "undefined" && "setItem" in localStorage && !!localStorage.setItem;
        } catch (e2) {
          return false;
        }
      }
      function _getKeyPrefix(options, defaultConfig) {
        var keyPrefix = options.name + "/";
        if (options.storeName !== defaultConfig.storeName) {
          keyPrefix += options.storeName + "/";
        }
        return keyPrefix;
      }
      function checkIfLocalStorageThrows() {
        var localStorageTestKey = "_localforage_support_test";
        try {
          localStorage.setItem(localStorageTestKey, true);
          localStorage.removeItem(localStorageTestKey);
          return false;
        } catch (e2) {
          return true;
        }
      }
      function _isLocalStorageUsable() {
        return !checkIfLocalStorageThrows() || localStorage.length > 0;
      }
      function _initStorage$2(options) {
        var self2 = this;
        var dbInfo = {};
        if (options) {
          for (var i2 in options) {
            dbInfo[i2] = options[i2];
          }
        }
        dbInfo.keyPrefix = _getKeyPrefix(options, self2._defaultConfig);
        if (!_isLocalStorageUsable()) {
          return Promise$1.reject();
        }
        self2._dbInfo = dbInfo;
        dbInfo.serializer = localforageSerializer;
        return Promise$1.resolve();
      }
      function clear$2(callback) {
        var self2 = this;
        var promise = self2.ready().then(function() {
          var keyPrefix = self2._dbInfo.keyPrefix;
          for (var i2 = localStorage.length - 1; i2 >= 0; i2--) {
            var key2 = localStorage.key(i2);
            if (key2.indexOf(keyPrefix) === 0) {
              localStorage.removeItem(key2);
            }
          }
        });
        executeCallback(promise, callback);
        return promise;
      }
      function getItem$2(key2, callback) {
        var self2 = this;
        key2 = normalizeKey2(key2);
        var promise = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          var result = localStorage.getItem(dbInfo.keyPrefix + key2);
          if (result) {
            result = dbInfo.serializer.deserialize(result);
          }
          return result;
        });
        executeCallback(promise, callback);
        return promise;
      }
      function iterate$2(iterator, callback) {
        var self2 = this;
        var promise = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          var keyPrefix = dbInfo.keyPrefix;
          var keyPrefixLength = keyPrefix.length;
          var length2 = localStorage.length;
          var iterationNumber = 1;
          for (var i2 = 0; i2 < length2; i2++) {
            var key2 = localStorage.key(i2);
            if (key2.indexOf(keyPrefix) !== 0) {
              continue;
            }
            var value = localStorage.getItem(key2);
            if (value) {
              value = dbInfo.serializer.deserialize(value);
            }
            value = iterator(value, key2.substring(keyPrefixLength), iterationNumber++);
            if (value !== void 0) {
              return value;
            }
          }
        });
        executeCallback(promise, callback);
        return promise;
      }
      function key$2(n2, callback) {
        var self2 = this;
        var promise = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          var result;
          try {
            result = localStorage.key(n2);
          } catch (error) {
            result = null;
          }
          if (result) {
            result = result.substring(dbInfo.keyPrefix.length);
          }
          return result;
        });
        executeCallback(promise, callback);
        return promise;
      }
      function keys$2(callback) {
        var self2 = this;
        var promise = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          var length2 = localStorage.length;
          var keys3 = [];
          for (var i2 = 0; i2 < length2; i2++) {
            var itemKey = localStorage.key(i2);
            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
              keys3.push(itemKey.substring(dbInfo.keyPrefix.length));
            }
          }
          return keys3;
        });
        executeCallback(promise, callback);
        return promise;
      }
      function length$2(callback) {
        var self2 = this;
        var promise = self2.keys().then(function(keys3) {
          return keys3.length;
        });
        executeCallback(promise, callback);
        return promise;
      }
      function removeItem$2(key2, callback) {
        var self2 = this;
        key2 = normalizeKey2(key2);
        var promise = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          localStorage.removeItem(dbInfo.keyPrefix + key2);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function setItem$2(key2, value, callback) {
        var self2 = this;
        key2 = normalizeKey2(key2);
        var promise = self2.ready().then(function() {
          if (value === void 0) {
            value = null;
          }
          var originalValue = value;
          return new Promise$1(function(resolve2, reject) {
            var dbInfo = self2._dbInfo;
            dbInfo.serializer.serialize(value, function(value2, error) {
              if (error) {
                reject(error);
              } else {
                try {
                  localStorage.setItem(dbInfo.keyPrefix + key2, value2);
                  resolve2(originalValue);
                } catch (e2) {
                  if (e2.name === "QuotaExceededError" || e2.name === "NS_ERROR_DOM_QUOTA_REACHED") {
                    reject(e2);
                  }
                  reject(e2);
                }
              }
            });
          });
        });
        executeCallback(promise, callback);
        return promise;
      }
      function dropInstance$2(options, callback) {
        callback = getCallback.apply(this, arguments);
        options = typeof options !== "function" && options || {};
        if (!options.name) {
          var currentConfig = this.config();
          options.name = options.name || currentConfig.name;
          options.storeName = options.storeName || currentConfig.storeName;
        }
        var self2 = this;
        var promise;
        if (!options.name) {
          promise = Promise$1.reject("Invalid arguments");
        } else {
          promise = new Promise$1(function(resolve2) {
            if (!options.storeName) {
              resolve2(options.name + "/");
            } else {
              resolve2(_getKeyPrefix(options, self2._defaultConfig));
            }
          }).then(function(keyPrefix) {
            for (var i2 = localStorage.length - 1; i2 >= 0; i2--) {
              var key2 = localStorage.key(i2);
              if (key2.indexOf(keyPrefix) === 0) {
                localStorage.removeItem(key2);
              }
            }
          });
        }
        executeCallback(promise, callback);
        return promise;
      }
      var localStorageWrapper = {
        _driver: "localStorageWrapper",
        _initStorage: _initStorage$2,
        _support: isLocalStorageValid(),
        iterate: iterate$2,
        getItem: getItem$2,
        setItem: setItem$2,
        removeItem: removeItem$2,
        clear: clear$2,
        length: length$2,
        key: key$2,
        keys: keys$2,
        dropInstance: dropInstance$2
      };
      var sameValue = function sameValue2(x2, y2) {
        return x2 === y2 || typeof x2 === "number" && typeof y2 === "number" && isNaN(x2) && isNaN(y2);
      };
      var includes = function includes2(array, searchElement) {
        var len = array.length;
        var i2 = 0;
        while (i2 < len) {
          if (sameValue(array[i2], searchElement)) {
            return true;
          }
          i2++;
        }
        return false;
      };
      var isArray2 = Array.isArray || function(arg) {
        return Object.prototype.toString.call(arg) === "[object Array]";
      };
      var DefinedDrivers = {};
      var DriverSupport = {};
      var DefaultDrivers = {
        INDEXEDDB: asyncStorage,
        WEBSQL: webSQLStorage,
        LOCALSTORAGE: localStorageWrapper
      };
      var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];
      var OptionalDriverMethods = ["dropInstance"];
      var LibraryMethods = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(OptionalDriverMethods);
      var DefaultConfig = {
        description: "",
        driver: DefaultDriverOrder.slice(),
        name: "localforage",
        size: 4980736,
        storeName: "keyvaluepairs",
        version: 1
      };
      function callWhenReady(localForageInstance, libraryMethod) {
        localForageInstance[libraryMethod] = function() {
          var _args = arguments;
          return localForageInstance.ready().then(function() {
            return localForageInstance[libraryMethod].apply(localForageInstance, _args);
          });
        };
      }
      function extend2() {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var arg = arguments[i2];
          if (arg) {
            for (var _key in arg) {
              if (arg.hasOwnProperty(_key)) {
                if (isArray2(arg[_key])) {
                  arguments[0][_key] = arg[_key].slice();
                } else {
                  arguments[0][_key] = arg[_key];
                }
              }
            }
          }
        }
        return arguments[0];
      }
      var LocalForage = function() {
        function LocalForage2(options) {
          _classCallCheck(this, LocalForage2);
          for (var driverTypeKey in DefaultDrivers) {
            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
              var driver = DefaultDrivers[driverTypeKey];
              var driverName = driver._driver;
              this[driverTypeKey] = driverName;
              if (!DefinedDrivers[driverName]) {
                this.defineDriver(driver);
              }
            }
          }
          this._defaultConfig = extend2({}, DefaultConfig);
          this._config = extend2({}, this._defaultConfig, options);
          this._driverSet = null;
          this._initDriver = null;
          this._ready = false;
          this._dbInfo = null;
          this._wrapLibraryMethodsWithReady();
          this.setDriver(this._config.driver)["catch"](function() {
          });
        }
        LocalForage2.prototype.config = function config2(options) {
          if ((typeof options === "undefined" ? "undefined" : _typeof(options)) === "object") {
            if (this._ready) {
              return new Error("Can't call config() after localforage has been used.");
            }
            for (var i2 in options) {
              if (i2 === "storeName") {
                options[i2] = options[i2].replace(/\W/g, "_");
              }
              if (i2 === "version" && typeof options[i2] !== "number") {
                return new Error("Database version must be a number.");
              }
              this._config[i2] = options[i2];
            }
            if ("driver" in options && options.driver) {
              return this.setDriver(this._config.driver);
            }
            return true;
          } else if (typeof options === "string") {
            return this._config[options];
          } else {
            return this._config;
          }
        };
        LocalForage2.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
          var promise = new Promise$1(function(resolve2, reject) {
            try {
              var driverName = driverObject._driver;
              var complianceError = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
              if (!driverObject._driver) {
                reject(complianceError);
                return;
              }
              var driverMethods = LibraryMethods.concat("_initStorage");
              for (var i2 = 0, len = driverMethods.length; i2 < len; i2++) {
                var driverMethodName = driverMethods[i2];
                var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== "function") {
                  reject(complianceError);
                  return;
                }
              }
              var configureMissingMethods = function configureMissingMethods2() {
                var methodNotImplementedFactory = function methodNotImplementedFactory2(methodName) {
                  return function() {
                    var error = new Error("Method " + methodName + " is not implemented by the current driver");
                    var promise2 = Promise$1.reject(error);
                    executeCallback(promise2, arguments[arguments.length - 1]);
                    return promise2;
                  };
                };
                for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                  var optionalDriverMethod = OptionalDriverMethods[_i];
                  if (!driverObject[optionalDriverMethod]) {
                    driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                  }
                }
              };
              configureMissingMethods();
              var setDriverSupport = function setDriverSupport2(support) {
                if (DefinedDrivers[driverName]) {
                  console.info("Redefining LocalForage driver: " + driverName);
                }
                DefinedDrivers[driverName] = driverObject;
                DriverSupport[driverName] = support;
                resolve2();
              };
              if ("_support" in driverObject) {
                if (driverObject._support && typeof driverObject._support === "function") {
                  driverObject._support().then(setDriverSupport, reject);
                } else {
                  setDriverSupport(!!driverObject._support);
                }
              } else {
                setDriverSupport(true);
              }
            } catch (e2) {
              reject(e2);
            }
          });
          executeTwoCallbacks(promise, callback, errorCallback);
          return promise;
        };
        LocalForage2.prototype.driver = function driver() {
          return this._driver || null;
        };
        LocalForage2.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
          var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error("Driver not found."));
          executeTwoCallbacks(getDriverPromise, callback, errorCallback);
          return getDriverPromise;
        };
        LocalForage2.prototype.getSerializer = function getSerializer(callback) {
          var serializerPromise = Promise$1.resolve(localforageSerializer);
          executeTwoCallbacks(serializerPromise, callback);
          return serializerPromise;
        };
        LocalForage2.prototype.ready = function ready(callback) {
          var self2 = this;
          var promise = self2._driverSet.then(function() {
            if (self2._ready === null) {
              self2._ready = self2._initDriver();
            }
            return self2._ready;
          });
          executeTwoCallbacks(promise, callback, callback);
          return promise;
        };
        LocalForage2.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
          var self2 = this;
          if (!isArray2(drivers)) {
            drivers = [drivers];
          }
          var supportedDrivers = this._getSupportedDrivers(drivers);
          function setDriverToConfig() {
            self2._config.driver = self2.driver();
          }
          function extendSelfWithDriver(driver) {
            self2._extend(driver);
            setDriverToConfig();
            self2._ready = self2._initStorage(self2._config);
            return self2._ready;
          }
          function initDriver(supportedDrivers2) {
            return function() {
              var currentDriverIndex = 0;
              function driverPromiseLoop() {
                while (currentDriverIndex < supportedDrivers2.length) {
                  var driverName = supportedDrivers2[currentDriverIndex];
                  currentDriverIndex++;
                  self2._dbInfo = null;
                  self2._ready = null;
                  return self2.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                }
                setDriverToConfig();
                var error = new Error("No available storage method found.");
                self2._driverSet = Promise$1.reject(error);
                return self2._driverSet;
              }
              return driverPromiseLoop();
            };
          }
          var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function() {
            return Promise$1.resolve();
          }) : Promise$1.resolve();
          this._driverSet = oldDriverSetDone.then(function() {
            var driverName = supportedDrivers[0];
            self2._dbInfo = null;
            self2._ready = null;
            return self2.getDriver(driverName).then(function(driver) {
              self2._driver = driver._driver;
              setDriverToConfig();
              self2._wrapLibraryMethodsWithReady();
              self2._initDriver = initDriver(supportedDrivers);
            });
          })["catch"](function() {
            setDriverToConfig();
            var error = new Error("No available storage method found.");
            self2._driverSet = Promise$1.reject(error);
            return self2._driverSet;
          });
          executeTwoCallbacks(this._driverSet, callback, errorCallback);
          return this._driverSet;
        };
        LocalForage2.prototype.supports = function supports(driverName) {
          return !!DriverSupport[driverName];
        };
        LocalForage2.prototype._extend = function _extend(libraryMethodsAndProperties) {
          extend2(this, libraryMethodsAndProperties);
        };
        LocalForage2.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
          var supportedDrivers = [];
          for (var i2 = 0, len = drivers.length; i2 < len; i2++) {
            var driverName = drivers[i2];
            if (this.supports(driverName)) {
              supportedDrivers.push(driverName);
            }
          }
          return supportedDrivers;
        };
        LocalForage2.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
          for (var i2 = 0, len = LibraryMethods.length; i2 < len; i2++) {
            callWhenReady(this, LibraryMethods[i2]);
          }
        };
        LocalForage2.prototype.createInstance = function createInstance(options) {
          return new LocalForage2(options);
        };
        return LocalForage2;
      }();
      var localforage_js = new LocalForage();
      module2.exports = localforage_js;
    }, { "3": 3 }] }, {}, [4])(4);
  });
})(localforage$1);
const localforage = localforage$1.exports;
class Debouncer {
  constructor(timeout) {
    this.timeout = timeout;
    this.timers = [];
  }
  debounce(identifier = null, action) {
    const timer = this._findTimer(identifier);
    if (timer) {
      this._clearTimer(timer);
    }
    this._setTimer(identifier, action);
  }
  _clearTimer(timer) {
    clearTimeout(timer.instance);
    this.timers = this.timers.filter((t2) => t2.identifier !== timer.identifier);
  }
  _findTimer(identifier) {
    return this.timers.find((timer) => timer.identifier === identifier);
  }
  _setTimer(identifier, action) {
    this.timers.push({
      identifier,
      instance: setTimeout(action, this.timeout)
    });
  }
}
const cache$2 = localforage.createInstance({
  name: "contexts"
});
const debouncer$2 = new Debouncer(800);
const find$1 = (state, id2) => {
  return state.contexts.all.find((context) => context.id === id2);
};
const contextsCachingPlugin = (store2) => {
  store2.subscribe(({ type: type2, payload }, state) => {
    switch (type2) {
      case ADD_CONTEXT:
        const found = find$1(state, payload.id);
        if (found) {
          debouncer$2.debounce(found.id, async () => {
            cache$2.setItem(found.id, unwrap(found));
          });
        }
        break;
      case REMOVE_CONTEXT:
        cache$2.removeItem(payload.id);
        break;
      case SETTINGS_LOADED:
        cache$2.keys().then((ids) => Promise.all(ids.map((id2) => cache$2.getItem(id2)))).then((contexts) => store2.dispatch(LOAD_CONTEXTS, contexts));
        break;
    }
  });
};
const cache$1 = localforage.createInstance({
  name: "firebase/documents"
});
const debouncer$1 = new Debouncer(800);
const find = (state, id2) => {
  return state.documents.all.find((doc2) => doc2.id === id2);
};
const documentsCachingPlugin = (store2) => {
  store2.subscribe(({ type: type2, payload }, state) => {
    switch (type2) {
      case ADD_DOCUMENT:
      case DISCARD_DOCUMENT:
      case EDIT_DOCUMENT:
      case MERGE_DOCUMENT:
      case RESTORE_DOCUMENT:
      case RESTRICT_DOCUMENT:
      case SHARE_DOCUMENT:
      case TOUCH_DOCUMENT:
        const found = find(state, payload.id);
        if (found) {
          debouncer$1.debounce(found.id, async () => {
            const doc2 = await pack(found, {
              preferEncryption: state.settings.crypto.enabled,
              publicKey: state.settings.crypto.publicKey
            });
            cache$1.setItem(found.id, doc2);
          });
        }
        break;
      case SETTINGS_LOADED:
        cache$1.keys().then((ids) => Promise.all(ids.map((id2) => cache$1.getItem(id2)))).then((docs) => {
          return Promise.all(
            docs.map((doc2) => {
              const packed = Object.assign({}, doc2, { id: doc2.id || doc2.clientId, textKey: doc2.textKey || doc2.dataKey });
              return unpack(packed, { privateKey: state.settings.crypto.privateKey });
            })
          );
        }).then((docs) => store2.dispatch(LOAD_DOCUMENTS, docs)).then(() => store2.dispatch(DOCUMENTS_LOADED));
        break;
    }
  });
};
const keybindingsPlugin = (store2) => {
  store2.subscribe(({ type: type2, _payload }, state) => {
    switch (type2) {
      case SETTINGS_LOADED:
        store2.dispatch(LOAD_KEYBINDINGS);
        break;
    }
  });
};
const CACHE_KEY = "main";
const cache = localforage.createInstance({
  name: "settings"
});
const settingsCachingPlugin = (store2) => {
  cache.getItem(CACHE_KEY).then((settings) => {
    if (settings) {
      store2.dispatch(LOAD_SETTINGS, settings).then(() => {
        store2.dispatch(SETTINGS_LOADED);
      });
    } else {
      store2.dispatch(SETTINGS_LOADED);
    }
  });
  store2.subscribe(({ type: type2, _payload }, state) => {
    switch (type2) {
      case SET_CRYPTO_ENABLED:
      case SET_CRYPTO_KEYS:
      case SET_EDITOR_IMAGES_ENABLED:
      case SET_EDITOR_IMAGES_SHOW_CAPTIONS:
      case SET_EDITOR_KEY_MAP:
      case SET_EDITOR_LIGATURES:
      case SET_EDITOR_LISTS_ENABLED:
      case SET_EDITOR_READABILITY_ENABLED:
      case SET_EDITOR_READABILITY_WORDS_PER_MINUTE:
      case SET_EDITOR_SPELLCHECK:
      case SET_EDITOR_TAB_SIZE:
      case SET_EDITOR_TOOLBAR:
      case SET_EXPERIMENTAL:
      case SET_THEME:
        cache.setItem(CACHE_KEY, unwrap(state.settings));
        break;
    }
  });
};
const debouncer = new Debouncer(1500);
const syncPlugin = (store2) => {
  store2.subscribe(async ({ type: type2, payload }, state) => {
    switch (type2) {
      case ADD_DOCUMENT:
      case DISCARD_DOCUMENT:
      case DOCUMENTS_LOADED:
      case EDIT_DOCUMENT:
      case RESTORE_DOCUMENT:
      case RESTRICT_DOCUMENT:
      case SET_ONLINE:
      case SET_USER:
      case SHARE_DOCUMENT:
      case TOUCH_DOCUMENT:
        if (store2.state.online && store2.state.auth.user) {
          debouncer.debounce("sync", () => {
            store2.dispatch(SYNC);
          });
        }
        break;
    }
  });
};
const SET_STRIPE_MODAL_VISIBILITY = "SET_STRIPE_MODAL_VISIBILITY";
const store = createStore({
  state() {
    return {
      context: {
        active: false,
        editing: false,
        tags: []
      },
      editor: null,
      modKey: "\u2303",
      online: true,
      showLeftSidebar: true,
      showRightSidebar: true,
      showStripeModal: false,
      showWelcome: false
    };
  },
  getters: {
    allTags(state, getters) {
      return Array.from(
        getters.allKept.reduce((set2, doc2) => {
          for (let tag of doc2.tags) {
            set2.add(tag);
          }
          return set2;
        }, /* @__PURE__ */ new Set())
      ).sort();
    },
    contextTags(state) {
      return state.context.tags.sort();
    },
    tags(state, getters) {
      return Array.from(
        getters.kept.reduce((set2, doc2) => {
          for (let tag of doc2.tags) {
            set2.add(tag);
          }
          return set2;
        }, /* @__PURE__ */ new Set())
      ).sort();
    }
  },
  mutations: {
    [ACTIVATE_CONTEXT](state, payload) {
      state.context.active = true;
    },
    [DEACTIVATE_CONTEXT](state, payload) {
      state.context.active = false;
      state.context.tags = [];
    },
    [SET_CONTEXT_TAGS](state, payload) {
      state.context.tags = payload.context.tags;
    },
    [SET_EDITOR](state, payload) {
      state.editor = payload.editor;
    },
    [SET_MOD_KEY](state, payload) {
      state.modKey = payload;
    },
    [SET_OFFLINE](state) {
      state.online = false;
    },
    [SET_ONLINE](state) {
      state.online = true;
    },
    [SET_RIGHT_SIDEBAR_VISIBILITY](state, isVisible) {
      state.showRightSidebar = isVisible;
    },
    [SET_STRIPE_MODAL_VISIBILITY](state, isVisible) {
      state.showStripeModal = isVisible;
    },
    [SET_SHOW_WELCOME](state, shouldShowWelcome) {
      state.showWelcome = shouldShowWelcome;
    }
  },
  actions: {
    async [ACTIVATE_CONTEXT](context) {
      context.commit(ACTIVATE_CONTEXT);
    },
    async [BLUR_EDITOR](context) {
      if (context.state.editor) {
        context.state.editor.getInputField().blur();
      }
    },
    async [DEACTIVATE_CONTEXT](context) {
      context.commit(DEACTIVATE_CONTEXT);
    },
    async [FOCUS_EDITOR](context) {
      if (context.state.editor) {
        context.state.editor.focus();
      }
    },
    async [SET_CONTEXT_TAGS](context, payload) {
      context.commit(SET_CONTEXT_TAGS, payload);
      if (payload.context.tags.length > 0) {
        if (!context.state.context.active) {
          return context.dispatch(ACTIVATE_CONTEXT);
        }
      } else {
        if (context.state.context.active) {
          return context.dispatch(DEACTIVATE_CONTEXT);
        }
      }
    },
    async [SET_EDITOR](context, payload) {
      context.commit(SET_EDITOR, payload);
    },
    async [SET_MOD_KEY](context, payload) {
      context.commit(SET_MOD_KEY, payload);
    },
    async [SET_OFFLINE](context) {
      context.commit(SET_OFFLINE);
    },
    async [SET_ONLINE](context) {
      context.commit(SET_ONLINE);
    },
    async [SET_RIGHT_SIDEBAR_VISIBILITY](context, isVisible) {
      context.commit(SET_RIGHT_SIDEBAR_VISIBILITY, isVisible);
    },
    async [SET_SHOW_WELCOME](context, shouldShowWelcome) {
      context.commit(SET_SHOW_WELCOME, shouldShowWelcome);
    },
    async [SET_STRIPE_MODAL_VISIBILITY](context, isVisible) {
      context.commit(SET_STRIPE_MODAL_VISIBILITY, isVisible);
      if (isVisible) {
        setTimeout(() => {
          if (context.state.showStripeModal) {
            context.commit(SET_STRIPE_MODAL_VISIBILITY, false);
          }
        }, 15e3);
      }
    }
  },
  modules: {
    auth: authModule,
    contexts: contextsModule,
    documents: documentsModule,
    keybindings: keybindingsModule,
    settings: settingsModule,
    sync: syncModule
  },
  plugins: [
    contextsCachingPlugin,
    documentsCachingPlugin,
    keybindingsPlugin,
    settingsCachingPlugin,
    syncPlugin
  ]
});
const DEFAULT_TITLE = "Build your knowledge base";
const setTitle = (title) => {
  document.title = `${title ? title : DEFAULT_TITLE} | Octo`;
};
const router = createRouter({
  history: createWebHistory(),
  routes: [
    {
      path: "/home",
      name: "home",
      meta: { track: true },
      component: () => __vitePreload(() => import("./home.232730c4.js"), true ? ["assets/home.232730c4.js","assets/AuthTiers.63840201.js","assets/Modal.1c333d29.js","assets/CoreButton.ad5d413b.js","assets/home.050596e1.css"] : void 0),
      beforeEnter(to2, from2, next) {
        if (store.state.showWelcome) {
          localStorage.setItem("octo/welcome/v1", "done");
          store.dispatch(SET_SHOW_WELCOME, false);
        }
        next();
      }
    },
    {
      path: "/",
      component: () => __vitePreload(() => import("./dashboard.9698b14a.js"), true ? ["assets/dashboard.9698b14a.js","assets/CoreButton.ad5d413b.js","assets/CoreDivider.201e5106.js","assets/menu.35b8e3c7.js","assets/TagLink.16ccd376.js","assets/Tag.vue_vue_type_script_setup_true_lang.a82a8ad2.js","assets/useFiles.3674e24e.js","assets/TrashIcon.d058248a.js","assets/meta.08d1ea12.js","assets/moment.9709ab41.js","assets/dashboard.9da5e2a8.css"] : void 0),
      children: [
        {
          path: "/",
          component: () => __vitePreload(() => import("./page.c000113f.js"), true ? [] : void 0),
          children: [
            {
              path: "/",
              meta: { track: true },
              beforeEnter(to2, from2, next) {
                if (globalConfig.supportsFirebase && store.state.showWelcome) {
                  next({ path: "/home" });
                } else {
                  next({ path: "/docs/new" });
                }
              }
            },
            {
              path: "/_routes",
              component: () => __vitePreload(() => import("./_routes.cd108e42.js"), true ? [] : void 0)
            },
            {
              path: "/account",
              meta: { title: "My Account", track: true },
              component: () => __vitePreload(() => import("./account.02248dd2.js"), true ? ["assets/account.02248dd2.js","assets/AuthTiers.63840201.js","assets/Modal.1c333d29.js","assets/CoreButton.ad5d413b.js"] : void 0)
            },
            {
              path: "/docs",
              meta: { title: "My Docs", track: true },
              component: () => __vitePreload(() => import("./docs.c6a3357d.js"), true ? ["assets/docs.c6a3357d.js","assets/DocList.c69edc08.js","assets/moment.9709ab41.js","assets/CoreDivider.201e5106.js","assets/Tag.vue_vue_type_script_setup_true_lang.a82a8ad2.js"] : void 0)
            },
            {
              path: "/docs/f/:filter",
              meta: { title: "My Docs" },
              component: () => __vitePreload(() => import("./docs.c6a3357d.js"), true ? ["assets/docs.c6a3357d.js","assets/DocList.c69edc08.js","assets/moment.9709ab41.js","assets/CoreDivider.201e5106.js","assets/Tag.vue_vue_type_script_setup_true_lang.a82a8ad2.js"] : void 0),
              props: true
            },
            {
              path: "/docs/t/:tag(.*)",
              meta: { title: "My Docs" },
              component: () => __vitePreload(() => import("./docs.c6a3357d.js"), true ? ["assets/docs.c6a3357d.js","assets/DocList.c69edc08.js","assets/moment.9709ab41.js","assets/CoreDivider.201e5106.js","assets/Tag.vue_vue_type_script_setup_true_lang.a82a8ad2.js"] : void 0),
              props: true
            },
            {
              path: "/docs/:docId/meta",
              name: "docs-doc-meta",
              component: () => __vitePreload(() => import("./meta.08d1ea12.js"), true ? ["assets/meta.08d1ea12.js","assets/moment.9709ab41.js","assets/TagLink.16ccd376.js","assets/Tag.vue_vue_type_script_setup_true_lang.a82a8ad2.js"] : void 0),
              props: true,
              beforeEnter(to2, from2, next) {
                store.dispatch(SET_DOCUMENT, { id: to2.params.docId });
                next();
              }
            },
            {
              path: "/docs/export",
              meta: { title: "Export Docs", track: true },
              component: () => __vitePreload(() => import("./export.30131bf7.js"), true ? [] : void 0)
            },
            {
              path: "/docs/import",
              meta: { title: "Import Docs", track: true },
              component: () => __vitePreload(() => import("./import.e09c9b30.js"), true ? [] : void 0)
            },
            {
              path: "/quick-action",
              meta: { title: "Quick Action", track: true },
              component: () => __vitePreload(() => import("./quick-action.69015d85.js"), true ? [] : void 0)
            },
            {
              path: "/menu",
              meta: { track: true },
              component: () => __vitePreload(() => import("./menu.35b8e3c7.js").then((n2) => n2.m), true ? ["assets/menu.35b8e3c7.js","assets/CoreButton.ad5d413b.js","assets/CoreDivider.201e5106.js","assets/TagLink.16ccd376.js","assets/Tag.vue_vue_type_script_setup_true_lang.a82a8ad2.js","assets/useFiles.3674e24e.js","assets/TrashIcon.d058248a.js"] : void 0)
            },
            {
              path: "/workspaces",
              meta: { title: "Workspaces", track: true },
              component: () => __vitePreload(() => import("./workspaces.3f72fc2c.js"), true ? ["assets/workspaces.3f72fc2c.js","assets/CoreButton.ad5d413b.js","assets/Tag.vue_vue_type_script_setup_true_lang.a82a8ad2.js","assets/TrashIcon.d058248a.js","assets/workspaces.118b605f.css"] : void 0)
            },
            {
              path: "/tags",
              meta: { title: "Tags", track: true },
              component: () => __vitePreload(() => import("./tags.c4976690.js"), true ? ["assets/tags.c4976690.js","assets/TagLink.16ccd376.js","assets/Tag.vue_vue_type_script_setup_true_lang.a82a8ad2.js","assets/tags.fd4d4d28.css"] : void 0),
              props: true
            },
            {
              path: "/settings",
              meta: { title: "App Settings", track: true },
              component: () => __vitePreload(() => import("./settings.5dea2c37.js"), true ? ["assets/settings.5dea2c37.js","assets/account.8a10d9d6.js","assets/export.30131bf7.js","assets/import.e09c9b30.js"] : void 0)
            },
            {
              path: "/privacy-policy",
              meta: { title: "Privacy Policy", track: true },
              component: () => __vitePreload(() => import("./privacy-policy.d79d0728.js"), true ? [] : void 0)
            },
            {
              path: "/terms-and-conditions",
              meta: { title: "Terms & Conditions", track: true },
              component: () => __vitePreload(() => import("./terms-and-conditions.a785fe62.js"), true ? [] : void 0)
            }
          ]
        },
        {
          path: "/docs/new",
          meta: { track: true },
          component: () => __vitePreload(() => import("./_doc_.e1be23d6.js"), true ? ["assets/_doc_.e1be23d6.js","assets/Editor.d12c4a4b.js","assets/account.8a10d9d6.js","assets/Editor.2adede1c.css"] : void 0),
          props: true,
          beforeEnter(to2, from2, next) {
            store.dispatch(SET_DOCUMENT, { id: null });
            if (globalConfig.supportsFirebase && store.state.showWelcome) {
              localStorage.setItem("octo/welcome/v1", "done");
              store.dispatch(SET_SHOW_WELCOME, false);
              next({ path: "/home" });
            } else {
              next();
            }
          }
        },
        {
          path: "/docs/:docId",
          name: "docs-doc",
          component: () => __vitePreload(() => import("./_doc_.e1be23d6.js"), true ? ["assets/_doc_.e1be23d6.js","assets/Editor.d12c4a4b.js","assets/account.8a10d9d6.js","assets/Editor.2adede1c.css"] : void 0),
          props({ params }) {
            if (typeof (params == null ? void 0 : params.props) === "string") {
              return {
                ...params,
                ...JSON.parse(params.props)
              };
            }
            return params;
          },
          beforeEnter(to2, from2, next) {
            store.dispatch(SET_DOCUMENT, { id: to2.params.docId });
            next();
          }
        },
        {
          path: "/notepad",
          meta: { title: "Notepad", track: true },
          component: () => __vitePreload(() => import("./notepad.114f875b.js"), true ? ["assets/notepad.114f875b.js","assets/moment.9709ab41.js","assets/_doc_.e1be23d6.js","assets/Editor.d12c4a4b.js","assets/account.8a10d9d6.js","assets/Editor.2adede1c.css"] : void 0),
          props: true
        },
        {
          path: "/public/:docId",
          name: "public-doc",
          component: () => __vitePreload(() => import("./_doc_.e1be23d6.js"), true ? ["assets/_doc_.e1be23d6.js","assets/Editor.d12c4a4b.js","assets/account.8a10d9d6.js","assets/Editor.2adede1c.css"] : void 0),
          props: { readonly: true }
        },
        {
          path: "/force-graph",
          meta: { title: "Force Graph", track: true },
          component: () => __vitePreload(() => import("./force-graph.32173eea.js"), true ? ["assets/force-graph.32173eea.js","assets/transform.11eec644.js","assets/ordinal.f87dfb70.js","assets/DocList.c69edc08.js","assets/moment.9709ab41.js","assets/CoreDivider.201e5106.js","assets/Tag.vue_vue_type_script_setup_true_lang.a82a8ad2.js","assets/force-graph.fe9bf3f4.css"] : void 0),
          props: true
        },
        {
          path: "/example",
          meta: { title: "Example", track: true },
          component: () => __vitePreload(() => import("./example.3091ad6b.js"), true ? ["assets/example.3091ad6b.js","assets/Editor.d12c4a4b.js","assets/account.8a10d9d6.js","assets/Editor.2adede1c.css"] : void 0),
          props: { url: "/example.md" }
        },
        {
          path: "/file-editor/:file",
          meta: { title: "File Editor" },
          component: () => __vitePreload(() => import("./_file_.82f0400b.js"), true ? ["assets/_file_.82f0400b.js","assets/Editor.d12c4a4b.js","assets/account.8a10d9d6.js","assets/Editor.2adede1c.css","assets/useFiles.3674e24e.js"] : void 0),
          props: true
        },
        {
          path: "/documents",
          redirect: { path: "/docs" }
        },
        {
          path: "/documents/new",
          redirect: { path: "/docs/new" }
        },
        {
          path: "/documents/export",
          redirect: { path: "/docs/export" }
        },
        {
          path: "/documents/import",
          redirect: { path: "/docs/import" }
        },
        {
          path: "/documents/recent",
          redirect: { path: "/docs" }
        },
        {
          path: "/documents/actionable",
          redirect: { path: "/docs/f/tasks" }
        },
        {
          path: "/documents/discarded",
          redirect: { path: "/docs/f/discarded" }
        },
        {
          path: "/documents/tasks",
          redirect: { path: "/docs/f/tasks" }
        },
        {
          path: "/documents/untagged",
          redirect: { path: "/docs/f/untagged" }
        },
        {
          path: "/documents/daily",
          redirect: { path: "/notepad" }
        },
        {
          path: "/documents/:id",
          redirect: (route) => ({ path: `/docs/${route.params.id}` })
        },
        {
          path: "/documents/:id/meta",
          redirect: (route) => ({ path: `/docs/${route.params.id}/meta` })
        },
        {
          path: "/shared/:id",
          redirect: (route) => ({ path: `/public/${route.params.id}` })
        },
        {
          path: "/context",
          redirect: { path: "/workspaces" }
        },
        {
          path: "/contexts",
          redirect: { path: "/workspaces" }
        },
        {
          path: "/tags/:tag",
          redirect: (route) => ({ path: `/docs/t/${route.params.tag}` })
        },
        {
          path: "/graph",
          redirect: { path: "/force-graph" }
        }
      ]
    }
  ]
});
router.beforeEach((to2) => {
  var _a2;
  if (to2.meta.title)
    setTitle(to2.meta.title);
  if (to2.meta.track)
    (_a2 = window.fathom) == null ? void 0 : _a2.trackPageview();
  return true;
});
const open$1 = (to2) => {
  var _a2;
  if ((_a2 = to2.params) == null ? void 0 : _a2.props) {
    to2.params.props = JSON.stringify(to2.params.props);
  }
  router.push(to2);
};
function getObjectType(object) {
  if (typeof object !== "object" || object === null) {
    return 0;
  }
  if (Array.isArray(object)) {
    return 2;
  }
  if (isRecord(object)) {
    return 1;
  }
  if (object instanceof Set) {
    return 3;
  }
  if (object instanceof Map) {
    return 4;
  }
  return 5;
}
function getKeys(objects) {
  const keys2 = /* @__PURE__ */ new Set();
  for (const object of objects) {
    for (const key of [
      ...Object.keys(object),
      ...Object.getOwnPropertySymbols(object)
    ]) {
      keys2.add(key);
    }
  }
  return keys2;
}
function objectHasProperty(object, property) {
  return typeof object === "object" && Object.prototype.propertyIsEnumerable.call(object, property);
}
function getIterableOfIterables(iterables) {
  return {
    *[Symbol.iterator]() {
      for (const iterable of iterables) {
        for (const value of iterable) {
          yield value;
        }
      }
    }
  };
}
const validRecordToStringValues = /* @__PURE__ */ new Set([
  "[object Object]",
  "[object Module]"
]);
function isRecord(value) {
  if (!validRecordToStringValues.has(Object.prototype.toString.call(value))) {
    return false;
  }
  const { constructor } = value;
  if (constructor === void 0) {
    return true;
  }
  const prototype = constructor.prototype;
  if (prototype === null || typeof prototype !== "object" || !validRecordToStringValues.has(Object.prototype.toString.call(prototype))) {
    return false;
  }
  if (!prototype.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  return true;
}
const defaultMergeFunctions = {
  mergeMaps: defaultMergeMaps,
  mergeSets: defaultMergeSets,
  mergeArrays: defaultMergeArrays,
  mergeRecords: defaultMergeRecords,
  mergeOthers: leaf
};
const actions = {
  defaultMerge: Symbol("deepmerge-ts: default merge"),
  skip: Symbol("deepmerge-ts: skip")
};
function defaultMetaDataUpdater(previousMeta, metaMeta) {
  return metaMeta;
}
function deepmerge(...objects) {
  return deepmergeCustom({})(...objects);
}
function deepmergeCustom(options, rootMetaData) {
  const utils = getUtils(options, customizedDeepmerge);
  function customizedDeepmerge(...objects) {
    return mergeUnknowns(objects, utils, rootMetaData);
  }
  return customizedDeepmerge;
}
function getUtils(options, customizedDeepmerge) {
  var _a2, _b;
  return {
    defaultMergeFunctions,
    mergeFunctions: {
      ...defaultMergeFunctions,
      ...Object.fromEntries(Object.entries(options).filter(([key, option]) => Object.prototype.hasOwnProperty.call(defaultMergeFunctions, key)).map(([key, option]) => option === false ? [key, leaf] : [key, option]))
    },
    metaDataUpdater: (_a2 = options.metaDataUpdater) !== null && _a2 !== void 0 ? _a2 : defaultMetaDataUpdater,
    deepmerge: customizedDeepmerge,
    useImplicitDefaultMerging: (_b = options.enableImplicitDefaultMerging) !== null && _b !== void 0 ? _b : false,
    actions
  };
}
function mergeUnknowns(values, utils, meta) {
  if (values.length === 0) {
    return void 0;
  }
  if (values.length === 1) {
    return mergeOthers(values, utils, meta);
  }
  const type2 = getObjectType(values[0]);
  if (type2 !== 0 && type2 !== 5) {
    for (let m_index = 1; m_index < values.length; m_index++) {
      if (getObjectType(values[m_index]) === type2) {
        continue;
      }
      return mergeOthers(values, utils, meta);
    }
  }
  switch (type2) {
    case 1:
      return mergeRecords(values, utils, meta);
    case 2:
      return mergeArrays(values, utils, meta);
    case 3:
      return mergeSets(values, utils, meta);
    case 4:
      return mergeMaps(values, utils, meta);
    default:
      return mergeOthers(values, utils, meta);
  }
}
function mergeRecords(values, utils, meta) {
  const result = utils.mergeFunctions.mergeRecords(values, utils, meta);
  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === void 0 && utils.mergeFunctions.mergeRecords !== utils.defaultMergeFunctions.mergeRecords) {
    return utils.defaultMergeFunctions.mergeRecords(values, utils, meta);
  }
  return result;
}
function mergeArrays(values, utils, meta) {
  const result = utils.mergeFunctions.mergeArrays(values, utils, meta);
  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === void 0 && utils.mergeFunctions.mergeArrays !== utils.defaultMergeFunctions.mergeArrays) {
    return utils.defaultMergeFunctions.mergeArrays(values);
  }
  return result;
}
function mergeSets(values, utils, meta) {
  const result = utils.mergeFunctions.mergeSets(values, utils, meta);
  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === void 0 && utils.mergeFunctions.mergeSets !== utils.defaultMergeFunctions.mergeSets) {
    return utils.defaultMergeFunctions.mergeSets(values);
  }
  return result;
}
function mergeMaps(values, utils, meta) {
  const result = utils.mergeFunctions.mergeMaps(values, utils, meta);
  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === void 0 && utils.mergeFunctions.mergeMaps !== utils.defaultMergeFunctions.mergeMaps) {
    return utils.defaultMergeFunctions.mergeMaps(values);
  }
  return result;
}
function mergeOthers(values, utils, meta) {
  const result = utils.mergeFunctions.mergeOthers(values, utils, meta);
  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === void 0 && utils.mergeFunctions.mergeOthers !== utils.defaultMergeFunctions.mergeOthers) {
    return utils.defaultMergeFunctions.mergeOthers(values);
  }
  return result;
}
function defaultMergeRecords(values, utils, meta) {
  const result = {};
  for (const key of getKeys(values)) {
    const propValues = [];
    for (const value of values) {
      if (objectHasProperty(value, key)) {
        propValues.push(value[key]);
      }
    }
    if (propValues.length === 0) {
      continue;
    }
    const updatedMeta = utils.metaDataUpdater(meta, {
      key,
      parents: values
    });
    const propertyResult = mergeUnknowns(propValues, utils, updatedMeta);
    if (propertyResult === actions.skip) {
      continue;
    }
    if (key === "__proto__") {
      Object.defineProperty(result, key, {
        value: propertyResult,
        configurable: true,
        enumerable: true,
        writable: true
      });
    } else {
      result[key] = propertyResult;
    }
  }
  return result;
}
function defaultMergeArrays(values) {
  return values.flat();
}
function defaultMergeSets(values) {
  return new Set(getIterableOfIterables(values));
}
function defaultMergeMaps(values) {
  return new Map(getIterableOfIterables(values));
}
function leaf(values) {
  return values[values.length - 1];
}
const caching = async ({ options: { caching: options }, store: store2 }) => {
  if (!options) {
    return;
  }
  if (options === true) {
    options = {};
  }
  const {
    actions: actions2 = false,
    mutations = true,
    namespace = store2.$id,
    hydrate = async (cache22) => {
      const state = await cache22.getItem(namespace);
      if (state) {
        store2.$state = deepmerge(store2.$state, state);
      }
    },
    persist = async (cache22) => {
      await cache22.setItem(namespace, unwrap(store2.$state));
    }
  } = options;
  const cache2 = localforage.createInstance({ name: namespace });
  await hydrate(cache2);
  if (mutations) {
    store2.$subscribe((_mutation, _state) => {
      persist(cache2);
    }, { detached: true });
  } else if (actions2) {
    store2.$onAction((_action) => {
      persist(cache2);
    }, true);
  }
};
const app$1 = "";
const overlayscrollbars = "";
function registerSW(options = {}) {
  const {
    immediate = false,
    onNeedRefresh,
    onOfflineReady,
    onRegistered,
    onRegisteredSW,
    onRegisterError
  } = options;
  let wb2;
  let registerPromise;
  const updateServiceWorker = async (reloadPage = true) => {
    await registerPromise;
  };
  async function register2() {
    if ("serviceWorker" in navigator) {
      const { Workbox, messageSW } = await __vitePreload(() => import("./workbox-window.prod.es5.d2780aeb.js"), true ? [] : void 0);
      wb2 = new Workbox("/sw.js", { scope: "/", type: "classic" });
      wb2.addEventListener("activated", (event) => {
        if (event.isUpdate)
          window.location.reload();
        else
          onOfflineReady == null ? void 0 : onOfflineReady();
      });
      wb2.register({ immediate }).then((r2) => {
        if (onRegisteredSW)
          onRegisteredSW("/sw.js", r2);
        else
          onRegistered == null ? void 0 : onRegistered(r2);
      }).catch((e2) => {
        onRegisterError == null ? void 0 : onRegisterError(e2);
      });
    }
  }
  registerPromise = register2();
  return updateServiceWorker;
}
registerSW({
  immediate: true,
  onOfflineReady() {
  },
  onNeedRefresh() {
    window.dispatchEvent(
      new Event("swupdated")
    );
  },
  onRegistered(swRegistration) {
  },
  onRegisterError(e2) {
  }
});
class Interface {
  constructor() {
    this.components = /* @__PURE__ */ new Set();
  }
  registerComponent({ component, container, position }) {
    this.components.add({ component, container, position });
  }
}
class Manager {
  constructor() {
    this.packages = /* @__PURE__ */ new Set();
    this.components = /* @__PURE__ */ new Set();
  }
  emit(event, data) {
    this.packages.forEach((pack2) => pack2.emit(event, data));
  }
  getComponents(container, position) {
    return [...this.components].filter((component) => {
      return component.container === container && component.position === position;
    }).map(({ component }) => component);
  }
  register(pack2) {
    const sdk = new Interface();
    pack2.register(sdk);
    sdk.components.forEach((component) => this.components.add(component));
    this.packages.add(pack2);
  }
}
const PackageManager = new Manager();
const updateAppHeight = () => {
  document.documentElement.style.setProperty("--app-height", `calc(${window.visualViewport.height}px - 1px)`);
};
init();
updateAppHeight();
window.visualViewport.addEventListener("resize", updateAppHeight);
if (localStorage.getItem("octo/welcome/v1") === null) {
  store.dispatch(SET_SHOW_WELCOME, true);
}
window.addEventListener("offline", () => {
  store.dispatch(SET_OFFLINE);
});
window.addEventListener("online", () => {
  store.dispatch(SET_ONLINE);
});
if (!navigator.onLine) {
  store.dispatch(SET_OFFLINE);
}
if (/Mac|iPod|iPhone|iPad/.test(navigator.platform || navigator.userAgentData.platform)) {
  store.dispatch(SET_MOD_KEY, "\u2318");
}
const app = createApp({
  render: () => h$1(App),
  setup() {
    const email = useStorage("email", "");
    const user = useStorage("user", {
      id: void 0,
      providers: [],
      roles: []
    }, void 0, { mergeDefaults: true });
    const { appearance } = useAppearance();
    provide("appearance", appearance);
    provide("email", email);
    provide("user", user);
    if (globalConfig.supportsFirebase) {
      getAuth().onIdTokenChanged(async (authUser) => {
        if (authUser) {
          user.value = {
            ...user.value,
            id: authUser.uid,
            providers: [...authUser.providerData]
          };
          store.commit(SET_USER, authUser);
          const token = await authUser.getIdTokenResult(true);
          if (token.claims.ambassador && !user.value.roles.includes("ambassador")) {
            user.value = {
              ...user.value,
              roles: [...user.value.roles, "ambassador"]
            };
            store.commit(SET_SUBSCRIPTION, { pro: true });
          }
          if (token.claims.stripeRole === "subscriber" && !user.value.roles.includes("subscriber")) {
            user.value = {
              ...user.value,
              roles: [...user.value.roles, "subscriber"]
            };
            store.commit(SET_SUBSCRIPTION, { pro: true });
          }
        } else {
          user.value = {
            id: void 0,
            providers: [],
            roles: []
          };
          store.commit(SET_USER, null);
          store.commit(SET_SUBSCRIPTION, { pro: false });
        }
      });
    }
  }
});
const pinia = createPinia();
pinia.use(caching);
app.config.globalProperties.$packageManager = PackageManager;
app.use(pinia);
app.use(router);
app.use(store);
app.component("CoreScrollable", CoreScrollable);
app.component("Extendable", Extendable);
app.use(plugin, {
  breakpoints: {
    xs: 0,
    sm: 577,
    md: 769,
    lg: 993,
    xl: 1201
  }
});
app.mount("#app");
export {
  useSlots as $,
  GoogleAuthProvider as A,
  addCheckout as B,
  defineComponent as C,
  withDirectives as D,
  vModelText as E,
  toDisplayString as F,
  GithubAuthProvider as G,
  renderSlot as H,
  vModelDynamic as I,
  unref as J,
  ref$2 as K,
  normalizeClass as L,
  useStorage as M,
  useRecentDocs as N,
  nanoid as O,
  useMq as P,
  bindGlobal as Q,
  onMounted as R,
  onBeforeUnmount as S,
  TwitterAuthProvider as T,
  Fragment as U,
  renderList as V,
  withModifiers as W,
  DEACTIVATE_CONTEXT as X,
  open$1 as Y,
  SET_CONTEXT_TAGS as Z,
  _export_sfc as _,
  createBaseVNode as a,
  parseCodeblocks as a0,
  parseReferences as a1,
  DISCARD_DOCUMENT as a2,
  DUPLICATE_DOCUMENT as a3,
  RESTORE_DOCUMENT as a4,
  RESTRICT_DOCUMENT as a5,
  SHARE_DOCUMENT as a6,
  SET_RIGHT_SIDEBAR_VISIBILITY as a7,
  defineStore as a8,
  linkWithRedirect as a9,
  exportKeys as aA,
  isRef as aB,
  SET_EXPERIMENTAL as aC,
  EDIT_DOCUMENT as aD,
  ADD_DOCUMENT as aE,
  fetchSharedDoc as aF,
  unpack as aG,
  setTitle as aH,
  SET_DOCUMENT as aI,
  __vitePreload as aJ,
  getAugmentedNamespace as aK,
  ref as aL,
  getStorage as aM,
  uploadBytes as aN,
  matchStarts as aO,
  HASHTAG_CODES as aP,
  matchHashtagPrefix as aQ,
  matchHashtag as aR,
  customAlphabet as aS,
  OverlayScrollbars as aT,
  useCssVars as aU,
  DOCUMENTS_LOADED as aV,
  watchEffect as aW,
  Debouncer as aX,
  MERGE_DOCUMENTS as aa,
  withKeys as ab,
  mergeProps as ac,
  commonjsGlobal as ad,
  commonjsRequire as ae,
  vModelCheckbox as af,
  Doc as ag,
  createStaticVNode as ah,
  REMOVE_CONTEXT as ai,
  ADD_CONTEXT as aj,
  vModelRadio as ak,
  SET_EDITOR_IMAGES_ENABLED as al,
  SET_EDITOR_LIGATURES as am,
  SET_EDITOR_LISTS_ENABLED as an,
  SET_EDITOR_READABILITY_ENABLED as ao,
  SET_EDITOR_READABILITY_MAX_WIDTH as ap,
  SET_EDITOR_READABILITY_WORDS_PER_MINUTE as aq,
  SET_EDITOR_IMAGES_SHOW_CAPTIONS as ar,
  SET_EDITOR_SPELLCHECK as as,
  SET_EDITOR_TAB_SIZE as at,
  SET_EDITOR_TOOLBAR as au,
  SET_EDITOR_KEY_MAP as av,
  SET_CRYPTO_KEYS as aw,
  SET_CRYPTO_ENABLED as ax,
  TOUCH_DOCUMENT as ay,
  generateKeys as az,
  createVNode as b,
  createElementBlock as c,
  createBlock as d,
  createTextVNode as e,
  createCommentVNode as f,
  globalConfig as g,
  popScopeId as h,
  computed as i,
  reactive as j,
  watch as k,
  isSignInWithEmailLink as l,
  getAuth as m,
  useOnline as n,
  openBlock as o,
  pushScopeId as p,
  inject as q,
  resolveComponent as r,
  useRouter as s,
  useStore as t,
  useRoute as u,
  sendSignInLinkToEmail as v,
  withCtx as w,
  signInWithEmailLink as x,
  signInWithRedirect as y,
  getRedirectResult as z
};
//# sourceMappingURL=index.fc474e50.js.map
